<!-- 
B0IDS :: autonomous flocking behavior ::
copyright 2025 :: Frank Maiello :: maiello.frank@gmail.com ::

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. In no event shall the author or copyright holders be liable for any claim, damages, or other liability, whether in an action of contract, tort or otherwise, arising from, our of or in, connection with the software or the use of other dealings in the Software.
-->

<!DOCTYPE html>
<html>
    <head>
    <meta name="viewport" content="width=500, initial-scale=1.0">
    <title>Boids 1.16</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        body {
            background-image: url('sky.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-attachment: fixed;
        }
    </style>
    </head>
<body>
<canvas id="myCanvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%">
</canvas>
<script>

    // Setup canvas and handle window resizing  ------------------
    canvas = document.getElementById("myCanvas");
    c = canvas.getContext("2d");
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    simMinWidth = 2.0;
    cScale = Math.min(canvas.width, canvas.height) / simMinWidth;
    simWidth = canvas.width / cScale;
    simHeight = canvas.height / cScale;

    // Mouse tracking
    let mouseX = simWidth / 2;
    let mouseY = simHeight / 2;
    let draggedCloud = null;
    let lastClickTime = 0;
    let lastClickedCloud = null;

    canvas.addEventListener('mousedown', function(e) {
        const rect = canvas.getBoundingClientRect();
        mouseX = (e.clientX - rect.left) / cScale;
        mouseY = (canvas.height - (e.clientY - rect.top)) / cScale;
        
        // Find which cloud was clicked (only foreground clouds)
        let clickedCloud = null;
        for (let cloud of Clouds) {
            if (cloud.contains(mouseX, mouseY)) {
                clickedCloud = cloud;
                break;
            }
        }
        
        if (e.button === 0) { // Left click
            const currentTime = Date.now();
            
            // Check for double-click
            if (currentTime - lastClickTime < 300) {
                if (clickedCloud && clickedCloud === lastClickedCloud) {
                    // Double-click on cloud: create new cloud at this position
                    Clouds.push(new CLOUD(mouseX, mouseY));
                } else if (!clickedCloud && lastClickedCloud === null) {
                    // Double-click on empty canvas: create new cloud
                    Clouds.push(new CLOUD(mouseX, mouseY));
                }
                lastClickTime = 0;
                lastClickedCloud = null;
            } else {
                // Single click: drag cloud if clicked on one
                draggedCloud = clickedCloud;
                lastClickTime = currentTime;
                lastClickedCloud = clickedCloud;
            }
        } else if (e.button === 2) { // Right click
            // Delete the clicked cloud
            if (clickedCloud) {
                Clouds = Clouds.filter(cloud => cloud !== clickedCloud);
            }
            e.preventDefault();
        }
    });

    canvas.addEventListener('mouseup', function(e) {
        draggedCloud = null;
    });

    canvas.addEventListener('contextmenu', function(e) {
        e.preventDefault();
    });

    canvas.addEventListener('mousemove', function(e) {
        const rect = canvas.getBoundingClientRect();
        mouseX = (e.clientX - rect.left) / cScale;
        mouseY = (canvas.height - (e.clientY - rect.top)) / cScale;
        
        if (draggedCloud) {
            draggedCloud.x = mouseX;
            draggedCloud.y = mouseY;
        }
    });

    //  HANDLE WINDOW RESIZING  ------------------
    function resizeCanvas() {
        canvas = document.getElementById("myCanvas");
        c = canvas.getContext("2d");
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;

        const oldSimWidth = simWidth;
        const oldSimHeight = simHeight;

        simMinWidth = 2.0;
        cScale = Math.min(canvas.width, canvas.height) / simMinWidth;
        simWidth = canvas.width / cScale;
        simHeight = canvas.height / cScale;

        // Calculate scale factors
        const scaleX = simWidth / oldSimWidth;
        const scaleY = simHeight / oldSimHeight;
        
        // Scale boid positions
        if (typeof boid !== 'undefined' && boid != null) {
            for (let boid of Boids) {
                boid.pos.x *= scaleX;
                boid.pos.y *= scaleY;
            }
        }
        
        // Scale Clouds
        if (typeof Clouds !== 'undefined' && Clouds != null) {
            for (let cloud of Clouds) {
                cloud.x *= scaleX;
                cloud.y *= scaleY;
                cloud.radius *= Math.min(scaleX, scaleY);
                // Regenerate the cloud's visual representation at the new size
                cloud.renderToCanvas();
            }
        }
        
        // Scale Background Clouds
        if (typeof BackgroundClouds !== 'undefined' && BackgroundClouds != null) {
            for (let cloud of BackgroundClouds) {
                cloud.x *= scaleX;
                cloud.y *= scaleY;
                cloud.radius *= Math.min(scaleX, scaleY);
                cloud.renderToCanvas();
            }
        }
        
        // Scale Foreground Clouds
        if (typeof ForegroundClouds !== 'undefined' && ForegroundClouds != null) {
            for (let cloud of ForegroundClouds) {
                cloud.x *= scaleX;
                cloud.y *= scaleY;
                cloud.radius *= Math.min(scaleX, scaleY);
                cloud.renderToCanvas();
            }
        }
    }
    window.addEventListener("resize", resizeCanvas);

    //  VECTOR OPERATIONS ---------------------------------------------------------------------
    class Vector2 {
        constructor(x = 0.0, y = 0.0) {
            this.x = x; 
            this.y = y;
        }
        clone() {
            return new Vector2(this.x, this.y);
        }
        add(v, s=1) {
            this.x += v.x * s;
            this.y += v.y * s;
            return this;
        }
        addVectors(a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            return this;
        }
        subtract(v, s = 1.0) {
            this.x -= v.x * s;
            this.y -= v.y * s;
            return this;
        }
        subtractVectors(a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            return this;			
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        scale(s) {
            this.x *= s;
            this.y *= s;
        }
        normalize() {
            const len = this.length();
            if (len > 0) {
                this.x /= len;
                this.y /= len;
            }
            return this;
        }
    }

    //  COORDINATE CONVERSION  -----------
    function cX(pos) {
        return pos.x * cScale;
    }
    function cY(pos) {
        return canvas.height - pos.y * cScale;
    }

    //  SPATIAL HASH GRID CLASS ---------------------------------------------------------------------
    class SpatialHashGrid {
        constructor(cellSize) {
            this.cellSize = cellSize;
            this.grid = new Map();
        }
        
        // Convert position to grid key
        getKey(x, y) {
            const gridX = Math.floor(x / this.cellSize);
            const gridY = Math.floor(y / this.cellSize);
            return `${gridX},${gridY}`;
        }
        
        // Clear the grid
        clear() {
            this.grid.clear();
        }
        
        // Add boid to grid
        insert(boid) {
            const key = this.getKey(boid.pos.x, boid.pos.y);
            if (!this.grid.has(key)) {
                this.grid.set(key, []);
            }
            this.grid.get(key).push(boid);
        }
        
        // Get nearby boids within a radius
        getNearby(boid, radius) {
            const nearby = [];
            const cellRadius = Math.ceil(radius / this.cellSize);
            const centerX = Math.floor(boid.pos.x / this.cellSize);
            const centerY = Math.floor(boid.pos.y / this.cellSize);
            
            // Check all cells within the radius
            for (let dx = -cellRadius; dx <= cellRadius; dx++) {
                for (let dy = -cellRadius; dy <= cellRadius; dy++) {
                    const key = `${centerX + dx},${centerY + dy}`;
                    if (this.grid.has(key)) {
                        nearby.push(...this.grid.get(key));
                    }
                }
            }
            return nearby;
        }
    }

    function makeSpatialGrid() {
        SpatialGrid = new SpatialHashGrid(boidProps.visualRange);
    }
    
    // BALLOON CLASS ---------------------------------------------------------------------
    class BALLOON {
        constructor (pos, vel) {
            this.pos = pos.clone();
            this.vel = vel.clone();
            this.radius = 0.15;
            this.hue = 360 * Math.random();
            this.stringPhase = Math.random() * Math.PI * 2; // Random starting phase for wave
        }
        simulate() {
            this.vel.y += 0.001;
            this.pos.add(this.vel, deltaT);
            this.stringPhase += deltaT * 3; // Animate the wave
            
            if (this.pos.y > simHeight + 5 * this.radius) {
                // remove balloon from array when it goes off top
                const index = Balloons.indexOf(this);
                if (index > -1) {
                    Balloons.splice(index, 1);
                }
            }
        }
        draw() {
            const radScale = this.radius * cScale;
            const stringLength = radScale * 3.5;
            const startY = 0.6 * radScale;
            const segments = 20;

            c.save();
            c.translate(cX(this.pos), cY(this.pos));

            // Draw string with wave
            c.strokeStyle = 'hsl(0, 0%, 80%)';
            c.lineWidth = 2.0;
            c.beginPath();
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const y = startY + stringLength * t;
                // Wave amplitude increases with distance from balloon (quadratic)
                const amplitude = radScale * 0.3 * t * t;
                const x = Math.sin(this.stringPhase + t * Math.PI * 2) * amplitude;
                
                if (i === 0) {
                    c.moveTo(x, y);
                } else {
                    c.lineTo(x, y);
                }
            }
            c.stroke();
            
            // Draw knot at balloon connection
            c.fillStyle = `hsl(${this.hue}, 40%, 30%)`;
            c.beginPath();
            c.ellipse(
                0, 
                startY + radScale * 0.12, 
                radScale * 0.08, 
                radScale * 0.12, 
                0, 
                0, 
                2 * Math.PI);
            c.fill();
            
            // Draw balloon
            const gradient = c.createRadialGradient(
                -radScale * 0.25,
                -radScale * 0.55, 
                0, 
                0, 
                -radScale * 0.3, 
                1.1 *radScale);
            gradient.addColorStop(0, `hsla(${this.hue}, 80%, 70%, 0.8)`);
            gradient.addColorStop(1, `hsla(${this.hue}, 60%, 20%, 0.9)`);
            c.fillStyle = gradient;
            c.beginPath();
            c.ellipse(
                0, 
                -radScale * 0.3, 
                radScale * 0.8, 
                radScale, 
                0, 
                0, 
                2 * Math.PI);
            c.fill();
            c.strokeStyle = `hsl(${this.hue}, 50%, 40%)`;
            c.lineWidth = 2;
            c.stroke();
            
            c.restore();
        }
    }

    // make balloon --------------------------------
    function initBalloon() {
        Balloons = [];
        balloonProps = {
            balloonInitialDelay: 40.0, // Delay before first balloon spawns (0 = immediate)
            balloonSpawnInterval: 50.0 // Time between balloon spawns after first one (seconds)
        } 
        balloonSpawnTimer = -balloonProps.balloonInitialDelay;
    }
    
    function spawnBalloon() {
        const pos = new Vector2(.1 * simWidth + Math.random() * 0.8 *simWidth, -0.3);
        const vel = new Vector2((Math.random() - 0.5) * 0.3, Math.random() * 0.3);
        Balloons.push(new BALLOON(pos, vel));
    }   

    //  CLOUD CLASS ---------------------------------------------------------------------
    class CLOUD {
        constructor(x, y, isBackground = false, isForeground = false) {
            this.x = x;
            this.y = y;
            this.isBackground = isBackground;
            this.isForeground = isForeground;
            // Foreground clouds are largest, background smallest, normal in between
            this.radius = isForeground ? 0.20 : (isBackground ? 0.07 : 0.15);
            this.speed = isForeground ? 0.08 : (isBackground ? 0.02 : 0.04); // Foreground fastest, background slowest
            // Create unique cloud shape using true randomness (changes on refresh)
            this.seed = Math.random();
            this.generatePuffs();
            this.renderToCanvas();
        }
        generatePuffs() {
            const numPuffs = 4;
            this.puffData = [];
            
            // Use seed to create deterministic but varied random values
            let rng = this.seed;
            const seededRandom = () => {
                rng = (rng * 9301 + 49297) % 233280;
                return rng / 233280;
            };
            
            // Create cloud-like arrangement with horizontal spread
            for (let i = 0; i < numPuffs; i++) {
                if (i < 3) {
                    // First 3 puffs form the base with flat bottom
                    // Horizontal position: spread across the width with variation
                    const offsetX = -0.7 + (i / 2) * 1.4 + (seededRandom() - 0.5) * 0.05;
                    
                    // Size variation
                    const size = 0.6 + seededRandom() * 0.3;
                    
                    // Vertical position: constrained to be close to the crop line
                    const offsetY = 0.3 + (seededRandom() - 0.5) * 0.4;
                    
                    this.puffData.push({
                        offsetX: offsetX,
                        offsetY: offsetY,
                        size: size
                    });
                } else {
                    // Fourth puff adds height - positioned above the crop line
                    const offsetX = -0.2 + (seededRandom() - 0.5) * 0.4; // More centered
                    const size = 0.5 + seededRandom() * 0.25; // Slightly smaller
                    const offsetY = -0.3 + (seededRandom() - 0.5) * 0.2; // Positioned higher (negative = up)
                    
                    this.puffData.push({
                        offsetX: offsetX,
                        offsetY: offsetY,
                        size: size
                    });
                }
            }
        }
        contains(x, y) {
            // Calculate the crop line position
            const r = this.radius;
            const cropY = this.y + r * 0.5;
            
            // Don't collide below the crop line
            if (y > cropY) return false;
            
            // Elliptical collision - wider horizontally than vertically
            const dx = (x - this.x) / (r * 1.5); // 1.5x wider horizontally
            const dy = (y - this.y) / r;
            return (dx * dx + dy * dy) < 1;
        }
        renderToCanvas() {
            // Create offscreen canvas sized for the cloud
            const r = this.radius * cScale;
            const padding = 30;
            const size = r * 3 + padding * 2;
            
            this.offscreenCanvas = document.createElement('canvas');
            this.offscreenCanvas.width = size;
            this.offscreenCanvas.height = size;
            const ctx = this.offscreenCanvas.getContext('2d');
            
            // Center position in offscreen canvas
            const cx = size / 2;
            const cy = size / 2;
            
            // Build puffs array
            const puffs = this.puffData.map(puff => ({
                x: cx + r * puff.offsetX,
                y: cy + r * puff.offsetY,
                r: r * puff.size,
                data: puff
            }));
            
            puffs.sort((a, b) => a.x - b.x);
            
            const bottomY = Math.max(...puffs.map(puff => puff.y + puff.r * 0.5));
            
            ctx.save();
            
            // Create clipping region
            const leftmost = Math.min(...puffs.map(p => p.x - p.r)) - 20;
            const rightmost = Math.max(...puffs.map(p => p.x + p.r)) + 20;
            const topmost = Math.min(...puffs.map(p => p.y - p.r)) - 20;
            
            ctx.beginPath();
            ctx.rect(leftmost, topmost, rightmost - leftmost, bottomY - topmost + 2);
            ctx.clip();
            
            // Draw outline strokes (darker for background clouds, lighter for foreground)
            if (this.isForeground) {
                ctx.strokeStyle = 'hsl(200, 85%, 85%)';
            } else if (this.isBackground) {
                ctx.strokeStyle = 'hsl(200, 30%, 50%)';
            } else {
                ctx.strokeStyle = 'hsl(200, 80%, 80%)';
            }
            ctx.lineWidth = 6;
            for (let puff of puffs) {
                ctx.beginPath();
                ctx.arc(puff.x, puff.y, puff.r, 0, 2 * Math.PI);
                ctx.stroke();
            }
            
            // Fill all puffs (darker for background clouds, white for others)
            if (this.isBackground) {
                ctx.fillStyle = 'hsl(0, 0%, 65%)';
            } else {
                ctx.fillStyle = 'hsl(0, 0%, 100%)';
            }
            for (let puff of puffs) {
                ctx.beginPath();
                ctx.arc(puff.x, puff.y, puff.r, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            ctx.restore();
            
            // Draw bottom edge (darker for background clouds)
            const bottomTraceY = bottomY + 1.5;
            if (this.isBackground) {
                ctx.strokeStyle = 'hsla(200, 30%, 50%, 0.6)';
            } else {
                ctx.strokeStyle = 'hsla(200, 80%, 80%, 0.8)';
            }
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i < puffs.length; i++) {
                const puff = puffs[i];
                const dy = bottomY - puff.y;
                if (dy < puff.r && dy > -puff.r) {
                    const ratio = Math.min(1, Math.max(-1, dy / puff.r));
                    const angle = Math.acos(ratio);
                    const extend = 2;
                    const leftX = puff.x - puff.r * Math.sin(angle) - (i === 0 ? extend : 0);
                    const rightX = puff.x + puff.r * Math.sin(angle) + (i === puffs.length - 1 ? extend : 0);
                    ctx.moveTo(leftX, bottomTraceY);
                    ctx.lineTo(rightX, bottomTraceY);
                }
            }
            ctx.stroke();
            
            // Store the offset for drawing
            this.offsetX = size / 2;
            this.offsetY = size / 2;
        }
        update(dt) {
            // Move cloud from right to left
            this.x -= this.speed * dt;
        }
        draw() {
            // Draw the pre-rendered cloud image
            const cx = this.x * cScale;
            const cy = canvas.height - this.y * cScale;
            c.drawImage(this.offscreenCanvas, cx - this.offsetX, cy - this.offsetY);
        }
    }

    //  MOVING AIRPLANE CLASS ---------------------------------------------------------------------
    class AIRPLANE {
        constructor(y, speed, size, respawnDelay, isFirstPass) {
            // On first pass, try to spawn above the topmost cloud
            if (isFirstPass) {
                this.y = this.pickAltitudeAboveClouds();
            } else {
                // Randomize vertical position avoiding cloud elevations
                this.y = this.pickSafeAltitude();
            }
            this.baseY = this.y; // Store initial y for loop calculation
            this.speed = speed; // Units per second
            this.baseSpeed = speed; // Store base speed
            this.size = size; // Width/height of the cloud
            this.radius = size * 0.7; // Effective radius for collision detection
            this.respawnDelay = respawnDelay; // Seconds to wait before respawning
            this.isWaiting = false;
            this.waitTimer = 0;
            this.propellerAngle = 0; // For spinning propeller effect
            this.angle = 0; // Current orientation angle
            this.isUpsideDown = false; // Whether plane is flying upside-down
            
            // Determine if plane should be upside-down (only if in top 30%)
            const topThreshold = simHeight * 0.7; // 30% from top
            if (this.y > topThreshold) {
                this.isUpsideDown = Math.random() < 0.5; // 50% chance
                if (this.isUpsideDown) {
                    this.angle = Math.PI; // Start upside-down
                }
            }
            
            // Direction: 1 = left to right, -1 = right to left
            this.direction = 1;
            this.x = -size; // Start position based on direction
            
            // Set image based on direction and upside-down state
            if (this.isUpsideDown) {
                this.image = kittyPlaneReverseImage; // Use reverse/flipped image when upside-down
            } else {
                this.image = kittyPlaneImage;
            }
            
            // Loop-the-loop parameters (clothoid trajectory)
            this.loopStartX = 0.4 * simWidth; // Where the loop begins
            this.loopRadius = 0.35 * simHeight; // Radius of the loop
            this.loopPhase = 0; // Current phase through the loop (0 = before, 1-2 = during, 3+ = after)
            this.pathDistance = 0; // Total distance traveled
            this.loopProgress = 0; // Progress through the loop (0 to 1)
            this.willDoLoop = false; // Whether this pass will do a loop
            this.loopDecided = false; // Whether we've decided about the loop yet
            
            // Propeller trails
            this.propTrail1 = []; // Trail for first blade tip
            this.propTrail2 = []; // Trail for second blade tip
            this.maxTrailLength = 100; // Number of trail points to keep
        }
        pickAltitudeAboveClouds() {
            const minY = simHeight * 0.05;
            const maxY = simHeight * 0.9;
            const buffer = 0.15;
            
            if (Clouds.length === 0) {
                // No clouds, use regular method
                return this.pickSafeAltitude();
            }
            
            // Find the highest cloud (largest y value)
            let highestCloudBottom = -Infinity;
            for (let cloud of Clouds) {
                const cloudBottom = cloud.y + cloud.radius * 0.5;
                if (cloudBottom > highestCloudBottom) {
                    highestCloudBottom = cloudBottom;
                }
            }
            
            // Try to spawn above the highest cloud
            const targetY = highestCloudBottom + buffer;
            
            // Check if there's enough room above
            if (targetY + 0.1 <= maxY) {
                // There's room, pick a random position above the highest cloud
                return targetY + Math.random() * (maxY - targetY);
            } else {
                // Not enough room above, use regular method
                return this.pickSafeAltitude();
            }
        }
        pickSafeAltitude() {
            const minY = simHeight * 0.05;
            const maxY = simHeight * 0.9;
            const buffer = 0.15; // Extra spacing buffer around clouds
            // Try to find a safe altitude (max 20 attempts)
            for (let attempt = 0; attempt < 20; attempt++) {
                const candidateY = minY + Math.random() * (maxY - minY);
                let isSafe = true;
                // Check against all cloud Clouds
                for (let cloud of Clouds) {
                    // In simulation coordinates: higher y = higher up on screen
                    const cloudBottom = cloud.y + cloud.radius * 0.5; // Flat bottom (crop line)
                    const cloudTop = cloud.y - cloud.radius * 1.2; // Approximate top below center
                    
                    // Cloud occupies the vertical range from cloudTop (lower y) to cloudBottom (higher y)
                    const effectiveTop = cloudTop - buffer; // Extend safe zone below cloud
                    const effectiveBottom = cloudBottom + buffer; // Extend safe zone above cloud
                    
                    // Check if candidate altitude conflicts with this cloud
                    // Plane is unsafe if it's between the cloud's top and bottom
                    if (candidateY >= effectiveTop && candidateY <= effectiveBottom) {
                        isSafe = false;
                        break;
                    }
                }
                if (isSafe) {
                    return candidateY;
                }
            }
            // If no safe altitude found after attempts, return a default safe position
            return simHeight * 0.2; // Low altitude as fallback
        }
        update(dt) {
            if (this.isWaiting) {
                // Count down the respawn timer
                this.waitTimer -= dt;
                
                if (this.waitTimer <= 0) {
                    // Timer expired, respawn from opposite direction
                    this.direction *= -1;
                    if (this.direction === 1) {
                        this.x = -this.size; // Start from left
                    } else {
                        this.x = simWidth + this.size; // Start from right
                    }
                    // Randomize vertical position avoiding cloud elevations
                    this.y = this.pickSafeAltitude();
                    this.baseY = this.y;
                    // Determine if plane should be upside-down (only if in top 30%)
                    const topThreshold = simHeight * 0.7;
                    this.isUpsideDown = false;
                    if (this.y > topThreshold) {
                        this.isUpsideDown = Math.random() < 0.5;
                    }
                    // Set image based on direction and upside-down state
                    if (this.isUpsideDown) {
                        this.image = this.direction === 1 ? kittyPlaneReverseImage : kittyPlaneImage;
                    } else {
                        this.image = this.direction === 1 ? kittyPlaneImage : kittyPlaneReverseImage;
                    }
                    // Reset loop parameters
                    this.pathDistance = 0;
                    this.loopPhase = 0;
                    this.loopProgress = 0;
                    this.angle = this.isUpsideDown ? Math.PI : 0;
                    this.loopDecided = false;
                    this.willDoLoop = false;
                    this.isWaiting = false;
                    
                    // Clear propeller trails
                    this.propTrail1 = [];
                    this.propTrail2 = [];
                }
            } else {
                // Check if we've reached the loop start point
                const loopTrigger = this.direction === 1 ? 
                    this.x >= this.loopStartX : 
                    this.x <= (simWidth - this.loopStartX);
                    
                if (this.loopPhase === 0 && loopTrigger && !this.isUpsideDown) {
                    // Decide whether to do a loop (50% chance) - only if not upside-down
                    // and only if plane is within bottom 25% of screen
                    const isInBottomQuarter = this.baseY <= simHeight * 0.35;
                    
                    if (!this.loopDecided && isInBottomQuarter) {
                        this.willDoLoop = Math.random() < 0.5;
                        this.loopDecided = true;
                    }
                    
                    if (this.willDoLoop) {
                        this.loopPhase = 1;
                        this.loopProgress = 0;
                    } else {
                        // Skip the loop, go straight to phase 2
                        this.loopPhase = 2;
                    }
                }
                
                if (this.loopPhase === 0) {
                    // Before the loop - straight flight
                    this.x += this.speed * dt * this.direction;
                    this.y = this.baseY;
                    this.angle = this.isUpsideDown ? Math.PI : 0;
                    this.speed = this.baseSpeed;  
                } else if (this.loopPhase === 1) {
                    // During the loop - follow circular trajectory
                    const loopCircumference = 2 * Math.PI * this.loopRadius;
                    const progressSpeed = this.baseSpeed / loopCircumference;
                    
                    // Advance through the loop based on time
                    this.loopProgress += progressSpeed * dt;
                    
                    if (this.loopProgress >= 1.0) {
                        // Loop complete
                        this.loopPhase = 2;
                        this.loopProgress = 0;
                        this.y = this.baseY;
                        this.angle = 0;
                        this.speed = this.baseSpeed;
                        // Continue moving forward after loop
                        this.x += this.speed * dt * this.direction;
                    } else {
                        // Smooth continuous trajectory
                        const p = this.loopProgress;
                        
                        // Smooth ease-in/ease-out using cosine
                        const easeProgress = 0.5 - 0.5 * Math.cos(p * Math.PI);
                        
                        // Full 2Ï€ rotation (base theta is always positive)
                        const theta = easeProgress * 2 * Math.PI;
                        
                        // Smooth speed variation
                        const speedMult = 0.85 + 0.15 * Math.sin(theta * 0.5);
                        this.speed = this.baseSpeed * speedMult;
                        
                        // Move along the circular path - velocity is tangent to the circle
                        // X movement direction depends on flight direction
                        this.x += this.speed * Math.cos(theta) * dt * this.direction;
                        // Y movement is always upward for the loop
                        this.y += this.speed * Math.sin(theta) * dt;
                        
                        // Plane angle follows the tangent (flip for reverse direction)
                        this.angle = theta * this.direction;
                    }
                } else {
                    // After the loop - straight flight
                    this.x += this.speed * dt * this.direction;
                    this.y = this.baseY;
                    this.angle = this.isUpsideDown ? Math.PI : 0;
                    this.speed = this.baseSpeed;
                }
                
                // Check if passed far beyond the edge (simWidth distance)
                const passedEdge = this.direction === 1 ? 
                    this.x - this.size > simWidth * 2 : 
                    this.x + this.size < -simWidth;
                if (passedEdge) {
                    // Start waiting timer
                    this.isWaiting = true;
                    this.waitTimer = this.respawnDelay;
                }
            }
            // Spin the propeller (faster when going faster)
            this.propellerAngle += dt * 20 * (this.speed / this.baseSpeed);
            
            // Store propeller tip positions for trails (in world coordinates)
            // Continue storing even when off-screen to let trails fade naturally
            if (!this.isWaiting) {
                // Calculate propeller tip positions in world space
                const drawSize = this.size;
                let propX, propY;
                if (this.isUpsideDown) {
                    propX = this.direction === 1 ? -drawSize * 0.452 : drawSize * 0.452;
                    propY = -drawSize * 0.125; // Negative because rotation system
                } else {
                    propX = this.direction === 1 ? drawSize * 0.452 : -drawSize * 0.452;
                    propY = -drawSize * 0.125; // Negative because rotation system
                }
                const propLength = drawSize * 0.25;
                
                // Transform propeller tips to world coordinates
                const cos = Math.cos(this.angle);
                const sin = Math.sin(this.angle);
                
                // Tip 1 (vertical blade)
                const tip1LocalX = propX;
                const tip1LocalY = propY + Math.cos(this.propellerAngle) * propLength;
                const tip1WorldX = this.x + (tip1LocalX * cos - tip1LocalY * sin);
                const tip1WorldY = this.y + (tip1LocalX * sin + tip1LocalY * cos);
                
                // Tip 2 (second blade, 90 degrees out of phase)
                const tip2LocalX = propX;
                const tip2LocalY = propY + Math.cos(this.propellerAngle + Math.PI) * propLength;
                const tip2WorldX = this.x + (tip2LocalX * cos - tip2LocalY * sin);
                const tip2WorldY = this.y + (tip2LocalX * sin + tip2LocalY * cos);
                
                // Add to trails
                this.propTrail1.push({ x: tip1WorldX, y: tip1WorldY });
                this.propTrail2.push({ x: tip2WorldX, y: tip2WorldY });
                
                // Limit trail length
                if (this.propTrail1.length > this.maxTrailLength) {
                    this.propTrail1.shift();
                }
                if (this.propTrail2.length > this.maxTrailLength) {
                    this.propTrail2.shift();
                }
            }
        }
        contains(x, y) {
            // Use rectangular collision for the moving planes
            return x >= this.x - this.size/2 && x <= this.x + this.size/2 &&
                   y >= this.y - this.size/2 && y <= this.y + this.size/2;
        }
        draw() {
            /*// Draw propeller trails first (even if plane is off-screen)
            if (this.propTrail1.length > 1) {
                c.save();
                c.lineCap = 'butt';
                c.lineJoin = 'butt';
                
                // Draw trail 1
                for (let i = 0; i < this.propTrail1.length - 1; i++) {
                    const alpha = (i / this.propTrail1.length) * 0.6;
                    const width = (i / this.propTrail1.length) * 4;
                    const point1 = this.propTrail1[i];
                    const point2 = this.propTrail1[i + 1];
                    c.strokeStyle = `hsla(200, 20%, 70%, ${alpha})`;
                    c.lineWidth = width;
                    c.beginPath();
                    c.moveTo(point1.x * cScale, canvas.height - point1.y * cScale);
                    c.lineTo(point2.x * cScale, canvas.height - point2.y * cScale);
                    c.stroke();
                }
                
                // Draw trail 2
                for (let i = 0; i < this.propTrail2.length - 1; i++) {
                    const alpha = (i / this.propTrail2.length) * 0.6;
                    const width = (i / this.propTrail2.length) * 4;
                    const point1 = this.propTrail2[i];
                    const point2 = this.propTrail2[i + 1];
                    c.strokeStyle = `hsla(200, 20%, 70%, ${alpha})`;
                    c.lineWidth = width;
                    c.beginPath();
                    c.moveTo(point1.x * cScale, canvas.height - point1.y * cScale);
                    c.lineTo(point2.x * cScale, canvas.height - point2.y * cScale);
                    c.stroke();
                }
                
                c.restore();
            }*/
            
            // Only draw the airplane if it's visible or nearby
            if (this.image && this.image.complete && !this.isWaiting) {
                const drawSize = this.size * cScale;
                const centerX = this.x * cScale;
                const centerY = canvas.height - this.y * cScale;
                
                // Draw propeller trail 1 behind the airplane
                if (this.propTrail1.length > 1) {
                    c.lineCap = 'butt';
                    c.lineJoin = 'butt';
                    for (let i = 0; i < this.propTrail1.length - 1; i++) {
                        const alpha = (i / this.propTrail1.length) * 0.7;
                        const width = (i / this.propTrail1.length) * 6;
                        const point1 = this.propTrail1[i];
                        const point2 = this.propTrail1[i + 1];
                        c.strokeStyle = `hsla(200, 20%, 70%, ${alpha})`;
                        c.lineWidth = width;
                        c.beginPath();
                        c.moveTo(point1.x * cScale, canvas.height - point1.y * cScale);
                        c.lineTo(point2.x * cScale, canvas.height - point2.y * cScale);
                        c.stroke();
                    }
                }

                // Translate to airplane center and rotate
                c.save();
                c.translate(centerX, centerY);
                c.rotate(-this.angle); // Negative because canvas Y is inverted

                // Draw the airplane image centered at origin
                c.drawImage(
                    this.image,
                    -drawSize / 2,
                    -drawSize / 2,
                    drawSize,
                    drawSize
                );
                
                // Draw spinning propeller effect
                let propX, propY;
                if (this.isUpsideDown) {
                    // When upside-down, flip the horizontal position
                    propX = this.direction === 1 ? -drawSize * 0.452 : drawSize * 0.452;
                    propY = drawSize * 0.125; // Keep same vertical offset (rotation handles the flip)
                } else {
                    propX = this.direction === 1 ? drawSize * 0.452 : -drawSize * 0.452;
                    propY = drawSize * 0.125; // Slight vertical offset
                }
                const propLength = drawSize * 0.25;
                // Calculate apparent width based on rotation angle (3D effect)
                const width1 = Math.cos(this.propellerAngle) * propLength;
                const width2 = Math.cos(this.propellerAngle + Math.PI / 2) * propLength;
                // Draw propeller blades with varying width (simulating 3D rotation)
                c.strokeStyle = 'hsla(200, 90%, 70%, 0.6)';
                c.lineWidth = 6;
                c.lineCap = 'round';
                // Vertical blade (appears to change width as it rotates)
                c.beginPath();
                c.moveTo(propX, propY - width1);
                c.lineTo(propX, propY + width1);
                c.stroke();
                // Second blade 90 degrees out of phase
                c.beginPath();
                c.moveTo(propX, propY - width2);
                c.lineTo(propX, propY + width2);
                c.stroke();
                
                c.restore();

                // Draw propeller trail 2 in front of airplane
                if (this.propTrail1.length > 1) {
                    //c.save();
                    c.lineCap = 'butt';
                    c.lineJoin = 'butt';
                    // Draw 
                    for (let i = 0; i < this.propTrail2.length - 1; i++) {
                        const alpha = (i / this.propTrail2.length) * 0.7;
                        const width = (i / this.propTrail2.length) * 6;
                        const point1 = this.propTrail2[i];
                        const point2 = this.propTrail2[i + 1];
                        c.strokeStyle = `hsla(200, 20%, 70%, ${alpha})`;
                        c.lineWidth = width;
                        c.beginPath();
                        c.moveTo(point1.x * cScale, canvas.height - point1.y * cScale);
                        c.lineTo(point2.x * cScale, canvas.height - point2.y * cScale);
                        c.stroke();
                    }
                    //c.restore();
                }
            }
        }
    }

    //  MAKE CLOUDS  ---------------------------------------------------------------------
    function findSafeCloudAltitude(isBackground, existingClouds) {
        // Both cloud types spawn in upper 75% of screen (higher y values)
        const minY = simHeight * 0.25;
        const maxY = isBackground ? simHeight * 0.9 : simHeight * 0.85;
        const minSeparation = 0.3; // Minimum vertical separation between clouds
        
        // Try to find a safe altitude (max 20 attempts)
        for (let attempt = 0; attempt < 20; attempt++) {
            const candidateY = minY + Math.random() * (maxY - minY);
            let isSafe = true;
            
            // Check against all existing clouds
            for (let cloud of existingClouds) {
                if (Math.abs(cloud.y - candidateY) < minSeparation) {
                    isSafe = false;
                    break;
                }
            }
            
            if (isSafe) {
                return candidateY;
            }
        }
        
        // If no safe position found, return a random position
        return minY + Math.random() * (maxY - minY);
    }
    
    function makeBackgroundClouds() {
        BackgroundClouds = [];
        // Spawn in upper 75% of screen (25% to 90% height)
        BackgroundClouds.push(new CLOUD(0.3 * simWidth, simHeight * (0.25 + Math.random() * 0.65), true, false));
        BackgroundClouds.push(new CLOUD(0.6 * simWidth, simHeight * (0.25 + Math.random() * 0.65), true, false));
        BackgroundClouds.push(new CLOUD(0.85 * simWidth, simHeight * (0.25 + Math.random() * 0.65), true, false));
    }
    
    function makeForegroundClouds() {
        ForegroundClouds = [];
        // Spawn one large foreground cloud in upper 75% of screen
        ForegroundClouds.push(new CLOUD(0.5 * simWidth, simHeight * (0.25 + Math.random() * 0.6), false, true));
    }
    
    function makeInitialClouds() {
        Clouds = [];
        Clouds.push(new CLOUD(0.8 * simWidth, 0.45 * simHeight, false, false));
        Clouds.push(new CLOUD(0.25 * simWidth, 0.65 * simHeight, false, false));
    }    
    
    //  MAKE AIRPLANE  ---------------------------------------------------------------------
    function makeAirplane() {
        Airplane = [];
        const y = 0.3 * simHeight;
        const speed = 0.6;
        const size = 0.3;
        const respawnDelay = 30.0;
        const isFirstPass = true;
        Airplane.push(new AIRPLANE(y, speed, size, respawnDelay, isFirstPass));
    }

    //  BOID CLASS ---------------------------------------------------------------------
    class BOID {
        constructor(pos, vel, hue, whiteBoid, blackBoid) {
            this.pos = pos.clone();
            this.vel = vel.clone();
            this.hue = hue;
            this.saturation = 0;
            this.lightness = 0;
            this.radius = boidRadius;
            this.angle = 0;
            this.hueCounter = 0;
            this.speedAdjust = 0;
            this.whiteBoid = whiteBoid
            this.blackBoid = blackBoid;
            this.flashing = false;
            this.flashTimer = 0; // Timer for flash duration
            this.flashDuration = 0.1; // How long the flash lasts (100ms)
            this.flashCooldown = 0; // Cooldown timer to prevent immediate re-flashing
            this.flashCooldownDuration = 0.3; // Must wait this long before flashing again (300ms)
            this.lastFlashCycle = -1; // Track which cycle last triggered this boid
            this.tail = [];
        }
        get left() {
            return this.pos.x - this.radius;
        }
        get right() {
            return this.pos.x + this.radius;
        }
        simulate() {
            // Enforce speed limit
            if (this.vel.length() > boidProps.speedLimit) {
                this.vel.normalize();
                this.vel.scale(boidProps.speedLimit);
            }
            // Update position based on velocity
            this.pos.x += this.vel.x * deltaT;
            this.pos.y += this.vel.y * deltaT;
            // Maintain tail 
            if (boidProps.doTails == true) {
                this.tail.push([this.pos.x, this.pos.y])
                this.tail = this.tail.slice(boidProps.tailLength);
            }
        }
        draw() {
            // scale size based on velocity
            const radScale = this.radius * cScale;
            this.speedAdjust = this.vel.length() / boidProps.speedLimit;

            // arrow dimensions ----------
            const arrowLength = Math.max((this.speedAdjust) * 1.5 * radScale, 1 * radScale);
            const arrowWidth = Math.min((1/this.speedAdjust) * 0.8 * radScale, 1.5 * radScale);
            const arrowDent = Math.min((1/this.speedAdjust) * 1.0 * radScale, 0.7 * radScale);

            // code hsl based on speed and height ----------
            this.hueCounter += 0.01;
            if (this.hueCounter >= 360) {
                this.hueCounter = 0;
            }
            this.hue = 350 - this.speedAdjust * 40 + this.hueCounter;
            this.saturation = 85;  
            this.lightness = 35 + (1 - (this.pos.y / simHeight)) * 35; 

            // Draw tail ----------
            if (boidProps.doTails == true && this.tail.length > 0) {
                c.beginPath();
                c.moveTo(cX({x: this.tail[0][0]}), cY({y: this.tail[0][1]}));
                for (var point of this.tail) {
                    c.lineTo(cX({x: point[0]}), cY({y: point[1]}));
                    
                }
                if (!this.whiteBoid && !this.blackBoid && !this.flashing) {
                    c.strokeStyle = 'hsla(0, 0%, 10%, 0.3)';
                    c.lineWidth = 1.0 + (1 - this.speedAdjust) * 1.0;
                } else if (this.whiteBoid) {
                    c.strokeStyle = `hsla(0, 0%, 95%, 0.5)`;
                    c.lineWidth = 4;
                } else if (this.blackBoid && !this.flashing) {
                    c.strokeStyle = `hsla(0, 0%, 5%, 0.5)`;
                    c.lineWidth = 4;
                } else if (this.flashing && !this.blackBoid) {
                    c.strokeStyle = `hsla(0, 0%, ${this.lightness * 1.5}%, 1.0)`;
                    c.lineWidth = 1.0 + (1 - this.speedAdjust) * 1.0;
                } else if (this.flashing && this.blackBoid) {
                    c.strokeStyle = `hsla(0, 0%, 95%, 0.5)`;
                    c.lineWidth = 1.0 + (1 - this.speedAdjust) * 1.0;
                }
                c.lineCap = 'round';
                c.stroke();
            } 

            // Set transform ----------
            const angle = Math.atan2(this.vel.y, this.vel.x);
            c.save();
            c.translate(cX(this.pos), cY(this.pos));
            //c.rotate(.5 * Math.PI - angle); // for teadrops
            c.rotate(-angle); // for arrows
            
            // fill body ----------
            c.beginPath();
            c.moveTo(arrowLength, 0);
            c.lineTo(-arrowLength, -arrowWidth / 2);
            c.lineTo(-arrowLength + arrowDent, 0);
            c.lineTo(-arrowLength, arrowWidth / 2);
            c.closePath();
            if (!this.whiteBoid && !this.blackBoid && !this.flashing) {
                c.fillStyle = `hsl(${this.hue + 70}, ${this.saturation}%, ${this.lightness}%)`;
            } else if (this.whiteBoid) {
                c.fillStyle = `hsl(0, 0%, 90%)`;
            } else if (this.blackBoid && !this.flashing) {
                c.fillStyle = `hsl(0, 0%, 10%)`;
            } else if (this.flashing && !this.blackBoid) {
                c.fillStyle = `hsl(${this.hue + 70}, ${this.saturation}%, ${this.lightness * 1.5}%)`;
            } else if (this.flashing && this.blackBoid) {
                c.fillStyle = `hsl(0, 0%, 90%)`;
            }
            c.fill();

            // draw arrow edges/wings ----------
            c.beginPath();
            c.moveTo(arrowLength, 0);
            c.lineTo(-arrowLength, -arrowWidth / 2);
            if (!this.whiteBoid && !this.blackBoid && !this.flashing) {
                c.strokeStyle = `hsl(${this.hue}, ${this.saturation}%, ${this.lightness * 0.8}%)`;
            } else if (this.whiteBoid) {
                c.strokeStyle = `hsl(0, 0%, 100%)`;
            } else if (this.blackBoid) {
                c.strokeStyle = `hsl(0, 0%, 0%)`;
            } else if (this.flashing && !this.blackBoid) {
                c.strokeStyle = `hsl(${this.hue}, ${this.saturation}%, ${this.lightness * 1.5}%)`;
            } else if (this.flashing && this.blackBoid) {
                c.strokeStyle = `hsl(0, 0%, 100%)`;
            }
            c.lineWidth = 1.0;
            c.stroke();
            c.beginPath();
            c.moveTo(-arrowLength, arrowWidth / 2);
            c.lineTo(arrowLength, 0);
            c.stroke();
            
            /*
            // Draw teardrop  -----------
            const numPoints = 32; 
            const a = 0.2;
            const b = 1.5;
            const pivotOffsetX = 0;
            const pivotOffsetY = -b * radScale;  // Centroid of bulb head
            c.beginPath();  
            for (let i = 0; i <= numPoints; i++) {
                const t = Math.PI / 2 + (i / numPoints) * (2 * Math.PI);
                const x = (2 * a * Math.cos(t) - a * Math.sin(2 * t)) * radScale;
                const y = b * Math.sin(t) * radScale;
                if (i === 0) {
                    c.moveTo(x - pivotOffsetX, y - pivotOffsetY);
                } else {
                    c.lineTo(x - pivotOffsetX, y - pivotOffsetY);
                }
            }  
            c.closePath();
            if (!this.whiteBoid && !this.blackBoid && !this.flashing) {
                c.fillStyle = `hsl(${this.hue + 70}, ${this.saturation}%, ${this.lightness}%)`;
                c.strokeStyle = `hsl(${this.hue}, ${this.saturation}%, ${this.lightness * 0.8}%)`;
            } else if (this.whiteBoid) {
                c.fillStyle = `hsl(0, 0%, 90%)`;
                c.strokeStyle = `hsl(0, 0%, 100%)`;
            } else if (this.blackBoid) {
                c.fillStyle = `hsl(0, 0%, 10%)`;
                c.strokeStyle = `hsl(0, 0%, 0%)`;
            } else if (this.flashing) {
                c.fillStyle = `hsl(${this.hue + 70}, ${this.saturation}%, ${this.lightness * 1.5}%)`;
                c.strokeStyle = `hsl(${this.hue}, ${this.saturation}%, ${this.lightness * 1.5}%)`;
            }
            c.fill();
            c.lineWidth = 1.0;
            c.stroke();
            */

            c.restore();

            /*
            // draw body circle ----------
            c.beginPath();
            c.arc(-1.5 * arrowLength, 0, 0.4 * radScale, 0, 2 * Math.PI);
            c.fillStyle = `hsl(${this.hue + 60}, ${this.saturation}%, ${this.lightness * 0.9}%)`;
            c.fill();
            */

            /*
            // draw eye circle ----------
            c.beginPath();
            c.arc(0.1 * arrowLength, -0.1 * arrowWidth, 0.005 * cScale, 0, 2 * Math.PI);
            //c.fillStyle = `blue`;
            c.fillStyle = `hsl(210, 80%, 30%)`;
            c.fill();
            */

            /*// draw beak
            c.beginPath();
            c.moveTo(arrowLength, 0);
            c.lineTo(-0.01*arrowLength, arrowWidth / 6);
            c.strokeStyle = `hsl(0, 0%, 30%)`;
            c.lineWidth = 1.0;
            c.stroke();
            c.beginPath();
            c.moveTo(arrowLength, 0);
            c.lineTo(-0.01*arrowLength, -arrowWidth / 6);
            c.stroke();*/
        }
    }

    //  MAKE BOIDS  ---------------------------------------------------------------------
    function makeBoids() {
        Boids = [];
        boidRadius = 0.02;

        boidProps = {
            numBoids: 0,
            marginX: simWidth * 0.2,
            marginY: simHeight * 0.2,
            minDistance: 5.0 * boidRadius, // Rule 1 - The distance to stay away from other Boids
            avoidFactor: 50.0, // Rule 1 -Adjust velocity by this %
            matchingFactor: 10.0, // Rule 2 - Adjust velocity by this %
            visualRange: 10.0 * boidRadius, // How far Boids can see each other
            centeringFactor: 5.0, // Rule 3 - Adjust velocity by this %
            speedLimit: 1.1, // clamp speed to this value
            turnFactor: 1.0, // How strongly Boids turn back when near edge
            tailLength: -10, // Number of trail points to keep (negative for last N points)
            doTails: true,
            blackBoidFlashInterval: 5.0, // Flash every 5 seconds
            blackBoidFlashTimer: 0,
            currentFlashCycle: 0, // Track which flash cycle we're in
        };

        // Set target boid count based on screen size
        if (simWidth < simHeight) {
            boidProps.numBoids = 500;
        } else {
            boidProps.numBoids = 2000;
        }
        // (no trails for phone?)  ---------
        if (simWidth < simHeight) {
            boidProps.doTails = true;
        } else {
            boidProps.doTails = true;
        }

        // Start with only 100 boids (will ramp up gradually)
        const initialBoidCount = 100;
        const spawnRadius = Math.sqrt(simWidth * simWidth + simHeight * simHeight) * 0.6;
        let pos, vel, ang;
        for (var i = 0; i < initialBoidCount; i += 1) {
            // Spawn from anywhere around the circle
            ang = Math.random() * 2 * Math.PI;
            pos = new Vector2(
                0.5 * simWidth + Math.cos(ang) * spawnRadius,
                0.5 * simHeight + Math.sin(ang) * spawnRadius);
            vel = new Vector2(0, 0);
            hue = 320;
            if (i == boidProps.numBoids - 1) {
                // White boid
                Boids.push(new BOID(pos, vel, hue, true, false));
            } else if (i == boidProps.numBoids - 2) {
                // Black boid
                Boids.push(new BOID(pos, vel, hue, false, true));
            } else {
                Boids.push(new BOID(pos, vel, hue, false, false));
            }
        }
    }

    // HANDLE BOID BOUNDS -------------
    function handleBounds(boid) {
        if (boid.pos.x <= boidProps.marginX) {
            boid.vel.x += boidProps.turnFactor * deltaT;
        }
        if (boid.pos.x >= simWidth - boidProps.marginX) {
            boid.vel.x -= boidProps.turnFactor * deltaT;
        }
        if (boid.pos.y <= boidProps.marginY) {
            boid.vel.y += boidProps.turnFactor * deltaT;
        }
        if (boid.pos.y >= simHeight - boidProps.marginY) {
            boid.vel.y -= boidProps.turnFactor * deltaT;
        }
    }

    //  HANDLE CLOUDS -------------
    function handleClouds(boid) {
        // CLOUD AVOIDANCE - loop through all Clouds
        for (let cloud of Clouds) {
            const cloudDx = boid.pos.x - cloud.x;
            const cloudDy = boid.pos.y - cloud.y;
            const cloudDistSq = cloudDx * cloudDx + cloudDy * cloudDy;
            const cloudAvoidRadius = cloud.radius + boidProps.minDistance * 1.5;
            const radiusSq = cloudAvoidRadius * cloudAvoidRadius;
            
            if (cloudDistSq < radiusSq && cloudDistSq > 0) {
                // Only compute sqrt when we know we need it
                const cloudDist = Math.sqrt(cloudDistSq);
                const cloudStrength = boidProps.avoidFactor * 3.0 * (cloudAvoidRadius - cloudDist) / cloudDist;
                boid.vel.x += cloudDx * cloudStrength * deltaT;
                boid.vel.y += cloudDy * cloudStrength * deltaT;
            }
        }
        
        // MOVING AIRPLANE AVOIDANCE
        for (let plane of Airplane) {
            const planeDx = boid.pos.x - plane.x;
            const planeDy = boid.pos.y - plane.y;
            const planeDistSq = planeDx * planeDx + planeDy * planeDy;
            const cloudAvoidRadius = plane.radius + boidProps.minDistance * 1.5;
            const radiusSq = cloudAvoidRadius * cloudAvoidRadius;
            
            if (planeDistSq < radiusSq && planeDistSq > 0) {
                const planeDist = Math.sqrt(planeDistSq);
                const planeStrength = boidProps.avoidFactor * 3.0 * (cloudAvoidRadius - planeDist) / planeDist;
                boid.vel.x += planeDx * planeStrength * deltaT;
                boid.vel.y += planeDy * planeStrength * deltaT;
            }
        }

        // BALLOON AVOIDANCE
        for (let balloon of Balloons) {
            const balloonDx = boid.pos.x - balloon.pos.x;
            const balloonDy = boid.pos.y - balloon.pos.y;
            const balloonDistSq = balloonDx * balloonDx + balloonDy * balloonDy;
            const balloonAvoidRadius = balloon.radius + boidProps.minDistance * 1.5;
            const radiusSq = balloonAvoidRadius * balloonAvoidRadius;
            
            if (balloonDistSq < radiusSq && balloonDistSq > 0) {
                const balloonDist = Math.sqrt(balloonDistSq);
                const balloonStrength = boidProps.avoidFactor * 3.0 * (balloonAvoidRadius - balloonDist) / balloonDist;
                boid.vel.x += balloonDx * balloonStrength * deltaT;
                boid.vel.y += balloonDy * balloonStrength * deltaT;
            }
        }
    }

    //  HANDLE FLASHING -------------
    function handleFlashing(boid) {
        // Update flash timer
        if (boid.flashing) {
            boid.flashTimer += deltaT;
            if (boid.flashTimer >= boid.flashDuration) {
                boid.flashing = false;
                boid.flashTimer = 0;
                boid.flashCooldown = boid.flashCooldownDuration; // Start cooldown
            }
        }
        
        // Update cooldown timer
        if (boid.flashCooldown > 0) {
            boid.flashCooldown -= deltaT;
            if (boid.flashCooldown < 0) {
                boid.flashCooldown = 0;
            }
        }
        
        // Check if nearby boids are flashing and respond
        // Only respond if not currently flashing, not in cooldown, not the blackBoid,
        // and hasn't already flashed in this cycle
        if (!boid.flashing && boid.flashCooldown <= 0 && !boid.blackBoid && boid.lastFlashCycle < boidProps.currentFlashCycle) {
            const nearbyBoids = SpatialGrid.getNearby(boid, boidProps.visualRange);
            const flashRangeSq = boidProps.visualRange * boidProps.visualRange;
            
            for (let otherBoid of nearbyBoids) {
                if (otherBoid !== boid && otherBoid.flashing && otherBoid.flashTimer > 0) {
                    const dx = boid.pos.x - otherBoid.pos.x;
                    const dy = boid.pos.y - otherBoid.pos.y;
                    const distSq = dx * dx + dy * dy;
                    
                    if (distSq < flashRangeSq) {
                        // Trigger flash with a small random delay
                        //const delay = Math.random() * 0.05; // 0-50ms delay
                        const delay = 0.01 + Math.random() * 0.04;
                        boid.flashTimer = -delay;
                        boid.flashing = true;
                        boid.lastFlashCycle = boidProps.currentFlashCycle; // Mark this cycle as processed
                        break;
                    }
                }
            }
        }
    }

    //  HANDLE BOID RULES -------------
    function handleBoidRules(boid) {
        let separationX = 0;
        let separationY = 0;
        let avgVelX = 0;
        let avgVelY = 0;
        let centerX = 0;
        let centerY = 0;
        let neighborCount = 0;
        
        // Get nearby boids from spatial hash
        const nearbyBoids = SpatialGrid.getNearby(boid, boidProps.visualRange);
        const visualRangeSq = boidProps.visualRange * boidProps.visualRange;
        const minDistSq = boidProps.minDistance * boidProps.minDistance;
        
        for (let otherBoid of nearbyBoids) {
            if (otherBoid !== boid) {
                const dx = boid.pos.x - otherBoid.pos.x;
                const dy = boid.pos.y - otherBoid.pos.y;
                const distSq = dx * dx + dy * dy;
                
                if (distSq < visualRangeSq) {
                    // RULE #2 - ALIGNMENT: accumulate velocities
                    avgVelX += otherBoid.vel.x;
                    avgVelY += otherBoid.vel.y;
                    
                    // RULE #3 - COHESION: accumulate positions
                    centerX += otherBoid.pos.x;
                    centerY += otherBoid.pos.y;
                    
                    if (distSq < minDistSq && distSq > 0) {
                        // RULE #1 - SEPARATION: only compute sqrt when needed
                        const dist = Math.sqrt(distSq);
                        const strength = boidProps.avoidFactor * (boidProps.minDistance - dist) / dist;
                        separationX += dx * strength;
                        separationY += dy * strength;
                    }

                    neighborCount++;
                }
            }
        }

        // RULE #1 - SEPARATION
        boid.vel.x += separationX * deltaT;
        boid.vel.y += separationY * deltaT;
        
        if (neighborCount > 0) {
            // RULE #2 - ALIGNMENT
            avgVelX /= neighborCount;
            avgVelY /= neighborCount;
            boid.vel.x += (avgVelX - boid.vel.x) * boidProps.matchingFactor * deltaT;
            boid.vel.y += (avgVelY - boid.vel.y) * boidProps.matchingFactor * deltaT;
            
            // RULE #3 - COHESION
            centerX /= neighborCount;
            centerY /= neighborCount;
            boid.vel.x += (centerX - boid.pos.x) * boidProps.centeringFactor * deltaT;
            boid.vel.y += (centerY - boid.pos.y) * boidProps.centeringFactor * deltaT;
        }
    }

    // Main animation loop  ------------
    function simulateEverything() {
        // Update background clouds
        for (let i = BackgroundClouds.length - 1; i >= 0; i--) {
            const cloud = BackgroundClouds[i];
            cloud.update(deltaT);
            
            // Check if cloud has moved off-screen to the left (account for visual size)
            // Clouds are rendered ~3x larger than their radius
            if (cloud.x + cloud.radius * 2 < 0) {
                // Remove this cloud and spawn a new one on the right
                BackgroundClouds.splice(i, 1);
                const newY = findSafeCloudAltitude(true, [...BackgroundClouds, ...Clouds]);
                BackgroundClouds.push(new CLOUD(simWidth + cloud.radius * 2, newY, true));
            }
        }
        
        // Update foreground clouds
        for (let i = Clouds.length - 1; i >= 0; i--) {
            const cloud = Clouds[i];
            cloud.update(deltaT);
            
            // Check if cloud has moved off-screen to the left (account for visual size)
            // Clouds are rendered ~3x larger than their radius
            if (cloud.x + cloud.radius * 2 < 0) {
                // Remove this cloud and spawn a new one on the right
                Clouds.splice(i, 1);
                const newY = findSafeCloudAltitude(false, [...BackgroundClouds, ...Clouds, ...ForegroundClouds]);
                Clouds.push(new CLOUD(simWidth + cloud.radius * 2, newY, false, false));
            }
        }
        
        // Update foreground (non-interactive) clouds
        for (let i = ForegroundClouds.length - 1; i >= 0; i--) {
            const cloud = ForegroundClouds[i];
            cloud.update(deltaT);
            
            // Check if cloud has moved off-screen to the left
            if (cloud.x + cloud.radius * 2 < 0) {
                // Remove this cloud and spawn a new one on the right
                ForegroundClouds.splice(i, 1);
                const newY = findSafeCloudAltitude(false, [...BackgroundClouds, ...Clouds, ...ForegroundClouds]);
                ForegroundClouds.push(new CLOUD(simWidth + cloud.radius * 2, newY, false, true));
            }
        }
        
        // Rebuild spatial grid
        SpatialGrid.clear();
        for (let boid of Boids) {
            SpatialGrid.insert(boid);
        }
        
        // Trigger blackBoid flash periodically
        boidProps.blackBoidFlashTimer += deltaT;
        if (boidProps.blackBoidFlashTimer >= boidProps.blackBoidFlashInterval) {
            // Find the blackBoid and check if it's in the central 25% of screen
            for (let boid of Boids) {
                if (boid.blackBoid) {
                    // Check if blackBoid is within central 25% of screen
                    const centerMinX = simWidth * 0.375;
                    const centerMaxX = simWidth * 0.625;
                    const centerMinY = simHeight * 0.375;
                    const centerMaxY = simHeight * 0.625;
                    
                    if (boid.pos.x >= centerMinX && boid.pos.x <= centerMaxX &&
                        boid.pos.y >= centerMinY && boid.pos.y <= centerMaxY) {
                        // BlackBoid is in central area, trigger flash
                        boidProps.blackBoidFlashTimer = 0; // Reset timer
                        boidProps.currentFlashCycle++; // Start a new flash cycle
                        boid.flashing = true;
                        boid.flashTimer = 0;
                        boid.lastFlashCycle = boidProps.currentFlashCycle;
                    }
                    // If not in center, timer stays at max and waits for blackBoid to enter center
                    break;
                }
            }
        }
        
        // Update boids
        for (var i = 0; i < Boids.length; i++) {
            var boid = Boids[i];
            handleFlashing(boid);
            handleBoidRules(boid);
            handleClouds(boid);
            handleBounds(boid);
            boid.simulate();
        }

        // Update balloon ---------
        // Timer starts at -initialDelay, reaches 0 after initialDelay time
        // After each spawn, resets to -spawnInterval
        balloonSpawnTimer += deltaT;
        
        if (balloonSpawnTimer >= 0) {
            spawnBalloon();
            balloonSpawnTimer = -balloonProps.balloonSpawnInterval;
        }
        
        for (let balloon of Balloons) {
            balloon.simulate();
        }

        // Update airplane
        if (doKitty == true) {
            for (let plane of Airplane) {
                plane.update(deltaT);
            }
        }
    }

    //  DRAW EVERYTHING  ------------
    function drawEverything() {
        // Clear canvas
        c.clearRect(0, 0, width, height);
        
        // Draw background clouds first
        for (let cloud of BackgroundClouds) {
            cloud.draw();
        }
        
        // Draw foreground clouds
        for (let cloud of Clouds) {
            cloud.draw();
        }

        // Draw boids
        for (var b = 0; b < Boids.length; b++) {
            boid = Boids[b];
            boid.draw();
        }
        
        if (doKitty == true) {
            // Draw airplane
            for (let plane of Airplane) {
                plane.draw();
            }
        }

        // Draw balloon ---------
        for (let balloon of Balloons) {
            balloon.draw();
        }
        
        // Draw large foreground clouds (non-interactive) last
        for (let cloud of ForegroundClouds) {
            cloud.draw();
        }
        
        // Draw stats (FPS and boid count)
        drawStats();
    }

    //  FPS MONITORING WITH RAMP-UP  ------------
    let fpsFrameTimes = [];
    let currentFPS = 60;
    let lastFrameTime = performance.now();
    let fpsCheckTimer = 0;
    let fpsCheckInterval = 0.25; // Check FPS every 0.25 seconds
    let minStableFPS = 57; // Target FPS threshold (stricter)
    let fpsStableTimer = 0;
    let fpsStableThreshold = 2.0; // FPS must be stable for 2 seconds before increasing (stricter)
    let isRampingUp = true; // Track if we're still ramping up
    let maxBoidsReached = false; // Track if we've hit the limit
    let safetyMarginApplied = false; // Track if we've applied the 200 boid safety reduction
    let stabilityTimerAfterMax = 0; // Timer to wait before applying safety margin
    let lastSafeBoidCount = 100; // Track the last known safe boid count
    let justReverted = false; // Track if we just reverted to safe count
    let revertVerificationTimer = 0; // Timer to verify stability after revert
    let revertVerificationPeriod = 5.0; // Wait 5 seconds after reverting before allowing further drops
    let startupWarmupTimer = 0; // Timer for startup warm-up period
    let startupWarmupPeriod = 3.0; // Wait 3 seconds after startup before monitoring FPS
    let isWarmedUp = false; // Track if warm-up period is complete

    function updateFPS() {
        const currentTime = performance.now();
        const frameTime = currentTime - lastFrameTime;
        lastFrameTime = currentTime;
        
        // Keep last 60 frame times (1 second at 60fps) - longer window for better stability check
        fpsFrameTimes.push(frameTime);
        if (fpsFrameTimes.length > 60) {
            fpsFrameTimes.shift();
        }
        
        // Calculate average FPS
        if (fpsFrameTimes.length > 0) {
            const avgFrameTime = fpsFrameTimes.reduce((a, b) => a + b) / fpsFrameTimes.length;
            currentFPS = 1000 / avgFrameTime;
        }
    }

    function checkAndAdjustBoids() {
        // Handle startup warm-up period
        if (!isWarmedUp) {
            startupWarmupTimer += deltaT;
            
            if (startupWarmupTimer >= startupWarmupPeriod) {
                isWarmedUp = true;
                // Reset FPS tracking after warm-up to start fresh
                fpsFrameTimes = [];
                lastFrameTime = performance.now();
                currentFPS = 60;
            } else {
                // During warm-up, just return without adjusting boids
                return;
            }
        }
        
        fpsCheckTimer += deltaT;
        
        if (fpsCheckTimer >= fpsCheckInterval) {
            fpsCheckTimer = 0;
            
            // Calculate how many frames are significantly slower
            let unstableFrames = 0;
            let maxFrameTime = 0;
            let minFrameTime = Infinity;
            
            for (let frameTime of fpsFrameTimes) {
                const fps = 1000 / frameTime;
                if (fps < minStableFPS) {
                    unstableFrames++;
                }
                maxFrameTime = Math.max(maxFrameTime, frameTime);
                minFrameTime = Math.min(minFrameTime, frameTime);
            }
            
            // Calculate variance to check consistency
            const variance = maxFrameTime - minFrameTime;
            const isConsistent = variance < 5; // Less than 5ms variance between frames
            
            // Update revert verification timer if we just reverted
            if (justReverted) {
                if (currentFPS >= minStableFPS && isConsistent) {
                    revertVerificationTimer += fpsCheckInterval;
                    
                    if (revertVerificationTimer >= revertVerificationPeriod) {
                        // Verification period complete, system is stable at safe count
                        justReverted = false;
                        revertVerificationTimer = 0;
                    }
                } else {
                    // Still unstable during verification - reset timer to keep waiting
                    revertVerificationTimer = 0;
                }
            }
            
            // Check if FPS is unstable or too low (stricter criteria)
            if (currentFPS < minStableFPS || unstableFrames > fpsFrameTimes.length * 0.1 || !isConsistent) {
                // Only revert if not currently in verification period
                if (!justReverted && Boids.length > lastSafeBoidCount && lastSafeBoidCount >= 100) {
                    const removeCount = Boids.length - lastSafeBoidCount;
                    
                    // Remove from the end, but keep the special boids (last 2)
                    if (Boids.length > 2 && removeCount > 0) {
                        // Remove regular boids from before the special ones
                        Boids.splice(Boids.length - 2 - removeCount, removeCount);
                    }
                    isRampingUp = false; // Stop ramping up
                    maxBoidsReached = true; // We've found the limit
                    justReverted = true; // Start verification period
                    revertVerificationTimer = 0;
                }
                fpsStableTimer = 0; // Reset stability timer
                stabilityTimerAfterMax = 0; // Reset stability timer for safety margin
            } else if (isRampingUp && !maxBoidsReached && currentFPS >= minStableFPS && isConsistent && !justReverted) {
                // FPS is good, increment stability timer
                fpsStableTimer += fpsCheckInterval;
                
                // Once FPS has been stable for the threshold period, add more boids
                if (fpsStableTimer >= fpsStableThreshold && Boids.length < boidProps.numBoids) {
                    fpsStableTimer = 0; // Reset timer
                    
                    // Save current count as last safe before adding more
                    lastSafeBoidCount = Boids.length;
                    
                    // Add 100 more boids
                    const addCount = Math.min(100, boidProps.numBoids - Boids.length);
                    const spawnRadius = Math.sqrt(simWidth * simWidth + simHeight * simHeight) * 0.6;
                    
                    for (let i = 0; i < addCount; i++) {
                        // Spawn from anywhere around the circle
                        const ang = Math.random() * 2 * Math.PI;
                        const pos = new Vector2(
                            0.5 * simWidth + Math.cos(ang) * spawnRadius,
                            0.5 * simHeight + Math.sin(ang) * spawnRadius);
                        const vel = new Vector2(0, 0);
                        const hue = 320;
                        
                        // Insert before the last 2 special boids
                        const newBoid = new BOID(pos, vel, hue, false, false);
                        Boids.splice(Boids.length - 2, 0, newBoid);
                    }
                    
                    // Check if we've reached the target
                    if (Boids.length >= boidProps.numBoids) {
                        isRampingUp = false;
                        maxBoidsReached = true;
                    }
                }
            } else if (maxBoidsReached && !safetyMarginApplied && currentFPS >= minStableFPS && isConsistent) {
                // Max reached, wait for stability then apply safety margin
                stabilityTimerAfterMax += fpsCheckInterval;
                
                if (stabilityTimerAfterMax >= 3.0 && Boids.length > 200) {
                    // Remove 200 boids as safety margin
                    const removeCount = Math.min(200, Boids.length - 100);
                    
                    if (Boids.length > 2) {
                        // Remove regular boids from before the special ones
                        Boids.splice(Boids.length - 2 - removeCount, removeCount);
                    }
                    
                    safetyMarginApplied = true;
                }
            }
        }
    }

    function drawStats() {
        // Draw FPS and boid count at bottom right
        c.save();
        
        // Set text properties
        c.font = '16px monospace';
        c.textAlign = 'right';
        c.textBaseline = 'bottom';
        
        // Prepare text
        const fpsText = `${currentFPS.toFixed(0)} fps`;
        const boidText = `${Boids.length} boids`;
        
        // Position at bottom right with padding
        const padding = 10;
        const lineHeight = 20;
        const x = canvas.width - padding;
        let y = canvas.height - padding;
        
        // Draw boid count
        // White text
        if (currentFPS >= 58) {
            c.fillStyle = '#00ff00'; // Green
        } else if (currentFPS >= 45) {
            c.fillStyle = '#ffff00'; // Yellow
        } else {
            c.fillStyle = '#ff0000'; // Red
        }
        c.fillText(boidText, x, y);
        
        /*
        // Draw FPS above it
        y -= lineHeight;
        // Color based on FPS
        if (currentFPS >= 58) {
            c.fillStyle = '#00ff00'; // Green
        } else if (currentFPS >= 45) {
            c.fillStyle = '#ffff00'; // Yellow
        } else {
            c.fillStyle = '#ff0000'; // Red
        }
        c.fillText(fpsText, x, y);
        */
        c.restore();
    }

    //  SETUP SCENE  ------------
    function setupScene() {
        deltaT = 1/60;
        lastFrameTime = performance.now();
        
        doKitty = true;
        // Load plane images
        kittyPlaneImage = new Image();
        kittyPlaneImage.src = 'kitty_plane.png';
        kittyPlaneReverseImage = new Image();
        kittyPlaneReverseImage.src = 'kitty_plane_reverse.png';
        // make Boids ----------
        makeBoids();
        // make Background Clouds ----------
        makeBackgroundClouds();
        // make Foreground Clouds (non-interactive) ----------
        makeForegroundClouds();
        // make Interactive Clouds ----------
        makeInitialClouds();
        // make Airplane ----------
        makeAirplane();
        // make balloon ----------
        initBalloon();
        // make spatial grid ----------
        makeSpatialGrid();
        SpatialGrid = new SpatialHashGrid(boidProps.visualRange);

        /*
        // Load and play audio from GitHub LFS
        const audio = new Audio('https://media.githubusercontent.com/media/frank-maiello/frank-maiello.github.io/main/audio.mp3');
        audio.loop = true; // Loop the audio
        audio.volume = 0.5; // Set volume to 50%
        
        // Try to play audio immediately, or wait for user interaction if blocked
        audio.play().catch(function(error) {
            console.log('Audio autoplay blocked. Waiting for user interaction...');
            // Play on first click anywhere on the page
            document.addEventListener('click', function() {
                audio.play();
            }, { once: true });
        });
        */
    }

    //  RUN  ------------------------------------------------
    setupScene();
    
    function update() {
        updateFPS();
        checkAndAdjustBoids();
        simulateEverything();
        drawEverything();
        requestAnimationFrame(update);
    } 
    update();

    </script>
</body>
</html>