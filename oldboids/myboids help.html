<!DOCTYPE html>
<html>
    <head>
    <meta name="viewport" content="width=500, initial-scale=1.0">
    <title>Boids</title>
        <style type="text/css">
            body {
            margin: 0;
            background: hsl(220, 13%, 18%);
            overflow: hidden;
            }
        </style>
    </head>
<body>
<canvas id="myCanvas" width="100%" height="100%"></canvas>
<script>

// Setup canvas and handle window resizing  ------------------
canvas = document.getElementById("myCanvas");
ctx = canvas.getContext("2d");
width = window.innerWidth;
height = window.innerHeight;
canvas.width = width;
canvas.height = height;

simMinWidth = 2.0;
cScale = Math.min(canvas.width, canvas.height) / simMinWidth;
simWidth = canvas.width / cScale;
simHeight = canvas.height / cScale;

function resizeCanvas() {
    canvas = document.getElementById("myCanvas");
    ctx = canvas.getContext("2d");
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    const oldSimWidth = simWidth;
    const oldSimHeight = simHeight;

    simMinWidth = 2.0;
    cScale = Math.min(canvas.width, canvas.height) / simMinWidth;
    simWidth = canvas.width / cScale;
    simHeight = canvas.height / cScale;

    // Calculate scale factors
    const scaleX = simWidth / oldSimWidth;
    const scaleY = simHeight / oldSimHeight;
    
    // Scale boid positions
    if (typeof boid !== 'undefined' && boid != null) {
        for (let boid of boids) {
            boid.pos.x *= scaleX;
            boid.pos.y *= scaleY;
        }
    }
}
window.addEventListener("resize", resizeCanvas);

//  VECTOR OPERATIONS ---------------------------------------------------------------------
class Vector2 {
    constructor(x = 0.0, y = 0.0) {
        this.x = x; 
        this.y = y;
    }
    clone() {
        return new Vector2(this.x, this.y);
    }
    add(v, s=1) {
        this.x += v.x * s;
        this.y += v.y * s;
        return this;
    }
    subtract(v, s = 1.0) {
        this.x -= v.x * s;
        this.y -= v.y * s;
        return this;
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    scale(s) {
        this.x *= s;
        this.y *= s;
    }
}

function cX(pos) {
    return pos.x * cScale;
}

function cY(pos) {
    return canvas.height - pos.y * cScale;
}

class BOID {
    constructor(pos, vel) {
        this.pos = pos.clone();
        this.vel = vel.clone();
        this.radius = 0.02;
        this.angle = 0;
        this.history = [];
    }
    simulate(){
        this.pos.x += this.vel.x * dT;
        this.pos.y += this.vel.y * dT;
        this.history.push([this.pos.x, this.pos.y])
        this.history = this.history.slice(-50);
    }
    draw(){
        // Draw boid ----------
        const angle = Math.atan2(this.vel.y, this.vel.x);
        ctx.save();
        ctx.translate(cX(this.pos), cY(this.pos));
        ctx.rotate(-angle);
        ctx.beginPath();
        ctx.moveTo(1.0 * this.radius * cScale, 0);
        ctx.lineTo(-1 * this.radius * cScale, 0.5 * this.radius * cScale);
        ctx.lineTo(-1 * this.radius * cScale, -0.5 * this.radius * cScale);
        ctx.closePath();
        ctx.fillStyle = 'hsl(320, 90%, 40%)';
        ctx.fill();
        ctx.restore();

        // Draw trail ----------
        const drawTrail = false;
        if (drawTrail == true && this.history.length > 0) {
            ctx.strokeStyle = 'blue';
            ctx.beginPath();
            ctx.moveTo(cX({x: this.history[0][0]}), cY({y: this.history[0][1]}));
            for (const point of this.history) {
                ctx.lineTo(cX({x: point[0]}), cY({y: point[1]}));
            }
            ctx.stroke();
        }
    }
}

function initBoids() {
    boids = [];
    const spawnRadius = Math.sqrt(simWidth * simWidth + simHeight * simHeight) * 0.6;
    let pos, vel, ang;
    const numBoids = 1000;
    for (var i = 0; i < numBoids; i += 1) {
        ang = Math.random() * 2 * Math.PI;
        pos = new Vector2(
            0.5 * simWidth + Math.cos(ang) * spawnRadius,
            0.5 * simHeight + Math.sin(ang) * spawnRadius);
        vel = new Vector2((Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2);
        boids.push(new BOID(pos, vel));
    }
}

function distance(boid1, boid2) {
    return Math.sqrt(
        (boid1.pos.x - boid2.pos.x) * (boid1.pos.x - boid2.pos.x) +
        (boid1.pos.y - boid2.pos.y) * (boid1.pos.y - boid2.pos.y),
    );
}

// Constrain a boid to within the window. If it gets too close to an edge,
// nudge it back in and reverse its direction.
function keepWithinBounds(boid) {
    const margin = -Math.min(simWidth, simHeight) * 0.1;
    const turnFactor = 6;
    if (boid.pos.x < margin) {
        boid.vel.x += turnFactor * dT;
    }
    if (boid.pos.x > simWidth - margin) {
        boid.vel.x -= turnFactor * dT;
    }
    if (boid.pos.y < margin) {
        boid.vel.y += turnFactor * dT;
    }
    if (boid.pos.y > simHeight - margin) {
        boid.vel.y -= turnFactor * dT;
    }
}



// RULE #1 - SEPARATION  -------------------------------
// Move away from other boids that are too close to avoid colliding
function avoidOthers(boid) {
    const minDistance = 0.1; 
    const avoidFactor = 100.0; 
    let moveX = 0;
    let moveY = 0;
    for (let otherBoid of boids) {
        if (otherBoid !== boid) {
            const dist = distance(boid, otherBoid);
            if (dist < boidProps.minDistance && dist > 0) {
                // Stronger force when closer (inverse distance weighting)
                const strength = (boidProps.minDistance - dist) / dist;
                moveX += (boid.pos.x - otherBoid.pos.x) * strength;
                moveY += (boid.pos.y - otherBoid.pos.y) * strength;
            }
        }
    }
    boid.vel.x += moveX * boidProps.avoidFactor * dT;
    boid.vel.y += moveY * boidProps.avoidFactor * dT;
}

// RULE #2 - ALIGNMENT  -------------------------------
// Find the average velocity (speed and direction) of the other boids and
// adjust velocity slightly to match.
function matchVelocity(boid) {
    let avgVelX = 0;
    let avgVelY = 0;
    let numNeighbors = 0;
    for (let otherBoid of boids) {
        if (distance(boid, otherBoid) < boidProps.visualRange) {
        avgVelX += otherBoid.vel.x;
        avgVelY += otherBoid.vel.y;
        numNeighbors += 1;
        }
    }
    if (numNeighbors) {
        avgVelX = avgVelX / numNeighbors;
        avgVelY = avgVelY / numNeighbors;
        boid.vel.x += (avgVelX - boid.vel.x) * boidProps.matchingFactor * dT;
        boid.vel.y += (avgVelY - boid.vel.y) * boidProps.matchingFactor * dT;
    }
}

// RULE #3 - COHESION  -------------------------------
// Find the center of mass of the other boids and adjust velocity slightly to
// point towards the center of mass.
function flyTowardsCenter(boid) {
    let centerX = 0;
    let centerY = 0;
    let numNeighbors = 0;
    for (let otherBoid of boids) {
        if (distance(boid, otherBoid) < boidProps.visualRange) {
        centerX += otherBoid.pos.x;
        centerY += otherBoid.pos.y;
        numNeighbors += 1;
        }
    }
    if (numNeighbors) {
        centerX = centerX / numNeighbors;
        centerY = centerY / numNeighbors;
        boid.vel.x += (centerX - boid.pos.x) * boidProps.centeringFactor * dT;
        boid.vel.y += (centerY - boid.pos.y) * boidProps.centeringFactor * dT;
    }
}

//  LIMIT SPEED ---------
function clampSpeed(boid) {
  const speed = boid.vel.length();
  if (speed > boidProps.speedLimit) {
    boid.vel.x = (boid.vel.x / speed) * boidProps.speedLimit;
    boid.vel.y = (boid.vel.y / speed) * boidProps.speedLimit;
  }
}

// Main animation loop
function simulateEverything() {
    // Update each boid
    for (let boid of boids) {
        // RULE #1 - SEPARATION  
        avoidOthers(boid);
        // RULE #2 - ALIGNMENT 
        matchVelocity(boid);
        // RULE #3 - COHESION  
        flyTowardsCenter(boid);
        //  Limit Speed 
        clampSpeed(boid);
        //  Stay Within Bounds 
        keepWithinBounds(boid);

        // Update the position based on the current velocity
        boid.pos.x += boid.vel.x * dT;
        boid.pos.y += boid.vel.y * dT;
        boid.history.push([boid.pos.x, boid.pos.y])
        boid.history = boid.history.slice(-50);
    }
}

function drawEverything() {
    ctx.clearRect(0, 0, width, height);
    //for (let boid of boids) {
    //    boid.draw();
    //}
    for (var b = 0; b < boids.length; b++) {
        boid = boids[b];
        boid.draw();
    }
}

function setupScene() {
    dT = 1/60;
    initBoids();

    boidProps = {
        minDistance: 0.1, // Rule 1 - The distance to stay away from other boids
        avoidFactor: 80.0, // Rule 1 -Adjust velocity by this %
        matchingFactor: 10.0, // Rule 2 - Adjust velocity by this %
        visualRange: 0.3, // How far boids can see each other
        centeringFactor: 5.0, // Rule 3 - Adjust velocity by this %
        speedLimit: 1.0, // clamp speed to this value
    }
}
setupScene()

function update() {
        simulateEverything();
		drawEverything();
		requestAnimationFrame(update);
	} 
update();

</script>
</body>
</html>