<!DOCTYPE html>
<html>
    <head>
    <meta name="viewport" content="width=500, initial-scale=1.0">
    <title>Boids</title>
        <style type="text/css">
            body {
            margin: 0;
            background: hsl(220, 13%, 18%);
            overflow: hidden;
            }
        </style>
    </head>
<body>
<canvas id="myCanvas" width="100%" height="100%"></canvas>
<script>

// Setup canvas and handle window resizing  ------------------
canvas = document.getElementById("myCanvas");
ctx = canvas.getContext("2d");
width = window.innerWidth;
height = window.innerHeight;
canvas.width = width;
canvas.height = height;

simMinWidth = 2.0;
cScale = Math.min(canvas.width, canvas.height) / simMinWidth;
simWidth = canvas.width / cScale;
simHeight = canvas.height / cScale;

function resizeCanvas() {
    canvas = document.getElementById("myCanvas");
    ctx = canvas.getContext("2d");
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    const oldSimWidth = simWidth;
    const oldSimHeight = simHeight;

    simMinWidth = 2.0;
    cScale = Math.min(canvas.width, canvas.height) / simMinWidth;
    simWidth = canvas.width / cScale;
    simHeight = canvas.height / cScale;

    // Calculate scale factors
    const scaleX = simWidth / oldSimWidth;
    const scaleY = simHeight / oldSimHeight;
    
    // Scale boid positions
    if (typeof boid !== 'undefined' && boid != null) {
        for (let boid of boids) {
            boid.pos.x *= scaleX;
            boid.pos.y *= scaleY;
        }
    }
}
window.addEventListener("resize", resizeCanvas);

//  VECTOR OPERATIONS ---------------------------------------------------------------------
class Vector2 {
    constructor(x = 0.0, y = 0.0) {
        this.x = x; 
        this.y = y;
    }
    clone() {
        return new Vector2(this.x, this.y);
    }
    add(v, s=1) {
        this.x += v.x * s;
        this.y += v.y * s;
        return this;
    }
    addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        return this;
    }
    subtract(v, s = 1.0) {
        this.x -= v.x * s;
        this.y -= v.y * s;
        return this;
    }
    subtractVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        return this;			
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    scale(s) {
        this.x *= s;
        this.y *= s;
    }
    normalize() {
        const len = this.length();
        if (len > 0) {
            this.x /= len;
            this.y /= len;
        }
        return this;
    }
}

function cX(pos) {
    return pos.x * cScale;
}

function cY(pos) {
    return canvas.height - pos.y * cScale;
}

class BOID {
    constructor(pos, vel) {
        this.pos = pos.clone();
        this.vel = vel.clone();
        this.radius = boidRadius;
        this.angle = 0;
        this.history = [];
    }
    simulate(){
        this.pos.x += this.vel.x * deltaT;
        this.pos.y += this.vel.y * deltaT;
        this.history.push([this.pos.x, this.pos.y])
        this.history = this.history.slice(-50);
    }
    draw(){
        // Draw boid ----------
        const angle = Math.atan2(this.vel.y, this.vel.x);
        ctx.save();
        ctx.translate(cX(this.pos), cY(this.pos));
        ctx.rotate(-angle);
        ctx.beginPath();
        ctx.moveTo(1.0 * this.radius * cScale, 0);
        ctx.lineTo(-1 * this.radius * cScale, 0.5 * this.radius * cScale);
        ctx.lineTo(-1 * this.radius * cScale, -0.5 * this.radius * cScale);
        ctx.closePath();
        ctx.fillStyle = 'hsl(320, 90%, 40%)';
        ctx.fill();
        //ctx.arc(0, 0, this.radius * cScale, 0, 2 * Math.PI);
        //ctx.strokeStyle = 'hsl(320, 90%, 60%)';
        //ctx.lineWidth = 0.5;
        //ctx.stroke();
        ctx.restore();

        // Draw trail ----------
        const drawTrail = false;
        if (drawTrail == true && this.history.length > 0) {
            ctx.strokeStyle = 'blue';
            ctx.beginPath();
            ctx.moveTo(cX({x: this.history[0][0]}), cY({y: this.history[0][1]}));
            for (const point of this.history) {
                ctx.lineTo(cX({x: point[0]}), cY({y: point[1]}));
            }
            ctx.stroke();
        }
    }
}

function initBoids() {
    boids = [];
    const spawnRadius = Math.sqrt(simWidth * simWidth + simHeight * simHeight) * 0.6;
    let pos, vel, ang;
    for (var i = 0; i < boidProps.numBoids; i += 1) {
        ang = Math.random() * 2 * Math.PI;
        pos = new Vector2(
            0.5 * simWidth + Math.cos(ang) * spawnRadius,
            0.5 * simHeight + Math.sin(ang) * spawnRadius);
        vel = new Vector2((Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2);
        boids.push(new BOID(pos, vel));
    }
}

// Constrain a boid to within the window. If it gets too close to an edge,
// nudge it back in and reverse its direction.
function keepWithinBounds(boid) {
    const margin = -Math.min(simWidth, simHeight) * 0.1;
    const turnFactor = 6;
    if (boid.pos.x < margin) {
        boid.vel.x += turnFactor * deltaT;
    }
    if (boid.pos.x > simWidth - margin) {
        boid.vel.x -= turnFactor * deltaT;
    }
    if (boid.pos.y < margin) {
        boid.vel.y += turnFactor * deltaT;
    }
    if (boid.pos.y > simHeight - margin) {
        boid.vel.y -= turnFactor * deltaT;
    }
}

// RULE #1 - SEPARATION  -------------------------------
// Steer away from close boids
function avoidBoids(boid) {
    for (let otherBoid of boids) {
        if (otherBoid !== boid) {
            var dir = new Vector2();
            dir.subtractVectors(boid.pos, otherBoid.pos);
            const dist = dir.length();
            if (dist < boidProps.minDistance && dist > 0) {
                // Stronger force when closer (inverse distance weighting)
                const strength = boidProps.avoidFactor * (boidProps.minDistance - dist) / dist;
                dir.scale(strength * deltaT);
                boid.vel.add(dir);
            }
        }
    }
}

// RULE #2 - ALIGNMENT  -------------------------------
// Find the average velocity vector of the other boids and
// adjust boid velocity slightly to match
function matchVelocity(boid) {
    let avgVel = new Vector2(0, 0);
    let numNeighbors = 0;
    for (let otherBoid of boids) {
        if (otherBoid !== boid) {
            var dir = new Vector2();
            dir.subtractVectors(boid.pos, otherBoid.pos);
            const dist = dir.length();
            if (dist < boidProps.visualRange) {
                avgVel.add(otherBoid.vel);
                numNeighbors += 1;
            }
        }
    }
    if (numNeighbors) {
        avgVel.scale(1 / numNeighbors);
        const adjustment = new Vector2();
        adjustment.subtractVectors(avgVel, boid.vel);
        adjustment.scale(boidProps.matchingFactor * deltaT);
        boid.vel.add(adjustment);
    }
}

// RULE #3 - COHESION  -------------------------------
// Find the center of mass of the other boids and adjust velocity slightly to
// point towards the center of mass.
function flyTowardsCenter(boid) {
    let center = new Vector2(0, 0);
    let numNeighbors = 0;
    for (let otherBoid of boids) {
        if (otherBoid !== boid) {
            var dir = new Vector2();
            dir.subtractVectors(boid.pos, otherBoid.pos);
            const dist = dir.length();
            if (dist < boidProps.visualRange) {
            center.add(otherBoid.pos);
            numNeighbors += 1;
            }
        }
    }
    if (numNeighbors) {
        center.scale(1 / numNeighbors);
        const adjustment = new Vector2();
        adjustment.scale(boidProps.centeringFactor * deltaT);
        adjustment.subtractVectors(center, boid.pos);
        boid.vel.add(adjustment);
    }
}

//  LIMIT SPEED ---------
function clampSpeed(boid) {
  const speed = boid.vel.length();
  if (speed > boidProps.speedLimit) {
    // use vector normalization to clamp speed
    boid.vel.normalize();
    boid.vel.scale(boidProps.speedLimit);
  }
}

// Main animation loop
function simulateEverything() {
    // Update each boid
    for (let boid of boids) {
        // RULE #1 - SEPARATION  
        avoidBoids(boid);
        // RULE #2 - ALIGNMENT 
        matchVelocity(boid);
        // RULE #3 - COHESION  
        flyTowardsCenter(boid);
        //  Limit Speed 
        clampSpeed(boid);
        //  Stay Within Bounds 
        keepWithinBounds(boid);
        //  Update Position
        boid.simulate();
    }
}

function drawEverything() {
    ctx.clearRect(0, 0, width, height);
    for (var b = 0; b < boids.length; b++) {
        boid = boids[b];
        boid.draw();
    }
}

function setupScene() {
    boidRadius = 0.01
    boidProps = {
        numBoids: 1000,
        minDistance: 5 * boidRadius, // Rule 1 - The distance to stay away from other boids
        avoidFactor: 80.0, // Rule 1 -Adjust velocity by this %
        matchingFactor: 10.0, // Rule 2 - Adjust velocity by this %
        visualRange: 10 * boidRadius, // How far boids can see each other
        centeringFactor: 5.0, // Rule 3 - Adjust velocity by this %
        speedLimit: 1.0, // clamp speed to this value
    }
    deltaT = 1/60;
    // make boids ----------
    initBoids();
}

setupScene();
function update() {
        simulateEverything();
		drawEverything();
		requestAnimationFrame(update);
	} 
update();

</script>
</body>
</html>