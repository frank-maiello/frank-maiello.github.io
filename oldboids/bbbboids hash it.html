<!DOCTYPE html>
<html>
    <head>
    <meta name="viewport" content="width=500, initial-scale=1.0">
    <title>Boids</title>
        <style type="text/css">
            body {
            margin: 0;
            background: hsl(220, 13%, 18%);
            overflow: hidden;
            }
        </style>
    </head>
<body>
<canvas id="myCanvas" width="100%" height="100%"></canvas>
<script>

// Setup canvas and handle window resizing  ------------------
canvas = document.getElementById("myCanvas");
ctx = canvas.getContext("2d");
width = window.innerWidth;
height = window.innerHeight;
canvas.width = width;
canvas.height = height;

simMinWidth = 2.0;
cScale = Math.min(canvas.width, canvas.height) / simMinWidth;
simWidth = canvas.width / cScale;
simHeight = canvas.height / cScale;

function resizeCanvas() {
    canvas = document.getElementById("myCanvas");
    ctx = canvas.getContext("2d");
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    const oldSimWidth = simWidth;
    const oldSimHeight = simHeight;

    simMinWidth = 2.0;
    cScale = Math.min(canvas.width, canvas.height) / simMinWidth;
    simWidth = canvas.width / cScale;
    simHeight = canvas.height / cScale;

    // Calculate scale factors
    const scaleX = simWidth / oldSimWidth;
    const scaleY = simHeight / oldSimHeight;
    
    // Scale boid positions
    if (typeof boid !== 'undefined' && boid != null) {
        for (let boid of boids) {
            boid.pos.x *= scaleX;
            boid.pos.y *= scaleY;
        }
    }
}
window.addEventListener("resize", resizeCanvas);

//  VECTOR OPERATIONS ---------------------------------------------------------------------
class Vector2 {
    constructor(x = 0.0, y = 0.0) {
        this.x = x; 
        this.y = y;
    }
    clone() {
        return new Vector2(this.x, this.y);
    }
    add(v, s=1) {
        this.x += v.x * s;
        this.y += v.y * s;
        return this;
    }
    addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        return this;
    }
    subtract(v, s = 1.0) {
        this.x -= v.x * s;
        this.y -= v.y * s;
        return this;
    }
    subtractVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        return this;			
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    scale(s) {
        this.x *= s;
        this.y *= s;
    }
    normalize() {
        const len = this.length();
        if (len > 0) {
            this.x /= len;
            this.y /= len;
        }
        return this;
    }
}

//  SPATIAL HASH GRID ---------------------------------------------------------------------
class SpatialHashGrid {
    constructor(cellSize) {
        this.cellSize = cellSize;
        this.grid = new Map();
    }
    
    // Convert position to grid key
    getKey(x, y) {
        const gridX = Math.floor(x / this.cellSize);
        const gridY = Math.floor(y / this.cellSize);
        return `${gridX},${gridY}`;
    }
    
    // Clear the grid
    clear() {
        this.grid.clear();
    }
    
    // Add boid to grid
    insert(boid) {
        const key = this.getKey(boid.pos.x, boid.pos.y);
        if (!this.grid.has(key)) {
            this.grid.set(key, []);
        }
        this.grid.get(key).push(boid);
    }
    
    // Get nearby boids within a radius
    getNearby(boid, radius) {
        const nearby = [];
        const cellRadius = Math.ceil(radius / this.cellSize);
        const centerX = Math.floor(boid.pos.x / this.cellSize);
        const centerY = Math.floor(boid.pos.y / this.cellSize);
        
        // Check all cells within the radius
        for (let dx = -cellRadius; dx <= cellRadius; dx++) {
            for (let dy = -cellRadius; dy <= cellRadius; dy++) {
                const key = `${centerX + dx},${centerY + dy}`;
                if (this.grid.has(key)) {
                    nearby.push(...this.grid.get(key));
                }
            }
        }
        return nearby;
    }
}

function cX(pos) {
    return pos.x * cScale;
}

function cY(pos) {
    return canvas.height - pos.y * cScale;
}

class BOID {
    constructor(pos, vel) {
        this.pos = pos.clone();
        this.vel = vel.clone();
        this.radius = boidRadius;
        this.angle = 0;
        //this.history = [];
    }
    simulate(){
        this.pos.x += this.vel.x * deltaT;
        this.pos.y += this.vel.y * deltaT;
        //this.history.push([this.pos.x, this.pos.y])
        //this.history = this.history.slice(-50);
    }
    draw(){
        // Draw boid ----------
        const angle = Math.atan2(this.vel.y, this.vel.x);
        ctx.save();
        ctx.translate(cX(this.pos), cY(this.pos));
        ctx.rotate(-angle);
        ctx.beginPath();
        ctx.moveTo(1.0 * this.radius * cScale, 0);
        ctx.lineTo(-1 * this.radius * cScale, 0.5 * this.radius * cScale);
        ctx.lineTo(-1 * this.radius * cScale, -0.5 * this.radius * cScale);
        ctx.closePath();
        ctx.fillStyle = 'hsl(320, 90%, 40%)';
        ctx.fill();
        //ctx.arc(0, 0, this.radius * cScale, 0, 2 * Math.PI);
        //ctx.strokeStyle = 'hsl(320, 90%, 60%)';
        //ctx.lineWidth = 0.5;
        //ctx.stroke();
        ctx.restore();

        // Draw trail ----------
        const drawTrail = false;
        if (drawTrail == true && this.history.length > 0) {
            ctx.strokeStyle = 'blue';
            ctx.beginPath();
            ctx.moveTo(cX({x: this.history[0][0]}), cY({y: this.history[0][1]}));
            for (const point of this.history) {
                ctx.lineTo(cX({x: point[0]}), cY({y: point[1]}));
            }
            ctx.stroke();
        }
    }
}

function initBoids() {
    boids = [];
    const spawnRadius = Math.sqrt(simWidth * simWidth + simHeight * simHeight) * 0.6;
    let pos, vel, ang;
    for (var i = 0; i < boidProps.numBoids; i += 1) {
        ang = Math.random() * 2 * Math.PI;
        pos = new Vector2(
            0.5 * simWidth + Math.cos(ang) * spawnRadius,
            0.5 * simHeight + Math.sin(ang) * spawnRadius);
        vel = new Vector2((Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2);
        boids.push(new BOID(pos, vel));
    }
}

// Constrain a boid to within the window. If it gets too close to an edge,
// nudge it back in and reverse its direction.
function keepWithinBounds(boid) {
    const margin = -Math.min(simWidth, simHeight) * 0.1;
    const turnFactor = 6;
    if (boid.pos.x < margin) {
        boid.vel.x += turnFactor * deltaT;
    }
    if (boid.pos.x > simWidth - margin) {
        boid.vel.x -= turnFactor * deltaT;
    }
    if (boid.pos.y < margin) {
        boid.vel.y += turnFactor * deltaT;
    }
    if (boid.pos.y > simHeight - margin) {
        boid.vel.y -= turnFactor * deltaT;
    }
}

// APPLY ALL FLOCKING RULES -------------------------------
// Get neighbors once and apply all three rules in one pass
function applyFlockingRules(boid) {
    // Get all nearby boids once
    const nearby = spatialGrid.getNearby(boid, boidProps.visualRange);
    
    // Accumulators for all three rules
    let separationX = 0, separationY = 0;
    let avgVelX = 0, avgVelY = 0;
    let centerX = 0, centerY = 0;
    let separationCount = 0;
    let neighborCount = 0;
    
    // Single pass through neighbors for all rules
    for (let otherBoid of nearby) {
        if (otherBoid !== boid) {
            const dx = boid.pos.x - otherBoid.pos.x;
            const dy = boid.pos.y - otherBoid.pos.y;
            const distSq = dx * dx + dy * dy;
            const dist = Math.sqrt(distSq);
            
            // Check if within visual range
            if (dist < boidProps.visualRange) {
                // RULE #2 - ALIGNMENT
                avgVelX += otherBoid.vel.x;
                avgVelY += otherBoid.vel.y;
                
                // RULE #3 - COHESION
                centerX += otherBoid.pos.x;
                centerY += otherBoid.pos.y;
                
                neighborCount++;
            }
            
            // RULE #1 - SEPARATION (smaller range)
            if (dist < boidProps.minDistance && dist > 0) {
                const strength = boidProps.avoidFactor * (boidProps.minDistance - dist) / dist;
                separationX += dx * strength;
                separationY += dy * strength;
                separationCount++;
            }
        }
    }
    
    // Apply RULE #1 - SEPARATION
    if (separationCount > 0) {
        boid.vel.x += separationX * deltaT;
        boid.vel.y += separationY * deltaT;
    }
    
    // Apply RULE #2 - ALIGNMENT
    if (neighborCount > 0) {
        avgVelX /= neighborCount;
        avgVelY /= neighborCount;
        boid.vel.x += (avgVelX - boid.vel.x) * boidProps.matchingFactor * deltaT;
        boid.vel.y += (avgVelY - boid.vel.y) * boidProps.matchingFactor * deltaT;
        
        // Apply RULE #3 - COHESION
        centerX /= neighborCount;
        centerY /= neighborCount;
        boid.vel.x += (centerX - boid.pos.x) * boidProps.centeringFactor * deltaT;
        boid.vel.y += (centerY - boid.pos.y) * boidProps.centeringFactor * deltaT;
    }
}

//  LIMIT SPEED ---------
function clampSpeed(boid) {
  const speed = boid.vel.length();
  if (speed > boidProps.speedLimit) {
    // use vector normalization to clamp speed
    boid.vel.normalize();
    boid.vel.scale(boidProps.speedLimit);
  }
}

// Main animation loop
function simulateEverything() {
    // Rebuild spatial grid
    spatialGrid.clear();
    for (let boid of boids) {
        spatialGrid.insert(boid);
    }
    
    // Update each boid
    for (let boid of boids) {
        // Apply all three flocking rules in one pass
        applyFlockingRules(boid);
        //  Limit Speed 
        clampSpeed(boid);
        //  Stay Within Bounds 
        keepWithinBounds(boid);
        //  Update Position
        boid.simulate();
    }
}

function drawEverything() {
    ctx.clearRect(0, 0, width, height);
    for (var b = 0; b < boids.length; b++) {
        boid = boids[b];
        boid.draw();
    }
}

function setupScene() {
    // Set variables ----------
    boidRadius = 0.015
    boidProps = {
        numBoids: 3000,
        minDistance: 5 * boidRadius, // Rule 1 - The distance to stay away from other boids
        avoidFactor: 80.0, // Rule 1 -Adjust velocity by this %
        matchingFactor: 10.0, // Rule 2 - Adjust velocity by this %
        visualRange: 10 * boidRadius, // How far boids can see each other
        centeringFactor: 5.0, // Rule 3 - Adjust velocity by this %
        speedLimit: 1.0, // clamp speed to this value
    }
    deltaT = 1/60;
    
    // make boids ----------
    initBoids();
    // Create spatial grid with cell size = visualRange --------
    spatialGrid = new SpatialHashGrid(boidProps.visualRange);
}

setupScene();
function update() {
        simulateEverything();
		drawEverything();
		requestAnimationFrame(update);
	} 
update();

</script>
</body>
</html>