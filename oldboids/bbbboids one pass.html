<!DOCTYPE html>
<html>
    <head>
    <meta name="viewport" content="width=500, initial-scale=1.0">
    <title>Boids</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        body {
            background-image: url('sky.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-attachment: fixed;
        }
    </style>
    </head>
<body>
<canvas id="myCanvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%">
</canvas>
<script>

// Setup canvas and handle window resizing  ------------------
canvas = document.getElementById("myCanvas");
c = canvas.getContext("2d");
width = window.innerWidth;
height = window.innerHeight;
canvas.width = width;
canvas.height = height;

simMinWidth = 2.0;
cScale = Math.min(canvas.width, canvas.height) / simMinWidth;
simWidth = canvas.width / cScale;
simHeight = canvas.height / cScale;

function resizeCanvas() {
    canvas = document.getElementById("myCanvas");
    c = canvas.getContext("2d");
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    const oldSimWidth = simWidth;
    const oldSimHeight = simHeight;

    simMinWidth = 2.0;
    cScale = Math.min(canvas.width, canvas.height) / simMinWidth;
    simWidth = canvas.width / cScale;
    simHeight = canvas.height / cScale;

    // Calculate scale factors
    const scaleX = simWidth / oldSimWidth;
    const scaleY = simHeight / oldSimHeight;
    
    // Scale boid positions
    if (typeof boid !== 'undefined' && boid != null) {
        for (let boid of Boids) {
            boid.pos.x *= scaleX;
            boid.pos.y *= scaleY;
        }
    }
}
window.addEventListener("resize", resizeCanvas);

//  VECTOR OPERATIONS ---------------------------------------------------------------------
class Vector2 {
    constructor(x = 0.0, y = 0.0) {
        this.x = x; 
        this.y = y;
    }
    clone() {
        return new Vector2(this.x, this.y);
    }
    add(v, s=1) {
        this.x += v.x * s;
        this.y += v.y * s;
        return this;
    }
    addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        return this;
    }
    subtract(v, s = 1.0) {
        this.x -= v.x * s;
        this.y -= v.y * s;
        return this;
    }
    subtractVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        return this;			
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    scale(s) {
        this.x *= s;
        this.y *= s;
    }
    normalize() {
        const len = this.length();
        if (len > 0) {
            this.x /= len;
            this.y /= len;
        }
        return this;
    }
}

function cX(pos) {
    return pos.x * cScale;
}

function cY(pos) {
    return canvas.height - pos.y * cScale;
}

class BOID {
    constructor(pos, vel) {
        this.pos = pos.clone();
        this.vel = vel.clone();
        this.radius = boidRadius;
        this.angle = 0;
        this.history = [];
    }
    get left() {
        return this.pos.x - this.radius;
    }
    get right() {
        return this.pos.x + this.radius;
    }
    simulate(){
        this.pos.x += this.vel.x * deltaT;
        this.pos.y += this.vel.y * deltaT;
        if (doTrail == true) {
            this.history.push([this.pos.x, this.pos.y])
            this.history = this.history.slice(-10);
        }
    }
    draw(){
        // Draw trail ----------
        if (doTrail == true && this.history.length > 0) {
            c.beginPath();
            c.moveTo(cX({x: this.history[0][0]}), cY({y: this.history[0][1]}));
            for (const point of this.history) {
                c.lineTo(cX({x: point[0]}), cY({y: point[1]}));
            }
            c.strokeStyle = 'hsla(320, 80%, 80%, 0.4)';
            c.stroke();
        }
        // Draw boid ----------
        const angle = Math.atan2(this.vel.y, this.vel.x);
        c.save();
        c.translate(cX(this.pos), cY(this.pos));
        c.rotate(-angle);
        c.beginPath();
        c.moveTo(1.0 * this.radius * cScale, 0);
        c.lineTo(-1 * this.radius * cScale, 0.5 * this.radius * cScale);
        c.lineTo(-1 * this.radius * cScale, -0.5 * this.radius * cScale);
        c.closePath();
        c.fillStyle = 'hsl(320, 90%, 40%)';
        c.fill();
        c.restore();
    }
}

function initBoids() {
    Boids = [];
    const spawnRadius = Math.sqrt(simWidth * simWidth + simHeight * simHeight) * 0.6;
    let pos, vel, ang;
    for (var i = 0; i < boidProps.numBoids; i += 1) {
        if (Math.random() < 0.5) {
            ang = 0.5 * Math.PI + Math.random() * 0.5 * Math.PI;
        } else {
            ang = 1.5 * Math.PI + Math.random() * 0.5 * Math.PI;
        }
        pos = new Vector2(
            0.5 * simWidth + Math.cos(ang) * spawnRadius,
            0.5 * simHeight + Math.sin(ang) * spawnRadius);
        vel = new Vector2(0, 0);
        Boids.push(new BOID(pos, vel));
    }
}

// HANDLE BOID BOUNDS -------------
function handleBounds(boid) {
    if (boid.pos.x <= boidProps.marginX) {
        boid.vel.x += boidProps.turnFactor * deltaT;
    }
    if (boid.pos.x >= simWidth - boidProps.marginX) {
        boid.vel.x -= boidProps.turnFactor * deltaT;
    }
    if (boid.pos.y <= boidProps.marginY) {
        boid.vel.y += boidProps.turnFactor * deltaT;
    }
    if (boid.pos.y >= simHeight - boidProps.marginY) {
        boid.vel.y -= boidProps.turnFactor * deltaT;
    }
}

function handleBoidRules(boid) {
    let separationX = 0;
    let separationY = 0;
    let avgVelX = 0;
    let avgVelY = 0;
    let centerX = 0;
    let centerY = 0;
    let neighborCount = 0;
    for (let otherBoid of Boids) {
        if (otherBoid !== boid) {
            const dx = boid.pos.x - otherBoid.pos.x;
            const dy = boid.pos.y - otherBoid.pos.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < boidProps.visualRange) {
                // RULE #2 - ALIGNMENT: accumulate velocities
                avgVelX += otherBoid.vel.x;
                avgVelY += otherBoid.vel.y;
                
                // RULE #3 - COHESION: accumulate positions
                centerX += otherBoid.pos.x;
                centerY += otherBoid.pos.y;
                
                if (dist < boidProps.minDistance && dist > 0) {
                    // RULE #1 - SEPARATION: accumulate separation forces
                    const strength = boidProps.avoidFactor * (boidProps.minDistance - dist) / dist;
                    separationX += dx * strength;
                    separationY += dy * strength;
                }

                neighborCount++;
            }
        }
    }
    
    // RULE #1 - SEPARATION
    boid.vel.x += separationX * deltaT;
    boid.vel.y += separationY * deltaT;
    
    if (neighborCount > 0) {
        // RULE #2 - ALIGNMENT
        avgVelX /= neighborCount;
        avgVelY /= neighborCount;
        boid.vel.x += (avgVelX - boid.vel.x) * boidProps.matchingFactor * deltaT;
        boid.vel.y += (avgVelY - boid.vel.y) * boidProps.matchingFactor * deltaT;
        
        // RULE #3 - COHESION
        centerX /= neighborCount;
        centerY /= neighborCount;
        boid.vel.x += (centerX - boid.pos.x) * boidProps.centeringFactor * deltaT;
        boid.vel.y += (centerY - boid.pos.y) * boidProps.centeringFactor * deltaT;
    }
}

//  LIMIT SPEED ---------
function clampSpeed(boid) {
  const speed = boid.vel.length();
  if (speed > boidProps.speedLimit) {
    // use vector normalization to clamp speed
    boid.vel.normalize();
    boid.vel.scale(boidProps.speedLimit);
  }
}

// Main animation loop
function simulateEverything() {
    sortedBoids = Boids.sort((a, b) => a.left - b.left);
    for (var i = 0; i < sortedBoids.length; i++) {
        var boid = sortedBoids[i];
        for (j = i + 1; j < sortedBoids.length; j++) {
            var boid2 = sortedBoids[j];   
            if (boid2.left > boid.right) {
                break;
            }     
            if (Math.abs(boid.pos.y - boid2.pos.y) <= boidProps.visualRange) {
                // Follow the Boid rules if within visual range
                handleBoidRules(boid);
            }
        }
        
        // Limit Speed
        clampSpeed(boid);
        // Keep within bounds
        handleBounds(boid);
        //  Update Position
        boid.simulate();
    }
}

function drawEverything() {
    c.clearRect(0, 0, width, height);
    //c.fillStyle = 'hsl(220, 13%, 18%)';
    //c.fillRect(0, 0, width, height);
    for (var b = 0; b < Boids.length; b++) {
        boid = Boids[b];
        boid.draw();
    }
}

function setupScene() {
    boidRadius = 0.015
    boidProps = {
        numBoids: 2000,
        marginX: simWidth * 0.1,
        marginY: simHeight * 0.1,
        minDistance: 5.0 * boidRadius, // Rule 1 - The distance to stay away from other Boids
        avoidFactor: 50.0, // Rule 1 -Adjust velocity by this %
        matchingFactor: 10.0, // Rule 2 - Adjust velocity by this %
        visualRange: 10.0 * boidRadius, // How far Boids can see each other
        centeringFactor: 5.0, // Rule 3 - Adjust velocity by this %
        speedLimit: 1.0, // clamp speed to this value
        turnFactor: 1.0 // How strongly Boids turn back when near edge
    }
    deltaT = 1/60;
    doTrail = true;
    // make Boids ----------
    initBoids();
}

setupScene();
function update() {
        simulateEverything();
		drawEverything();
		requestAnimationFrame(update);
	} 
update();

</script>
</body>
</html>