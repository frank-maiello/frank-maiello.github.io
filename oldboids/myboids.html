<!DOCTYPE html>
<html>
    <head>
    <meta name="viewport" content="width=500, initial-scale=1.0">
    <title>Boids</title>
        <style type="text/css">
            body {
            margin: 0;
            background: hsl(220, 13%, 18%);
            overflow: hidden;
            }
        </style>
    </head>
<body>
<canvas id="myCanvas" width="100%" height="100%"></canvas>
<script>

// Setup canvas and handle window resizing  ------------------
canvas = document.getElementById("myCanvas");
ctx = canvas.getContext("2d");
width = window.innerWidth;
height = window.innerHeight;
canvas.width = width;
canvas.height = height;

simMinWidth = 2.0;
cScale = Math.min(canvas.width, canvas.height) / simMinWidth;
simWidth = canvas.width / cScale;
simHeight = canvas.height / cScale;

function resizeCanvas() {
    canvas = document.getElementById("myCanvas");
    ctx = canvas.getContext("2d");
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    const oldSimWidth = simWidth;
    const oldSimHeight = simHeight;

    simMinWidth = 2.0;
    cScale = Math.min(canvas.width, canvas.height) / simMinWidth;
    simWidth = canvas.width / cScale;
    simHeight = canvas.height / cScale;

    // Calculate scale factors
    const scaleX = simWidth / oldSimWidth;
    const scaleY = simHeight / oldSimHeight;
    
    // Scale boid positions
    if (typeof boid !== 'undefined' && boid != null) {
        for (let boid of boids) {
            boid.pos.x *= scaleX;
            boid.pos.y *= scaleY;
        }
    }
}
window.addEventListener("resize", resizeCanvas);

//  VECTOR OPERATIONS ---------------------------------------------------------------------
class Vector2 {
    constructor(x = 0.0, y = 0.0) {
        this.x = x; 
        this.y = y;
    }
    clone() {
        return new Vector2(this.x, this.y);
    }
    add(v, s=1) {
        this.x += v.x * s;
        this.y += v.y * s;
        return this;
    }
    subtract(v, s = 1.0) {
        this.x -= v.x * s;
        this.y -= v.y * s;
        return this;
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    scale(s) {
        this.x *= s;
        this.y *= s;
    }
}

function cX(pos) {
    return pos.x * cScale;
}

function cY(pos) {
    return canvas.height - pos.y * cScale;
}

class BOID {
    constructor(pos, vel) {
        this.pos = pos.clone();
        this.vel = vel.clone();
        this.radius = 0.02;
        this.history = [];
    }
    simulate(){
        this.pos.x += this.vel.x * dT;
        this.pos.y += this.vel.y * dT;
        this.history.push([this.pos.x, this.pos.y])
        this.history = this.history.slice(-50);
    }
    draw(){
        const angle = Math.atan2(this.vel.y, this.vel.x);
        //ctx.translate(this.pos.x * cScale, this.pos.y * cScale);
        //ctx.rotate(angle);
        //ctx.translate(-this.pos.x * cScale, -this.pos.y * cScale);
        ctx.fillStyle = "#558cf4";
        ctx.beginPath();
        ctx.moveTo(cX(this.pos), cY(this.pos));
        ctx.lineTo(
            cX(this.pos) - 3 * this.radius * cScale, cY(this.pos) + this.radius * cScale);
        ctx.lineTo(
            cX(this.pos) - 3 * this.radius * cScale, cY(this.pos) - this.radius * cScale);
        ctx.lineTo(cX(this.pos), 
            cY(this.pos));
        ctx.fill();
        //ctx.setTransform(1, 0, 0, 1, 0, 0);

        if (DRAW_TRAIL) {
            ctx.strokeStyle = "#558cf466";
            ctx.beginPath();
            ctx.moveTo(this.history[0][0], this.history[0][1]);
            for (const point of this.history) {
            ctx.lineTo(point[0], point[1]);
            }
            ctx.stroke();
        }
    }
}

function initBoids() {
    boids = [];
    numBoids = 100;
    /*for (var i = 0; i < numBoids; i += 1) {
        boids[boids.length] = {
        x: Math.random() * width,
        y: Math.random() * height,
        dx: Math.random() * 10 - 5,
        dy: Math.random() * 10 - 5,
        history: [],
        }
    }*/
    for (var i = 0; i < numBoids; i += 1) {
        pos = new Vector2(Math.random() * simWidth, Math.random() * simHeight);
        vel = new Vector2(Math.random() - 0.5, Math.random() - 0.5);
        boids.push(new BOID(pos, vel));
    }
}

function distance(boid1, boid2) {
    return Math.sqrt(
        (boid1.pos.x - boid2.pos.x) * (boid1.pos.x - boid2.pos.x) +
        (boid1.pos.y - boid2.pos.y) * (boid1.pos.y - boid2.pos.y),
    );
}

// Return the `n` closest boids to the given boid
function nClosestBoids(boid, n) {
    // Make a copy
    const sorted = boids.slice();
    // Sort the copy by distance from `boid`
    sorted.sort((a, b) => distance(boid, a) - distance(boid, b));
    // Return the `n` closest
    return sorted.slice(1, n + 1);
}

// Constrain a boid to within the window. If it gets too close to an edge,
// nudge it back in and reverse its direction.
function keepWithinBounds(boid) {
    const turnFactor = 10;
    if (boid.pos.x < boid.radius) {
        boid.vel.x += turnFactor * dT;
    }
    if (boid.pos.x > simWidth - boid.radius) {
        boid.vel.x -= turnFactor * dT;
    }
    if (boid.pos.y < boid.radius) {
        boid.vel.y += turnFactor * dT;
    }
    if (boid.pos.y > simHeight - boid.radius) {
        boid.vel.y -= turnFactor * dT;
    }
}

// RULE #1 - SEPARATION  -------------------------------
// Move away from other boids that are too close to avoid colliding
function avoidOthers(boid) {
    const minDistance = 20; // The distance to stay away from other boids
    const avoidFactor = 0.05; // Adjust velocity by this %
    let moveX = 0;
    let moveY = 0;
    for (let otherBoid of boids) {
        if (otherBoid !== boid) {
            if (distance(boid, otherBoid) < minDistance) {
                moveX += boid.pos.x - otherBoid.pos.x;
                moveY += boid.pos.y - otherBoid.pos.y;
            }
        }
    }

    boid.pos.x += moveX * avoidFactor * dT;
    boid.pos.y += moveY * avoidFactor * dT;
}

// RULE #2 - ALIGNMENT  -------------------------------
// Find the average velocity (speed and direction) of the other boids and
// adjust velocity slightly to match.
function matchVelocity(boid) {
    const matchingFactor = 0.05; // Adjust by this % of average velocity

    let avgVelX = 0;
    let avgVelY = 0;
    let numNeighbors = 0;

    for (let otherBoid of boids) {
        if (distance(boid, otherBoid) < visualRange) {
        avgVelX += otherBoid.vel.x;
        avgVelY += otherBoid.vel.y;
        numNeighbors += 1;
        }
    }

    if (numNeighbors) {
        avgVelX = avgVelX / numNeighbors;
        avgVelY = avgVelY / numNeighbors;

        boid.vel.x += (avgVelX - boid.vel.x) * matchingFactor;
        boid.vel.y += (avgVelY - boid.vel.y) * matchingFactor;
    }
}

// RULE #3 - COHESION  -------------------------------
// Find the center of mass of the other boids and adjust velocity slightly to
// point towards the center of mass.
function flyTowardsCenter(boid) {
    const centeringFactor = 0.005; // adjust velocity by this %

    let centerX = 0;
    let centerY = 0;
    let numNeighbors = 0;

    for (let otherBoid of boids) {
        if (distance(boid, otherBoid) < visualRange) {
        centerX += otherBoid.pos.x;
        centerY += otherBoid.pos.y;
        numNeighbors += 1;
        }
    }

    if (numNeighbors) {
        centerX = centerX / numNeighbors;
        centerY = centerY / numNeighbors;

        boid.vel.x += (centerX - boid.pos.x) * centeringFactor / dT;
        boid.vel.y += (centerY - boid.pos.y) * centeringFactor / dT;
    }
}

//  LIMIT SPEED ---------
function clampSpeed(boid) {
  const speedLimit = 10;
  const speed = boid.vel.length();
  if (speed > speedLimit) {
    boid.vel.x = (boid.vel.x / speed) * speedLimit;
    boid.vel.y = (boid.vel.y / speed) * speedLimit;
  }
}

// Main animation loop
function simulateEverything() {
    // Update each boid
    for (let boid of boids) {
        // RULE #1 - SEPARATION  
        avoidOthers(boid);
        // RULE #2 - ALIGNMENT 
        matchVelocity(boid);
        // RULE #3 - COHESION  
        flyTowardsCenter(boid);
        //  Limit Speed 
        clampSpeed(boid);
        //  Stay Within Bounds 
        keepWithinBounds(boid);

        // Update the position based on the current velocity
        boid.pos.x += boid.vel.x * dT;
        boid.pos.y += boid.vel.y * dT;
        boid.history.push([boid.pos.x, boid.pos.y])
        boid.history = boid.history.slice(-50);
    }
}

function drawEverything() {
    ctx.clearRect(0, 0, width, height);
    //for (let boid of boids) {
    //    boid.draw();
    //}
    for (var b = 0; b < boids.length; b++) {
        boid = boids[b];
        boid.draw();
    }
}

function setupScene() {
    visualRange = 200;
    dT = 1/60;
    initBoids();
    DRAW_TRAIL = false;
}
setupScene()

function update() {
        simulateEverything();
		drawEverything();
		requestAnimationFrame(update);
	} 
update();

</script>
</body>
</html>