<!-- 
PLINK(0) LAB :: a simulated particle kinetics toy ::
copyright 2025 :: Frank Maiello :: maiello.frank@gmail.com ::

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. In no event shall the author or copyright holders be liable for any claim, damages, or other liability, whether in an action of contract, tort or otherwise, arising from, our of or in, connection with the software or the use of other dealings in the Software.
-->

<!DOCTYPE html>
<html>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
	<head>
		<title>Slosh 1.24</title>
        <style>
			body {font-family: monospace; 
                font-size: 16px;
                color: hsl(0, 0%, 60%);
                text-align: center;
                text-shadow: 3px 4px 10px hsl(0, 0%, 0%);
                padding-left: 5px;
                padding-right: 10px;
                /* Touch optimization */
                -webkit-touch-callout: none;
                -webkit-user-select: none;
                -khtml-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
                -webkit-tap-highlight-color: transparent;
                }
            h1 {font-family: monospace;
                font-size: 10px;
                text-align: center}
            h2 {font-family: monospace;
                font-size: 4px;
                text-align: center}

    /*  BUTTONS  ----------------------------------------------------------- */
			.buttongreen:hover {opacity: 1}
            .buttongreen {
                width: 18px;
                height: 18px;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                border-radius: 9px;
                background-color: hsl(108, 50%, 50%);
                opacity: 0.7;
                border: none;
				cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            
            .buttongreenbig:hover {opacity: 1}
            .buttongreenbig {
                width: 24px;
                height: 24px;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                border-radius: 12px;
                color: hsl(0, 0%, 100%);
                background-color: hsl(108, 50%, 50%);
                opacity: 0.7;
                border: none;
				cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}

            .buttonorange:hover {opacity: 1}
            .buttonorange {
                width: 24px;
                height: 24px;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                border-radius: 12px;
                background-color: hsl(23, 81%, 54%);
                opacity: 0.7;
                border: none;
				cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}

            .buttonmint:hover {opacity: 1}
            .buttonmint {
                width: 24px;
                height: 24px;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                border-radius: 12px;
                background-color: hsl(160, 80%, 50%);
                opacity: 0.7;
                border: none;
				cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            
            .buttonpink:hover {opacity: 1}
            .buttonpink {
                width: 24px;
                height: 24px;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                color: hsl(58, 100%, 59%);
                border-radius: 12px;
                background-color: hsl(323, 80%, 60%);
                opacity: 0.7;
                border: none;
				cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}


    /*  SLIDERS  ---------------------------------------------------------- */
            .slider-blue:hover {opacity: 1} 
            .slider-blue {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 60px;
				height: 4px;
				border-radius: 5px;
                background: hsl(0, 0%, 0%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s}
            .slider-blue::-webkit-slider-thumb {-webkit-appearance: none;
                width: 10px;
                height: 22px;
                border-radius: 30%;
                background: hsl(220, 80%, 60%);
                cursor: pointer}

            .slidersquare-fountain:hover {opacity: 1}
            .slidersquare-fountain {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 60px;
				height: 4px;
				border-radius: 5px;
                background: hsl(0, 0%, 0%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s}
            .slidersquare-fountain::-webkit-slider-thumb {-webkit-appearance: none;
                width: 18px;
                height: 18px;
                border-radius: 30%;
                background: hsl(300, 60%, 60%);
                cursor: pointer}

            .slider-pink:hover {opacity: 1}
            .slider-pink {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 50px;
				height: 4px;
				border-radius: 5px;
                background: hsl(0, 0%, 0%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s}
            .slider-pink::-webkit-slider-thumb {-webkit-appearance: none;
                width: 10px;
                height: 22px;
                border-radius: 30%;
                background: hsl(330, 100%, 70%);
                cursor: pointer}

            .slider-purple:hover {opacity: 1}
            .slider-purple {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 120px;
				height: 4px;
				border-radius: 5px;
                background: hsl(0, 0%, 0%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s}
            .slider-purple::-webkit-slider-thumb {-webkit-appearance: none;
                width: 10px;
                height: 22px;
                border-radius: 30%;
                background: hsl(300, 60%, 60%);
                cursor: pointer} 

            .slider-purple-short:hover {opacity: 1}
            .slider-purple-short {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 60px;
				height: 4px;
				border-radius: 5px;
                background: hsl(0, 0%, 0%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s}
            .slider-purple-short::-webkit-slider-thumb {-webkit-appearance: none;
                width: 10px;
                height: 22px;
                border-radius: 30%;
                background: hsl(300, 60%, 60%);
                cursor: pointer} 

            .slider-redspawn:hover {opacity: 1}
            .slider-redspawn {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 120px;
				height: 4px;
				border-radius: 5px;
                background: hsl(0, 0%, 0%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s}
            .slider-redspawn::-webkit-slider-thumb {-webkit-appearance: none;
                width: 26px;
                height: 12px;
                border-radius: 30%;
                background: hsl(350, 70%, 50%);
                cursor: pointer} 

            .slider-redspawn2:hover {opacity: 1}
            .slider-redspawn2 {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 60px;
				height: 4px;
				border-radius: 5px;
                background: hsl(0, 0%, 0%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s}
            .slider-redspawn2::-webkit-slider-thumb {-webkit-appearance: none;
                width: 10px;
                height: 22px;
                border-radius: 30%;
                background: hsl(350, 70%, 50%);
                cursor: pointer}
            
            .slider-cyan:hover {opacity: 1} 
            .slider-cyan {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 110px;
				height: 4px;
				border-radius: 5px;
                background: hsl(0, 0%, 0%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s}
            .slider-cyan::-webkit-slider-thumb {-webkit-appearance: none;
                width: 10px;
                height: 22px;
                border-radius: 30%;
                background: hsl(181, 82%, 66%);
                cursor: pointer}

            /* Corner radius slider with detent at value 100 */
            .slider-corner-detent {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 110px;
				height: 4px;
				border-radius: 5px;
                background: linear-gradient(to right, 
                    hsl(0, 0%, 0%) 0%, 
                    hsl(0, 0%, 0%) 49%, 
                    hsl(181, 82%, 66%) 49.5%, 
                    hsl(181, 82%, 66%) 50.5%, 
                    hsl(0, 0%, 0%) 51%, 
                    hsl(0, 0%, 0%) 100%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s;
                /* Add snap points */
                scroll-snap-type: x mandatory;
                scroll-snap-points-x: repeat(50%);
                -webkit-scroll-snap-points-x: repeat(50%);
                -ms-scroll-snap-points-x: repeat(50%);}
            .slider-corner-detent:hover {opacity: 1}
            .slider-corner-detent::-webkit-slider-thumb {-webkit-appearance: none;
                width: 10px;
                height: 22px;
                border-radius: 30%;
                margin-bottom: 0px;
                background: hsl(181, 82%, 66%);
                cursor: pointer;
                /* Snap point for the thumb */
                scroll-snap-align: center;}

            .slider-yellow:hover {opacity: 1} 
            .slider-yellow {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 70px;
				height: 4px;
				border-radius: 5px;
                background: hsl(0, 0%, 0%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s}
            .slider-yellow::-webkit-slider-thumb {-webkit-appearance: none;
                width: 10px;
                height: 22px;
                border-radius: 30%;
                background: hsl(45, 75%, 41%);
                cursor: pointer}

            .slider-organge:hover {opacity: 1} 
            .slider-orange {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 70px;
				height: 4px;
				border-radius: 5px;
                background: hsl(0, 0%, 0%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s}
            .slider-orange::-webkit-slider-thumb {-webkit-appearance: none;
                width: 10px;
                height: 22px;
                border-radius: 20%;
                background: hsl(26, 91%, 46%);
                cursor: pointer}

            .slider-organge-horiz:hover {opacity: 1} 
            .slider-orange-horiz {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 70px;
				height: 4px;
				border-radius: 5px;
                background: hsl(0, 0%, 0%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s}
            .slider-orange-horiz::-webkit-slider-thumb {-webkit-appearance: none;
                width: 26px;
                height: 12px;
                border-radius: 30%;
                background: hsl(26, 91%, 46%);
                cursor: pointer}

            .slider-lime:hover {opacity: 1} 
            .slider-lime {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 70px;
				height: 4px;
				border-radius: 5px;
                background: hsl(0, 0%, 0%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s}
            .slider-lime::-webkit-slider-thumb {-webkit-appearance: none;
                width: 10px;
                height: 22px;
                border-radius: 20%;
                background: hsl(75, 91%, 46%);
                cursor: pointer}

            .slider-red:hover {opacity: 1} 
            .slider-red {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 100px;
				height: 4px;
				border-radius: 5px;
                background: linear-gradient(to right, 
                    hsl(0, 0%, 10%) 0%, 
                    hsl(0, 0%, 80%) 100%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s}
            .slider-red::-webkit-slider-thumb {-webkit-appearance: none;
                width: 10px;
                height: 22px;
                border-radius: 30%;
                background: hsl(0, 60%, 70%);
                cursor: pointer}

            .slider-red2:hover {opacity: 1} 
            .slider-red2 {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 130px;
				height: 4px;
				border-radius: 5px;
                background: linear-gradient(to right, 
                    hsl(0, 70%, 50%) 17%, 
                    hsl(60, 70%, 50%) 34%, 
                    hsl(120, 70%, 50%) 50%,
                    hsl(180, 70%, 50%) 67%, 
                    hsl(240, 70%, 50%) 84%, 
                    hsl(300, 70%, 50%) 100%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s}
            .slider-red2::-webkit-slider-thumb {-webkit-appearance: none;
                width: 10px;
                height: 22px;
                border-radius: 30%;
                background: hsl(0, 60%, 70%);
                cursor: pointer}


            .slider-lightred:hover {opacity: 1}
            .slider-lightred {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                position: 10px;
                width: 75px;
				height: 4px;
				border-radius: 5px;
                background: linear-gradient(to right, 
                    hsl(0, 0%, 0%) 0%, 
                    hsl(0, 90%, 50%) 100%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s}
            .slider-lightred::-webkit-slider-thumb {-webkit-appearance: none;
                width: 10px;
                height: 22px;
                border-radius: 30%;
                background: hsl(0, 60%, 70%);
                cursor: pointer}

            .slider-mint:hover {opacity: 1} 
            .slider-mint {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 60px;
				height: 4px;
				border-radius: 5px;
                background: hsl(0, 0%, 0%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s}
            .slider-mint::-webkit-slider-thumb {-webkit-appearance: none;
                width: 10px;
                height: 22px;
                border-radius: 30%;
                background: hsl(140, 80%, 60%);
                cursor: pointer}

            .slider-green:hover {opacity: 1}
            .slider-green {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                position: 10px;
                width: 75px;
				height: 4px;
				border-radius: 5px;
                background: hsl(0, 0%, 0%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s}
            .slider-green::-webkit-slider-thumb {-webkit-appearance: none;
                width: 10px;
                height: 22px;
                border-radius: 30%;
                background: hsl(90, 70%, 50%);
                cursor: pointer}

    /*  FIELDS  ----------------------------------------------------------- */
            .field-cyan-short:hover {opacity: 1}       
            .field-cyan-short {-webkit-appearance: none;
                appearance: none;
                font-family: monospace;
                font-size: 16px;
                background: hsl(0, 0%, 0%);
                margin-top: 5px;
                margin-bottom: 10px;
                padding-top: 2px;
                padding-left: 6px;
				width: 54px;
				height: 18px;
                border-width: 0;
				border-radius: 10px;
                color: hsl(170, 75%, 50%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
				transition: opacity .2s}

            .field-cyan:hover {opacity: 1}
            .field-cyan {-webkit-appearance: none;
                appearance: none;
                font-family: monospace;
                font-size: 16px;
                text-align: center;
                background: hsl(0, 0%, 0%);
                margin-bottom: 10px;
                padding-left: 6px;
				width: 80px;
				height: 22px;
                border-width: 0;
				border-radius: 10px;
                color: hsl(170, 75%, 50%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
				transition: opacity .2s}

            .field-purple {-webkit-appearance: none;
                appearance: none;
                font-family: monospace;
                font-size: 16px;
                text-align: center;
                background: hsl(0, 0%, 0%);
                margin-top: 5px;
                margin-bottom: 10px;
                padding-left: 6px;
				width: 120px;
				height: 18px;
                border-width: 0;
				border-radius: 10px;
                color: hsl(300, 60%, 70%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
				transition: opacity .2s}
            

    /*  CHECKBOXES  -------------------------------------------------------- */

            .checkbox-orange:hover {opacity: 1}
            .checkbox-orange {-webkit-appearance: none;
                appearance: none;
                opacity: 0.8;
                width: 24px;
                height: 24px;
                margin-top: 5px;
                margin-bottom: 10px;
                background-color: hsl(23, 50%, 40%);
                border-radius: 50%;
                vertical-align: middle;
                border: 3px solid hsl(0, 0%, 80%);
                outline: none;
                cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            .checkbox-orange:checked {
                background-color: hsl(23, 70%, 60%)}

            .checkbox-lime:hover {opacity: 1}
            .checkbox-lime {-webkit-appearance: none;
                appearance: none;
                opacity: 0.8;
                width: 24px;
                height: 24px;
                margin-top: 5px;
                margin-bottom: 10px;
                background-color: hsl(75, 80%, 20%);
                border-radius: 50%;
                vertical-align: middle;
                border: 3px solid hsl(0, 0%, 80%);
                outline: none;
                cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            .checkbox-lime:checked {
                background-color: hsl(75, 80%, 50%)}

            .checkbox-gray:hover {opacity: 1}
            .checkbox-gray {-webkit-appearance: none;
                appearance: none;
                opacity: 0.8;
                width: 24px;
                height: 24px;
                margin-top: 5px;
                margin-bottom: 10px;
                background-color: hsl(0, 0%, 20%);
                border-radius: 50%;
                vertical-align: middle;
                border: 3px solid hsl(0, 0%, 80%);
                outline: none;
                cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            .checkbox-gray:checked {
                background-color: hsl(0, 0%, 60%);}

            .checkbox-roundgray:hover {opacity: 1}
            .checkbox-roundgray {-webkit-appearance: none;
                appearance: none;
                opacity: 0.8;
                width: 24px;
                height: 24px;
                margin-top: 5px;
                margin-bottom: 10px;
                background-color: hsl(9, 0%, 30%);
                border-radius: 50%;
                vertical-align: middle;
                border: 3px solid hsl(0, 0%, 80%);
                outline: none;
                cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            .checkbox-roundgray:checked {
                background-color: hsl(0, 0%, 60%)}

            .checkbox-oneshot:hover {opacity: 1}
            .checkbox-oneshot {-webkit-appearance: none;
                appearance: none;
                opacity: 0.8;
                width: 24px;
                height: 24px;
                margin-top: 5px;
                margin-bottom: 10px;
                background-color: hsl(0, 50%, 20%);
                border-radius: 50%;
                vertical-align: middle;
                border: 3px solid hsl(0, 0%, 80%);
                outline: none;
                cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            .checkbox-oneshot:checked {
                background-color: hsl(0, 50%, 50%)}

            .checkbox-yellow:hover {opacity: 1}
            .checkbox-yellow {-webkit-appearance: none;
                appearance: none;
                opacity: 0.8;
                width: 24px;
                height: 24px;
                margin-top: 5px;
                margin-bottom: 10px;
                background-color: hsl(56, 80%, 20%);
                border-radius: 50%;
                vertical-align: middle;
                border: 3px solid hsl(0, 0%, 80%);
                outline: none;
                cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            .checkbox-yellow:checked {
                background-color: hsl(45, 80%, 50%)}

            .checkbox-pause:hover {opacity: 1}
            .checkbox-pause {-webkit-appearance: none;
                appearance: none;
                opacity: 0.8;
                width: 24px;
                height: 24px;
                margin-top: 5px;
                margin-bottom: 10px;
                background-color: hsl(150, 80%, 50%);
                border-radius: 50%;
                vertical-align: middle;
                border: 3px solid hsl(0, 0%, 80%);
                outline: none;
                cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            .checkbox-pause:checked {
                background-color: hsl(54, 100%, 50%);
                border: 3px dotted hsl(0, 0%, 10%);}

            .checkbox-roundbluelight:hover {opacity: 1}    
            .checkbox-roundbluelight {-webkit-appearance: none;
                appearance: none;
                opacity: 0.8;
                width: 24px;
                height: 24px;
                margin-top: 5px;
                margin-bottom: 10px;
                background-color: hsl(190, 50%, 30%);
                border-radius: 50%;
                vertical-align: middle;
                border: 3px solid hsl(0, 0%, 80%);
                outline: none;
                cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            .checkbox-roundbluelight:checked {
                background-color: hsl(190, 70%, 50%)}
                
            .checkbox-ceiling:hover {opacity: 1}
            .checkbox-ceiling {-webkit-appearance: none;
                appearance: none;
                opacity: 0.8;
                width: 24px;
                height: 24px;
                margin-top: 5px;
                margin-bottom: 10px;
                background-color: hsl(80, 50%, 20%);
                border-radius: 50%;
                vertical-align: middle;
                border: 3px solid hsl(0, 0%, 80%);
                outline: none;
                cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            .checkbox-ceiling:checked {
                background-color: hsl(80, 50%, 50%)}

            .checkbox-floor:hover {opacity: 1}
            .checkbox-floor {-webkit-appearance: none;
                appearance: none;
                opacity: 0.8;
                width: 24px;
                height: 24px;
                margin-top: 5px;
                margin-bottom: 10px;
                background-color: hsl(160, 50%, 20%);
                border-radius: 50%;
                vertical-align: middle;
                border: 3px solid hsl(0, 0%, 80%);
                outline: none;
                cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            .checkbox-floor:checked {
                background-color: hsl(160, 50%, 45%)}

            .checkbox-leftwall:hover {opacity: 1}
            .checkbox-leftwall {-webkit-appearance: none;
                appearance: none;
                opacity: 0.8;
                width: 24px;
                height: 24px;
                margin-top: 5px;
                margin-bottom: 10px;
                background-color: hsl(230, 70%, 20%);
                border-radius: 50%;
                vertical-align: middle;
                border: 3px solid hsl(0, 0%, 80%);
                outline: none;
                cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            .checkbox-leftwall:checked {
                background-color: hsl(230, 70%, 70%)}

            .checkbox-rightwall:hover {opacity: 1}
            .checkbox-rightwall {-webkit-appearance: none;
                appearance: none;
                opacity: 0.8;
                width: 24px;
                height: 24px;
                margin-top: 5px;
                margin-bottom: 10px;
                background-color: hsl(310, 50%, 20%);
                border-radius: 50%;
                vertical-align: middle;
                border: 3px solid hsl(0, 0%, 80%);
                outline: none;
                cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            .checkbox-rightwall:checked {
                background-color: hsl(310, 50%, 50%)}

                
    /*  RADIO BUTTONS  -------------------------------------------------------- */

            .radio:hover {opacity: 1}
            .radio {-webkit-appearance: none;
                appearance: none;
                padding: 0px;
                border: 0px;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 20px;
                height: 20px;
                border-radius: 10px;
                background-color: hsl(0, 0%, 20%);
                opacity: 0.7;
                border: 4px solid hsl(0, 0%, 60%);
				cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            .radio:checked {
                background-color:hsl(300, 60%, 50%);
            }

            .radio2:hover {opacity: 1}
            .radio2 {-webkit-appearance: none;
                appearance: none;
                padding: 0px;
                border: 0px;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 20px;
                height: 20px;
                border-radius: 10px;
                background-color: hsl(0, 0%, 20%);
                opacity: 0.7;
                border: 4px solid hsl(0, 0%, 60%);
				cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            .radio2:checked {
                background-color: hsl(350, 80%, 60%);
            }

            .radioball:hover {opacity: 1}
            .radioball {-webkit-appearance: none;
                appearance: none;
                padding: 0px;
                border: 0px;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 20px;
                height: 20px;
                border-radius: 10px;
                background-color: hsl(0, 0%, 20%);
                opacity: 0.7;
                border: 4px solid hsl(0, 0%, 60%);
				cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            .radioball:checked {
                background-color: hsl(184, 60%, 85%);
            }

            .radio-green:hover {opacity: 1}
            .radio-green {-webkit-appearance: none;
                appearance: none;
                padding: 0px;
                border: 0px;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 20px;
                height: 20px;
                border-radius: 10px;
                background-color: hsl(0, 0%, 20%);
                opacity: 0.7;
                border: 4px solid hsl(0, 0%, 60%);
				cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            .radio-green:checked {
                background: hsl(90, 70%, 50%);
            }

            .radio-blue:hover {opacity: 1}
            .radio-blue {-webkit-appearance: none;
                appearance: none;
                padding: 0px;
                border: 0px;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 20px;
                height: 20px;
                border-radius: 10px;
                background-color: hsl(0, 0%, 20%);
                opacity: 0.7;
                border: 4px solid hsl(0, 0%, 60%);
				cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            .radio-blue:checked {
                background-color: hsl(220, 80%, 50%);
            }
            
		</style>
	</head>
<body> 

	<!-- <body style="background: hsl(0, 0%, 10%); background-attachment: fixed; margin-left: 0px;"> -->
    <body style="background: linear-gradient(to bottom, hsl(0, 0%, 0%) 0%, hsl(195, 64%, 8%) 100%); background-attachment: fixed; margin-left: 0px;"> 
    <canvas id="myCanvas" style="border:0px solid hsl(0, 0%, 50%); margin-left: 10px"></canvas>

    <h2><br></h2>
	<input type="button" title="Restart [r]" class="buttongreenbig" value="&#8629" onclick="makeBalls()">
    <input type="radio" title="Round Cluster Start" name="rackemType" id="cluster" class="radioball">
    <input type="radio" title="Square Array Start" name="rackemType" id="array" class="radioball" checked>
    
    walls&#8594
    <input type="range"  title="Corner Radius" id="cornerRadiusSlider" min="0" max="200" value="100" list="detents"class="slider-corner-detent">
    
    <input type="checkbox" title="Ceiling" id="ceilingButton" class="checkbox-ceiling" checked>
    <input type="checkbox" title="Floor" value="F" id="floorButton"  class="checkbox-floor" checked>
    <input type="checkbox" title="Left Wall" id="leftWallButton" class="checkbox-leftwall" checked>
    <input type="checkbox" title="Right Wall" id="rightWallButton" class="checkbox-rightwall" checked>
    
    particles&#8594
    <select title="Particle Count" id="ballsInput" class="field-cyan">
        <optgroup label="Number of Balls">
            <option value="1">1</option>
            <option value="25">25</option>
            <option value="100">100</option>
            <option value="400">400</option>
            <option value="1024">1024</option>
            <option value="1600">1600</option>
            <option value="2025">2025</option>
            <option value="2500">2500</option>
            <option value="3600">3600</option>
            <option value="4096" selected>4096</option>
            <option value="4900">4900</option>
            <option value="5625">5625</option>
            <option value="6400">6400</option>
            <option value="7056">7056</option>
            <option value="8100">8100</option>
            <option value="9025">9025</option>
        </optgroup>
    </select>
    <input type="number" title="Minimum Ball Radius (will ignore if '0')" id="smallBallInput" min="0" value="4" class="field-cyan-short">
	<input type="number" title="Maximum Ball Radius" id="bigBallInput" min="1" value="16" class="field-cyan-short">
    <input type="radio" title="Spheres" name="ballType" id="ballSphere" class="radio-green">
    <input type="radio" title="Discs" name="ballType" id="ballDisc" class="radio-green" checked>
    <input type="radio" title="Circles" name="ballType" id="ballCircle" class="radio-green">
    
    <span style="white-space: nowrap">time&#8594
    <input type="checkbox" title="Pause" id="x" value="false" class="checkbox-pause" onclick="pause()" unchecked></span>
    <input type="range"  title="Time  ::  <--- Slower : Normal" id="timeSlider" min="40" max="100" value="100" class="slider-mint">
    <input type="range"  title="Persistence" id="persistenceSlider" min="0" max="30" value="12" class="slider-mint">
    
    <span style="white-space: nowrap">
    gravity&#8594
    <input type="radio" title="Down" name="gravityType" id="gravityDown" class="radio-blue" checked>
    <input type="radio" title="Right" name="gravityType" id="gravityRight" class="radio-blue">
    <input type="range"  title="Gravity  ::  Zero Gravity : More Gravity --->" id="gravitySlider" min="0" max="100" value="0" class="slider-blue"></span>
    
    <span style="white-space: nowrap">
    repulsion&#8594
    <input type="checkbox" title="Repulsion on/off" id="repulsionButton" class="checkbox-lime" checked>
    <input type="range"  title="Repulsion Force between Particles" id="repulsionForceSlider" min="1" max="20" value="20" class="slider-lime">
    
    bounce&#8594
    <input type="range"  title="Ball Restitution on Collision" id="ballRestSlider" min="0" max="100" value="0" class="slider-lime"></span>
    
    <span style="white-space: nowrap">
    pucks&#8594
    <input type="checkbox" title="Pucks on/off" id="showPuckButton" value="true" class="checkbox-roundbluelight" checked>
    <input type="range"  title="Puck Radius" id="puckRadiusSlider" min="100" max="1000" value="200" class="slider-cyan"></span>
    
    <span style="white-space: nowrap">
    eaters&#8594
    <input type="checkbox" title="Eaters on/off" id="showHungryPuckButton" value="false" class="checkbox-roundbluelight" unchecked></span>
    
    respawn&#8594
    <input type="checkbox" title="One Shot (no respawn)" id="oneShotButton" value="false" class="checkbox-oneshot" unchecked>
    <input type="range"  title="Shower Width" id="dumpSlider" min="1" max="100" value="40" class="slider-redspawn2">
    <input type="range"  title="Shower Position" id="dumpMoveSlider" min="-50" max="50" value="0" class="slider-redspawn">
    <span style="white-space: nowrap">shower &#8592
    <input type="radio" title="Shower" name="spawnType" id="shower" value="shower" class="radio2">
    / <input type="radio" title="Mr. Mister" name="spawnType" id="fountain" value="fountain" class="radio" checked>
    
    &#8594 mr.mister</span>
    <input type="range"  title="Yeet" id="yeetSlider" min="0" max="600" value="250" class="slider-purple-short">
    <input type="range"  title="Sweeper Speed" id="sprinklerSpeedSlider" min="0" max="30" value="10" class="slider-pink">
    
    <select title="Mr. Mister Mode" name="misterMode" id="misterMode" class="field-purple">
        <optgroup label="Mr. Mister Motion">
            <option value="idle" selected>mouse</option>
            <option value="worm">worm</option>
            <option value="scanner" >scan</option>
            <option value="printer">printer</option>
            <option value="typewriter">typewriter</option>
            <option value="circle">circle</option>
            <option value="oval">oval</option>
            <option value="bernoulli">figure-8</option>
            <option value="billiard">pong</option>
        </optgroup>
    </select>
    <input type="range"  title="Mr. Mister Orbit Speed" id="misterSpeedSlider" min="10" max="200" value="100" class="slider-purple-short">
    
    <span style="white-space: nowrap">
    plinko&#8594
    <input type="checkbox" title="Pegs on/off" id="showBumperEntry" value="false" class="checkbox-yellow" unchecked>
    <input type="range"  title="Peg Rows" id="rowsInput" min="1" max="20" value="3" class="slider-yellow">
    <input type="range"  title="Peg Radius" id="bumperRadiusInput" min="20" max="100" value="40" class="slider-yellow"></span>
    
    <span style="white-space: nowrap">
    worm&#8594
    <input type="checkbox" title="Worm on/off" id="wormButton" class="checkbox-orange" checked>
    <input type="range"  title="Worm Tail Radius" id="wormEndRadiusSlider" min="40" max="300" value="40" class="slider-orange">
    <input type="range"  title="Worm Head Radius" id="wormStartRadiusSlider" min="70" max="300" value="150" class="slider-orange">
    <input type="range"  title="Worm Segments" id="wormNumNodesSlider" min="3" max="30" value="10" class="slider-orange-horiz"></span>

    <span style="white-space: nowrap">
    tracer&#8594
    <input type="checkbox" title="Particle Trace on/off" id="tracerButton" class="checkbox-gray" checked></span>
    
    <span style="white-space: nowrap">
    color&#8594
    <input type="range"  title="Speed Sensitivity" id="velColorMapSlider" min="1" max="500" value="100" class="slider-red2">
    <input type="range"  title="Saturation" id="saturationSlider" min="0" max="100" value="90" class="slider-lightred">
    <input type="range"  title="Lightness" id="lightnessSlider" min="5" max="100" value="50" class="slider-red"></span>
    
    <input type="button" title="Restart [r]" class="buttongreenbig" value="&#8629" onclick="makeBalls()">
    
    <h2><br></h2><h1>:: SL0SH :: repulsive particle simulation ::</h1>

<script>

    //  CANVAS SETUP AND SCALING --------------------------------------------------------------
    canvas = document.getElementById("myCanvas");
    c = canvas.getContext("2d");
    canvas.style.cursor = "pointer";
    if (window.innerWidth < window.innerHeight) {
        // vertical orientation
        screenVertical = true;
        ballsInput.value = 1600;
        canvas.width = window.innerWidth - 40;
        canvas.height = window.innerHeight - 140; 
    } else if (window.innerWidth > 1.75 * window.innerHeight) {
        screenVertical = false;
        canvas.width = window.innerWidth - 40;
        canvas.height = window.innerHeight - 30;
    } else {
        screenVertical = false;
        canvas.width = window.innerWidth - 40;
        canvas.height = window.innerHeight - 210;
    }
    simMinWidth = 2.0;
    cScale = Math.min(canvas.width, canvas.height) / simMinWidth;
    simWidth = canvas.width / cScale;
    simHeight = canvas.height / cScale;
    topMargin = 0;
    bottomMargin = 0;

    function refreshPage() {
        location.reload();
    }
    window.addEventListener("resize", refreshPage);
    // Gradient used to fill canvas corners/masks to match page background
    let cornerFillGradient = null;
    function updateCornerFillGradient() {
        // Align the canvas gradient with the page's background gradient (to bottom)
        // using viewport-relative coordinates so the transition is seamless.
        const rect = canvas.getBoundingClientRect();
        const y0 = -rect.top;                 // where the canvas starts relative to viewport (px)
        const y1 = y0 + window.innerHeight;   // viewport bottom relative to canvas
        const g = c.createLinearGradient(0, y0, 0, y1);
        // Match body CSS: linear-gradient(to bottom, hsl(0, 0%, 0%) 0%, hsl(195, 64%, 8%) 100%)
        g.addColorStop(0.0, 'hsl(0, 0%, 0%)');
        g.addColorStop(1.0, 'hsl(195, 64%, 8%)');
        cornerFillGradient = g;
    }
    // Initialize gradient now
    updateCornerFillGradient();
    // Keep it updated on scroll (viewport relative) for a fixed page background
    window.addEventListener('scroll', updateCornerFillGradient, { passive: true });
    
    //  KEYBOARD SHORTCUTS -----------------------------------------------------
    
    document.addEventListener('keydown', event => {
        switch(event.key) {
            case 'n': physProps.paused = false; simulate(); physProps.paused = true; break;
            case 'N': physProps.paused = false; simulate(); physProps.paused = true; break;
            case 'm': physProps.paused = !physProps.paused; break;
            case 'M': physProps.paused = !physProps.paused; break;
            case 'p': physProps.paused = !physProps.paused; break;
            case 'P': physProps.paused = !physProps.paused; break;
            case 'r': forcedWipeRestart();
            case 'R': forcedWipeRestart();
        }
    });

    //  GET WORLD PROPERTIES FROM SLIDERS ---------------------------------------------
    
    document.getElementById("timeSlider").oninput = function() {
        physProps.dt = 1 / (Math.floor(Math.exp(((140 - timeSlider.value) / 10))) + 6);}
    document.getElementById('persistenceSlider').oninput = function() {
        persistence = persistenceSlider.value;}
    document.getElementById("gravitySlider").oninput = function() {
        if (gravityDown.checked == true) {
            physProps.gravity = new Vector2(0, 1 + -1 * (2 ** (gravitySlider.value/100)));
        } else if (gravityRight.checked == true) {
            physProps.gravity = new Vector2(1 * (2 ** (gravitySlider.value/100)), 0);}}
    document.getElementById("gravityDown").oninput = function() {
        doGravityDown = true;
        doGravityRight = false;
        physProps.gravity = new Vector2(0, 1 + -1 * (2 ** (gravitySlider.value/100)))}  
    document.getElementById("gravityRight").oninput = function() {
        doGravityDown = false;
        doGravityRight = true;
        physProps.gravity = new Vector2(1 * (2 ** (gravitySlider.value/100)), 0);}
    document.getElementById("shower").oninput = function() {
        if (gravityDown.checked == true) {
            physProps.gravity = new Vector2(0, 1 + -1 * (10 ** (gravitySlider.value/100)));
        } else if (gravityRight.checked == true) {
            physProps.gravity = new Vector2(1 + 1 * (10 ** (gravitySlider.value/100)), 0);}
            var puck1 = Hungrypuck[0];
            var puck2 = Hungrypuck[1];
            puck1.pos.y = -0.1 * puck1.radius;
            puck2.pos.y = -0.1 * puck2.radius;
            doShower = true;
            doFountain = false;}
    document.getElementById("fountain").oninput = function() {
        if (gravityDown.checked == true) {
            physProps.gravity = new Vector2(0, 1 + -1 * (10 ** (gravitySlider.value/100)));
        } else if (gravityRight.checked == true) {
            physProps.gravity = new Vector2(1 + 1 * (10 ** (gravitySlider.value/100)), 0);
        }
        var puck1 = Hungrypuck[0];
        var puck2 = Hungrypuck[1];
        puck1.pos.y = -0.1 * puck1.radius;
        puck2.pos.y = -0.1 * puck2.radius;
        doShower = false;
        doFountain = true;}
    document.getElementById("ballRestSlider").oninput = function() {
        // Logarithmic growth mapping for fine control near 1.0
        // t in [0,1], ballRest in [0,1]
        const t = parseFloat(this.value) / 100;
        const k = 1000000; // shape parameter; ~0.95 at midpoint when kâ‰ˆ1e6
        physProps.ballRest = Math.log(1 + k * t) / Math.log(1 + k);
    }
    document.getElementById('repulsionButton').oninput = function() {
        if (repulsionButton.checked == true) {  
            ballRepulsion = true;
        } else {
            ballRepulsion = false;}}
    document.getElementById("repulsionForceSlider").oninput = function() {
	    physProps.repulsionForce = repulsionForceSlider.value / 10;}
    document.getElementById("velColorMapSlider").oninput = function() {
        physProps.velColorMap = velColorMapSlider.value;}
    document.getElementById("ballsInput").onchange = function() {
        makeBalls();}
    document.getElementById("ballSphere").oninput = function() {
        doSpheres = true;
        doDiscs = false;
        doCircles = false;
        saturationSlider.value = 80;
        ballSaturation = 80;
        lightnessSlider.value = 45;
        ballLightness = 45;}
    document.getElementById("ballDisc").oninput = function() {
        doDiscs = true;
        doSpheres = false;
        doCircles = false;
        saturationSlider.value = 90;
        ballSaturation = 90;
        lightnessSlider.value = 40;
        ballLightness = 40;}
    document.getElementById("ballCircle").oninput = function() {
        doCircles = true;
        doDiscs = false;
        doSpheres = false;
        saturationSlider.value = 100;
        ballSaturation = 100;
        lightnessSlider.value = 70;
        ballLightness = lightnessSlider.value * 1;}
    document.getElementById("saturationSlider").oninput = function() {
        ballSaturation = saturationSlider.value * 1;}
     document.getElementById("lightnessSlider").oninput = function() {
        ballLightness = lightnessSlider.value * 1;}
    document.getElementById("misterSpeedSlider").oninput = function() {
        misterSpeed = misterSpeedSlider.value / 100;}
    document.getElementById("dumpSlider").oninput = function() {
        dumpSqueeze = dumpSlider.value / 100;}
    document.getElementById("dumpMoveSlider").oninput = function() {
        dumpShift = dumpMoveSlider.value / 100 * simWidth;}
    document.getElementById("rowsInput").oninput = function() {
        makeBumpers();}
    document.getElementById("bumperRadiusInput").oninput = function() {
        makeBumpers();}
    document.getElementById("smallBallInput").oninput = function() {
        makeBalls();}
    document.getElementById("bigBallInput").oninput = function() {
        makeBalls();}
    document.getElementById("cluster").oninput = function() {
        makeBalls();}
    document.getElementById("array").oninput = function() {
        makeBalls();}
    document.getElementById("showHungryPuckButton").oninput = function() {
        if (showHungryPuckButton.checked == true)
        fountain.checked = true;}
    document.getElementById('showBumperEntry').oninput = function() {
        if (showBumperEntry.checked == true) {
            showBumpers = true;
        } else {
            showBumpers = false;}}
    document.getElementById('showHungryPuckButton').oninput = function() {
        if (showHungryPuckButton.checked == true) {
            showEaters = true;
        } else {
            showEaters = false;}}
    document.getElementById('showPuckButton').oninput = function() {
        if (showPuckButton.checked == true) {
            for (var p = 0; p < Puck.length; p++) {
                Puck[p].radius = 0;
                Puck[p].puckArriving = true;
            }
            showPucks = true;
        } else {
            showPucks = false;}}
    document.getElementById('puckRadiusSlider').oninput = function() {
        for (p = 0; p < Puck.length; p++) {
            puck = Puck[p];
            if (p == 0) {
                puck.radius = 1.0 * puckRadiusSlider.value / 1000;
                puck.OGradius = puck.radius;
            }
            if (p == 1) {
                puck.radius = 0.5 * puckRadiusSlider.value / 1000;
                puck.OGradius = puck.radius;}}}
    document.getElementById('cornerRadiusSlider').oninput = function() {
        cornerRad = 1 * cornerRadiusSlider.value;
        if (cornerRadiusSlider.value < 100) {
            for (var c = 0; c < Corners.length; c++) {
                corner = Corners[c]; 
                if (screenVertical == true) {
                    corner.radius = 0.01 * cornerRad * 0.5 * simWidth;
                } else {
                    corner.radius = 0.01 * cornerRad * 0.5 * simHeight;
                }
                if (corner.corner == 'northwest' || corner.corner == 'southwest') {
                    corner.pos.x = 0;
                } else if (corner.corner == 'northeast' || corner.corner == 'southeast') {
                    corner.pos.x = simWidth;
                } 
}
        } else {
            for (var c = 0; c < Corners.length; c++) {
                corner = Corners[c]; 
                if (screenVertical == true) {
                    corner.radius = 0.5 * simWidth;
                } else {
                    corner.radius = 0.5 * simHeight;
                }

                // shift corners
                // calculate distance between corners
                var cornerSeparation = simWidth - 2 * corner.radius;
                var cornerClosureRatio = 1 - 0.01 * (200 - cornerRadiusSlider.value);
                var maximumShift = 0.5 * simWidth - corner.radius;
                var shiftAmount = Math.min(maximumShift, cornerSeparation * cornerClosureRatio);
                
                if (cornerClosureRatio > 0) {
                    if (corner.corner == 'northwest' || corner.corner == 'southwest') {
                        corner.pos.x = shiftAmount;
                    } else if (corner.corner == 'northeast' || corner.corner == 'southeast') {
                        corner.pos.x = simWidth - shiftAmount;
                    }
                }
            }
        }
    }

    document.getElementById('misterMode').oninput = function() {
        fountain.checked = true;
        doFountain = true;
        if (misterMode.value == "idle") {
            mrMode = 'idle';
        } else if (misterMode.value == "billiard") {
            mrMode = 'billiard';
            mrMr = MisterMister[0];
            mrMr.vel.x = .5;
            mrMr.vel.y = 0.2;
        } else if (misterMode.value == "typewriter") {
            mrMode = 'typewriter';
        } else if (misterMode.value == "printer") {
            mrMode = 'printer';
        } else if (misterMode.value == "scanner") {
            mrMode = 'scanner';
        } else if (misterMode.value == "circle") {
            mrMode = 'circle';
        } else if (misterMode.value == "oval") {
            mrMode = 'oval';
        } else if (misterMode.value == "bernoulli") {
            mrMode = 'bernoulli';
        } else if (misterMode.value == "worm") {
            mrMode = 'worm';
            wormButton.checked = true;
            doWorm = true;}}
    document.getElementById('ceilingButton').oninput = function() {
        if (ceilingButton.checked == true) {
            doCeiling = true;
        } else {
            doCeiling = false;
        }}
    document.getElementById('floorButton').oninput = function() {
        if (floorButton.checked == true) {
            doFloor = true;
        } else {
            doFloor = false;}}
    document.getElementById('leftWallButton').oninput = function() {
        if (leftWallButton.checked == true) {
            doLeftWall = true;
        } else {
            doLeftWall = false;}}
    document.getElementById('rightWallButton').oninput = function() {
        if (rightWallButton.checked == true) {
            doRightWall = true;
        } else {
            doRightWall = false;}}
    document.getElementById('oneShotButton').oninput = function() {
        if (oneShotButton.checked == true) {
            doOneShot = true;
        } else {
            doOneShot = false;}}
    document.getElementById('yeetSlider').oninput = function() {
        yeet = 1.0 * yeetSlider.value;}
    document.getElementById('wormButton').oninput = function() {
        if (wormButton.checked == true) {
            doWorm = true;
        } else {
            doWorm = false;}}
    document.getElementById('wormStartRadiusSlider').oninput = function() {
        WormProps.startRadius = 0.001 * wormStartRadiusSlider.value;
        makeWorm();}
    document.getElementById('wormEndRadiusSlider').oninput = function() {
        WormProps.endRadius = 0.001 * wormEndRadiusSlider.value;
        makeWorm();}
    document.getElementById('wormNumNodesSlider').oninput = function() {
        WormProps.numNodes = 1 * wormNumNodesSlider.value;
        makeWorm();}
    document.getElementById('sprinklerSpeedSlider').oninput = function() {
        sprinklerSpeed = 0.0001 * sprinklerSpeedSlider.value;};
    document.getElementById('wormStartRadiusSlider').oninput = function() {
        WormProps.startRadius = 0.001 * wormStartRadiusSlider.value;}
    document.getElementById('wormEndRadiusSlider').oninput = function() {
        WormProps.endRadius = 0.001 * wormEndRadiusSlider.value;}
    document.getElementById('wormNumNodesSlider').oninput = function() {
        WormProps.numNodes = 1 * wormNumNodesSlider.value;}
    document.getElementById('tracerButton').oninput = function() {
        if (tracerButton.checked == true) {
            doTracer = true;
            // Clear existing traces when tracer is turned on
            for (let i = 0; i < Balls.length; i++) {
                if (Balls[i].tracerBall == true) {
                    Balls[i].resetTrace();
                }
            }
        } else {
            doTracer = false;}}
    
    //  end get world properties from sliders 

    //  MOUSE STUFF AND TOUCH STUFF  -------------------------------------------------------------------
    
    let cursorX = simWidth / 2;
    let cursorY = 0;
    let initialBumperPositions = []; // Store initial Y positions of bumpers for relative movement
    let mouseDown = false;
    let newX = 0, newY = 0, startX = 0, startY = 0;
    canvas.addEventListener('mousedown', mouseDownHandler);
    canvas.addEventListener('mouseup', mouseUp);
    canvas.addEventListener('touchstart', touchStartHandler, {passive: false});
    canvas.addEventListener('touchend', touchEndHandler, {passive: false});
    canvas.addEventListener('touchcancel', touchEndHandler, {passive: false});
    
    function mouseDownHandler(ev) {
        const e = ev || window.event;
        puck1 = Puck[0];
        puck2 = Puck[1];
        hungryPuck = Hungrypuck[0];
        hungryPuck2 = Hungrypuck[1];
        misterMister = MisterMister[0];
        
        bounds = canvas.getBoundingClientRect();
		mX = e.clientX - bounds.left - canvas.clientLeft;
        mY = e.clientY - bounds.top - canvas.clientTop;

		cursorX = mX / cScale;
        cursorY = (canvas.height - mY) / cScale;
        mousePos = new Vector2(cursorX, cursorY)
        
        startX = e.clientX;
        startY = canvas.height - e.clientY;

        firstCornerX = mX;
        firstCornerY = mY;
        
        // ESTABLISH OBJECT DISTANCES TO MOUSE POSITION  ------------------------
        dirHungryPuck = new Vector2();
		dirHungryPuck.subtractVectors(mousePos, hungryPuck.pos);
		dHungryPuck = dirHungryPuck.length();

        dirHungryPuck2 = new Vector2();
		dirHungryPuck2.subtractVectors(mousePos, hungryPuck2.pos);
		dHungryPuck2 = dirHungryPuck2.length();

        dirMisterMister = new Vector2();
		dirMisterMister.subtractVectors(mousePos, misterMister.pos);
		dMisterMister = dirMisterMister.length();

        dirPuck1 = new Vector2();
		dirPuck1.subtractVectors(mousePos, puck1.pos);
		dPuck1 = dirPuck1.length();

        dirPuck2 = new Vector2();
		dirPuck2.subtractVectors(mousePos, puck2.pos);
		dPuck2 = dirPuck2.length();

        if (showBumpers == true) {
            // Calculate bumper array bounds if bumpers exist
            var bumperArrayBottom = -Infinity;
            var bumperArrayTop = Infinity;
            if (Bumpers.length > 0) {
                var lowestBumper = Bumpers[0];
                var highestBumper = Bumpers[Bumpers.length - 1];
                bumperArrayBottom = lowestBumper.pos.y - lowestBumper.radius;
                bumperArrayTop = highestBumper.pos.y + highestBumper.radius;
            }
        }
        
    // CHOOSE FOREGROUND OBJECTS UNDER CURSOR TO MOVE  ---------------------
        
        if (dMisterMister < misterMister.radius) {
            dX = startX / cScale - misterMister.pos.x;
            dY = startY / cScale - misterMister.pos.y;
            document.addEventListener('mousemove', mouseMisterMisterMove);
            document.addEventListener('touchmove', touchMisterMisterMove, {passive: false});
        } else {
        if (dHungryPuck2 < hungryPuck2.radius) {
            dX = startX / cScale - hungryPuck2.pos.x;
            dY = startY / cScale - hungryPuck2.pos.y;
            document.addEventListener('mousemove', mouseHungryPuck2Move);
            document.addEventListener('touchmove', touchHungryPuck2Move, {passive: false});
        } else {
		if (dHungryPuck < hungryPuck.radius) {
            dX = startX / cScale - hungryPuck.pos.x;
            dY = startY / cScale - hungryPuck.pos.y;
            document.addEventListener('mousemove', mouseHungryPuckMove);
            document.addEventListener('touchmove', touchHungryPuckMove, {passive: false});
        } else {
        if (dPuck2 < puck2.radius) {
            dX = startX / cScale - puck2.pos.x;
            dY = startY / cScale - puck2.pos.y;
            mouseDown = true;
            document.addEventListener('mousemove', mousePuck2Move);
            document.addEventListener('touchmove', touchPuck2Move, {passive: false});
        } else {
        if (dPuck1 < puck1.radius) {
            dX = startX / cScale - puck1.pos.x;
            dY = startY / cScale - puck1.pos.y;
            mouseDown = true;
            document.addEventListener('mousemove', mousePuck1Move);
            document.addEventListener('touchmove', touchPuck1Move, {passive: false});
        } else {
        if (showBumpers == true && Bumpers.length > 0 && mousePos.y < bumperArrayTop && mousePos.y > bumperArrayBottom) {
            dY = startY / cScale - (bumperArrayTop + bumperArrayBottom) / 2;
            // Store initial positions of all bumpers for relative movement
            initialBumperPositions = [];
            for (var i = 0; i < Bumpers.length; i++) {
                initialBumperPositions[i] = Bumpers[i].pos.y;
            }
            document.addEventListener('mousemove', mouseBumperMove);
            document.addEventListener('touchmove', touchBumperMove, {passive: false});
        } else {
            // Nothing else selected: update spray direction immediately and start tracking drag
            setNewDir(e);
            mouseDown = true;
            document.addEventListener('mousemove', setNewDir, false);
            document.addEventListener('touchmove', setNewDir, {passive: false});
        }}}}}}
    }

    function setNewDir(e) {
        const ev = e || window.event;
        if (!ev) return;
        const rect = canvas.getBoundingClientRect();
        const clientX = ev.clientX;
        const clientY = ev.clientY;
        if (typeof clientX !== 'number' || typeof clientY !== 'number') return;

        // Convert to simulation coordinates
        const mx = (clientX - rect.left - canvas.clientLeft) / cScale;
        const my = (canvas.height - (clientY - rect.top - canvas.clientTop)) / cScale;

    const misterMister = MisterMister[0];
    // Center of particle spawn region (use center, not random). Ignore ball.radius for direction.
    // spawnX center: mr.pos.x - 0.35R + 0.5*(0.9R) = mr.pos.x + 0.10R
    const originX = misterMister.pos.x + 0.10 * misterMister.radius;
    // spawnY center differs by mode:
    //  worm:    mr.pos.y - 0.30R  (from -0.3R - 0.35R + 0.5*0.7R)
    //  default: mr.pos.y - 0.70R  (from -0.65R - 0.35R + 0.5*0.6R)
    const originYOffset = (typeof mrMode === 'string' && mrMode === 'worm') ? 0.30 : 0.70;
    const originY = misterMister.pos.y - originYOffset * misterMister.radius;
    // Angle from spawn-region center to cursor
    misterMister.respawnDir = Math.atan2(my - originY, mx - originX);
    }

    function mouseBumperMove() {
        newY = event.clientY;   
        var currentMouseY = (simHeight - newY / cScale);
        var targetCenterY = currentMouseY - dY;
        var initialCenterY = (initialBumperPositions[0] + initialBumperPositions[initialBumperPositions.length - 1]) / 2;
        var offsetY = targetCenterY - initialCenterY;
        
        for (var t = 0; t < Bumpers.length; t++) {
            bumper = Bumpers[t];
            bumper.pos.y = initialBumperPositions[t] + offsetY;
        }
    }
    function mouseHungryPuckMove() {
        hungryPuck = Hungrypuck[0];
        newX = event.clientX;
        newY = event.clientY;   
        startX = event.clientX;
        startY = event.clientY;
        hungryPuck.pos.x = (newX / cScale) - dX;
        hungryPuck.pos.y = (simHeight - newY / cScale) - dY;
    }
    function mouseHungryPuck2Move() {
        hungryPuck2 = Hungrypuck[1];
        newX = event.clientX;
        newY = event.clientY;   
        startX = event.clientX;
        startY = event.clientY;
        hungryPuck2.pos.x = (newX / cScale) - dX;
        hungryPuck2.pos.y = (simHeight - newY / cScale) - dY;
    }
    function mouseMisterMisterMove() {
        misterMister = MisterMister[0];
        newX = event.clientX;
        newY = event.clientY;   
        startX = event.clientX;
        startY = event.clientY;
        misterMister.pos.x = (newX / cScale) - dX;
        misterMister.pos.y = (simHeight - newY / cScale) - dY;
    }
    function mousePuck1Move() {
        puck = Puck[0];
        newX = event.clientX;
        newY = event.clientY;   
        startX = event.clientX;
        startY = event.clientY;
        puck.puckMoved = true;
        puck.moving = true;
        
        // Store previous position for velocity calculation
        puck.prevPos.set(puck.pos);
        
        // Update position
        puck.pos.x = (newX / cScale) - dX;
        puck.pos.y = (simHeight - newY / cScale) - dY;
        
        // Calculate velocity based on position change
        puck.vel.subtractVectors(puck.pos, puck.prevPos);
        // Scale velocity by frame rate approximation (assuming 60fps)
        puck.vel.scale(60);
    }
    function mousePuck2Move() {
        puck = Puck[1];
        newX = event.clientX;
        newY = event.clientY;   
        startX = event.clientX;
        startY = event.clientY;
        puck.puckMoved = true;
        puck.moving = true;
        
        // Store previous position for velocity calculation
        puck.prevPos.set(puck.pos);
        
        // Update position
        puck.pos.x = (newX / cScale) - dX;
        puck.pos.y = (simHeight - newY / cScale) - dY;
        
        // Calculate velocity based on position change
        puck.vel.subtractVectors(puck.pos, puck.prevPos);
        // Scale velocity by frame rate approximation (assuming 60fps)
        puck.vel.scale(60);
    }
    
    function mouseUp() {
        document.removeEventListener('mousemove', mouseHungryPuckMove);
        document.removeEventListener('mousemove', mouseHungryPuck2Move);
        document.removeEventListener('mousemove', mousePuck1Move);
        document.removeEventListener('mousemove', mousePuck2Move);
        document.removeEventListener('mousemove', mouseMisterMisterMove);
        document.removeEventListener('mousemove', mouseBumperMove);
        document.removeEventListener('mousemove', setNewDir);
        
        // Also remove touch move listeners
        document.removeEventListener('touchmove', touchHungryPuckMove);
        document.removeEventListener('touchmove', touchHungryPuck2Move);
        document.removeEventListener('touchmove', touchPuck1Move);
        document.removeEventListener('touchmove', touchPuck2Move);
        document.removeEventListener('touchmove', touchMisterMisterMove);
        document.removeEventListener('touchmove', touchBumperMove);
        
        mouseDown = false;
        mouseUpTime = Date.now();
        for (var p = 0; p < Puck.length; p++) {
            if (Puck[p].puckMoved == true) {
                Puck[p].puckFadingIn = true;
                Puck[p].puckMoved = false;
            }
            Puck[p].moving = false;
        }
    }

    let touchDown = false;
    
    function touchStartHandler(event) {
        event.preventDefault(); // Prevent scrolling and other default touch behaviors
        
        // Use the first touch point
        var touch = event.touches[0];
        if (!touch) return;
        
        // Create a synthetic event object that mimics the mouse event structure
        var syntheticEvent = {
            clientX: touch.clientX,
            clientY: touch.clientY
        };
        
        // Store the original event object temporarily
        var originalEvent = window.event;
        window.event = syntheticEvent;
        
        // Call the existing mouse down handler
        mouseDownHandler();
        
        // Restore the original event
        window.event = originalEvent;
        
        touchDown = true;
    }
    
    function touchEndHandler(event) {
        event.preventDefault();
        
        if (touchDown) {
            // Remove touch move listeners
            document.removeEventListener('touchmove', touchHungryPuckMove);
            document.removeEventListener('touchmove', touchHungryPuck2Move);
            document.removeEventListener('touchmove', touchPuck1Move);
            document.removeEventListener('touchmove', touchPuck2Move);
            document.removeEventListener('touchmove', touchMisterMisterMove);
            document.removeEventListener('touchmove', touchBumperMove);
            
            // Call the existing mouse up handler
            mouseUp();
            
            touchDown = false;
        }
    }
    
    // Touch move functions that mirror the mouse move functions
    function touchBumperMove(event) {
        event.preventDefault();
        var touch = event.touches[0];
        if (!touch) return;
        
        var originalEvent = window.event;
        window.event = { clientY: touch.clientY };
        mouseBumperMove();
        window.event = originalEvent;
    }
    
    function touchHungryPuckMove(event) {
        event.preventDefault();
        var touch = event.touches[0];
        if (!touch) return;
        
        var originalEvent = window.event;
        window.event = { clientX: touch.clientX, clientY: touch.clientY };
        mouseHungryPuckMove();
        window.event = originalEvent;
    }
    
    function touchHungryPuck2Move(event) {
        event.preventDefault();
        var touch = event.touches[0];
        if (!touch) return;
        
        var originalEvent = window.event;
        window.event = { clientX: touch.clientX, clientY: touch.clientY };
        mouseHungryPuck2Move();
        window.event = originalEvent;
    }
    
    function touchMisterMisterMove(event) {
        event.preventDefault();
        var touch = event.touches[0];
        if (!touch) return;
        
        var originalEvent = window.event;
        window.event = { clientX: touch.clientX, clientY: touch.clientY };
        mouseMisterMisterMove();
        window.event = originalEvent;
    }
    
    function touchPuck1Move(event) {
        event.preventDefault();
        var touch = event.touches[0];
        if (!touch) return;
        
        var originalEvent = window.event;
        window.event = { clientX: touch.clientX, clientY: touch.clientY };
        mousePuck1Move();
        window.event = originalEvent;
    }
    
    function touchPuck2Move(event) {
        event.preventDefault();
        var touch = event.touches[0];
        if (!touch) return;
        
        var originalEvent = window.event;
        window.event = { clientX: touch.clientX, clientY: touch.clientY };
        mousePuck2Move();
        window.event = originalEvent;
    }

    //  end mouse and touch stuff
    
	//  BASIC FUNCTIONS -----------------------------------------------------------------------
	
    class Vector2 {
		constructor(x = 0.0, y = 0.0) {
			this.x = x; 
			this.y = y;
		}
		set(v) {
			this.x = v.x; 
            this.y = v.y;
		}
		clone() {
			return new Vector2(this.x, this.y);
		}
		add(v, s=1) {
			this.x += v.x * s;
			this.y += v.y * s;
			return this;
		}
		addVectors(a, b) {
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			return this;
		}
		subtract(v, s = 1.0) {
			this.x -= v.x * s;
			this.y -= v.y * s;
			return this;
		}
		subtractVectors(a, b) {
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			return this;			
		}
		length() {
			return Math.sqrt(this.x * this.x + this.y * this.y);
		}
		scale(s) {
			this.x *= s;
			this.y *= s;
		}
		dot(v) {
			return this.x * v.x + this.y * v.y;
		}
        perp() {
			return new Vector2(-this.y, this.x);
		}
	}

    function closestPointOnSegment(p, a, b) 
	{
		var ab = new Vector2();
		ab.subtractVectors(b, a);
		var t = ab.dot(ab);
		if (t == 0.0)
			return a.clone();
		t = Math.max(0.0, Math.min(1.0, (p.dot(ab) - a.dot(ab)) / t));
		var closest = a.clone();
		return closest.add(ab, t);
	}

    function cX(pos) {
        return pos.x * cScale;
    }
	function cY(pos) {
        return canvas.height - pos.y * cScale;
    }
    
    
    function wipeRestart() {
        c.fillStyle = 'hsl(0, 0%, 0%)';
        c.fillRect(0, 0, canvas.width, canvas.height);
        makeBalls()
    }
    function forcedWipeRestart() {
        c.fillStyle = 'hsl(0, 0%, 0%)';
        c.fillRect(0, 0, canvas.width, canvas.height);
        makeBalls()
    }
    function pause() {
		physProps.paused = !physProps.paused;
        let input = document.querySelectorAll('.checkbox-pause');
        if (physProps.paused == true) { 
            for (i = 0; i < input.length; i++) {
                input[i].checked = true;
            }
        } else {
            for (i = 0; i < input.length; i++) {
            input[i].checked = false;
            }
        }
	}
	function pauseAndStep() {
        let input = document.querySelectorAll('.checkbox-pause');
        for (i = 0; i < input.length; i++) {
            input[i].checked = true;
        }
		physProps.paused = false;
		simulate();
		physProps.paused = true
	}
    function drawCircle(x, y, radius) {
        c.beginPath();			
		c.arc(x, y, radius, 0.0, 2.0 * Math.PI) 
		c.closePath();
	}
    function drawEllipse(x, y, radiusX, radiusY) {
        c.beginPath();			
		c.ellipse(x * cScale, y * cScale, radiusX * cScale, radiusY * cScale, 0, 0, 2 * Math.PI) 
		c.closePath();
	}

    // COLLISIONS AND BOUNDARIES =============================================================

    //  HANDLE WORM SEGMENT HITS --------------------------------------------------------
    function handleWormSegmentHits(ball, wormSegment, segmentRadius, segmentVelocity) {
        var dir = new Vector2();
        dir.subtractVectors(ball.pos, wormSegment);
        var d = dir.length();
        if (d == 0.0 || d >= ball.radius + segmentRadius)
            return;

        dir.scale(1.0 / d);
        var overlap = ball.radius + segmentRadius - d;
        var corr = overlap + 0.003; // Small buffer to prevent immediate re-collision
        ball.pos.add(dir, corr);

        var relativeVel = new Vector2();
        relativeVel.subtractVectors(ball.vel, segmentVelocity);
        var velAlongNormal = relativeVel.dot(dir);
        var massScale = 10000000;
        var segmentMass = massScale * segmentRadius * segmentRadius;
        // Only apply velocity impulse if objects are approaching each other
        if (velAlongNormal <= 0) {
            var e = physProps.puckRest;
            // Calculate impulse scalar
            var j = -(1 + e) * velAlongNormal;
            j /= (1 / ball.mass) + (1 / segmentMass);
            var impulse = new Vector2();
            impulse.set(dir);
            impulse.scale(j);
            
            ball.vel.add(impulse, 1 / ball.mass);
        }

        var v = ball.vel.dot(dir);
        ball.vel.add(dir, v * -10.0 * physProps.ballRest);
    }

    //  HANDLE BALL TO BALL HITS --------------------------------------------------------------------
	function handleBallHits(ball1, ball2) {
		var dir = new Vector2();
		dir.subtractVectors(ball2.pos, ball1.pos);
		var d = dir.length();
		if (d == 0.0 || d >= ball1.radius + ball2.radius)
			return;

		dir.scale(1.0 / d);
		var corr = (ball1.radius + ball2.radius - d) / 2.0 + 0.001; // Small buffer to prevent immediate re-collision
		var v1 = ball1.vel.dot(dir);
		var v2 = ball2.vel.dot(dir);
		var m1 = ball1.mass;
		var m2 = ball2.mass;
		var newV1 = (m1 * v1 + m2 * v2 - m2 * (v1 - v2) * physProps.ballRest) / (m1 + m2);
		var newV2 = (m1 * v1 + m2 * v2 - m1 * (v2 - v1) * physProps.ballRest) / (m1 + m2);

        ball1.pos.add(dir, -corr);
		ball2.pos.add(dir, corr);
		ball1.vel.add(dir, newV1 - v1);
		ball2.vel.add(dir, newV2 - v2);
	}

    //  HANDLE BALL TO BALL COMPRESSION --------------------------------------------------------------------
	function handleBallRepulsion(ball1, ball2) {
		var dir = new Vector2();
		dir.subtractVectors(ball2.pos, ball1.pos);
		var d = dir.length();
		var repulsionThreshold = physProps.repulsionDist * (ball1.radius + ball2.radius);
		if (d == 0.0 || d >= repulsionThreshold)
			return;
		dir.scale(1.0 / d);
		var compression = Math.abs(repulsionThreshold - d);
		var force = physProps.repulsionForce * compression;
		var totalMass = ball1.mass + ball2.mass;
		var force1 = force * (ball2.mass / totalMass);
		var force2 = force * (ball1.mass / totalMass);
		
		ball1.vel.add(dir, -force1);
		ball2.vel.add(dir, force2);
	}

    //  HANDLE BUMPER HITS ------------------------------------------------------------------- 
	function handleBumperHits(ball, bumper) {
        var dir = new Vector2();
		dir.subtractVectors(ball.pos, bumper.pos);
		var d = dir.length();
		if (d == 0.0 || d >= ball.radius + bumper.radius)
			return;

		dir.scale(1.0 / d);
		var corr = (ball.radius + bumper.radius - d);
		var v = ball.vel.dot(dir);
        ball.pos.add(dir, corr);
        ball.vel.add(dir, v * -2.0 * physProps.bumperRest);

	}
    
    //  HANDLE PUCK TO BALL HITS  -------------------------------------------------------------------- 
	function handlePuckHits(ball, puck) {
        var dir = new Vector2();
		dir.subtractVectors(ball.pos, puck.pos);
		var d = dir.length();
		if (d == 0.0 || d >= ball.radius + puck.radius)
			return;

		dir.scale(1.0 / d);
		var overlap = ball.radius + puck.radius - d;
		
		// For puck collisions, push the ball out completely to prevent clipping
		// Use a slightly larger separation to ensure clean separation
		var corr = overlap + 0.001; // Small buffer to prevent immediate re-collision
		ball.pos.add(dir, corr);

        if (puck.moving == true) {
            var relativeVel = new Vector2();
            relativeVel.subtractVectors(ball.vel, puck.vel);
            var velAlongNormal = relativeVel.dot(dir);
            // Only apply velocity impulse if objects are approaching each other
            if (velAlongNormal <= 0) {
                var e = physProps.puckRest;
                // Calculate impulse scalar
                var j = -(1 + e) * velAlongNormal;
                j /= (1 / ball.mass) + (1 / puck.mass);
                var impulse = new Vector2();
                impulse.set(dir);
                impulse.scale(j);
                
                ball.vel.add(impulse, 1 / ball.mass);
            }
        } else {
            var v = ball.vel.dot(dir);
            ball.vel.add(dir, v * -2.0 * physProps.puckRest);
        }
	}

    //  HANDLE CORNER HITS  --------------------------------------------------------------------
    function handleCornerHits(ball1, corner) {
        // Find arc center based on corner position and type
        let arcCenterX, arcCenterY;
        if (corner.corner === 'northwest') {
            arcCenterX = corner.pos.x + corner.radius; 
            arcCenterY = corner.pos.y + corner.radius;
        } else if (corner.corner === 'northeast') {
            arcCenterX = corner.pos.x - corner.radius; 
            arcCenterY = corner.pos.y + corner.radius;
        } else if (corner.corner === 'southwest') {
            arcCenterX = corner.pos.x + corner.radius; 
            arcCenterY = corner.pos.y - corner.radius;
        } else { // southeast
            arcCenterX = corner.pos.x - corner.radius; 
            arcCenterY = corner.pos.y - corner.radius;
        }
        
        const dx = ball1.pos.x - arcCenterX;
        const dy = ball1.pos.y - arcCenterY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Check if ball is colliding with the inside of the arc
        if (distance > corner.radius - ball1.radius) {
            // Surface normal points from arc center toward ball
            const normalX = dx / distance;
            const normalY = dy / distance;
            
            ball1.pos.x = arcCenterX + normalX * (corner.radius - ball1.radius);
            ball1.pos.y = arcCenterY + normalY * (corner.radius - ball1.radius);
            
            const dot = ball1.vel.x * normalX + ball1.vel.y * normalY;
            ball1.vel.x -= 2 * dot * normalX;
            ball1.vel.y -= 2 * dot * normalY;
        }
    }
    
    //  HANDLE SHOWER  -------------------------------------------------------------------- 
    function goShower(ball) {
        if (doGravityDown == true) {
            ball.pos.y = simHeight + ball.radius + 30 * Math.random() * ball.radius;
            ball.pos.x = dumpShift + ((Math.random() * simWidth * dumpSqueeze) + ((1.0 / (2 * dumpSqueeze)) - 0.5) * simWidth * dumpSqueeze);
            ball.vel.x = 0;
            ball.vel.y = 0;
        } else if (doGravityRight == true) {
            ball.pos.x = -ball.radius - 30 * Math.random() * ball.radius;
            ball.pos.y = dumpShift + ((Math.random() * simHeight * dumpSqueeze) + ((1.0 / (2 * dumpSqueeze)) - 0.5) * simHeight * dumpSqueeze);
            ball.vel.x = 0;
            ball.vel.y = 0;
        }
    }
    
    //  HANDLE MR. MISTER go fountain --------------------------------------------------------------------
    function goFountain(ball) {
        if (mrMode == "typewriter" && goLeft == true) {
            return;
        }
        var mrMr = MisterMister[0];
        if (mrMode == "worm") {
            ball.immuneToWorm = true;
            ball.immunityFramesLeft = 10; 
            if (mrMr.pos.x < 0 || mrMr.pos.x > simWidth || 
                mrMr.pos.y < 0 || mrMr.pos.y > simHeight) {
                return;
            }
            var spawnX = mrMr.pos.x - (0.35 * mrMr.radius - ball.radius) + (Math.random() * (0.9 * mrMr.radius - 6 * ball.radius));
            var spawnY = mrMr.pos.y - 0.3 * mrMr.radius - (0.35 * mrMr.radius - ball.radius) + (Math.random() * (0.7 * mrMr.radius - 4 * ball.radius));
            ball.pos.x = Math.max(0, Math.min(simWidth, spawnX));
            ball.pos.y = Math.max(0, Math.min(simHeight, spawnY));
            var velX = 0.01 * yeet * Math.cos(mrMr.respawnDir + alpha);
            var velY = 0.01 * yeet * Math.sin(mrMr.respawnDir + alpha);
        } else {
            var spawnX = mrMr.pos.x - (0.35 * mrMr.radius - ball.radius) + (Math.random() * (0.9 * mrMr.radius - 6 * ball.radius));
            var spawnY = mrMr.pos.y - 0.65 * mrMr.radius - (0.35 * mrMr.radius - ball.radius) + (Math.random() * (0.6 * mrMr.radius - 4 * ball.radius));
            ball.pos.x = Math.max(0, Math.min(simWidth, spawnX));
            ball.pos.y = Math.max(0, Math.min(simHeight, spawnY));
            if (sprinklerSpeed > 0 && fountainSpinMode == "sweep") {
                var velX = 0.01 * yeet * Math.cos(mrMr.respawnDir + alpha);
                var velY = 0.01 * yeet * Math.sin(mrMr.respawnDir + alpha);
            } else {
                var velX = 0.01 * yeet * Math.cos(mrMr.respawnDir);
                var velY = 0.01 * yeet * Math.sin(mrMr.respawnDir);
            }
        }
        
        ball.vel.x = velX;
        ball.vel.y = velY;
    }

    //  HUNGRY PUCK HITS  --------------------------------------------------------------------
	function handleHungryPuckHits(ball, hungryPuck) {
        var dir = new Vector2();
		dir.subtractVectors(ball.pos, hungryPuck.pos);
		var d = dir.length();
		if (d == 0.0 || d > ball.radius + hungryPuck.radius)
			return;

		dir.scale(1.0 / d);
        // FOUNTAIN AND SWEEPER SETUP FOR HUNGRY PUCK--------------------------------------------------
        var sprinklerSpeed = 0.0001;
        if (fountainSpinMode == 'cw') {
            alpha += sprinklerSpeed * -1.0 * physProps.dt;
            if (alpha > 2*Math.PI || alpha < -2*Math.PI) {
                alpha = 0
            }
        } else if (fountainSpinMode == 'ccw') {
            alpha += sprinklerSpeed * 1.0 * physProps.dt;
            if (alpha > 2*Math.PI || alpha < -2*Math.PI) {
                alpha = 0
            }
        } else {
            alpha += sprinklerSpeed * -1.0 * physProps.dt;
            if (alpha > 2*Math.PI || alpha < -2*Math.PI) {
                alpha = 0
            }
        }

        // HANDLE SHOWER AND FOUNTAIN FOR HUNGRY PUCK -------------------------------------------------------------  
        if (doOneShot == false) {
            if (doShower == true) {
                goShower(ball); 
            }
            
            if (doFountain == true) {
                goFountain(ball);
            }
        }
    }

    //  HANDLE BOUNDARIES = FLOOR, WALLS, CEILING -------------------------------------------------------
	function handleOutOfBounds(ball, worldSize) {
        // FOUNTAIN AND SWEEPER SETUP ----------------------------------------------------
        if (fountainSpinMode == 'cw') {
            sweepAngle = 2 * Math.PI;
            alpha += sprinklerSpeed * -1.0 * physProps.dt;
            if (alpha > 2 * Math.PI || alpha < -2 * Math.PI) {
                alpha = 0;
            }
        } else if (fountainSpinMode == 'ccw') {
            sweepAngle = 2 * Math.PI;
            alpha += sprinklerSpeed * 1.0 * physProps.dt;
            if (alpha > 2 * Math.PI || alpha < -2 * Math.PI) {
                alpha = 0;
            }
        } else {
            sweepAngle = 0.35 * Math.PI;
            alpha += sprinklerSpeed * sweepDir * physProps.dt;
            if (alpha > (sweepAngle * 1.01) || alpha < (-sweepAngle * 1.01)) { // small chance of stalling
                alpha = 0
            }
            if (alpha > sweepAngle || alpha < -sweepAngle) {
                sweepDir *= -1;
            }
        }

        // HANDLE WALL HITS ------------------------------------------------------------  
        if (doCeiling == true) {
            if (ball.pos.y > worldSize.y - ball.radius) {
                ball.pos.y = worldSize.y - ball.radius;
                ball.vel.y = -ball.vel.y * physProps.ceilingRest;
		    }
        }
        if (doFloor == true) {
            if (ball.pos.y < ball.radius) {
		        ball.pos.y = ball.radius;
		        ball.vel.y = -ball.vel.y * physProps.floorRest;
		        }
        }
        if (doLeftWall == true) {
            if (cornerRad <= 100) {
                if (ball.pos.x < ball.radius) {
                    ball.pos.x = ball.radius;
                    ball.vel.x = -ball.vel.x * physProps.wallRest;
                }
            } else {
                NWCorner = Corners[0];
                if (ball.pos.x < NWCorner.pos.x + ball.radius) {
                    ball.pos.x = NWCorner.pos.x + ball.radius
                    ball.vel.x = -ball.vel.x * physProps.wallRest;
                }
            }
        }
        if (doRightWall == true) {
            if (cornerRad <= 100) {
                if (ball.pos.x > worldSize.x - ball.radius) {
                    ball.pos.x = worldSize.x - ball.radius;
                    ball.vel.x = -ball.vel.x * physProps.wallRest;
                }    
            } else {
                NECorner = Corners[1];
                if (ball.pos.x > NECorner.pos.x - ball.radius) {
                    ball.pos.x = NECorner.pos.x - ball.radius;
                    ball.vel.x = -ball.vel.x * physProps.wallRest;
                }  
            }
        }

        // HANDLE BOUNDS FOR SHOWER AND FOUNTAIN -------------------------------------------------------------  
        if (doOneShot == false) {
            if (doShower == true) {
                if (ball.pos.y < -2.0 * ball.radius || 
                    ball.pos.y > simHeight + 2.0 * ball.radius ||
                    ball.pos.x < -2.0 * ball.radius || 
                    ball.pos.x > simWidth + 2.0 * ball.radius) {
                    goShower(ball);
                }
            } 
            var hP = MisterMister[0];
            var dir = hP.respawnDir;
            var velX = yeet / 100 * Math.cos(dir + alpha);
            velY = yeet / 100 * Math.sin(dir + alpha);
            if (doFountain == true) {
                if (ball.pos.y < -2.0 * ball.radius || 
                    ball.pos.y > simHeight + 2.0 * ball.radius ||
                    ball.pos.x < -2.0 * ball.radius || 
                    ball.pos.x > simWidth + 2.0 * ball.radius) {
                    
                    // Additional check for worm mode: only respawn if Mr. Mister is within bounds
                    if (mrMode == "worm") {
                        
                        if (hP.pos.x >= 0 && hP.pos.x <= simWidth && 
                            hP.pos.y >= 0 && hP.pos.y <= simHeight) {
                            goFountain(ball);
                        }
                        // If Mr. Mister is outside bounds in worm mode, don't respawn the particle
                    } else {
                        // Normal respawn behavior for other modes
                        goFountain(ball);
                    }
                }
            }
        }
	}

    // HANDLE MR. MISTER BOUNDS ------------------------------------------------------------  
    function handleMrMrBounds(hungryPuck, worldSize) {
        mrMr = MisterMister[0];
            if (mrMr.pos.y > worldSize.y - mrMr.radius) {
                mrMr.pos.y = worldSize.y - mrMr.radius;
                mrMr.vel.y = -mrMr.vel.y;
            }
            if (mrMr.pos.y < mrMr.radius) {
                mrMr.pos.y = mrMr.radius;
                mrMr.vel.y = -mrMr.vel.y;
            }
            if (mrMr.pos.x < mrMr.radius) {
                mrMr.pos.x = mrMr.radius;
                mrMr.vel.x = -mrMr.vel.x;
            }
            if (mrMr.pos.x > worldSize.x - mrMr.radius) {
                mrMr.pos.x = worldSize.x - mrMr.radius;
                mrMr.vel.x = -mrMr.vel.x;
            }
    }

    //  WORLD PROPERTIES INIT DEFINITIONS ----------------------------------------------
	var physProps = {
		gravity : new Vector2(0, 0),
		substeps: 1,
		dt : 1 / (60 * 1), // updated when substeps changes
		worldSize : new Vector2(simWidth, simHeight),

		ballRest : 0,
        bumperRest : 0.95,
        floorRest : 1.0,
        wallRest : 1.0,
        ceilingRest : 1.0,
        puckRest: 0.95,
        persistence: 0,
        paused : false,
        repulsionForce: 2,
        repulsionDist: 4,
        velColorMap: 0,
	}

    var WormProps = {
        gravity : new Vector2(0, 0),
        dt : 1 / 60,
        wormSubSteps : 10,
        paused : true,
        phase: 0.0,
    
        wiggleActive: false,
        wiggleFrame: 0,
        wigglePerFrameVelY: 0.0,
        wigglePerFrameVelX: 0.0,
        wigglePerFrameVel: 0.0,
        wiggleDir: 1,
        prevHeadVY: 0.0,
        wiggleToggle: 1, // alternates sign each cycle
        wiggleAdvancePerFrame: 0.0,
        startRadius: 0,
        endRadius: 0,
        numNodes: 0,
        
        // Worm delay properties
        isHiding: false,
        hideStartTime: 0,
        hideDelay: 10000, // 10 seconds in milliseconds
    }
    
    // Function to update dt when substeps change
    function updateSubsteps(newSubsteps) {
        physProps.substeps = newSubsteps;
        physProps.dt = 1 / (60 * physProps.substeps);
    }
    
	//  SETUP SCENE ======================================================
	function setupScene() {
        let input = document.querySelectorAll('.checkbox-pause');
        for (i = 0; i < input.length; i++) {
            input[i].checked = false;
        }
        currentDate = new Date();
        mSecs = currentDate.getMilliseconds();
        dumpSqueeze2 = 0.2;
        alpha = 0;
        sweepDir = 1;
        dir = 0;
        huePos = 0;
        delta = 0;
        mrMrTimer = 0;
        mouseUpTime = 0;
        mouseDownTime = 0;
        
        goLeft = false;
        spawnLeft = true;
        showEaters = false;
        mrMode = "";

        doCeiling = ceilingButton.checked;
        doFloor = floorButton.checked;
        doLeftWall = leftWallButton.checked;
        doRightWall = rightWallButton.checked;
        dumpShift = 0.01 * dumpMoveSlider.value * simWidth;
        dumpSqueeze = 0.01 * dumpSlider.value;
        showBumpers = showBumperEntry.checked;
        showPucks = showPuckButton.checked;
        doShower = shower.checked;
        doFountain = fountain.checked;
        doTracer = tracerButton.checked;
        sprinklerSpeed = 0.0001 * sprinklerSpeedSlider.value;
        respawnDir = 0;
        
        ballRepulsion = repulsionButton.checked;
        misterSpeed = 0.01 * misterSpeedSlider.value;
        ballSaturation = 1 * saturationSlider.value;
        ballLightness = 1 *  lightnessSlider.value;
        persistence = 1.0 * persistenceSlider.value;
        cornerRad = 1.0 * cornerRadiusSlider.value;
        doSpheres = ballSphere.checked;
        doDiscs = ballDisc.checked;
        doCircles = ballCircle.checked;
        doOneShot = oneShotButton.checked;
        yeet = 1.0 * yeetSlider.value;
        doGravityDown = gravityDown.checked;
        doGravityRight = gravityRight.checked;
        doWorm = wormButton.checked;

        physProps.velColorMap = velColorMapSlider.value;
        // Initialize ball restitution from slider using the same log mapping
        (function(){
            const el = document.getElementById('ballRestSlider');
            if (el) {
                const t = parseFloat(el.value) / 100;
                const k = 1000000;
                physProps.ballRest = Math.log(1 + k * t) / Math.log(1 + k);
            }
        })();

        WormProps.startRadius = 0.001 * wormStartRadiusSlider.value,
        WormProps.endRadius = 0.001 * wormEndRadiusSlider.value,
        WormProps.numNodes = 1 * wormNumNodesSlider.value,
        
        fountainSpinMode = 'sweep';

        makePucks();
        makeHungryPucks();
        makeMisterMister();
        
        if (firstRun == true) {
            makeBalls();
            makeCorners()
            makeBumpers();
            makeWorm();
            firstRun = false;
        }
    }

	//  BALL CONSTRUCTOR  -----------------------------------------------------------------------
	class BALL {
		constructor(radius, mass, pos, vel, saturation, whiteBall, tracerBall, smallBallRadius, bigBallRadius) {
			this.radius = radius;
			this.mass = mass;
			this.pos = pos.clone();
			this.vel = vel.clone();
            this.color = 0;
            this.hiColor = 0;
            this.saturation = saturation;
            this.whiteBall = whiteBall;
            this.immuneToWorm = false;
            this.immunityFramesLeft = 0; 
            this.tracerBall = tracerBall;
            this.artificialMovement = false; // Flag to track when ball is being repositioned artificially
            if (tracerBall == true) {
                this.radius = 0.5 * (smallBallRadius + bigBallRadius);
                this.trail = new Float32Array(1500); // Increased size to accommodate flags
                this.trailFirst = 0;
                this.trailLast = 0;
                this.tracer = true;
            }
		}
        get top() {
            return this.pos.y + this.radius;
        }
        get bottom() {
            return this.pos.y - this.radius;
        }
        get left() {
            return this.pos.x - this.radius;
        }
        get right() {
            return this.pos.x + this.radius;
        }
        updateTrace() {
            // Check if ball is outside simulation boundaries
            var isOutsideBounds = (this.pos.x < 0 || this.pos.x > simWidth || 
                                 this.pos.y < 0 || this.pos.y > simHeight);
            
            if (isOutsideBounds) {
                this.artificialMovement = true; // Mark as outside/artificial movement
                return; // Don't record trace when outside
            }
            
            // Ball is back inside bounds - resume normal tracing (don't reset trace)
            var wasArtificial = this.artificialMovement;
            if (this.artificialMovement) {
                this.artificialMovement = false; // Resume normal tracing
            }
            
            // Record normal trace point (x, y, discontinuity_flag)
            this.trail[this.trailLast] = this.pos.x;
            this.trail[this.trailLast + 1] = this.pos.y;
            this.trail[this.trailLast + 2] = wasArtificial ? 1.0 : 0.0; // Flag discontinuity
            this.trailLast = (this.trailLast + 3) % this.trail.length;
            if (this.trailLast == this.trailFirst)
                this.trailFirst = (this.trailFirst + 3) % this.trail.length;
        }
        resetTrace() {
            this.trailFirst = 0;
            this.trailLast = 0;
        }
		simulate() {
			this.vel.add(physProps.gravity, physProps.dt);
            const maxSpeed = 3.0;
            if (this.vel.length() > maxSpeed) {
                this.vel.x *= maxSpeed / this.vel.length();
                this.vel.y *= maxSpeed / this.vel.length();
            }
			this.pos.add(this.vel, physProps.dt)
            if (this.whiteBall == true || this.tracerBall == true) {
                this.color = `hsl(0, 0%, ${ballLightness + 20}%)`;
                this.hiColor = `hsl(0, 0%, ${ballLightness + 50}%)`;
            } else {
                var speedHue = this.vel.length() * physProps.velColorMap;
                if (speedHue > 330) {speedHue = 330}
                var speedHueRatio = Math.min(0.8 + 0.2 * speedHue / 330, 1.0);
                //speedHue = 240 - (240 * speedHueRatio);
                this.color = `hsl(${speedHue}, ${ballSaturation * this.saturation}%, ${speedHueRatio * ballLightness}%)`;
                this.hiColor = `hsl(${speedHue}, ${ballSaturation * this.saturation}%, ${speedHueRatio * ballLightness + 15}%)`;
            }
		}
        drawTrace() {
            c.lineCap = 'round';
            c.lineWidth = this.radius * cScale;
            if (this.trailLast != this.trailFirst) {
                var i = this.trailFirst;
                var segmentCount = 0;
                var totalSegments = 0;
                
                // First, count total segments
                var tempI = this.trailFirst;
                while (tempI != this.trailLast) {
                    totalSegments++;
                    tempI = (tempI + 3) % this.trail.length;
                }
                
                // Draw each segment with fading
                i = this.trailFirst;
                var prevX = this.trail[i] * cScale;
                var prevY = canvas.height - this.trail[i + 1] * cScale;
                i = (i + 3) % this.trail.length;
                
                while (i != this.trailLast) {
                    var currentX = this.trail[i] * cScale;
                    var currentY = canvas.height - this.trail[i + 1] * cScale;
                    var isDiscontinuity = this.trail[i + 2] > 0.5; // Check discontinuity flag
                    
                    // Skip drawing if this point represents a discontinuity (post-teleportation)
                    if (!isDiscontinuity) {
                        // Calculate fade: older segments are more transparent
                        var fadeRatio = segmentCount / totalSegments;
                        var alpha = 1.0 - fadeRatio; // Start opaque, fade to transparent
                        
                        c.strokeStyle = `hsl(200, 60%, 70%, ${1 - alpha})`;
                        c.beginPath();
                        c.moveTo(prevX, prevY);
                        c.lineTo(currentX, currentY);
                        c.stroke();
                    }
                    // If isDiscontinuity is true, skip drawing this segment (creates gap)
                    
                    prevX = currentX;
                    prevY = currentY;
                    segmentCount++;
                    i = (i + 3) % this.trail.length;
                }
            }
        }
        draw() {
            if (doSpheres == true) {
                const shineOffsetX = cScale * this.radius * 0.3; // old masterShineShiftX;
                const shineOffsetY = cScale * this.radius * 0.4; // old masterShineShiftY;
                const shineVector = Math.sqrt(shineOffsetX * shineOffsetX + shineOffsetY * shineOffsetY);
                const shineRadius = 0.5 * cScale * this.radius + shineVector;
                
                const shading = c.createRadialGradient(
                    cX(this.pos) - shineOffsetX, 
                    cY(this.pos) - shineOffsetY, 
                    shineRadius, 
                    cX(this.pos) - shineOffsetX, 
                    cY(this.pos) - shineOffsetY, 
                    0);
                shading.addColorStop(0, this.color);
                shading.addColorStop(1, this.hiColor);
                drawCircle(cX(this.pos), cY(this.pos), this.radius * cScale);
                c.fillStyle = shading;
                c.fill()
            } 
            if (doDiscs == true) {
                drawCircle(cX(this.pos), cY(this.pos), this.radius * cScale);    
                c.fillStyle = this.color;
                c.fill();
                c.strokeStyle = this.hiColor;
                c.lineWidth = 0.2 * this.radius * cScale;
                c.stroke();
            }
            if (doCircles == true) {
                drawCircle(cX(this.pos), cY(this.pos), this.radius * cScale);    
                c.strokeStyle = this.color;
                c.lineWidth = 0.2 * this.radius * cScale;
                c.stroke();
            }
        }
	}

    //  MAKE BALLS -------------------------------------------
    //  SQUARE ARRAY 
    function makeBalls() {
        Balls = [];
        var smallBallRadius = smallBallInput.value / 1000;
        var bigBallRadius = bigBallInput.value / 1000;
        var maxBallRadius = Math.max(smallBallRadius, bigBallRadius);
        var getNumBalls = ballsInput.value * 1;
        var ballJitter = 0.20;
        var brakes = 0;
        var dumpSqueeze = dumpSlider.value / 100;
        var dumpSqueeze2 = 0.2;
        var dumpShift = dumpMoveSlider.value / 100 * simWidth;
        var velX = 0;
        var velY = 0;
        if (array.checked == true) {  
            var numCols = Math.floor(Math.sqrt(getNumBalls));
            var numRows = Math.floor(Math.sqrt(getNumBalls));
            var countDifference = getNumBalls - (numCols * numRows);
            var addedRows = Math.ceil(countDifference / numCols);
            var boxWidth = (numCols * 2.0 * maxBallRadius);
            var boxHeight = ((numRows + addedRows) * 2.0 * maxBallRadius);
            var horizBias = 0.5 * (simWidth - boxWidth);
            var vertBias = 0.5 * (simHeight - boxHeight);
            var middleRow = Math.floor((numRows + addedRows) / 2);
            var middleCol = Math.floor(numCols / 2);
            for (var j = 0; j < (numRows + addedRows); j++) {
                for (var i = 0; i < numCols; i++) {
                    if (smallBallRadius == 0) {
                        var radius = bigBallRadius;
                    } else {
                        var radius = smallBallRadius + Math.random() * (bigBallRadius - smallBallRadius);
                    }          
                    var mass = 2 * Math.PI * radius * radius; 
                    var vel = new Vector2((-0.5 + 1.0 * Math.random()) * brakes, (-0.5 + 1.0 * Math.random()) * brakes);
                    var boxedPosX = (i + 1) * (boxWidth / (numCols +1)) + (Math.random() * radius * ballJitter) + horizBias;
                    var boxedPosY = (j + 1) * (boxHeight / (numRows + 1)) + vertBias;
                    var pos = new Vector2(boxedPosX, boxedPosY);
                    var saturation = 0.5 + 0.5 * Math.random();
                    if (Math.random() * 100 < 5) {
                            var whiteBall = true;
                        } else {
                            var whiteBall = false;
                        }
                    var tracerBall = (j == middleRow && i == middleCol);
                    if (Balls.length < getNumBalls) {
                        Balls.push(new BALL(radius, mass, pos, vel, saturation, whiteBall, tracerBall, smallBallRadius, bigBallRadius));
                    }
                }
            }
        }
        //  ROUND CLUSTER
        if (cluster.checked == true) {
            for (var q = 0; q < getNumBalls; q++) {
                var clusterRadius = 0.2 * simWidth;
                var randomRadius = Math.random() * clusterRadius;
                var randomTheta = Math.random() * 2 * Math.PI;
                var circleXpos = 0.5 * simWidth + Math.cos(randomTheta) * randomRadius;
                var circleYpos = 0.5 * simHeight + Math.sin(randomTheta) * randomRadius;
                if (smallBallRadius == 0) {
                    var radius = bigBallRadius;
                    } else {
                    var radius = smallBallRadius + Math.random() * (bigBallRadius - smallBallRadius);
                }
                var mass = 2 * Math.PI * radius * radius; 
                var pos = new Vector2(circleXpos, circleYpos);   
                var vel = new Vector2(Math.cos(randomTheta) * brakes, Math.sin(randomTheta) * brakes);
                if (Math.random() * 100 < 5) {
                    var whiteBall = true;
                } else {
                    var whiteBall =false;
                }
                if (q == 0) {
                    var tracerBall = true;
                } else {
                    var tracerBall = false;
                }   
                var saturation = 0.5 + 0.5 * Math.random();

                Balls.push(new BALL(radius, mass, pos, vel, saturation, whiteBall, tracerBall, smallBallRadius, bigBallRadius));
            }   
        }
    }

    //  CORNER CONSTRUCTOR  ---------------------------------------------------------------------
    class CORNER {
		constructor(pos, corner) {
			this.pos = pos.clone();
            this.corner = corner;
            this.radius = 0.01 * cornerRad * 0.5 * simHeight;
            if (screenVertical == true) {
                this.radius = 0.01 * cornerRad * 0.5 * simWidth;
            } else {
                this.radius = 0.01 * cornerRad * 0.5 * simHeight;
            }
        }
        get left() {
            return this.pos.x - this.radius;
        }
        get right() {
            return this.pos.x + this.radius;
        }
        draw() {
            // Use canvas gradient that matches page background for seamless edges
            if (!cornerFillGradient) { updateCornerFillGradient(); }
            c.fillStyle = cornerFillGradient; 
            var budge = 0;
            if (this.corner == 'northwest') {
                c.beginPath();
                c.moveTo(0, 0);
                c.lineTo(this.radius * cScale, 0);
                c.arc((this.pos.x + this.radius - budge) * cScale, (this.pos.y + this.radius - budge) * cScale, this.radius * cScale, 1.5 * Math.PI, Math.PI, true);
                c.lineTo(0, this.radius * cScale);
                c.closePath();
                c.fill();
            }
            if (this.corner == 'southwest') {
                c.beginPath();
                c.moveTo(0, simHeight * cScale);
                c.lineTo(0, (simHeight - this.radius) * cScale);
                c.arc((this.pos.x + this.radius - budge) * cScale, (this.pos.y - this.radius + budge) * cScale, this.radius * cScale, Math.PI, 0.5 * Math.PI, true);
                c.lineTo(this.radius * cScale, simHeight * cScale);
                c.closePath();
                c.fill();
            }
            if (this.corner == 'southeast') {
                c.beginPath();
                c.moveTo(simWidth * cScale, simHeight * cScale);
                c.lineTo((simWidth - this.radius) * cScale, simHeight * cScale);
                c.arc((this.pos.x - this.radius + budge) * cScale, (this.pos.y - this.radius + budge) * cScale, this.radius * cScale, 0.5 * Math.PI, 0, true);
                c.lineTo(simWidth * cScale, (simHeight - this.radius) * cScale);
                c.closePath();
                c.fill();
            }   
            if (this.corner == 'northeast') {
                c.beginPath();
                c.moveTo(simWidth * cScale, 0);
                c.lineTo(simWidth * cScale, this.radius * cScale);
                c.arc((this.pos.x - this.radius + budge) * cScale, (this.pos.y + this.radius - budge) * cScale, this.radius * cScale, 0, 1.5 * Math.PI, true);
                c.lineTo((simWidth - this.radius) * cScale, 0);
                c.closePath();
                c.fill();
            }
            
            // Draw the arc outlines
            c.strokeStyle = 'hsl(0, 0%, 60%)';
            c.lineWidth = 0.007 * cScale;
            c.lineCap = 'butt';
            var budge = 0.0035;
            if (this.corner == 'northwest') {
                c.beginPath();
                c.arc((this.pos.x + this.radius + budge) * cScale, (this.pos.y + this.radius + budge) * cScale, this.radius * cScale, Math.PI, 1.5 * Math.PI, false);
            }
            if (this.corner == 'southwest') {
                c.beginPath();
                c.arc((this.pos.x + this.radius + budge) * cScale, (this.pos.y - this.radius - budge) * cScale, this.radius * cScale, 0.5 * Math.PI, 1.0 * Math.PI, false);
            }
            if (this.corner == 'southeast') {
                c.beginPath();
                c.arc((this.pos.x - this.radius - budge) * cScale, (this.pos.y - this.radius - budge) * cScale, this.radius * cScale, 2 * Math.PI, 0.5 * Math.PI, false);
            }   
            if (this.corner == 'northeast') {
                c.beginPath();
                c.arc((this.pos.x - this.radius - budge) * cScale, (this.pos.y + this.radius + budge) * cScale, this.radius * cScale, 1.5 * Math.PI, 2 * Math.PI, false);
            }
            c.stroke();
            c.lineWidth = 0.009 * cScale;
            // top edge (ceiling)
            if (doCeiling == true) {
                c.beginPath();
                // Connect to actual corner positions when corners exist
                var leftCorner = Corners.find(c => c.corner === 'northwest');
                var rightCorner = Corners.find(c => c.corner === 'northeast');
                var leftX = (doLeftWall && this.radius > 0) ? (leftCorner.pos.x + this.radius + budge) * cScale : budge * cScale;
                var rightX = (doRightWall && this.radius > 0) ? (rightCorner.pos.x - this.radius - budge) * cScale : (simWidth - budge) * cScale;
                c.moveTo(leftX, budge * cScale);
                c.lineTo(rightX, budge * cScale);
                c.closePath();
                c.stroke();
            }
            // bottom edge (floor)
            if (doFloor == true) {
                c.beginPath();
                // Connect to actual corner positions when corners exist
                var leftCorner = Corners.find(c => c.corner === 'southwest');
                var rightCorner = Corners.find(c => c.corner === 'southeast');
                var leftX = (doLeftWall && this.radius > 0) ? (leftCorner.pos.x + this.radius + budge) * cScale : budge * cScale;
                var rightX = (doRightWall && this.radius > 0) ? (rightCorner.pos.x - this.radius - budge) * cScale : (simWidth - budge) * cScale;
                c.moveTo(leftX, (simHeight - budge) * cScale);
                c.lineTo(rightX, (simHeight - budge) * cScale);
                c.closePath();
                c.stroke();
            }
            
            // When corners move inward, we normally skip side outlines in horizontal mode,
            // but if either ceiling or floor is disabled, keep drawing the side outlines.
            if (cornerRad >= 100 && screenVertical == false && doCeiling && doFloor) {  
                return;
            }
            // left edge
            budge = 0.0;
            c.lineWidth = 0.015 * cScale;
            if (doLeftWall == true) {
                c.beginPath();
                // When corner radius > 0, connect to corner arcs; when corner radius = 0 or adjacent wall disabled, extend to edge
                var topY = (!doCeiling && cornerRad > 100) ? 0 : ((doCeiling && this.radius > 0) ? (this.radius + budge) * cScale : budge * cScale);
                var bottomY = (!doFloor && cornerRad > 100) ? (simHeight * cScale) : ((doFloor && this.radius > 0) ? (simHeight - this.radius - budge) * cScale : (simHeight - budge) * cScale);
                var leftWallX;
                if (cornerRad > 100 && (!doCeiling || !doFloor)) {
                    var leftCorner = (Corners && Corners.find(c => c.corner === 'northwest')) || (Corners && Corners.find(c => c.corner === 'southwest'));
                    if (leftCorner && typeof leftCorner.pos?.x === 'number') {
                        // Align with the vertical boundary defined by the corner center X
                        leftWallX = (leftCorner.pos.x + budge) * cScale;
                    } else {
                        leftWallX = budge * cScale; // fallback
                    }
                } else {
                    leftWallX = budge * cScale;
                }
                c.moveTo(leftWallX, topY);
                c.lineTo(leftWallX, bottomY);
                c.closePath();
                c.stroke();

                // Fill outside area to the left when corridor is constricted and a horizontal boundary is open
                if (cornerRad > 100 && (!doCeiling || !doFloor)) {
                    var prevFill = c.fillStyle;
                    // Match corner fill gradient
                    if (!cornerFillGradient) { updateCornerFillGradient(); }
                    c.fillStyle = cornerFillGradient;
                    c.beginPath();
                    c.rect(0, topY, Math.max(0, leftWallX), Math.max(0, bottomY - topY));
                    c.fill();
                    c.fillStyle = prevFill;
                }
            }  
            // right edge
            if (doRightWall == true) {
                c.beginPath();
                // When corner radius > 0, connect to corner arcs; when corner radius = 0 or adjacent wall disabled, extend to edge
                var topY = (!doCeiling && cornerRad > 100) ? 0 : ((doCeiling && this.radius > 0) ? (this.radius + budge) * cScale : budge * cScale);
                var bottomY = (!doFloor && cornerRad > 100) ? (simHeight * cScale) : ((doFloor && this.radius > 0) ? (simHeight - this.radius - budge) * cScale : (simHeight - budge) * cScale);
                var rightWallX;
                if (cornerRad > 100 && (!doCeiling || !doFloor)) {
                    var rightCorner = (Corners && Corners.find(c => c.corner === 'northeast')) || (Corners && Corners.find(c => c.corner === 'southeast'));
                    if (rightCorner && typeof rightCorner.pos?.x === 'number') {
                        // Align with the vertical boundary defined by the corner center X
                        rightWallX = (rightCorner.pos.x) * cScale;
                    } else {
                        rightWallX = (simWidth - budge) * cScale; // fallback
                    }
                } else {
                    rightWallX = (simWidth - budge) * cScale;
                }
                c.moveTo(rightWallX, topY);
                c.lineTo(rightWallX, bottomY);
                c.closePath();
                c.stroke();

                // Fill outside area to the right when corridor is constricted and a horizontal boundary is open
                if (cornerRad > 100 && (!doCeiling || !doFloor)) {
                    var prevFill2 = c.fillStyle;
                    // Match corner fill gradient
                    if (!cornerFillGradient) { updateCornerFillGradient(); }
                    c.fillStyle = cornerFillGradient;
                    c.beginPath();
                    var rx = Math.min(rightWallX, simWidth * cScale);
                    c.rect(rx, topY, Math.max(0, simWidth * cScale - rx), Math.max(0, bottomY - topY));
                    c.fill();
                    c.fillStyle = prevFill2;
                }
            }
        }
    }

    class WORM {
        constructor(masses, lengths, angles, radii) {
            this.masses = [0.0];
            this.lengths = [0.0];
            this.radii = [0.0];
            this.pos = [{x:0.0, y:0.0}];
            this.prevPos = [{x:0.0, y:0.0}];
            this.vel = [{x:0.0, y:0.0}];
            this.theta = [0.0];
            this.omega = [0.0];
            this.waver = 0.0;

            var x = 0.0, y = 0.0;
            for (var i = 0; i < masses.length; i++) {
                var mi = masses[i];
                var li = lengths[i];
                var ai = angles[i];
                var ri = radii[i];
                this.masses.push(mi);
                this.lengths.push(li);
                this.radii.push(ri);
                this.theta.push(ai);
                this.omega.push(0.0);

                x = 0;
                y += li * Math.cos(ai);
                this.pos.push({ x:x, y:y});
                this.prevPos.push({ x:x, y:y});
                this.vel.push({x:0, y:0});
            }
        }
        simulate(dt) {
            var p = this;
            for (var i = 1; i < p.masses.length; i++) {
                p.prevPos[i].x = p.pos[i].x;
                p.prevPos[i].y = p.pos[i].y;
                p.pos[i].x += p.vel[i].x * dt;
                p.pos[i].y += p.vel[i].y * dt;
            }
            for (var i = 1; i < p.masses.length; i++) {
                var dx = p.pos[i].x - p.pos[i-1].x;
                var dy = p.pos[i].y - p.pos[i-1].y;
                var d = Math.sqrt(dx * dx + dy * dy);
                if (d > 1e-9) {
                    var w0 = p.masses[i - 1] > 0.0 ? 1.0 / p.masses[i - 1] : 0.0;
                    var w1 = p.masses[i] > 0.0 ? 1.0 / p.masses[i] : 0.0;
                    var corr = (p.lengths[i] - d) / d / (w0 + w1);
                    p.pos[i - 1].x -= w0 * corr * dx; 
                    p.pos[i - 1].y -= w0 * corr * dy; 
                    p.pos[i].x += w1 * corr * dx; 
                    p.pos[i].y += w1 * corr * dy; 
                }
            }
                // --- Joint angle limits: iterate interior joints and prevent acute folding
                for (var i = 1; i < p.pos.length - 1; i++) {
                    var A = p.pos[i-1];
                    var B = p.pos[i];
                    var C = p.pos[i+1];
                    // vectors from joint B
                    var vBAx = A.x - B.x, vBAy = A.y - B.y;
                    var vBCx = C.x - B.x, vBCy = C.y - B.y;
                    var lenBA = Math.sqrt(vBAx*vBAx + vBAy*vBAy);
                    var lenBC = Math.sqrt(vBCx*vBCx + vBCy*vBCy);
                    if (lenBA < 1e-9 || lenBC < 1e-9) continue;
                    // compute angle between vBA and vBC (0..PI)
                    var dot = (vBAx * vBCx + vBAy * vBCy) / (lenBA * lenBC);
                    dot = Math.max(-1, Math.min(1, dot));
                    var angle = Math.acos(dot);
                    if (angle < MIN_JOINT_ANGLE) {
                        // need to increase angle to MIN_JOINT_ANGLE by rotating vBC around B
                        var targetAngle = MIN_JOINT_ANGLE;
                        var delta = targetAngle - angle; // positive
                        // determine rotation direction using cross product (z-component)
                        var cross = vBAx * vBCy - vBAy * vBCx;
                        var sign = (cross >= 0) ? 1 : -1;
                        // compute current angle of vBC
                        var cur = Math.atan2(vBCy, vBCx);
                        // rotate by sign * delta
                        var newAngle = cur + sign * delta;
                        // place C at new location preserving segment length lenBC (should be p.lengths[i+1])
                        var newCx = B.x + Math.cos(newAngle) * lenBC;
                        var newCy = B.y + Math.sin(newAngle) * lenBC;
                        // apply small smoothing: lerp between old and new to avoid jitter
                        var smooth = 0.9; // keep most of the correction
                        p.pos[i+1].x = newCx * smooth + C.x * (1 - smooth);
                        p.pos[i+1].y = newCy * smooth + C.y * (1 - smooth);
                        // update prevPos to avoid large velocity spikes
                        p.prevPos[i+1].x = p.pos[i+1].x - (p.pos[i+1].x - p.prevPos[i+1].x) * 0.5;
                        p.prevPos[i+1].y = p.pos[i+1].y - (p.pos[i+1].y - p.prevPos[i+1].y) * 0.5;
                    }
                }
            for (var i = 1; i < p.masses.length; i++) {
                p.vel[i].x = 0.99 * (p.pos[i].x - p.prevPos[i].x) / dt;
                p.vel[i].y = 0.99 * (p.pos[i].y - p.prevPos[i].y) / dt;

            }
        }
        draw() {
            var p = this;
            
            //  SPINE  ----------
            /*c.strokeStyle = "green";
            c.lineWidth = 10;
            // draw the polyline starting at the visible head (pos[1]) so the
            // invisible pivot (pos[0]) doesn't create an extra leading link
            if (p.pos.length > 1) {
                c.beginPath();
                c.moveTo(cX(p.pos[1]), cY(p.pos[1]));
                for (var i = 2; i < p.pos.length; i++)
                    c.lineTo(cX(p.pos[i]), cY(p.pos[i]));
                c.stroke();
            }*/

            //  CIRCLES  ----------
            for (var i = 1; i < p.pos.length; i++) {
                var ri = (i < p.radii.length && typeof p.radii[i] === 'number') ? p.radii[i] : 0.02;
                var r = ri;
                c.beginPath();
                c.arc(
                    cX(p.pos[i]), cY(p.pos[i]), cScale * r, 0.0, 2 * Math.PI);
                c.closePath();
                var sphereGradient = c.createRadialGradient(
                        (cX(p.pos[i]) - (0.2 * r * cScale)), 
                        (cY(p.pos[i]) - (0.4 * r * cScale)), 
                        0, 
                        (cX(p.pos[i]) - (0.2 * r * cScale)), 
                        (cY(p.pos[i]) - (0.4 * r * cScale)), 
                        1.2 * r * cScale
                    );
                var highlight = 'hsl(30, 80%, 80%)';
                var midtone = 'hsl(30, 80%, 60%)';
                var shadow = 'hsl(30, 80%, 10%)';
                sphereGradient.addColorStop(0.0, highlight);
                sphereGradient.addColorStop(0.15, midtone);
                sphereGradient.addColorStop(1.0, shadow);
                c.fillStyle = sphereGradient;
                c.fill();
                c.lineWidth = .02 * cScale;  
                c.strokeStyle = "blue";       
                c.fillStyle = "darkblue";
                //c.fill();
                //c.stroke();
            }
            // pivot (pos[0]) is intentionally not drawn so the first visible
            // circle (pos[1]) is the head of the chain.
        }
    }

    function simulateWorm() {
        var sdt = WormProps.dt / WormProps.wormSubSteps;

        for (var step = 0; step < WormProps.wormSubSteps; step++) {
            WormProps.SpaceWorm.simulate(sdt, WormProps.gravity);
        }

        // Wiggle trigger: when head vertical velocity crosses zero (top/bottom of stroke)
        var p = WormProps.SpaceWorm;
        if (!WormProps.wiggleActive && p && p.vel && p.vel.length > 1) {
            var headVY = p.vel[1].y;
            // detect zero crossing (sign change) with a small threshold to avoid noise
            if (Math.abs(headVY) < WIGGLE_VY_ZERO_THRESHOLD && Math.abs(WormProps.prevHeadVY) >= WIGGLE_VY_ZERO_THRESHOLD) {
                // alternate wiggle direction each cycle for visual variation
                WormProps.wiggleToggle *= -1;
                var dir = WormProps.wiggleToggle; // -1 or +1
                WormProps.wiggleDir = dir;
                // vertical per-frame impulse in sim units
                var totalSimY = (WIGGLE_DISTANCE_PIXELS / cScale) * dir;
                WormProps.wigglePerFrameVel = (totalSimY / (WIGGLE_FRAMES * WormProps.dt));
                // horizontal propulsion per-frame (sim units)
                var totalSimX = (WIGGLE_X_PIXELS / cScale) * dir;
                WormProps.wigglePerFrameVelX = (totalSimX / (WIGGLE_FRAMES * WormProps.dt));
                // small pivot advance per frame to push the worm forward during wiggle
                var totalAdvanceSim = (WIGGLE_X_PIXELS * 0.5 / cScale) * dir; // proportional to X pixels
                WormProps.wiggleAdvancePerFrame = totalAdvanceSim / WIGGLE_FRAMES;
                WormProps.wiggleActive = true;
                WormProps.wiggleFrame = 0;
            }
            WormProps.prevHeadVY = headVY;
        }
        if (WormProps.wiggleActive) {
            var p = WormProps.SpaceWorm;
            if (p && p.pos.length > 1) {
                // apply per-frame vertical impulse to head (pos[1])
                p.pos[1].y += WormProps.wigglePerFrameVel * WormProps.dt;
                // apply small horizontal impulse to head
                p.pos[1].x += WormProps.wigglePerFrameVelX * WormProps.dt;
                // nudge prevPos to create a velocity impulse for the solver
                p.prevPos[1].y = p.pos[1].y - WormProps.wigglePerFrameVel * WormProps.dt * 0.5;
                p.prevPos[1].x = p.pos[1].x - WormProps.wigglePerFrameVelX * WormProps.dt * 0.5;
                // also advance the pivot a little to visualize propulsion
                p.pos[0].x += WormProps.wiggleAdvancePerFrame;
                p.prevPos[0].x += WormProps.wiggleAdvancePerFrame * 0.5;
            }
            WormProps.wiggleFrame++;
            if (WormProps.wiggleFrame >= WIGGLE_FRAMES) {
                WormProps.wiggleActive = false;
                WormProps.wiggleAdvancePerFrame = 0.0;
            }
        }

        // Run movement/wrap logic once per frame (per dT) instead of every substep.
        if (WormProps.SpaceWorm && !WormProps.isHiding) {
            var p = WormProps.SpaceWorm;
            // regular horizontal advance of the pivot (scaled to dT)
            // apply once per full time-step
            p.pos[0].x += ADVANCE_SPEED;
            // traveling-wave body undulation (fish-like propulsion)
            // advance the global wave phase
            WormProps.phase += WAVE_PHASE_INCREMENT;
            // compute amplitude in sim units
            var ampPixels = canvas.height * WAVE_AMPLITUDE_RATIO;
            var ampSim = ampPixels / cScale;
            // For each node, compute a target lateral position from a traveling sinusoid
            for (var i = 1; i < p.pos.length; i++) {
                // spatial phase lag increases toward the tail
                var nodePhase = WormProps.phase - (i * WAVE_NODE_LAG);
                var targetY = SPAWN_INITIAL_Y_SIM + ampSim * Math.sin(nodePhase);
                // nudge current node toward the target wave position (smooth steering)
                var deltaY = (targetY - p.pos[i].y) * WAVE_NUDGE;
                p.pos[i].y += deltaY;
                // update prevPos slightly so the solver sees an effective lateral velocity impulse
                p.prevPos[i].y += deltaY * 0.5;
                // compute lateral velocity (sim units / dt)
                var lateralV = (p.pos[i].y - p.prevPos[i].y) / WormProps.dt;
                // convert a portion of lateral motion into forward thrust
                // larger nodes (near the head) produce slightly less per-node thrust
                var sizeFactor = (i < p.radii.length ? p.radii[i] : 0.02);
                var thrust = -Math.sign(lateralV) * Math.abs(lateralV) * THRUST_COEFF * (sizeFactor * 50);
                // apply small forward displacement to simulate reaction against fluid
                p.pos[i].x += thrust;
                p.prevPos[i].x += thrust * 0.5;
            }
            // keep pivot vertically anchored to the spawn baseline so the whole body follows
            p.pos[0].y = SPAWN_INITIAL_Y_SIM + ampSim * Math.sin(WormProps.phase - (0 * WAVE_NODE_LAG));
        }
        
        // Handle worm wrap-around and delay logic
        if (WormProps.SpaceWorm) {
            var p = WormProps.SpaceWorm;

            // If the entire chain has passed the right edge, start hiding delay
            // or check if delay has elapsed to reappear on left side
            var minX = Infinity, maxX = -Infinity;
            for (var i = 0; i < p.pos.length; i++) {
                if (p.pos[i].x < minX) minX = p.pos[i].x;
                if (p.pos[i].x > maxX) maxX = p.pos[i].x;
            }
            var canvasRightSim = canvas.width / cScale;
            // Check when the last circle (tail) has fully passed the right edge.
            // Compute the left edge of the last circle (center.x - radius) in sim units
            var lastIdx = p.pos.length - 1;
            var lastRadius = (lastIdx < p.radii.length) ? p.radii[lastIdx] : 0.02;
            var lastLeftEdge = p.pos[lastIdx].x - lastRadius;
            
            if (lastLeftEdge > canvasRightSim && !WormProps.isHiding) {
                // Worm has completely passed right edge - start hiding period
                WormProps.isHiding = true;
                WormProps.hideStartTime = Date.now();
            } else if (WormProps.isHiding) {
                // Check if hiding delay has elapsed
                var currentTime = Date.now();
                if (currentTime - WormProps.hideStartTime >= WormProps.hideDelay) {
                    // Delay has elapsed - use original repositioning logic
                    WormProps.isHiding = false;
                    // spawnGap in sim units: pick either a pixel-based min or a fraction of canvas width
                    var spawnGapSim = Math.max(SPAWN_GAP_MIN_PIXELS / cScale, SPAWN_GAP_WIDTH_FACTOR * canvas.width / cScale, SPAWN_GAP_MIN_SIM);
                    var shiftSim = - (maxX + spawnGapSim);
                    for (var i = 0; i < p.pos.length; i++) {
                        p.pos[i].x += shiftSim;
                        p.prevPos[i].x += shiftSim; // keep prevPos in sync to avoid velocity spikes
                    }
                }
                // If still hiding, don't move the worm at all
            }
        }
    }

    //  MAKE WORM  ---------------------------------
    function makeWorm() {
        //  WORM CONSTANTS -----------
        steps = 100;
        // Tunable constants (edit these to change motion/spawn behavior)
        ADVANCE_SPEED = 0.01;                 // sim units per frame (horizontal advance)
        // Fish-style traveling wave (body undulation) parameters
        WAVE_AMPLITUDE_RATIO = 0.07;         // body wave amplitude as fraction of canvas height
        WAVE_PHASE_INCREMENT = 0.1;          // how fast the wave travels along the body (temporal frequency)
        WAVE_NODE_LAG = 0.7;                  // phase lag per node (spatial wave number)
        WAVE_NUDGE = 0.65;                    // how strongly nodes are nudged toward the target wave each frame (0..1)
        THRUST_COEFF = 0.0018;                // how much lateral motion converts to forward thrust (tweakable)
        // Joint angle limiting prevents the chain folding inward on itself.
        // Joint angle is measured between vectors (pos[i-1]-pos[i]) and (pos[i+1]-pos[i]).
        // A straight chain has angle ~= PI; we require angle >= MIN_JOINT_ANGLE.
        MIN_JOINT_ANGLE = Math.PI * 0.6;      // minimum allowed interior joint angle (radians). Lower -> more flexible.
        SPAWN_GAP_MIN_SIM = 0.1;               // min spawn gap in sim units used at setup
        SPAWN_GAP_MIN_PIXELS = 50;             // min spawn gap in pixels used at wrap-time
        SPAWN_GAP_WIDTH_FACTOR = 0.1;          // alternative spawn gap as fraction of canvas width (in sim units)
        // Wiggle tuning: quick impulse parameters. Wiggle will be triggered
        // when the head vertical velocity crosses zero (top/bottom of stroke).
        WIGGLE_FRAMES = 6;                     // frames over which the wiggle is applied
        WIGGLE_DISTANCE_PIXELS = 24;           // total vertical travel during wiggle (pixels)
        WIGGLE_X_PIXELS = 0;                   // total horizontal propulsion applied during wiggle (pixels)
        WIGGLE_VY_ZERO_THRESHOLD = 0.005;     // threshold to treat vy as zero
        // Initial spawn position in simulation units. These must be numeric values
        // (no fallback to computed defaults). Edit these to choose the pivot start.
        SPAWN_INITIAL_X_SIM = 0; // e.g. -2.0 puts pivot 2 sim units left of x=0
        SPAWN_INITIAL_Y_SIM = 0.5 * simHeight; // explicit vertical spawn position
        //leadRradius = 0.15;
        //minRradius = 0.05;
        //numNodes = 20;
        leadRradius = WormProps.startRadius;
        minRradius = WormProps.endRadius;
        numNodes = WormProps.numNodes;

        var angles = [];
        var lengths = [];
        var masses = [];
        var radii = [];
        if (numNodes == 1) {
            radii.push(leadRradius);
        } else {
            // progression from leadRradius to minRradius
            var ratio = Math.pow(minRradius / leadRradius, 1.0 / (numNodes - 1));
            for (var i = 0; i < numNodes; i++)
                radii.push(leadRradius * Math.pow(ratio, i));
        }
        //  Lengths are chosen so neighboring circles touch (center distance = r_prev + r_curr).
        //  lengths: distance from pivot to first node, then between nodes so circles touch
        lengths = [];
        var pivotRadius = leadRradius; // make pivot radius match lead so the first length fits
        for (var i = 0; i < numNodes; i++) {
            if (i == 0)
                lengths.push(1.03 * (pivotRadius + radii[0])); // extra space from pivot to head
            else
                lengths.push(1.03 * (radii[i - 1] + radii[i]));
        }
        //  set mass
        var massScale = 10000000;
        for (var i = 0; i < radii.length; i++) {
            masses.push(Math.max(0.0001, radii[i] * radii[i] * massScale));
        }

        WormProps.SpaceWorm = new WORM(masses, lengths, angles, radii);
        
        // Initialize worm delay state
        WormProps.isHiding = false;
        WormProps.hideStartTime = 0;
        
        // spawn the  chain
        (function(){
            var p = WormProps.SpaceWorm;
            if (!p) return;
            // compute total span from pivot to last node in sim units
            var totalSpan = 0.0;
            for (var i = 1; i < p.lengths.length; i++) {
                totalSpan += p.lengths[i];
            }
            // spawnGapSim: how far left of x=0 the rightmost node should be
            var spawnGapSim = Math.max(
                SPAWN_GAP_MIN_SIM, 
                SPAWN_GAP_WIDTH_FACTOR * canvas.width / cScale, 
                SPAWN_GAP_MIN_PIXELS / cScale
            );
            // startX is where the pivot (pos[0]) will be placed â€” use the
            // explicit SPAWN_INITIAL_X_SIM constant (no fallback).
            p.pos[0].x = SPAWN_INITIAL_X_SIM;
            // use explicit SPAWN_INITIAL_Y_SIM for vertical placement
            p.pos[0].y = SPAWN_INITIAL_Y_SIM;
            p.prevPos[0].x = p.pos[0].x;
            p.prevPos[0].y = p.pos[0].y;
            for (var i = 1; i < p.pos.length; i++) {
                // place each subsequent node to the LEFT of the previous one
                p.pos[i].x = p.pos[i-1].x - p.lengths[i];
                p.pos[i].y = SPAWN_INITIAL_Y_SIM;
                p.prevPos[i].x = p.pos[i].x;
                p.prevPos[i].y = p.pos[i].y;
            }
        })();
    }

    //  DEFINE CORNERS  ---------------------------------------------------------------------
    function makeCorners() {
        Corners = [];
        Corners.push(new CORNER(new Vector2(0, 0), 'northwest'));
        Corners.push(new CORNER(new Vector2(simWidth, 0), 'northeast'));
        Corners.push(new CORNER(new Vector2(0, simHeight), 'southwest'));
        Corners.push(new CORNER(new Vector2(simWidth, simHeight), 'southeast'));
    }

    //  DEFINE BUMPERS --------------------------------------------------------------
    function makeBumpers() {
        Bumpers = [];
        bumperRows = rowsInput.value;
        bumperRadius = bumperRadiusInput.value / 1000;
        gapMultiplier = 1.1;
        smallBumperRatio = 0.75;
        vertBumperPadding = 0.30;
        var smallBallRadius = smallBallInput.value / 1000;
        var bigBallRadius = bigBallInput.value / 1000;
        var maxBallRadius = Math.max(smallBallRadius, bigBallRadius);
        bumperSpacing = (2 * maxBallRadius) * gapMultiplier;
        combinedSpacing = (2 * bumperRadius) + bumperSpacing;
        verticalBPD = vertBumperPadding * combinedSpacing;
        combinedVerticalSpacing = (2 * bumperRadius) + bumperSpacing + verticalBPD;
        paddingCorrectionShift = -0.5 * ((bumperRows - 1) * verticalBPD);
        if (Math.trunc(simWidth / combinedSpacing) % 2 == 0) {
            bumperCols = Math.trunc(simWidth / combinedSpacing); 
        } else {
            bumperCols = Math.trunc(simWidth / combinedSpacing) + 1; 
        }
        bumperBarLengthX = ((bumperCols - 1.0) * bumperSpacing) + ((2.0 * (bumperCols -1.0)) * bumperRadius);
        bumperBarLengthY = ((bumperRows - 1.0) * bumperSpacing) + ((2.0 * (bumperRows -1.0)) * bumperRadius);
        centeringOffsetX = (simWidth / 2.0) - (bumperBarLengthX / 2.0);
        centeringOffsetY = (simHeight / 2.0) - (bumperBarLengthY / 2.0) + (-0.3 * simHeight + paddingCorrectionShift);
        bottomMargin = ((simHeight - bumperBarLengthY) / 2) + 2 * bumperRadius;
        topMargin = ((simHeight - bumperBarLengthY) / 2) + bumperBarLengthY + 2 * bumperRadius; 
        centeringOffsetY - combinedVerticalSpacing/2
        numBumpers = 0;
        for (p = -1; p < bumperCols; p++) {
            for (q = 0; q < bumperRows; q++) {
                if (q % 2 == 0) {
                    Bumpers.push(new BUMPER(bumperRadius, new Vector2((p * combinedSpacing) + (combinedSpacing / 2.0) + centeringOffsetX, (q * combinedVerticalSpacing) + centeringOffsetY)));        
                    numBumpers += 1;
                } else if (p > -1) {
                    Bumpers.push(new BUMPER(bumperRadius * smallBumperRatio, new Vector2((p * combinedSpacing) + centeringOffsetX, (q * combinedVerticalSpacing) + centeringOffsetY)));    
                    numBumpers += 1;
                }
            }
        }
    }

    //  BUMPER CONSTRUCTOR  ---------------------------------------------------------------------
	class BUMPER {
		constructor(radius, pos) {
			this.radius = radius;
			this.pos = pos.clone();
            this.OGpos = pos.clone();
		}
        get left() {
            return this.pos.x - this.radius;
        }
        get right() {
            return this.pos.x + this.radius;
        }
        draw() {
            drawCircle(cX(this.pos), cY(this.pos), this.radius * cScale);
            c.fillStyle = `hsl(0, 0%, 70%)`;
            c.fill();
            drawCircle(cX(this.pos), cY(this.pos), (this.radius - .002 * simWidth) * cScale);
            c.fillStyle = `hsl(0, 0%, 30%)`;
            c.fill();
        }
	}

    //  PUCK CONSTRUCTOR -----------------------------------------------------------------------
    class PUCK {
		constructor(radius, pos, color) {
			this.radius = radius;
            this.OGradius = radius;
			this.pos = pos.clone();
            this.vel = new Vector2(0, 0);
            this.prevPos = pos.clone();
            this.color = color;
            this.mass = 0.001 * radius;
            this.puckFadingIn = false;
            this.moving = false;
            this.puckArriving = false;
		}
        simulate() {
            for (var r = 0; r < this.OGradius; r++) {
                if (this.radius >= this.OGradius) {
                    this.radius = this.OGradius;
                    this.puckArriving = false;
                } else {
                    this.radius += this.OGradius * 0.0001;
                }
            }
        }
        draw() {
            if (this.puckFadingIn == true) {
                var fadeInTimer = 400; 
                var timeSinceMouseUp = Date.now() - mouseUpTime;
                var alphaPercent = timeSinceMouseUp / fadeInTimer;
                if (timeSinceMouseUp >= fadeInTimer) {
                    this.puckFadingIn = false;
                }
            } else {
                var alphaPercent = 1;
            }
            if (this.moving == false) {
                drawCircle(cX(this.pos), cY(this.pos), 0.985 * this.radius * cScale);
                const grd = c.createRadialGradient(
                    cX(this.pos), 
                    cY(this.pos), 
                    0, 
                    cX(this.pos), 
                    cY(this.pos), 
                    1.3 *this.radius * cScale);
                grd.addColorStop(1, `hsla(220, 70%, 30%, ${alphaPercent * 0.4})`);
                grd.addColorStop(0.5, `hsla(220, 60%, 5%, ${alphaPercent * 0.4})`);
                c.fillStyle = grd;
                c.fill();

                c.strokeStyle = `hsla(0, 0%, 60%, ${alphaPercent})`;
                c.lineWidth = 4;
                c.stroke();
            } else {
                drawCircle(cX(this.pos), cY(this.pos), this.radius * cScale);
                const grd = c.createRadialGradient(
                    cX(this.pos), 
                    cY(this.pos), 
                    0, 
                    cX(this.pos), 
                    cY(this.pos), 
                    1.0 *this.radius * cScale);
                grd.addColorStop(0, `hsla(220, 70%, 15%, ${alphaPercent * 0.2})`);
                grd.addColorStop(1.0, `hsla(220, 70%, 8%, ${alphaPercent * 0.2})`);
                c.fillStyle = grd;
                c.fill();
            }
        }
        get left() {
            return this.pos.x - this.radius;
        }
        get right() {
            return this.pos.x + this.radius;
        }
	}
    
    //  HUNGRY PUCK CONSTRUCTOR ----------------------------------------------------------------
    class HUNGRYPUCK {
		constructor(radius, pos, vel, color) {
			this.radius = radius;
			this.pos = pos.clone();
            this.vel = vel.clone();
            this.color = color;
		}
        get left() {
            return this.pos.x - this.radius;
        }
        get right() {
            return this.pos.x + this.radius;
        }
        draw1() {
            // body
            const grd = c.createRadialGradient(cX(this.pos), cY(this.pos), 1.2 * this.radius * cScale, 
            cX(this.pos), cY(this.pos), 1.6 * this.radius * cScale);
            grd.addColorStop(0.0, `hsla(0, 0%, 0%, 100%)`);
            grd.addColorStop(1.0, `hsla(0, 0%, 0%, 0%)`);
            c.fillStyle = grd;
            drawCircle(cX(this.pos), cY(this.pos), 1.6 * this.radius * cScale);
            c.fill();
            // eyes
            c.strokeStyle = "hsl(120, 50%, 50%)";
            c.lineWidth = 0.04 * this.radius * cScale;
            c.beginPath();
            c.moveTo(cX(this.pos) + 0.2 * this.radius * cScale, cY(this.pos) - 0.2 * this.radius * cScale);
            c.lineTo(cX(this.pos) + 0.5 * this.radius * cScale, cY(this.pos) - 0.3 * this.radius * cScale);
            c.stroke();
            c.beginPath();
            c.moveTo(cX(this.pos) - 0.2 * this.radius * cScale, cY(this.pos) - 0.2 * this.radius * cScale);
            c.lineTo(cX(this.pos) - 0.5 * this.radius * cScale, cY(this.pos) - 0.3 * this.radius * cScale);
            c.stroke();
            // mouth
            c.strokeStyle = "hsl(90, 40%, 20%)";
            c.lineWidth = 0.06 * this.radius * cScale;
            c.beginPath();
            c.arc(cX(this.pos), cY(this.pos), 0.9 * this.radius * cScale, 0, Math.PI) 
            c.stroke();
            // dimples
            c.fillStyle = "hsl(90, 40%, 30%)";
            drawCircle(cX(this.pos) + 0.9 * this.radius * cScale, cY(this.pos), 0.07 * this.radius * cScale);
            c.fill();
            drawCircle(cX(this.pos) - 0.9 * this.radius * cScale, cY(this.pos), 0.07 * this.radius * cScale);
            c.fill();   
        }
        draw2() {
            // body
            const grd = c.createRadialGradient(cX(this.pos), cY(this.pos), 1.2 * this.radius * cScale, 
            cX(this.pos), cY(this.pos), 1.6 * this.radius * cScale);
            grd.addColorStop(0.0, `hsla(0, 0%, 0%, 100%)`);
            grd.addColorStop(1.0, `hsla(0, 0%, 0%, 0%)`);
            c.fillStyle = grd;
            drawCircle(cX(this.pos), cY(this.pos), 1.6 * this.radius * cScale);
            c.fill();
            // eyes
            c.strokeStyle = "hsl(335, 70%, 60%)";
            c.lineWidth = 0.04 * this.radius * cScale;
            c.beginPath();
            c.moveTo(cX(this.pos) + 0.25 * this.radius * cScale, cY(this.pos) - 0.2 * this.radius * cScale);
            c.lineTo(cX(this.pos) + 0.55 * this.radius * cScale, cY(this.pos) - 0.25 * this.radius * cScale);
            c.stroke();
            c.beginPath();
            c.moveTo(cX(this.pos) - 0.25 * this.radius * cScale, cY(this.pos) - 0.2 * this.radius * cScale);
            c.lineTo(cX(this.pos) - 0.55 * this.radius * cScale, cY(this.pos) - 0.25 * this.radius * cScale);
            c.stroke();
            // mouth
            c.strokeStyle = "hsl(335, 50%, 45%)";
            c.lineWidth = 0.05 * this.radius * cScale;
            c.beginPath();
            c.arc(cX(this.pos), cY(this.pos) + 0.4 * this.radius * cScale, 0.2 * this.radius * cScale, Math.PI, 0);
            c.stroke();
            // cheeks
            c.fillStyle = "hsl(335, 40%, 20%)";
            drawCircle(cX(this.pos) + 0.8 * this.radius * cScale, cY(this.pos) + 0.2 * this.radius * cScale, 0.2 * this.radius * cScale);
            c.fill();
            drawCircle(cX(this.pos) - 0.8 * this.radius * cScale, cY(this.pos) + 0.2 * this.radius * cScale, 0.2 * this.radius * cScale);
            c.fill();
        }
	}

    //  MR. MISTER CONSTRUCTOR ----------------------------------------------------------------
    class MISTERMISTER {
		constructor(pos, vel, color) {
			this.pos = pos.clone();
            this.vel = vel.clone();
            this.color = color;
            this.radius = 0.15;
            this.respawnDir = 0;
		}
        get left() {
            return this.pos.x - this.radius;
        }
        get right() {
            return this.pos.x + this.radius;
        }
        simulate() {
            if (mrMode == 'billiard') {
                this.pos.add(this.vel, physProps.dt)
            }
            if (mrMode == "typewriter") {
                if (goLeft == false) {
                    this.pos.x += this.vel.x * physProps.dt * misterSpeed;
                        if (this.pos.x > simWidth) {
                            goLeft = true;
                        }
                }
                if (goLeft == true) {
                    this.pos.x -= this.vel.x * 5 * physProps.dt * misterSpeed;
                        if (this.pos.x < 0) {
                            goLeft = false;
                        };
                }
            }
            if (mrMode == "printer") {
                if (goLeft == false) {
                    this.pos.x += this.vel.x * physProps.dt * misterSpeed;
                        if (this.pos.x > simWidth) {
                            goLeft = true;
                        }
                }
                if (goLeft == true) {
                    this.pos.x -= this.vel.x * physProps.dt * misterSpeed;
                        if (this.pos.x < 0) {
                            goLeft = false;
                        };
                }
            }
            if (mrMode == "scanner") {
                if (this.pos.x < 1.5 * this.radius + simWidth) {
                    this.pos.x += this.vel.x * physProps.dt * misterSpeed;
                }
                if (this.pos.x > 1.5 * this.radius + simWidth) {
                    this.pos.x = -1.5 * this.radius;
                }
            }
            if (mrMode == "circle") {
                delta += physProps.dt * misterSpeed;
                this.pos.x = 0.5 * simWidth + 0.2 * simWidth * Math.cos(delta);
                this.pos.y = 0.5 * simHeight + 0.2 * simWidth * Math.sin(delta);
            }
            if (mrMode == "oval") {
                delta += physProps.dt * misterSpeed;
                this.pos.x = 0.5 * simWidth + 0.3 * simWidth * Math.cos(delta);
                this.pos.y = 0.5 * simHeight + 0.3 * simHeight * Math.sin(delta);
            }
            if (mrMode == "bernoulli") {
                delta += physProps.dt * misterSpeed;
                var pathScale = 2 / (3 - Math.cos(2 * delta));
                this.pos.x = (0.5 * simWidth) + (0.4 * simWidth) * pathScale * Math.cos(delta);
                this.pos.y = (0.5 * simHeight) + (0.3 * simWidth) * pathScale * Math.sin(2 * delta) / 2;
            }
            if (mrMode == "worm") {
                if (WormProps.SpaceWorm && WormProps.SpaceWorm.pos.length > 1) {
                    this.pos.x = WormProps.SpaceWorm.pos[1].x;
                    this.pos.y = WormProps.SpaceWorm.pos[1].y;
                } else {
                    this.pos.x = 0.5 * simWidth;
                    this.pos.y = 0.5 * simHeight;
                }
            }
        }
        draw() {
            mrMrTimer += .05;
            var eyeLight = 30 + 70 * Math.abs(Math.sin(mrMrTimer));
            // body
            if (mrMode != 'worm') {
                const grd = c.createRadialGradient(cX(this.pos), cY(this.pos), 1.2 * 0.15 * cScale, 
                cX(this.pos), cY(this.pos), 1.6 * 0.15 * cScale);
                grd.addColorStop(0.0, `hsla(0, 0%, 0%, 100%)`);
                grd.addColorStop(1.0, `hsla(0, 0%, 0%, 0%)`);
                c.fillStyle = grd;
                c.strokeStyle = `hsl(200, 80%, ${eyeLight}%)`;
                drawCircle(cX(this.pos), cY(this.pos), 1.6 * 0.15 * cScale);
            } else {
                var sphereGradient = c.createRadialGradient(
                (cX(this.pos) - (this.radius * cScale)), 
                (cY(this.pos) - (0.4 * this.radius * cScale)), 
                0, 
                (cX(this.pos) - (0.2 * this.radius * cScale)), 
                (cY(this.pos) - (0.4 * this.radius * cScale)), 
                this.radius * cScale
                );
                var highlight = 'hsl(30, 80%, 80%)';
                var midtone = 'hsl(30, 80%, 60%)';
                var shadow = 'hsl(30, 80%, 10%)';
                sphereGradient.addColorStop(0.0, highlight);
                sphereGradient.addColorStop(0.15, midtone);
                sphereGradient.addColorStop(1.0, shadow);
                c.fillStyle = sphereGradient;
                c.strokeStyle = `hsl(200, 80%, ${eyeLight -40}%)`;
                drawCircle(cX(this.pos), cY(this.pos), 1.0 * 0.15 * cScale);
            }
            c.fill();
            // eyes  ----------
            c.lineWidth = 0.05 * 0.2 * cScale;
            c.beginPath();
            c.moveTo(cX(this.pos) + 0.35 * 0.15 * cScale, cY(this.pos) - 0.1 * 0.15 * cScale);
            c.lineTo(cX(this.pos) + 0.7 * 0.15 * cScale, cY(this.pos) - 0.1 * 0.15 * cScale);
            c.stroke();
            c.beginPath();
            c.moveTo(cX(this.pos) - 0.3 * 0.15 * cScale, cY(this.pos) - 0.1 * 0.15 * cScale);
            c.lineTo(cX(this.pos) - 0.65 * 0.15 * cScale, cY(this.pos) - 0.1 * 0.15 * cScale);
            c.stroke();
            // mouth  ----------
            if (mrMode == 'worm') {
                c.fillStyle = `black`;
                c.lineWidth = 0.05 * 0.2 * cScale;
                c.beginPath();
                c.ellipse(
                cX(this.pos), 
                cY(this.pos) + 0.45 * 0.15 * cScale, 
                0.45 * 0.15 * cScale, 
                0.35 * 0.15 * cScale, 
                0, 
                0, 
                2 * Math.PI, false);
                c.fillStyle = `black`;
            } else {
                c.fillStyle = `hsl(200, 80%, ${40 - eyeLight / 3}%)`;
                c.lineWidth = 0.05 * 0.2 * cScale;
                c.beginPath();
                c.ellipse(
                cX(this.pos), 
                cY(this.pos) + 0.7 * 0.15 * cScale, 
                0.45 * 0.15 * cScale, 
                0.35 * 0.15 * cScale, 
                0, 
                0, 
                2 * Math.PI, false);
            }
            
            c.fill();
            c.stroke();
        }
	}

    //  DEFINE PUCKS -----------------------------------------------------------------         
    function makePucks() {
        Puck = [];
        puck1color = `hsla(70, 20%, 40%, 65%)`;
        puck2color = `hsla(160, 20%, 30%, 65%)`;
        Puck.push (new PUCK(
            1.0 * puckRadiusSlider.value / 1000, 
            new Vector2(0.7 * simWidth, 
            0.8 * simHeight), puck1color));
        Puck.push (new PUCK(0.5 * puckRadiusSlider.value / 1000, 
            new Vector2(0.3 * simWidth, 
            0.25 * simHeight), puck2color));
        }
    
    //  DEFINE HUNGRY PUCKS ----------------------------------------------------------        
    function makeHungryPucks() {
        Hungrypuck = [];
        hungryPuckVel = new Vector2(0, 0);
        Hungrypuck.push (new HUNGRYPUCK(0.15, new Vector2(0.7 * simWidth, -0.1 * 0.15), hungryPuckVel, `hsl(0, 50%, 50%)`));
        Hungrypuck.push (new HUNGRYPUCK(0.15, new Vector2(0.3 * simWidth, -0.1 * 0.15), hungryPuckVel, `hsl(0, 50%, 50%)`));
    }
    
    // DEFINE MR. MISTER  ------------------------------------------------------------
    function makeMisterMister() {
        MisterMister = [];
        mrMrVel = new Vector2(1, 0);
        MisterMister.push (new MISTERMISTER(new Vector2(0.2 * simWidth, 0.7 * simHeight), mrMrVel, `hsl(0, 50%, 50%)`));
    }

    // END OF PUSH DEFINITIONS =======================================================

    //  SIMULATION --------------------------------------------------------------------------
	function simulate() {
        if (physProps.paused)
            return;	

        //  DRAW WORM ---------------------------------------------------------------------
        if (doWorm == true) {
            simulateWorm();
        }

        //  MR. & MRS. MISTER  ----------------------------------
        if (doFountain == true) {
            var mrMr = MisterMister[0];
            mrMr.simulate();
        }
        
        //  BALLS ----------------------------------
        var sortedBalls = Balls.sort((a, b) => a.left - b.left);     
        for (i = 0; i < Balls.length; i++) {
            var ball1 = sortedBalls[i];
            ball1.simulate();    

            if (doTracer == true && ball1.tracerBall == true) {
                ball1.updateTrace();
            }
            
            // Update worm immunity frame counter
            if (ball1.immuneToWorm) {
                // Initialize immunityFramesLeft for existing balls that might not have it
                if (typeof ball1.immunityFramesLeft === 'undefined') {
                    ball1.immunityFramesLeft = 10; // Give existing immune balls some frames
                }
                
                if (ball1.immunityFramesLeft > 0) {
                    ball1.immunityFramesLeft--;
                    if (ball1.immunityFramesLeft <= 0) {
                        ball1.immuneToWorm = false; // Remove immunity when frames expire
                    }
                }
            }
            
            //  HANDLE BALL TO BALL REPULSION AND HITS -----------------------------
            //  HANDLE BALL TO BALL REPULSION  -----------------------------
            if (ballRepulsion == true) {  
                for (var j = i + 1; j < Balls.length; j++) {
                    var ball2 = sortedBalls[j];   
                    if (ball2.left - physProps.repulsionDist * (ball1.radius + ball2.radius) > ball1.right + 4 * (ball1.radius + ball2.radius)) {
                        break;
                    }     
                    if (Math.abs(ball1.pos.y - ball2.pos.y) < physProps.repulsionDist * (ball1.radius + ball2.radius)) {
                        handleBallRepulsion(ball1, ball2);
                        if (Math.abs(ball1.pos.y - ball2.pos.y) <= ball1.radius + ball2.radius) {
                            handleBallHits(ball1, ball2);
                        }
                    }
                }
            } else {
                //  HANDLE BALL TO BALL HITS  -----------------------------
                for (var j = i + 1; j < Balls.length; j++) {
                    var ball2 = sortedBalls[j];   
                    
                    if (ball2.left > ball1.right) {
                        break;
                    }     
                    if (Math.abs(ball1.pos.y - ball2.pos.y) <= ball1.radius + ball2.radius) {
                        handleBallHits(ball1, ball2);
                    }
                }
            }

            if (showBumpers == true) {
                lowestBumper = Bumpers[0];
                highestBumper = Bumpers[Bumpers.length - 1];
                arrayBottom = lowestBumper.pos.y - lowestBumper.radius;
                arrayTop = highestBumper.pos.y + highestBumper.radius;
                if (ball1.bottom <= arrayTop && ball1.top >= arrayBottom) {
                    var sortedBumpers = Bumpers.sort((a, b) => a.left - b.left);
                    for (k = 0; k < Bumpers.length; k++) {
                        var bumper = sortedBumpers[k];
                        if (bumper.left > ball1.right) {
                            break;
                        }
                        if (Math.abs(ball1.pos.y - bumper.pos.y) <= ball1.radius + bumper.radius) {
                            handleBumperHits(ball1, bumper)
                        }
                    }
                } 
            }
            
            //  HUNGRY PUCK CHECKS  -----------------------------
            if (showEaters == true) {
                var hungryPuck = Hungrypuck[0];
                if (hungryPuck.right > ball1.left) {
                    if (Math.abs(ball1.pos.y - hungryPuck.pos.y) <= ball1.radius + hungryPuck.radius) {
                        handleHungryPuckHits(ball1, hungryPuck)
                    }
                }
                var hungryPuck = Hungrypuck[1];
                if (hungryPuck.right > ball1.left) {
                    if (Math.abs(ball1.pos.y - hungryPuck.pos.y) <= ball1.radius + hungryPuck.radius) {
                        handleHungryPuckHits(ball1, hungryPuck)
                    }
                }
            } 

            //  PUCK ARRIVING AND GROW  -----------------------------
            for (var p=0; p < Puck.length; p++) {
                var puck = Puck[p];
                if (puck.puckArriving == true) {
                    puck.simulate();
                }
            }
            
            //  PUCK CHECKS  -----------------------------
            if (showPucks == true) {
                for (var p=0; p < Puck.length; p++) {
                    var puck = Puck[p];
                    if (puck.right < ball1.left) {
                        break;
                    }
                    if (Math.abs(ball1.pos.y - puck.pos.y) <= ball1.radius + puck.radius) {
                        handlePuckHits(ball1, puck)
                    }
                }     
            } 

            //  WORM SEGMENT CHECKS  -----------------------------
            if (ball1.immuneToWorm != true) {
                if (doWorm == true && WormProps.SpaceWorm && WormProps.SpaceWorm.pos.length > 1) {
                    var worm = WormProps.SpaceWorm;
                    
                    // Broad-phase detection: check if ball could potentially hit any part of the worm
                    // Find worm's bounding box
                    var wormMinX = Infinity, wormMaxX = -Infinity;
                    var wormMinY = Infinity, wormMaxY = -Infinity;
                    
                    // Skip lead segment (index 1) when mrMode is 'worm'
                    //var startIndex = (mrMode == "worm") ? 2 : 1;
                    
                    for (var w = 0; w < worm.pos.length; w++) { // Skip pivot at index 0, and optionally lead segment at index 1
                        var segmentRadius = (w < worm.radii.length && typeof worm.radii[w] === 'number') ? worm.radii[w] : 0.02;
                        wormMinX = Math.min(wormMinX, worm.pos[w].x - segmentRadius);
                        wormMaxX = Math.max(wormMaxX, worm.pos[w].x + segmentRadius);
                        wormMinY = Math.min(wormMinY, worm.pos[w].y - segmentRadius);
                        wormMaxY = Math.max(wormMaxY, worm.pos[w].y + segmentRadius);
                    }
                    
                    // Broad-phase: check if ball's bounding box overlaps with worm's bounding box
                    if (ball1.pos.x + ball1.radius >= wormMinX && 
                        ball1.pos.x - ball1.radius <= wormMaxX &&
                        ball1.pos.y + ball1.radius >= wormMinY && 
                        ball1.pos.y - ball1.radius <= wormMaxY) {
                        
                        // Narrow-phase: check each worm segment individually
                        for (var w = 0; w < worm.pos.length; w++) { // Skip pivot at index 0, and optionally lead segment at index 1
                            var segmentRadius = (w < worm.radii.length && typeof worm.radii[w] === 'number') ? worm.radii[w] : 0.02;
                            
                            // Simple distance check for collision
                            var dx = ball1.pos.x - worm.pos[w].x;
                            var dy = ball1.pos.y - worm.pos[w].y;
                            var distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance <= ball1.radius + segmentRadius) {
                                handleWormSegmentHits(ball1, worm.pos[w], segmentRadius, worm.vel[w]);
                            }
                        }
                    }
                } 
            }

            //  CORNER CHECKS  -----------------------------
            for (var v = 0; v < Corners.length; v++) {
                var corner = Corners[v];
                // Skip corners on open sides based on boundary settings
                var shouldSkipCorner = false;
                if (corner.corner == 'northwest') {
                    shouldSkipCorner = !doFloor || !doLeftWall;
                } else if (corner.corner == 'northeast') {
                    shouldSkipCorner = !doFloor || !doRightWall;
                } else if (corner.corner == 'southwest') {
                    shouldSkipCorner = !doCeiling || !doLeftWall;
                } else { // southeast
                    shouldSkipCorner = !doCeiling || !doRightWall;
                }

                if (shouldSkipCorner) {
                    continue; // Skip this corner and continue with next corner
                }
                // Only check collision if corner should be active
                var shouldCheckCollision = false;
                if (corner.corner == 'northwest' || corner.corner == 'southwest') {
                    shouldCheckCollision = corner.right > ball1.left && 
                        Math.abs(ball1.pos.y - corner.pos.y) <= ball1.radius + corner.radius;
                } else if (corner.corner == 'northeast' || corner.corner == 'southeast') {
                    shouldCheckCollision = corner.left < ball1.left && 
                        Math.abs(ball1.pos.y - corner.pos.y) <= ball1.radius + corner.radius;
                }
                
                if (shouldCheckCollision) {
                    handleCornerHits(ball1, corner);
                }
            }

            //  MR. MR. OUT OF BOUNDS CHECKS  -----------------------------
            if (mrMode == "billiard") {
                var hungryPuck = MisterMister[0];
                handleMrMrBounds(hungryPuck, physProps.worldSize);
            }

            //  BALL OUT OF BOUNDS CHECKS  -----------------------------
            handleOutOfBounds(ball1, physProps.worldSize);
		}
    }

    //  DRAW EVERYTHING -----------------------------------------------------------------
	function drawEverything() {
        wipeOpacity = Math.pow(2.718, persistence / -10);
        c.fillStyle = `hsla(0, 0%, 0%, ${wipeOpacity})`;
        c.fillRect(0, 0, canvas.width, canvas.height);

        // Ensure the corner/mask gradient tracks the viewport each frame
        updateCornerFillGradient();

        // DRAW GRID -----------------------------------------------------------------
        if (persistence < 20) {
            var gridSpacing = .07;
            var horizGrids = simWidth / gridSpacing;
            var vertGrids = simHeight / gridSpacing;
            // Calculate center positions for heavy lines
            var centerX = simWidth * 0.5;
            var centerY = simHeight * 0.5;
            var centerGridX = Math.round(centerX / gridSpacing);
            var centerGridY = Math.round(centerY / gridSpacing);
            c.setLineDash([4, 4]);
            // Draw vertical lines
            for (var h = 1; h < horizGrids; h++) {
                // Make line heavy if it's at center or every 5th line from center
                var distanceFromCenter = Math.abs(h - centerGridX);
                if (distanceFromCenter % 5 == 0) {
                    c.lineWidth = 2;
                } else {
                    c.lineWidth = 1;
                }
                c.beginPath();
                c.moveTo(h * gridSpacing * cScale, 0);
                c.lineTo(h * gridSpacing * cScale, simHeight * cScale);
                c.strokeStyle = `hsl(0, 0%, 15%)`;
                c.stroke();
            }
            // Draw horizontal lines
            for (var v = 1; v < vertGrids; v++) {
                // Make line heavy if it's at center or every 5th line from center
                var distanceFromCenter = Math.abs(v - centerGridY);
                if (distanceFromCenter % 5 == 0) {
                    c.lineWidth = 2;
                } else {
                    c.lineWidth = 1;
                }
                c.beginPath();
                c.moveTo(0, v * gridSpacing * cScale);
                c.lineTo(simWidth * cScale, v * gridSpacing * cScale);
                c.stroke();
            }
            c.setLineDash([0, 0]);
        }
        //  DRAW WORM ---------------------------------------------------------------------
        if (doWorm == true && mrMode == "worm") {
             WormProps.SpaceWorm.draw()
        }
        // DRAW MR. MISTER --------------------------------------------------------------
        if (doFountain == true) {
            MrMr = MisterMister[0];
            MrMr.draw();
        }
        //  DRAW BALLS-------------------------------------------------------------------
        for (i = 0; i < Balls.length; i++) {
			ball = Balls[i];
            if (doTracer == true && ball.tracerBall == true) {
                ball.drawTrace(); 
            }
            ball.draw();
		}
        //  DRAW WORM ---------------------------------------------------------------------
        if (doWorm == true && mrMode != "worm") {
             WormProps.SpaceWorm.draw()
        }
        //  DRAW BUMPERS ----------------------------------------------------------------
        if (showBumpers == true) {
            for (k = 0; k < Bumpers.length; k++) {
            bumpers = Bumpers[k];   
            bumpers.draw();
            }
        }
        //  DRAW HUNGRY PUCKS ---------------------------------------------------------------     
        if (showEaters == true) {
            // draw first hungry puck
            var hungryPuck = Hungrypuck[0];
            hungryPuck.draw1();
            
            // draw second hungry puck
            var hungryPuck = Hungrypuck[1];
            hungryPuck.draw2();
        }
        //  DRAW PUCKS ----------------------------------------------------------------         
        if (showPucks == true) {
            for (p=0; p < Puck.length; p++) { 
                var puck = Puck[p];
                puck.draw();
            }
        }       
        //  DRAW CORNERS  ---------------------------------------------------------------------
        for (var v = 0; v < Corners.length; v++) {
            corner = Corners[v];
            
            // Skip drawing corners on open sides based on boundary settings
            var shouldSkipCorner = false;
            if (corner.corner == 'northwest') {
                shouldSkipCorner = !doCeiling || !doLeftWall;
            } else if (corner.corner == 'northeast') {
                shouldSkipCorner = !doCeiling || !doRightWall;
            } else if (corner.corner == 'southwest') {
                shouldSkipCorner = !doFloor || !doLeftWall;
            } else if (corner.corner == 'southeast') {
                shouldSkipCorner = !doFloor || !doRightWall;
            }
            
            if (!shouldSkipCorner) {
                corner.draw();
            }
        } 
        if (!doCeiling && !doFloor) {
            var leftXSim = 0;
            var rightXSim = simWidth;
            if (cornerRad > 100 && Array.isArray(Corners) && Corners.length >= 2) {
                var nw = Corners[0]; 
                var ne = Corners[1]; 
                if (nw && typeof nw.pos?.x === 'number') leftXSim = nw.pos.x;
                if (ne && typeof ne.pos?.x === 'number') rightXSim = ne.pos.x;
            }
            // Fill masks beyond the left/right bounds using the same gradient as corners
            if (!cornerFillGradient) { updateCornerFillGradient(); }
            var prevFill = c.fillStyle;
            c.fillStyle = cornerFillGradient;
            var leftPX = Math.max(0, leftXSim * cScale);
            var rightPX = Math.min(simWidth * cScale, rightXSim * cScale);
            // Left mask: from canvas left to left bound
            if (doLeftWall == true && leftPX > 0) {
                c.beginPath();
                c.rect(0, 0, leftPX, simHeight * cScale);
                c.fill();
            }
            // Right mask: from right bound to canvas right
            if (doRightWall == true && rightPX < simWidth * cScale) {
                c.beginPath();
                c.rect(rightPX, 0, (simWidth * cScale - rightPX), simHeight * cScale);
                c.fill();
            }
            c.fillStyle = prevFill;
            c.strokeStyle = 'hsl(0, 0%, 60%)';
            c.lineWidth = 0.012 * cScale;
            c.lineCap = 'butt';
            // Left bound
            if (doLeftWall == true) {
                c.beginPath();
                c.moveTo(leftXSim * cScale, 0);
                c.lineTo(leftXSim * cScale, simHeight * cScale);
                c.stroke();
            }
            // Right bound
            if (doRightWall == true) {
                c.beginPath();
                c.moveTo(rightXSim * cScale, 0);
                c.lineTo(rightXSim * cScale, simHeight * cScale);
                c.stroke();
            }
        }
	}

    //  MAIN SEQUENCE ----------------------------------------------------------------------------
	firstRun = true;
    setupScene();
    
    function update() {
        // Run multiple simulation substeps per frame
        for (let substep = 0; substep < physProps.substeps; substep++) {
            simulate();
        }
        drawEverything();
        requestAnimationFrame(update);
    }
    
    update();

</script> 
</body>
</html>