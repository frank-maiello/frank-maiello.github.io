<!-- 
PLINK(0) LAB :: a simulated particle kinetics toy ::
copyright 2025 :: Frank Maiello :: maiello.frank@gmail.com ::

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. In no event shall the author or copyright holders be liable for any claim, damages, or other liability, whether in an action of contract, tort or otherwise, arising from, our of or in, connection with the software or the use of other dealings in the Software.
-->

<!DOCTYPE html>
<html>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
	<head>
		<title>Slosh 1.33
        </title>
        <style>
			body {font-family: monospace; 
                font-size: 14px;
                color: hsl(0, 0%, 55%);
                text-align: center;
                text-shadow: 3px 4px 10px hsl(0, 0%, 0%);
                padding-left: 10px;
                padding-right: 10px;
                /* Touch optimization */
                -webkit-touch-callout: none;
                -webkit-user-select: none;
                -khtml-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
                -webkit-tap-highlight-color: transparent;
                }
            h1 {font-family: monospace;
                font-size: 10px;
                text-align: center}
            h2 {font-family: monospace;
                font-size: 0px;
                text-align: center;}
            h3 {font-family: monospace;
                font-size: 2px;
                text-align: center;}

    /*  BUTTONS  ----------------------------------------------------------- */
			.buttongreen:hover {opacity: 1}
            .buttongreen {
                width: 18px;
                height: 18px;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                border-radius: 9px;
                background-color: hsl(108, 50%, 50%);
                opacity: 0.7;
                border: none;
				cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            
            .buttongreenbig:hover {opacity: 1}
            .buttongreenbig {
                width: 24px;
                height: 24px;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                border-radius: 12px;
                color: hsl(0, 0%, 100%);
                background-color: hsl(108, 50%, 50%);
                opacity: 0.7;
                border: none;
				cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}

            .buttonorange:hover {opacity: 1}
            .buttonorange {
                width: 24px;
                height: 24px;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                border-radius: 12px;
                background-color: hsl(23, 81%, 54%);
                opacity: 0.7;
                border: none;
				cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}

            .buttonmint:hover {opacity: 1}
            .buttonmint {
                width: 24px;
                height: 24px;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                border-radius: 12px;
                background-color: hsl(160, 80%, 50%);
                opacity: 0.7;
                border: none;
				cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            
            .buttonpink:hover {opacity: 1}
            .buttonpink {
                width: 24px;
                height: 24px;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                color: hsl(58, 100%, 59%);
                border-radius: 12px;
                background-color: hsl(323, 80%, 60%);
                opacity: 0.7;
                border: none;
				cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}


    /*  SLIDERS  ---------------------------------------------------------- */
            .slider-blue:hover {opacity: 1} 
            .slider-blue {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 60px;
				height: 4px;
				border-radius: 5px;
                background: hsl(0, 0%, 0%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s}
            .slider-blue::-webkit-slider-thumb {-webkit-appearance: none;
                width: 10px;
                height: 22px;
                border-radius: 30%;
                background: hsl(220, 80%, 60%);
                box-shadow: 3px 4px 15px hsl(0, 0%, 0%);
                cursor: pointer}

            .slidersquare-fountain:hover {opacity: 1}
            .slidersquare-fountain {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 60px;
				height: 4px;
				border-radius: 5px;
                background: hsl(0, 0%, 0%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s}
            .slidersquare-fountain::-webkit-slider-thumb {-webkit-appearance: none;
                width: 18px;
                height: 18px;
                border-radius: 30%;
                background: hsl(300, 60%, 60%);
                box-shadow: 3px 4px 15px hsl(0, 0%, 0%);
                cursor: pointer}

            .slider-pink:hover {opacity: 1}
            .slider-pink {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 50px;
				height: 4px;
				border-radius: 5px;
                background: hsl(0, 0%, 0%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s}
            .slider-pink::-webkit-slider-thumb {-webkit-appearance: none;
                width: 10px;
                height: 22px;
                border-radius: 30%;
                background: hsl(330, 100%, 70%);
                box-shadow: 3px 4px 15px hsl(0, 0%, 0%);
                cursor: pointer}

            .slider-purple:hover {opacity: 1}
            .slider-purple {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 120px;
				height: 4px;
				border-radius: 5px;
                background: hsl(0, 0%, 0%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s}
            .slider-purple::-webkit-slider-thumb {-webkit-appearance: none;
                width: 10px;
                height: 22px;
                border-radius: 30%;
                background: hsl(300, 60%, 60%);
                box-shadow: 3px 4px 15px hsl(0, 0%, 0%);
                cursor: pointer} 

            .slider-purple-short:hover {opacity: 1}
            .slider-purple-short {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 60px;
				height: 4px;
				border-radius: 5px;
                background: hsl(0, 0%, 0%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s}
            .slider-purple-short::-webkit-slider-thumb {-webkit-appearance: none;
                width: 10px;
                height: 22px;
                border-radius: 30%;
                background: hsl(300, 60%, 60%);
                box-shadow: 3px 4px 15px hsl(0, 0%, 0%);
                cursor: pointer} 

            .slider-redspawn:hover {opacity: 1}
            .slider-redspawn {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 120px;
				height: 4px;
				border-radius: 5px;
                background: hsl(0, 0%, 0%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s}
            .slider-redspawn::-webkit-slider-thumb {-webkit-appearance: none;
                width: 26px;
                height: 12px;
                border-radius: 30%;
                background: hsl(350, 70%, 50%);
                box-shadow: 3px 4px 15px hsl(0, 0%, 0%);
                cursor: pointer} 

            .slider-redspawn2:hover {opacity: 1}
            .slider-redspawn2 {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 60px;
				height: 4px;
				border-radius: 5px;
                background: hsl(0, 0%, 0%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s}
            .slider-redspawn2::-webkit-slider-thumb {-webkit-appearance: none;
                width: 10px;
                height: 22px;
                border-radius: 30%;
                background: hsl(350, 70%, 50%);
                box-shadow: 3px 4px 15px hsl(0, 0%, 0%);
                cursor: pointer}
            
            .slider-cyan:hover {opacity: 1} 
            .slider-cyan {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 110px;
				height: 4px;
				border-radius: 5px;
                background: hsl(0, 0%, 0%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s}
            .slider-cyan::-webkit-slider-thumb {-webkit-appearance: none;
                width: 10px;
                height: 22px;
                border-radius: 30%;
                background: hsl(181, 82%, 66%);
                box-shadow: 3px 4px 15px hsl(0, 0%, 0%);
                cursor: pointer}

            /* Particle count slider */
            .slider-particle-count:hover {opacity: 1} 
            .slider-particle-count {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 100px;
				height: 4px;
				border-radius: 5px;
                background: hsl(0, 0%, 0%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s}
            .slider-particle-count::-webkit-slider-thumb {-webkit-appearance: none;
                width: 10px;
                height: 22px;
                border-radius: 30%;
                background: hsl(170, 75%, 50%);
                box-shadow: 3px 4px 15px hsl(0, 0%, 0%);
                cursor: pointer}

            /* Particle count display window */
            .particle-count-display {-webkit-appearance: none;
                appearance: none;
                display: inline-block;
                font-family: monospace;
                font-size: 16px;
                text-align: center;
                background: hsl(0, 0%, 0%);
                width: 80px;
				height: 18px;
                border-width: 10px;
				border-radius: 10px;
                margin-left: 5px;
                margin-right: 5px;
                margin-top: 5px;
                margin-bottom: 10px;
                vertical-align: middle;
                line-height: 21px;
                
                color: hsl(170, 75%, 40%);
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
				transition: opacity .2s;
            }
            
            

            /* Corner radius slider with detent at value 100 */
            .slider-corner-detent {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 110px;
				height: 4px;
				border-radius: 5px;
                background: linear-gradient(to right, 
                    hsl(0, 0%, 0%) 0%, 
                    hsl(0, 0%, 0%) 49%, 
                    hsl(181, 82%, 66%) 49.5%, 
                    hsl(181, 82%, 66%) 50.5%, 
                    hsl(0, 0%, 0%) 51%, 
                    hsl(0, 0%, 0%) 100%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s;
                /* Add snap points */
                scroll-snap-type: x mandatory;
                scroll-snap-points-x: repeat(50%);
                -webkit-scroll-snap-points-x: repeat(50%);
                -ms-scroll-snap-points-x: repeat(50%);}
            .slider-corner-detent:hover {opacity: 1}
            .slider-corner-detent::-webkit-slider-thumb {-webkit-appearance: none;
                width: 10px;
                height: 22px;
                border-radius: 30%;
                margin-bottom: 0px;
                background: hsl(181, 82%, 66%);
                box-shadow: 3px 4px 15px hsl(0, 0%, 0%);
                cursor: pointer;
                /* Snap point for the thumb */
                scroll-snap-align: center;}

            .slider-yellow:hover {opacity: 1} 
            .slider-yellow {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 70px;
				height: 4px;
				border-radius: 5px;
                background: hsl(0, 0%, 0%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s}
            .slider-yellow::-webkit-slider-thumb {-webkit-appearance: none;
                width: 10px;
                height: 22px;
                border-radius: 30%;
                background: hsl(45, 80%, 50%);
                box-shadow: 3px 4px 15px hsl(0, 0%, 0%);
                cursor: pointer}

            .slider-organge:hover {opacity: 1} 
            .slider-orange {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 70px;
				height: 4px;
				border-radius: 5px;
                background: hsl(0, 0%, 0%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s}
            .slider-orange::-webkit-slider-thumb {-webkit-appearance: none;
                width: 10px;
                height: 22px;
                border-radius: 20%;
                background: var(--worm-ui-color);
                box-shadow: 3px 4px 15px hsl(0, 0%, 0%);
                cursor: pointer}
            .slider-orange::-moz-range-thumb {
                width: 10px;
                height: 22px;
                border: none;
                border-radius: 20%;
                background: var(--worm-ui-color);
                box-shadow: 3px 4px 15px hsl(0, 0%, 0%);
                cursor: pointer;
            }

            .slider-organge-horiz:hover {opacity: 1} 
            .slider-orange-horiz {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 70px;
				height: 4px;
				border-radius: 5px;
                background: hsl(0, 0%, 0%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s}
            .slider-orange-horiz::-webkit-slider-thumb {-webkit-appearance: none;
                width: 26px;
                height: 12px;
                border-radius: 30%;
                background: var(--worm-ui-color);
                box-shadow: 3px 4px 15px hsl(0, 0%, 0%);
                cursor: pointer}
            .slider-orange-horiz::-moz-range-thumb {
                width: 26px;
                height: 12px;
                border: none;
                border-radius: 30%;
                background: var(--worm-ui-color);
                box-shadow: 3px 4px 15px hsl(0, 0%, 0%);
                cursor: pointer;
            }

            .slider-lime:hover {opacity: 1} 
            .slider-lime {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 70px;
				height: 4px;
				border-radius: 5px;
                background: hsl(0, 0%, 0%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s}
            .slider-lime::-webkit-slider-thumb {-webkit-appearance: none;
                width: 10px;
                height: 22px;
                border-radius: 20%;
                background: hsl(75, 91%, 46%);
                box-shadow: 3px 4px 15px hsl(0, 0%, 0%);
                cursor: pointer}

            .slider-lime2:hover {opacity: 1} 
            .slider-lime2 {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 70px;
				height: 4px;
				border-radius: 5px;
                background: hsl(0, 0%, 0%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s}
            .slider-lime2::-webkit-slider-thumb {-webkit-appearance: none;
                width: 10px;
                height: 22px;
                border-radius: 20%;
                background: hsl(75, 91%, 46%);
                box-shadow: 3px 4px 15px hsl(0, 0%, 0%);
                cursor: pointer}

            .slider-red:hover {opacity: 1} 
            .slider-red {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 100px;
				height: 4px;
				border-radius: 5px;
                background: linear-gradient(to right, 
                    hsl(0, 0%, 10%) 0%, 
                    hsl(0, 0%, 80%) 100%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s}
            .slider-red::-webkit-slider-thumb {-webkit-appearance: none;
                width: 10px;
                height: 22px;
                border-radius: 30%;
                background: hsl(0, 60%, 70%);
                box-shadow: 3px 4px 15px hsl(0, 0%, 0%);
                cursor: pointer}

            .slider-red2:hover {opacity: 1} 
            .slider-red2 {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 130px;
				height: 4px;
				border-radius: 5px;
                background: linear-gradient(to right, 
                    hsl(0, 70%, 50%) 17%, 
                    hsl(60, 70%, 50%) 34%, 
                    hsl(120, 70%, 50%) 50%,
                    hsl(180, 70%, 50%) 67%, 
                    hsl(240, 70%, 50%) 84%, 
                    hsl(300, 70%, 50%) 100%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s}
            .slider-red2::-webkit-slider-thumb {-webkit-appearance: none;
                width: 10px;
                height: 22px;
                border-radius: 30%;
                background: hsl(0, 60%, 70%);
                box-shadow: 3px 4px 15px hsl(0, 0%, 0%);
                cursor: pointer}


            .slider-lightred:hover {opacity: 1}
            .slider-lightred {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                position: 10px;
                width: 75px;
				height: 4px;
				border-radius: 5px;
                background: linear-gradient(to right, 
                    hsl(0, 0%, 0%) 0%, 
                    hsl(0, 90%, 50%) 100%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s}
            .slider-lightred::-webkit-slider-thumb {-webkit-appearance: none;
                width: 10px;
                height: 22px;
                border-radius: 30%;
                background: hsl(0, 60%, 70%);
                box-shadow: 3px 4px 15px hsl(0, 0%, 0%);
                cursor: pointer}

            .slider-mint:hover {opacity: 1} 
            .slider-mint {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 75px;
				height: 4px;
				border-radius: 5px;
                background: hsl(0, 0%, 0%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s}
            .slider-mint::-webkit-slider-thumb {-webkit-appearance: none;
                width: 10px;
                height: 22px;
                border-radius: 30%;
                background: hsl(140, 80%, 60%);
                box-shadow: 3px 4px 15px hsl(0, 0%, 0%);
                cursor: pointer}

            .slider-green:hover {opacity: 1}
            .slider-green {-webkit-appearance: none;
				appearance: none;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                position: 10px;
                width: 75px;
				height: 4px;
				border-radius: 5px;
                background: hsl(0, 0%, 0%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
			    transition: opacity .2s}
            .slider-green::-webkit-slider-thumb {-webkit-appearance: none;
                width: 10px;
                height: 22px;
                border-radius: 30%;
                background: hsl(90, 70%, 50%);
                box-shadow: 3px 4px 15px hsl(0, 0%, 0%);
                cursor: pointer}

    /*  FIELDS  ----------------------------------------------------------- */
            .field-cyan-short:hover {opacity: 1}       
            .field-cyan-short {-webkit-appearance: none;
                appearance: none;
                font-family: monospace;
                font-size: 16px;
                background: hsl(0, 0%, 0%);
                margin-top: 5px;
                margin-bottom: 10px;
                margin-left: 5px;
                padding-top: 2px;
                padding-left: 6px;
				width: 54px;
				height: 18px;
                border-width: 0;
				border-radius: 10px;
                color: hsl(170, 75%, 50%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
				transition: opacity .2s}

            .field-cyan:hover {opacity: 1}
            .field-cyan {-webkit-appearance: none;
                appearance: none;
                font-family: monospace;
                font-size: 16px;
                text-align: center;
                background: hsl(0, 0%, 0%);
                margin-bottom: 10px;
                padding-left: 6px;
				width: 80px;
				height: 22px;
                border-width: 0;
				border-radius: 10px;
                color: hsl(170, 75%, 50%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
				transition: opacity .2s}

            .field-cyan2:hover {opacity: 1}
            .field-cyan2 {-webkit-appearance: none;
                appearance: none;
                font-family: monospace;
                font-size: 16px;
                text-align: center;
                background: hsl(0, 0%, 0%);
                margin-bottom: 10px;
                padding-left: 6px;
				width: 100px;
				height: 22px;
                border-width: 0;
				border-radius: 10px;
                color: hsl(170, 75%, 50%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
				transition: opacity .2s}

            .field-purple {-webkit-appearance: none;
                appearance: none;
                font-family: monospace;
                font-size: 16px;
                text-align: center;
                background: hsl(0, 0%, 0%);
                margin-top: 5px;
                margin-bottom: 10px;
                padding-left: 6px;
				width: 120px;
				height: 18px;
                border-width: 0;
				border-radius: 10px;
                color: hsl(300, 60%, 70%);
				outline: none;
				opacity: 0.7;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
				-webkit-transition: .2s;
				transition: opacity .2s}
            

    /*  CHECKBOXES  -------------------------------------------------------- */
            .checkbox-orange:hover {opacity: 1}
            .checkbox-orange {-webkit-appearance: none;
                appearance: none;
                opacity: 0.8;
                width: 24px;
                height: 24px;
                margin-top: 5px;
                margin-bottom: 10px;
                background-color: hsl(23, 50%, 20%);
                border-radius: 50%;
                vertical-align: middle;
                border: 3px solid hsl(0, 0%, 80%);
                outline: none;
                cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            .checkbox-orange:checked {
                background-color: hsl(23, 70%, 60%)}

            .checkbox-lime:hover {opacity: 1}
            .checkbox-lime {-webkit-appearance: none;
                appearance: none;
                opacity: 0.8;
                width: 24px;
                height: 24px;
                margin-top: 5px;
                margin-bottom: 10px;
                background-color: hsl(75, 80%, 20%);
                border-radius: 50%;
                vertical-align: middle;
                border: 3px solid hsl(0, 0%, 80%);
                outline: none;
                cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            .checkbox-lime:checked {
                background-color: hsl(75, 80%, 50%)}

            .checkbox-gray:hover {opacity: 1}
            .checkbox-gray {-webkit-appearance: none;
                appearance: none;
                opacity: 0.8;
                width: 24px;
                height: 24px;
                margin-top: 5px;
                margin-bottom: 10px;
                background-color: hsl(0, 0%, 20%);
                border-radius: 50%;
                vertical-align: middle;
                border: 3px solid hsl(0, 0%, 80%);
                outline: none;
                cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            .checkbox-gray:checked {
                background-color: hsl(0, 0%, 60%);}

            /* Repulsion toggle: U+2608 icon, dim/bright lime */
            .checkbox-repulsion:hover { opacity: 1; filter: brightness(1.05); }
            .checkbox-repulsion { -webkit-appearance: none;
                appearance: none;
                opacity: 0.95;
                width: 24px;
                height: 24px;
                margin-top: 5px;
                margin-bottom: 10px;
                border-radius: 50%;
                vertical-align: middle;
                border: none;
                outline: none;
                cursor: pointer;
                background: transparent;
                position: relative;
                display: inline-block;
                /* Tunables (match lime theme) */
                --rep-dim:    hsl(75, 80%, 20%);
                --rep-bright: hsl(75, 80%, 50%);
            }
            .checkbox-repulsion::after {
                content: "\2608"; /* thunderstorm symbol */
                position: absolute;
                left: 50%;
                top: 60%;
                transform: translate(-50%, -56%);
                font-size: 28px;
                line-height: 1;
                color: var(--rep-dim);
                pointer-events: none;
                text-shadow: 3px 4px 10px hsl(0, 0%, 0%);
                transition: color 120ms ease, filter 120ms ease;
            }
            .checkbox-repulsion:checked::after { color: var(--rep-bright); }

            .checkbox-roundgray:hover {opacity: 1}
            .checkbox-roundgray {-webkit-appearance: none;
                appearance: none;
                opacity: 0.8;
                width: 24px;
                height: 24px;
                margin-top: 5px;
                margin-bottom: 10px;
                background-color: hsl(9, 0%, 30%);
                border-radius: 50%;
                vertical-align: middle;
                border: 3px solid hsl(0, 0%, 80%);
                outline: none;
                cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            .checkbox-roundgray:checked {
                background-color: hsl(0, 0%, 60%)}

            /* One-shot toggle: recycling symbol, dim when off, bright when on (no animation) */
            .checkbox-oneshot:hover { opacity: 1; filter: brightness(1.05); }
            .checkbox-oneshot { -webkit-appearance: none;
                appearance: none;
                opacity: 0.95;
                width: 24px;
                height: 24px;
                margin-top: 5px;
                margin-bottom: 10px;
                border-radius: 50%;
                vertical-align: middle;
                border: none;
                outline: none;
                cursor: pointer;
                background: transparent;
                position: relative;
                display: inline-block;
                /* Tunables */
                --os-bright:    #214a2c;  /* muted green */
                --os-dim: #73ff9a;  /* bright mint */
            }
            .checkbox-oneshot::after {
                content: "\267B"; /* ♻ */
                position: absolute;
                left: 50%;
                top: 60%;
                transform: translate(-50%, -56%);
                font-size: 26px;
                line-height: 1;
                color: var(--os-dim);
                pointer-events: none;
                text-shadow: 3px 4px 10px rgba(0,0,0,0.35);
                transition: color 120ms ease, filter 120ms ease;
            }
            .checkbox-oneshot:checked::after {
                color: var(--os-bright);
            }

            .checkbox-tracer:hover { opacity: 1; filter: brightness(1.05); }
            .checkbox-tracer { -webkit-appearance: none;
                appearance: none;
                opacity: 0.95;
                width: 24px;
                height: 24px;
                margin-top: 5px;
                margin-bottom: 10px;
                border-radius: 50%;
                vertical-align: middle;
                border: none;
                outline: none;
                cursor: pointer;
                background: transparent;
                position: relative;
                display: inline-block;
                /* Tunables */
                --tr-dim:    hsl(0, 0%, 20%);  /* dim gray */
                --tr-bright: hsl(170, 20%, 60%);  /* bright gray */}
            .checkbox-tracer::after {
                content: "\2621"; /* ✐ */
                position: absolute;
                left: 50%;
                top: 60%;
                transform: translate(-50%, -56%);
                font-size: 30px;
                line-height: 1;
                color: var(--tr-dim);
                pointer-events: none;
                text-shadow: 3px 4px 10px hsl(0, 0%, 0%);
                transition: color 120ms ease, filter 120ms ease;}
            .checkbox-tracer:checked::after { color: var(--tr-bright); }
            
            .checkbox-tracer-small:hover { opacity: 1; filter: brightness(1.05); }
            .checkbox-tracer-small { -webkit-appearance: none;
                appearance: none;
                opacity: 0.95;
                width: 24px;
                height: 24px;
                margin-top: 5px;
                margin-bottom: 10px;
                border-radius: 50%;
                vertical-align: middle;
                border: none;
                outline: none;
                cursor: pointer;
                background: transparent;
                position: relative;
                display: inline-block;
                /* Tunables */
                --tr-dim:    hsl(0, 0%, 20%);  /* dim gray */
                --tr-bright: hsl(170, 20%, 60%);  /* bright gray */}
            .checkbox-tracer-small::after {
                content: "\2710"; /* ✐ */
                position: absolute;
                left: 50%;
                top: 60%;
                transform: translate(-50%, -56%);
                font-size: 24px;
                line-height: 1;
                color: var(--tr-dim);
                pointer-events: none;
                text-shadow: 3px 4px 10px hsl(0, 0%, 0%);
                transition: color 120ms ease, filter 120ms ease;}
            .checkbox-tracer-small:checked::after { color: var(--tr-bright); }

            .checkbox-tracer-medium:hover { opacity: 1; filter: brightness(1.05); }
            .checkbox-tracer-medium { -webkit-appearance: none;
                appearance: none;
                opacity: 0.95;
                width: 24px;
                height: 24px;
                margin-top: 5px;
                margin-bottom: 10px;
                border-radius: 50%;
                vertical-align: middle;
                border: none;
                outline: none;
                cursor: pointer;
                background: transparent;
                position: relative;
                display: inline-block;
                /* Tunables */
                --tr-dim:    hsl(0, 0%, 20%);
                --tr-bright: hsl(170, 20%, 60%);}
            .checkbox-tracer-medium::after {
                content: "\2710"; /* ✐ */
                position: absolute;
                left: 50%;
                top: 60%;
                transform: translate(-50%, -56%);
                font-size: 28px;
                line-height: 1;
                color: var(--tr-dim);
                pointer-events: none;
                text-shadow: 3px 4px 10px hsl(0, 0%, 0%);
                transition: color 120ms ease, filter 120ms ease;}
            .checkbox-tracer-medium:checked::after { color: var(--tr-bright); }

            .checkbox-tracer-large:hover { opacity: 1; filter: brightness(1.05); }
            .checkbox-tracer-large { -webkit-appearance: none;
                appearance: none;
                opacity: 0.95;
                width: 24px;
                height: 24px;
                margin-top: 5px;
                margin-bottom: 10px;
                border-radius: 50%;
                vertical-align: middle;
                border: none;
                outline: none;
                cursor: pointer;
                background: transparent;
                position: relative;
                display: inline-block;
                /* Tunables */
                --tr-dim:    hsl(0, 0%, 20%);  /* dim gray */
                --tr-bright: hsl(170, 20%, 60%);  /* bright gray */}
            .checkbox-tracer-large::after {
                content: "\2710"; /* ✐ */
                position: absolute;
                left: 50%;
                top: 60%;
                transform: translate(-50%, -56%);
                font-size: 32px;
                line-height: 1;
                color: var(--tr-dim);
                pointer-events: none;
                text-shadow: 3px 4px 10px hsl(0, 0%, 0%);
                transition: color 120ms ease, filter 120ms ease;}
            .checkbox-tracer-large:checked::after { color: var(--tr-bright); }

            /* When master tracer is OFF, force all tracer-size buttons to dim regardless of checked state */
            body:has(#noTracerButton:not(:checked)) .checkbox-tracer-small::after,
            body:has(#noTracerButton:not(:checked)) .checkbox-tracer-medium::after,
            body:has(#noTracerButton:not(:checked)) .checkbox-tracer-large::after {
                color: var(--tr-dim) !important;
                filter: none !important;
                opacity: 0.8;
            }

            /* Cycle puck toggle: ✢ (U+2742), dim when off, bright when on */
            .checkbox-cycle:hover { opacity: 1; filter: brightness(1.05); }
            .checkbox-cycle { -webkit-appearance: none;
                appearance: none;
                opacity: 0.95;
                width: 24px;
                height: 24px;
                margin-top: 5px;
                margin-bottom: 10px;
                border-radius: 50%;
                vertical-align: middle;
                border: none;
                outline: none;
                cursor: pointer;
                background: transparent;
                position: relative;
                display: inline-block;
                /* Tunables (teal/cyan theme) */
                --cyc-dim:    hsl(190, 50%, 20%);
                --cyc-bright: hsl(190, 80%, 55%);}
            .checkbox-cycle::after {
                content: "!!!"; /* ✢ */
                position: absolute;
                left: 50%;
                top: 60%;
                transform: translate(-50%, -56%);
                font-size: 28px;
                line-height: 1;
                color: var(--cyc-dim);
                pointer-events: none;
                text-shadow: 3px 4px 10px hsl(0, 0%, 0%);
                transition: color 120ms ease, filter 120ms ease;}
            .checkbox-cycle:checked::after { color: var(--cyc-bright); }

            /* Normal pucks toggle: ☉ (U+2609), dim when off, bright when on */
            .checkbox-puck:hover { opacity: 1; filter: brightness(1.05); }
            .checkbox-puck { -webkit-appearance: none;
                appearance: none;
                opacity: 0.95;
                width: 24px;
                height: 24px;
                margin-top: 5px;
                margin-bottom: 10px;
                border-radius: 50%;
                vertical-align: middle;
                border: none;
                outline: none;
                cursor: pointer;
                background: transparent;
                position: relative;
                display: inline-block;
                /* Tunables (cyan theme to match pucks) */
                --puck-dim:    hsl(190, 45%, 20%);
                --puck-bright: hsl(190, 85%, 55%);
            }
            .checkbox-puck::after {
                content: "\2609"; /* ☉ sun */
                position: absolute;
                left: 50%;
                top: 72%;
                transform: translate(-50%, -56%);
                font-size: 50px;
                line-height: 1;
                color: var(--puck-dim);
                pointer-events: none;
                text-shadow: 3px 4px 10px hsl(0, 0%, 0%);
                transition: color 120ms ease, filter 120ms ease;
            }
            .checkbox-puck:checked::after { color: var(--puck-bright); }

            /* Worm toggle: ⚕ (U+2695) rotated 90° clockwise, dim/bright orange */
            .checkbox-worm:hover { opacity: 1; filter: brightness(1.05); }
            .checkbox-worm { -webkit-appearance: none;
                appearance: none;
                opacity: 0.95;
                width: 24px;
                height: 24px;
                margin-top: 5px;
                margin-bottom: 10px;
                border-radius: 50%;
                vertical-align: middle;
                border: none;
                outline: none;
                cursor: pointer;
                background: transparent;
                position: relative;
                display: inline-block;
                /* Tunables (match original orange theme) */
                --worm-dim:    hsl(23, 40%, 20%);
                --worm-bright: hsl(23, 70%, 60%);
            }
            .checkbox-worm::after {
                content: "\2695"; /* ⚕ */
                position: absolute;
                left: 50%;
                top: 60%;
                transform: translate(-50%, -56%) rotate(90deg);
                font-size: 40px;
                line-height: 1;
                color: var(--worm-dim);
                pointer-events: none;
                text-shadow: 3px 4px 10px hsl(0, 0%, 0%);
                transition: color 120ms ease, filter 120ms ease;
            }
            .checkbox-worm:checked::after { color: var(--worm-bright); }

            /* Worm UI theming: simple CSS linkage between the Worm button and worm sliders */
            body {
                /* Palette mirrors .checkbox-worm */
                --worm-ui-dim:    hsl(23, 40%, 20%);
                --worm-ui-bright: hsl(23, 70%, 60%);
                /* Sliders default to dim when the Worm button is off */
                --worm-ui-color: var(--worm-ui-dim);
            }
            /* When the Worm button is checked, brighten the slider knobs */
            body:has(#wormButton:checked) {
                --worm-ui-color: var(--worm-ui-bright);
            }

            /* Plinko/Bumper UI theming: link the Plinko toggle to the yellow slider knobs */
            /* Mirrors .checkbox-bumper colors so the knob matches the button's dim/bright state */
            body {
                --bumper-ui-dim:    hsl(45, 45%, 20%);
                --bumper-ui-bright: hsl(45, 80%, 50%);
                /* Default: dim when Plinko (showBumperEntry) is off */
                --bumper-ui-color: var(--bumper-ui-dim);
            }
            /* Brighten yellow slider knobs when Plinko is enabled */
            body:has(#showBumperEntry:checked) {
                --bumper-ui-color: var(--bumper-ui-bright);
            }
            /* Apply the theme color to yellow slider thumbs (WebKit and Firefox) */
            .slider-yellow::-webkit-slider-thumb { background: var(--bumper-ui-color); }
            .slider-yellow::-moz-range-thumb    { background: var(--bumper-ui-color); }

            /* Puck Radius slider theming: dim knob when ALL puck toggles are off; brighten if ANY are on */
            body {
                /* Match .checkbox-puck cyan palette */
                --puck-ui-dim:    hsl(190, 45%, 20%);
                --puck-ui-bright: hsl(190, 85%, 55%);
                /* Default to dim when no puck toggles are checked */
                --puck-ui-color: var(--puck-ui-dim);
            }
            /* If any puck-related toggle is checked, use bright */
            body:has(#showPuckButton:checked),
            body:has(#showCyclePuckButton:checked),
            body:has(#showHeartButton:checked) {
                --puck-ui-color: var(--puck-ui-bright);
            }
            /* Apply to the puck radius slider knob */
            #puckRadiusSlider::-webkit-slider-thumb { background: var(--puck-ui-color); }
            #puckRadiusSlider::-moz-range-thumb    { background: var(--puck-ui-color); }

            /* Shower sliders theming: dim dump sliders when Shower is OFF; brighten when ON */
            body {
                /* Match spawn red theme used by shower controls */
                --dump-ui-dim:    hsl(350, 40%, 35%);
                --dump-ui-bright: hsl(350, 70%, 50%);
                --dump-ui-color: var(--dump-ui-dim);
            }
            body:has(#shower:checked) {
                --dump-ui-color: var(--dump-ui-bright);
            }
            /* Apply to both shower sliders: width (redspawn2) and position (redspawn) */
            .slider-redspawn2::-webkit-slider-thumb, .slider-redspawn::-webkit-slider-thumb { background: var(--dump-ui-color); }
            .slider-redspawn2::-moz-range-thumb,    .slider-redspawn::-moz-range-thumb    { background: var(--dump-ui-color); }

            /* Repulsion slider theming: dim lime slider when Repulsion is OFF; brighten when ON */
            body {
                /* Match repulsion toggle lime theme */
                --rep-ui-dim:    hsl(75, 80%, 20%);
                --rep-ui-bright: hsl(75, 80%, 50%);
                --rep-ui-color: var(--rep-ui-dim);
            }
            body:has(#repulsionButton:checked) { --rep-ui-color: var(--rep-ui-bright); }
            .slider-lime::-webkit-slider-thumb { background: var(--rep-ui-color); }
            .slider-lime::-moz-range-thumb    { background: var(--rep-ui-color); }

            /* Mr. Mister (Fountain) UI theming: dim when fountain is OFF; brighten when ON */
            body {
                /* Match radio-fountain magenta theme */
                --mister-ui-dim:    hsl(300, 40%, 20%);
                --mister-ui-bright: hsl(300, 60%, 55%);
                --mister-ui-color: var(--mister-ui-dim);
            }
            body:has(#fountain:checked) {
                --mister-ui-color: var(--mister-ui-bright);
            }
            /* Apply to fountain controls: purple-short + pink sliders, and the purple field */
            .slider-purple-short::-webkit-slider-thumb, .slider-pink::-webkit-slider-thumb { background: var(--mister-ui-color); }
            .slider-purple-short::-moz-range-thumb,    .slider-pink::-moz-range-thumb    { background: var(--mister-ui-color); }
            /* Subtly tint the Mr. Mister mode select border to match */
            .field-purple { border-color: var(--mister-ui-color); }

            /* Bumper/Pegs toggle: Die face five (U+2684), dim/bright yellow */
            .checkbox-bumper:hover { opacity: 1; filter: brightness(1.05); }
            .checkbox-bumper { -webkit-appearance: none;
                appearance: none;
                opacity: 0.95;
                width: 24px;
                height: 24px;
                margin-top: 5px;
                margin-bottom: 10px;
                border-radius: 50%;
                vertical-align: middle;
                border: none;
                outline: none;
                cursor: pointer;
                background: transparent;
                position: relative;
                display: inline-block;
                /* Tunables (match yellow theme) */
                --bumper-dim:    hsl(45, 45%, 20%);
                --bumper-bright: hsl(45, 80%, 50%);
            }
            .checkbox-bumper::after {
                content: "\2684"; /* ⚄ (die face five) */
                position: absolute;
                left: 50%;
                top: 52%;
                transform: translate(-50%, -56%);
                font-size: 40px;
                line-height: 1;
                color: var(--bumper-dim);
                pointer-events: none;
                text-shadow: 3px 4px 10px hsl(0, 0%, 0%);
                transition: color 120ms ease, filter 120ms ease;
            }
            .checkbox-bumper:checked::after { color: var(--bumper-bright); }

            .checkbox-yellow:hover {opacity: 1}
            .checkbox-yellow {-webkit-appearance: none;
                appearance: none;
                opacity: 0.8;
                width: 24px;
                height: 24px;
                margin-top: 5px;
                margin-bottom: 10px;
                background-color: hsl(56, 80%, 20%);
                border-radius: 50%;
                vertical-align: middle;
                border: 3px solid hsl(0, 0%, 80%);
                outline: none;
                cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            .checkbox-yellow:checked {
                background-color: hsl(45, 80%, 50%)}

            /* Pause toggle: STOP sign (octagon), red dim/bright, no text */
            .checkbox-pause:hover { opacity: 1; filter: brightness(1.05); }
            .checkbox-pause { -webkit-appearance: none;
                appearance: none;
                opacity: 0.95;
                width: 24px;
                height: 24px;
                margin-top: 5px;
                margin-bottom: 10px;
                background: transparent;
                border: none;
                border-radius: 50%; /* pretend round for simple shadow */
                vertical-align: middle;
                outline: none;
                cursor: pointer;
                position: relative;
                display: inline-block;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
                /* Tunables */
                --stop-dim:    hsl(0, 68%, 20%);
                --stop-bright: hsl(0, 78%, 54%);
                --stop-color:  var(--stop-dim);
            }
            /* No separate shadow layer; use simple circular box-shadow on host */
            .checkbox-pause::before { content: none; }
            /* Inner red octagon fill */
            .checkbox-pause::after {
                content: "";
                position: absolute;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                width: 24px;
                height: 24px;
                background: var(--stop-color);
                clip-path: polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%);
                pointer-events: none;
                transition: background-color 120ms ease, filter 120ms ease;
            }
            .checkbox-pause:checked { --stop-color: var(--stop-bright); }

            /* White octagonal border when checked (sits behind the red fill) */
            .checkbox-pause:checked::before {
                content: "";
                position: absolute;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                width: 28px;   /* slightly larger than the red fill */
                height: 28px;
                background: #ffffff; /* white border */
                clip-path: polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%);
                pointer-events: none;
            }

            /* Impulse buttons (explode/implode/unravel): dim when off, bright when 'checked' */
            input.splodeButton:hover,
            input.implodeButton:hover,
            input.unravelButton:hover { opacity: 1; filter: brightness(1.5); }
            input.splodeButton,
            input.implodeButton,
            input.unravelButton {
                -webkit-appearance: none;
                appearance: none;
                opacity: 0.95;
                width: 24px;
                height: 24px;
                margin-top: 5px;
                margin-bottom: 10px;
                border-radius: 50%;
                vertical-align: middle;
                border: none;
                outline: none;
                cursor: pointer;
                background: transparent;
                position: relative;
                display: inline-block;
                
            }
            /* Per-button color themes */
            input.splodeButton { --imp-dim: hsl(15, 60%, 35%);  --imp-bright: hsl(15, 78%, 54%); }
            input.implodeButton { --imp-dim: hsl(190, 40%, 40%); --imp-bright: hsl(190, 80%, 55%); }
            input.unravelButton { --imp-dim: hsl(300, 40%, 30%); --imp-bright: hsl(300, 60%, 55%); }

            /* Icons */
            input.splodeButton::after {
                /* two-line: arrows pointing outwards */
                content: "\2196 \2197\A\2199 \2198"; /* ↖ ↗ \A ↙ ↘ */
                white-space: pre;
                position: absolute;
                left: 50%;
                top: 55%;
                transform: translate(-50%, -56%);
                font-family: monospace, bold;
                font-size: 22px;
                line-height: 0.6;
                color: var(--imp-dim);
                pointer-events: none;
                text-shadow: 3px 4px 10px hsl(0, 0%, 0%);
                transition: color 120ms ease, filter 120ms ease;
            }
            input.splodeButton:checked::after { color: var(--imp-bright); }

            input.implodeButton::after {
                /* two-line: arrows pointing inward (diagonals flipped) */
                content: "\2198 \2199\A\2197 \2196"; /* ↘ ↙ \A ↗ ↖ */
                white-space: pre;
                position: absolute;
                left: 50%;
                top: 55%;
                transform: translate(-50%, -56%);
                font-family: monospace, bold;
                font-size: 22px;
                line-height: 0.7;
                color: var(--imp-dim);
                pointer-events: none;
                text-shadow: 3px 4px 10px hsl(0, 0%, 0%);
                transition: color 120ms ease, filter 120ms ease;
            }
            input.implodeButton:checked::after { color: var(--imp-bright); }

            input.unravelButton::after {
                content: "\269B"; /* ➿ short spiral */
                position: absolute;
                left: 50%;
                top: 60%;
                transform: translate(-50%, -56%);
                font-family: monospace, bold;
                font-size: 46px;
                line-height: 1;
                color: var(--imp-dim);
                pointer-events: none;
                text-shadow: 3px 4px 10px hsl(0, 0%, 0%);
                transition: color 120ms ease, filter 120ms ease;
            }
            input.unravelButton:checked::after { color: var(--imp-bright); }

            .checkbox-cyan:hover {opacity: 1}    
            .checkbox-cyan {-webkit-appearance: none;
                appearance: none;
                opacity: 0.8;
                width: 24px;
                height: 24px;
                margin-top: 5px;
                margin-bottom: 10px;
                background-color: hsl(190, 50%, 30%);
                border-radius: 50%;
                vertical-align: middle;
                border: 3px solid hsl(0, 0%, 80%);
                outline: none;
                cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            .checkbox-cyan:checked {
                background-color: hsl(190, 70%, 50%)}

            /* Heart toggle button: dim when off, bright and pulsing when on */
            .checkbox-heart:hover { opacity: 1; filter: brightness(1.05); }
            .checkbox-heart {
                -webkit-appearance: none;
                appearance: none;
                opacity: 0.95;
                width: 24px;
                height: 24px;
                margin-top: 5px;
                margin-bottom: 10px;
                border-radius: 50%;
                vertical-align: middle;
                border: none;
                outline: none;
                cursor: pointer;
            
                background: transparent;
                position: relative; /* anchor for ::after */
                display: inline-block; /* ensure a proper positioning context */
                /* Tunables */
                --heart-dim:  hsl(190, 50%, 20%);  /* unchecked */
                --heart-bright: #ff6fa3; /* checked */
            }
            .checkbox-heart::after {
                content: "\2665"; /* ♥ */
                position: absolute;
                left: 50%;
                top: 60%;
                transform: translate(-50%, -56%) scale(1);
                font-family: monospace;
                font-size: 35px;
                line-height: 1;
                color: var(--heart-dim);
                pointer-events: none;
                text-shadow: 3px 4px 10px hsl(0, 0%, 0%);
                transition: transform 120ms ease, color 120ms ease;
            }
            .checkbox-heart:checked::after {
                color: var(--heart-bright);
                /* Longer cycle with a pause after the double pulse */
                animation: heart-beat 1200ms ease-in-out infinite;
            }
            /* Two quick pulses, then a short rest (lub‑dub … pause) */
            @keyframes heart-beat {
                0%   { transform: translate(-50%, -56%) scale(0.96); }
                10%  { transform: translate(-50%, -56%) scale(1.12); }  /* first peak */
                20%  { transform: translate(-50%, -56%) scale(1.00); }  /* settle */
                28%  { transform: translate(-50%, -56%) scale(1.08); }  /* second peak */
                38%  { transform: translate(-50%, -56%) scale(1.00); }  /* settle */
                100% { transform: translate(-50%, -56%) scale(0.96); }  /* rest/pause */
            }

            .checkbox-blue-dark:hover {opacity: 1}
            .checkbox-blue-dark {
                -webkit-appearance: none;
                appearance: none;
                opacity: 0.9;
                width: 24px;
                height: 24px;
                margin-top: 5px;
                margin-bottom: 10px;
                border-radius: 50%;
                vertical-align: middle;
                border: none; /* no outline/border */
                outline: none;
                cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%);
                /* Tunables */
                --pac: #645202; /* dimmer yellow (unchecked) */
                --mouth: 36deg; /* half-angle of the mouth opening */
                /* Pac-Man: body with mouth wedge; facing 3 o'clock */
                background:
                    conic-gradient(from 90deg at 50% 50%,
                    hsl(0, 0%, 0%) 0 var(--mouth),
                    var(--pac) var(--mouth) calc(360deg - var(--mouth)),
                    hsl(0, 0%, 0%) calc(360deg - var(--mouth)) 360deg);
                background-color: transparent; /* show panel through the mouth */
                transition: filter 120ms ease;
            }
            .checkbox-blue-dark:hover { filter: brightness(1.05); }
            /* Checked: brighten and chomp continuously (no direction flip) */
            .checkbox-blue-dark:checked {
                --pac: #FFD54A; /* bright yellow */
                animation: pac-chomp 420ms ease-in-out infinite;
            }
            @keyframes pac-chomp {
                0%    { --mouth: 14deg; }
                12.5% { --mouth: 20deg; }
                25%   { --mouth: 28deg; }
                37.5% { --mouth: 38deg; }
                50%   { --mouth: 46deg; }
                62.5% { --mouth: 38deg; }
                75%   { --mouth: 28deg; }
                87.5% { --mouth: 20deg; }
                100%  { --mouth: 14deg; }
            }
                
            .checkbox-ceiling:hover {opacity: 1}
            .checkbox-ceiling {-webkit-appearance: none;
                appearance: none;
                opacity: 0.8;
                width: 28px;
                height: 14px;
                margin-top: 5px;
                margin-bottom: 10px;
                background-color: hsl(80, 50%, 20%);
                border-radius: 24px 24px 0 0;
                vertical-align: middle;
                border: 3px solid hsl(0, 0%, 80%);
                border-bottom: none;
                outline: none;
                cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            .checkbox-ceiling:checked {
                background-color: hsl(80, 50%, 50%)}

            .checkbox-floor:hover {opacity: 1}
            .checkbox-floor {-webkit-appearance: none;
                appearance: none;
                opacity: 0.8;
                width: 28px;
                height: 14px;
                margin-top: 5px;
                margin-bottom: 10px;
                background-color: hsl(160, 50%, 20%);
                border-radius: 0 0 24px 24px;
                vertical-align: middle;
                border: 3px solid hsl(0, 0%, 80%);
                border-top: none;
                outline: none;
                cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            .checkbox-floor:checked {
                background-color: hsl(160, 50%, 45%)}

            .checkbox-leftwall:hover {opacity: 1}
            .checkbox-leftwall {-webkit-appearance: none;
                appearance: none;
                opacity: 0.8;
                width: 14px;
                height: 28px;
                margin-top: 5px;
                margin-bottom: 10px;
                background-color: hsl(230, 70%, 20%);
                border-radius: 24px 0 0 24px;
                vertical-align: middle;
                border: 3px solid hsl(0, 0%, 80%);
                border-right: none;
                outline: none;
                cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            .checkbox-leftwall:checked {
                background-color: hsl(230, 70%, 70%)}

            .checkbox-rightwall:hover {opacity: 1}
            .checkbox-rightwall {-webkit-appearance: none;
                appearance: none;
                opacity: 0.8;
                width: 14px;
                height: 28px;
                margin-top: 5px;
                margin-bottom: 10px;
                background-color: hsl(310, 50%, 20%);
                border-radius: 0 24px 24px 0;
                vertical-align: middle;
                border: 3px solid hsl(0, 0%, 80%);
                border-left: none;
                outline: none;
                cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            .checkbox-rightwall:checked {
                background-color: hsl(310, 50%, 50%)}

                
    /*  RADIO BUTTONS  -------------------------------------------------------- */

            .radio:hover {opacity: 1}
            .radio {-webkit-appearance: none;
                appearance: none;
                padding: 0px;
                border: 0px;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 20px;
                height: 20px;
                border-radius: 10px;
                background-color: hsl(0, 0%, 20%);
                opacity: 0.7;
                border: 4px solid hsl(0, 0%, 60%);
				cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            .radio:checked {
                background-color:hsl(300, 60%, 50%);
            }

            .radio2:hover {opacity: 1}
            .radio2 {-webkit-appearance: none;
                appearance: none;
                padding: 0px;
                border: 0px;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 20px;
                height: 20px;
                border-radius: 10px;
                background-color: hsl(0, 0%, 20%);
                opacity: 0.7;
                border: 4px solid hsl(0, 0%, 60%);
				cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            .radio2:checked {
                background-color: hsl(350, 80%, 60%);
            }

            /* Gravity radios: ➲ (U+27B2) icon; rotate for down */
            input.radio-gravity:hover { opacity: 1; filter: brightness(1.05); }
            input.radio-gravity {
                -webkit-appearance: none;
                appearance: none;
                opacity: 0.95;
                width: 24px;
                height: 24px;
                margin-top: 5px;
                margin-bottom: 10px;
                border-radius: 50%;
                vertical-align: middle;
                border: none !important;
                outline: none;
                cursor: pointer;
                background: transparent !important;
                box-shadow: none !important;
                position: relative;
                display: inline-block;
                /* Tunables (blue theme) */
                --grav-dim:    hsl(220, 35%, 20%);
                --grav-bright: hsl(220, 80%, 50%);
            }
            input.radio-gravity::after {
                content: "\27A1"; /* ➲ */
                position: absolute;
                left: 50%;
                top: 60%;
                transform: translate(-50%, -56%) rotate(0deg);
                font-size: 30px;
                line-height: 1;
                color: var(--grav-dim);
                pointer-events: none;
                text-shadow: 3px 4px 10px hsl(0, 0%, 0%);
                transition: color 120ms ease, filter 120ms ease;
            }
            input.radio-gravity:checked::after { color: var(--grav-bright); }
            /* Down variant rotates the arrow */
                input.radio-gravity-down::after {
                    transform: translate(-50%, -56%) rotate(90deg);
                    /* Mirror the horizontal arrow's shadow across the vertical axis */
                    text-shadow: 3px -4px 10px hsl(0, 0%, 0%);
                }
            
            input.radio-umbrella::after {
            content: "\2602"; /* ☂ umbrella */
            position: absolute;
            left: 50%;
            top: 60%;
            transform: translate(-50%, -56%);
            font-size: 26px;
            line-height: 1;
            color: var(--umb-dim);
            pointer-events: none;
            text-shadow: 3px 4px 10px hsl(0, 0%, 0%);
            transition: color 120ms ease, filter 120ms ease;
            }
            input.radio-umbrella:checked::after { color: var(--umb-bright); }


            /* Umbrella-styled radio for Shower control (uses U+2602) */
            input.radio-umbrella:hover { opacity: 1; filter: brightness(1.05); }
            input.radio-umbrella {
                -webkit-appearance: none;
                appearance: none;
                opacity: 0.95;
                width: 24px;
                height: 24px;
                margin-top: 5px;
                margin-bottom: 10px;
                border-radius: 50%;
                vertical-align: middle;
                border: none !important;
                outline: none;
                cursor: pointer;
                background: transparent !important;
                box-shadow: none !important; /* icon carries the shadow */
                position: relative; /* anchor for ::after */
                display: inline-block;
                /* Tunables */
                /* Match spawn slider red theme */
                --umb-dim:   hsl(350, 40%, 35%);  /* dim red (unchecked) */
                --umb-bright: hsl(350, 70%, 50%);  /* bright red (checked) */
            }

            /* Fountain-styled radio for Mr. Mister: face with two eyes and an elliptical mouth */
            input.radio-fountain:hover { opacity: 1; filter: brightness(1.05); }
            input.radio-fountain {
                -webkit-appearance: none;
                appearance: none;
                opacity: 0.95;
                width: 36px;   /* 1.5x overall size */
                height: 36px;  /* 1.5x overall size */
                margin-top: 5px;
                margin-bottom: 10px;
                border-radius: 50%;
                vertical-align: middle;
                border: none !important;
                outline: none;
                cursor: pointer;
                background: transparent !important;
                box-shadow: none !important;
                position: relative;
                display: inline-block;
                /* Match original fountain (.radio) magenta theme */
                --fnt-dim:    hsl(300, 40%, 35%);
                --fnt-bright: hsl(300, 60%, 50%);
            }
            /* Eyes (two short horizontal lines) */
            input.radio-fountain::before {
                content: "";
                position: absolute;
                left: 50%;
                top: 22%;
                transform: translate(-50%, -50%);
                width: 24px;  /* wider container for separated eyes */
                height: 12px; /* scaled with size */
                color: var(--fnt-dim); /* used via currentColor in gradients */
                background:
                    /* two horizontal eye lines; moved further apart by reducing insets */
                    linear-gradient(currentColor, currentColor) left 0px center / 7px 2px no-repeat,
                    linear-gradient(currentColor, currentColor) right 0px center / 7px 2px no-repeat;
                pointer-events: none;
                filter: drop-shadow(-3px 4px 4px hsl(0, 0%, 0%));
                transition: color 120ms ease, filter 120ms ease;
            }
            input.radio-fountain:checked::before { color: var(--fnt-bright); }

            /* Mouth (elliptical) */
            input.radio-fountain::after {
                content: "";
                position: absolute;
                left: 50%;
                top: 64%;
                transform: translate(-50%, -50%);
                width: 15px;  /* slightly narrower mouth */
                height: 10px; /* 1.5x mouth height (rounded) */
                border-radius: 50% / 60%;
                color: var(--fnt-dim); /* currentColor applied to border */
                background: transparent; /* outline only, no fill */
                border: 2px solid currentColor;
                pointer-events: none;
                filter: drop-shadow(-3px 4px 4px hsl(0, 0%, 0%));
                transition: color 120ms ease, filter 120ms ease;
            }
            input.radio-fountain:checked::after { color: var(--fnt-bright); background: currentColor; }

            .radio-cluster:hover {opacity: 1}
            .radio-cluster {-webkit-appearance: none;
                appearance: none;
                padding: 0px;
                border: 0px;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 28px;
                height: 28px;
                border-radius: 14px;
                background-color: hsl(0, 0%, 20%);
                opacity: 0.7;
                border: 4px solid hsl(108, 60%, 55%);
				cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            .radio-cluster:checked {
                background-color: hsl(108, 50%, 30%);
            }

            .radio-array:hover {opacity: 1}
            .radio-array {-webkit-appearance: none;
                appearance: none;
                padding: 0px;
                border: 0px;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 26px;
                height: 26px;
                border-radius: 0px;
                background-color: hsl(0, 0%, 20%);
                opacity: 0.7;
                border: 3px solid hsl(108, 60%, 55%);
				cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            .radio-array:checked {
                background-color: hsl(108, 50%, 30%);
            }

            .radio-green:hover {opacity: 1}
            .radio-green {-webkit-appearance: none;
                appearance: none;
                padding: 0px;
                border: 0px;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 20px;
                height: 20px;
                border-radius: 10px;
                background-color: hsl(0, 0%, 20%);
                opacity: 0.7;
                border: 4px solid hsl(0, 0%, 60%);
				cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            .radio-green:checked {
                background: hsl(90, 70%, 50%);
            }

            .radio-blue:hover {opacity: 1}
            .radio-blue {-webkit-appearance: none;
                appearance: none;
                padding: 0px;
                border: 0px;
                vertical-align: middle;
                margin-top: 5px;
                margin-bottom: 10px;
                width: 20px;
                height: 20px;
                border-radius: 10px;
                background-color: hsl(0, 0%, 20%);
                opacity: 0.7;
                border: 4px solid hsl(0, 0%, 60%);
				cursor: pointer;
                box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
            .radio-blue:checked {
                background-color: hsl(220, 80%, 50%);
            }
            
		</style>
	</head>
<body> 

	<!-- <body style="background: hsl(0, 0%, 10%); background-attachment: fixed; margin-left: 0px;"> -->
    <body style="background: linear-gradient(to bottom, hsl(0, 0%, 0%) 0%, hsl(195, 64%, 8%) 100%); background-attachment: fixed; margin-left: 0px;"> 
    <canvas id="myCanvas" style="border:0px solid hsl(0, 0%, 50%); margin-left: 10px"></canvas>

    <h3><br><br></h3>
    /go&#8594
    <input type="radio" title="Round Cluster Start" name="rackemType" id="cluster" class="radio-cluster" onclick="makeBalls()">
    <input type="radio" title="Square Array Start" name="rackemType" id="array" class="radio-array" onclick="makeBalls()" checked>
    <input type="checkbox" title="Implode (Hold)" id="implodeButton" class="implodeButton" onmousedown="startContinuousImplode()" onmouseup="stopContinuousImplode()" onmouseleave="stopContinuousImplode()" ontouchstart="startContinuousImplode()" ontouchend="stopContinuousImplode()">
    <!--<input type="checkbox" title="Explode" id="splodeButton" class="splodeButton" onclick="fireSplode()">-->
    <!--<input type="checkbox" title="Unravel" id="unravelButton" class="unravelButton" onclick="fireUnravel()">-->
    <input type="checkbox" title="Pause" id="x" value="false" class="checkbox-pause" onclick="pause()" unchecked>
    
    /walls&#8594
    <input type="range"  title="Corner Radius" id="cornerRadiusSlider" min="0" max="200" value="100" list="detents"class="slider-corner-detent">
    <i>u</i><input type="checkbox" title="Ceiling" id="ceilingButton" class="checkbox-ceiling" checked>
    <i>d</i><input type="checkbox" title="Floor" value="F" id="floorButton"  class="checkbox-floor" checked>
    <i>l</i><input type="checkbox" title="Left Wall" id="leftWallButton" class="checkbox-leftwall" checked>
    <i>r</i><input type="checkbox" title="Right Wall" id="rightWallButton" class="checkbox-rightwall" checked>
    
    /particles&#8594
    <input type="range" title="Set Number of Particles (Slider ranges from 2 to 100, #=n^2)" id="ballsSlider" min="2" max="100" value="70" class="slider-particle-count">
    <i>#</i><span id="particleCountDisplay" title="Number of Particles"class="particle-count-display">4900</span>
    <i>sm</i><input type="number" title="Minimum Ball Radius (will ignore if '0')" id="smallBallInput" min="0" value="3" class="field-cyan-short">
	<i>lg</i><input type="number" title="Maximum Ball Radius" id="bigBallInput" min="1" value="12" class="field-cyan-short">
    <!-- Hidden ballsInput element for compatibility with existing code -->
    <input type="hidden" id="ballsInput" value="4900">

    <select title="Particle Style" id="renderType" class="field-cyan2">
        <optgroup label="Particle Style">
            <option value="drawSpheres">spheres</option>
            <option value="drawDiscs" selected>discs</option>
            <option value="drawCircles">circles</option>
            <option value="drawGummies">gummies</option>
        </optgroup>
    </select>
   
    <span style="white-space: nowrap">
    /time&#8594
    <input type="range"  title="Time  ::  <--- Slower : Normal" id="timeSlider" min="40" max="100" value="100" class="slider-mint"></span>
    
    <span style="white-space: nowrap">
    /gravity&#8594
    <i>d</i><input type="radio" title="Down" name="gravityType" id="gravityDown" class="radio-blue radio-gravity radio-gravity-down" checked>
    <i>r</i><input type="radio" title="Right" name="gravityType" id="gravityRight" class="radio-blue radio-gravity">
    <input type="range"  title="Gravity  ::  Zero Gravity : More Gravity --->" id="gravitySlider" min="0" max="100" value="0" class="slider-blue"></span>
    
    <span style="white-space: nowrap">
    /repulsion&#8594
    <input type="checkbox" title="Repulsion on/off" id="repulsionButton" class="checkbox-repulsion" checked>
    <input type="range"  title="Repulsion Force between Particles" id="repulsionForceSlider" min="1" max="20" value="20" class="slider-lime">
    
    /bounce&#8594
    <input type="range"  title="Ball Restitution on Collision" id="ballRestSlider" min="0" max="100" value="0" class="slider-lime2"></span>
    
    <span style="white-space: nowrap">
    /trace&#8594
    <input type="checkbox" title="Trace on/off" id="noTracerButton" class="checkbox-tracer" checked>
    <input type="radio" name="traceType" title="Small Particle Trace" id="smallTracerButton" class="checkbox-tracer-small">
    <input type="radio" name="traceType" title="Medium Particle Trace" id="mediumTracerButton" class="checkbox-tracer-medium" checked>
    <input type="radio" name="traceType" title="Big Particle Trace" id="bigTracerButton" class="checkbox-tracer-large"></span>

    <span style="white-space: nowrap">
    /pucks&#8594
    <input type="checkbox" title="Pucks on/off" id="showPuckButton" value="true" class="checkbox-puck" checked>
    <input type="checkbox" title="Cycle puck on/off" id="showCyclePuckButton" class="checkbox-cycle" unchecked>
    <input type="checkbox" title="Heartbeat on/off" id="showHeartButton" class="checkbox-heart" unchecked>
    <input type="range"  title="Puck Radius" id="puckRadiusSlider" min="100" max="1000" value="300" class="slider-cyan"></span>
    
    <span style="white-space: nowrap">
    /eaters&#8594
    <input type="checkbox" title="Eaters on/off" id="showHungryPuckButton" class="checkbox-blue-dark" unchecked></span>
    
    <span style="white-space: nowrap">
    /worm&#8594
    <input type="checkbox" title="Worm on/off" id="wormButton" class="checkbox-worm" checked>
    <input type="range"  title="Worm Tail Radius" id="wormEndRadiusSlider" min="40" max="300" value="40" class="slider-orange">
    <input type="range"  title="Worm Head Radius" id="wormStartRadiusSlider" min="70" max="300" value="150" class="slider-orange">
    <input type="range"  title="Worm Segments" id="wormNumNodesSlider" min="3" max="30" value="10" class="slider-orange-horiz"></span>

    <span style="white-space: nowrap">
    /plinko&#8594
    <input type="checkbox" title="Pegs on/off" id="showBumperEntry" value="false" class="checkbox-bumper" unchecked>
    <input type="range"  title="Peg Rows" id="rowsInput" min="1" max="20" value="3" class="slider-yellow">
    <input type="range"  title="Peg Radius" id="bumperRadiusInput" min="20" max="100" value="40" class="slider-yellow"></span>

    <span style="white-space: nowrap">
    /recycle&#8594
    <input type="checkbox" title="One Shot (no respawn)" id="oneShotButton" value="false" class="checkbox-oneshot" unchecked></span>
    <span style="white-space: nowrap">
    /&#8594&#8594
    <input type="range"  title="Shower Width" id="dumpSlider" min="1" max="100" value="40" class="slider-redspawn2">
    <input type="range"  title="Shower Position" id="dumpMoveSlider" min="-50" max="50" value="0" class="slider-redspawn">
    shower 
    <input type="radio" title="Shower" name="spawnType" id="shower" value="shower" class="radio2 radio-umbrella" unchecked></span>
    
    <span style="white-space: nowrap">
    &#8592 or &#8594<input type="radio" title="Mr. Mister" name="spawnType" id="fountain" value="fountain" class="radio radio-fountain" checked>
    mr.mister
    <input type="range"  title="Yeet" id="yeetSlider" min="0" max="600" value="250" class="slider-purple-short">
    <input type="range"  title="Sweep" id="sprinklerSpeedSlider" min="0" max="30" value="0" class="slider-pink">
    
    <select title="Mr. Mister Mode" name="misterMode" id="misterMode" class="field-purple">
        <optgroup label="Mr. Mister Motion">
            <option value="idle" selected>mouse</option>
            <option value="worm">worm</option>
            <option value="scanner" >scan</option>
            <option value="printer">printer</option>
            <option value="typewriter">typewriter</option>
            <option value="circle">circle</option>
            <option value="oval">oval</option>
            <option value="bernoulli">figure-8</option>
            <option value="billiard">pong</option>
        </optgroup>
    </select>
    <input type="range"  title="Mr. Mister Orbit Speed" id="misterSpeedSlider" min="10" max="200" value="100" class="slider-purple-short">
    &#8592&#8592\
    </span>

    <span style="white-space: nowrap">
    /color&#8594
    <i>h</i><input type="range"  title="Base Hue" id="baseColorSlider" min="0" max="330" value="220" class="slider-red2">
    <i>v</i><input type="range"  title="Velocity Sensitivity" id="velColorMapSlider" min="1" max="500" value="200" class="slider-red">
    <i>s</i><input type="range"  title="Saturation" id="saturationSlider" min="0" max="100" value="90" class="slider-lightred">
    <i>l</i><input type="range"  title="Lightness" id="lightnessSlider" min="5" max="100" value="40" class="slider-red">
    <i>&#9996</i><input type="range"  title="Persistence of Vision" id="persistenceSlider" min="0" max="30" value="12" class="slider-red">
    
    <input type="button" title="Restart [r]" class="buttongreenbig" value="&#8629" onclick="makeBalls()"></span>
    
    <h2><br></h2><h1>:: SL0SH :: repulsive particle simulation ::</h1>

<script>

    // Gummi Bear image for ball rendering (scaled to ball radius)
    var gummiImage = new Image();
    var gummiReady = false;
    var doGummi = false; // fourth ball rendering style
    // Faster response = smaller tau; controls heading smoothing speed (seconds)
    var gummiHeadingTau = 0.05;
    // Orientation offset so the TOP of the image leads along the velocity vector
    var gummiHeadingOffset = Math.PI / 2;
    gummiImage.onload = function() { gummiReady = true; };
    // Image file is in the same folder
    gummiImage.src = 'gummibear_bw.png';

    //  CANVAS SETUP AND SCALING --------------------------------------------------------------
    canvas = document.getElementById("myCanvas");
    c = canvas.getContext("2d");
    canvas.style.cursor = "pointer";
    
    // Get reference to hidden ballsInput element
    ballsInput = document.getElementById("ballsInput");
    
    if (window.innerWidth < window.innerHeight) {
        // vertical orientation
        screenVertical = true;
        ballsInput.value = 1600;
        if (typeof syncParticleCountControls === 'function') syncParticleCountControls();
        canvas.width = window.innerWidth - 40;
        canvas.height = window.innerHeight - 140; 
    } else if (window.innerWidth > 1.75 * window.innerHeight) {
        // wide screen
        screenVertical = false;
        canvas.width = window.innerWidth - 40;
        canvas.height = window.innerHeight - 20;
    } else {
        // normal
        screenVertical = false;
        canvas.width = window.innerWidth - 40;
        canvas.height = window.innerHeight - 220;
    }
    simMinWidth = 2.0;
    cScale = Math.min(canvas.width, canvas.height) / simMinWidth;
    simWidth = canvas.width / cScale;
    simHeight = canvas.height / cScale;
    topMargin = 0;
    bottomMargin = 0;

    // Responsive resize handling: recompute canvas size and restart simulation WITHOUT reloading page
    // (preserves all current UI control states: sliders, checkboxes, radios, selects)
    let _resizeDebounce = null;
    function handleResizeRestart() {
        // Snapshot current relative positions of pucks and related actors before dimensions change
        const oldSimWidth = simWidth;
        const oldSimHeight = simHeight;
        const puckSnapshots = (typeof Puck !== 'undefined' && Array.isArray(Puck)) ? Puck.map(p => ({ p, rx: p.pos.x / oldSimWidth, ry: p.pos.y / oldSimHeight })) : [];
        const hungrySnapshots = (typeof Hungrypuck !== 'undefined' && Array.isArray(Hungrypuck)) ? Hungrypuck.map(p => ({ p, rx: p.pos.x / oldSimWidth, ry: p.pos.y / oldSimHeight })) : [];
        const misterSnapshots = (typeof MisterMister !== 'undefined' && Array.isArray(MisterMister)) ? MisterMister.map(p => ({ p, rx: p.pos.x / oldSimWidth, ry: p.pos.y / oldSimHeight })) : [];
        // (If later we need worm node preservation, we can snapshot here similarly.)
        // Determine orientation & set canvas dimensions (mirrors initial logic)
        if (window.innerWidth < window.innerHeight) {
            screenVertical = true;
            canvas.width  = window.innerWidth - 40;
            canvas.height = window.innerHeight - 140; 
        } else if (window.innerWidth > 1.75 * window.innerHeight) {
            screenVertical = false;
            canvas.width  = window.innerWidth - 40;
            canvas.height = window.innerHeight - 20;
        } else {
            screenVertical = false;
            canvas.width  = window.innerWidth - 40;
            canvas.height = window.innerHeight - 220;
        }
        // Recompute simulation scaling & world dimensions
        cScale    = Math.min(canvas.width, canvas.height) / simMinWidth;
        simWidth  = canvas.width / cScale;
        simHeight = canvas.height / cScale;
        if (typeof physProps === 'object' && physProps.worldSize) {
            physProps.worldSize.x = simWidth;
            physProps.worldSize.y = simHeight;
        }
        // Helper clamp to keep actors within new bounds (optional: allow slight overshoot)
        function clampActorPos(actor) {
            if (!actor || !actor.pos) return;
            if (actor.pos.x < 0) actor.pos.x = 0;
            if (actor.pos.x > simWidth) actor.pos.x = simWidth;
            if (actor.pos.y < 0) actor.pos.y = 0;
            if (actor.pos.y > simHeight) actor.pos.y = simHeight;
        }
        // Re-apply preserved relative positions to pucks & friends using NEW sim dimensions
        puckSnapshots.forEach(s => { s.p.pos.x = s.rx * simWidth; s.p.pos.y = s.ry * simHeight; clampActorPos(s.p); });
        hungrySnapshots.forEach(s => { s.p.pos.x = s.rx * simWidth; s.p.pos.y = s.ry * simHeight; clampActorPos(s.p); });
        misterSnapshots.forEach(s => { s.p.pos.x = s.rx * simWidth; s.p.pos.y = s.ry * simHeight; clampActorPos(s.p); });
        // Rebuild gradient matching background for new geometry
        updateCornerFillGradient();
        // Clear existing frame
        c.fillStyle = 'hsl(0, 0%, 0%)';
        c.fillRect(0, 0, canvas.width, canvas.height);
        // Recreate geometry dependent on dimensions
    if (typeof makeCorners === 'function') makeCorners();
    if (typeof makeBumpers === 'function') makeBumpers();
        // Restart dynamic actors & particles
    if (typeof makeBalls === 'function') makeBalls();
    if (typeof syncParticleCountControls === 'function') syncParticleCountControls();
    if (typeof makeWorm === 'function' && typeof doWorm !== 'undefined' && doWorm) { makeWorm(); }
        // Re-select tracer if tracing enabled so trail restarts cleanly
        if (typeof selectTracerBall === 'function' && typeof doTracer !== 'undefined') {
            if (doTracer && (doSmallTracer || doMediumTracer || doBigTracer)) {
                selectTracerBall();
            }
        }
    }
    window.addEventListener('resize', () => {
        if (_resizeDebounce) clearTimeout(_resizeDebounce);
        _resizeDebounce = setTimeout(handleResizeRestart, 150); // debounce to avoid rapid churn
    });
    // Gradient used to fill canvas corners/masks to match page background
    let cornerFillGradient = null;
    // Tunables
    const heartResumeDelayMs = 1500; // Pause after release/toggle before heartbeat resumes
    function updateCornerFillGradient() {
        // Align the canvas gradient with the page's background gradient (to bottom)
        // using viewport-relative coordinates so the transition is seamless.
        const rect = canvas.getBoundingClientRect();
        const y0 = -rect.top;                 // where the canvas starts relative to viewport (px)
        const y1 = y0 + window.innerHeight;   // viewport bottom relative to canvas
        const g = c.createLinearGradient(0, y0, 0, y1);
        // Match body CSS: linear-gradient(to bottom, hsl(0, 0%, 0%) 0%, hsl(195, 64%, 8%) 100%)
        g.addColorStop(0.0, 'hsl(0, 0%, 0%)');
        g.addColorStop(1.0, 'hsl(195, 64%, 8%)');
        cornerFillGradient = g;
    }
    // Initialize gradient now
    updateCornerFillGradient();
    // Keep it updated on scroll (viewport relative) for a fixed page background
    window.addEventListener('scroll', updateCornerFillGradient, { passive: true });
    
    //  KEYBOARD SHORTCUTS -----------------------------------------------------
    
    document.addEventListener('keydown', event => {
        switch(event.key) {
            case 'n': physProps.paused = false; simulate(); physProps.paused = true; break;
            case 'N': physProps.paused = false; simulate(); physProps.paused = true; break;
            case 'm': physProps.paused = !physProps.paused; break;
            case 'M': physProps.paused = !physProps.paused; break;
            case 'p': physProps.paused = !physProps.paused; break;
            case 'P': physProps.paused = !physProps.paused; break;
            case 'r': forcedWipeRestart();
            case 'R': forcedWipeRestart();
        }
    });

    //  GET WORLD PROPERTIES FROM SLIDERS ---------------------------------------------
    
    document.getElementById("timeSlider").oninput = function() {
        physProps.dt = 1 / (Math.floor(Math.exp(((140 - timeSlider.value) / 10))) + 6);}
    document.getElementById('persistenceSlider').oninput = function() {
        persistence = persistenceSlider.value;}
    document.getElementById("gravitySlider").oninput = function() {
        if (gravityDown.checked == true) {
            physProps.gravity = new Vector2(0, 1 + -1 * (2 ** (gravitySlider.value/100)));
        } else if (gravityRight.checked == true) {
            physProps.gravity = new Vector2(1 * (2 ** (gravitySlider.value/100)), 0);}}
    document.getElementById("gravityDown").oninput = function() {
        doGravityDown = true;
        doGravityRight = false;
        physProps.gravity = new Vector2(0, 1 + -1 * (2 ** (gravitySlider.value/100)))}  
    document.getElementById("gravityRight").oninput = function() {
        doGravityDown = false;
        doGravityRight = true;
        physProps.gravity = new Vector2(1 * (2 ** (gravitySlider.value/100)), 0);}
    document.getElementById("shower").oninput = function() {
        if (gravityDown.checked == true) {
            physProps.gravity = new Vector2(0, 1 + -1 * (10 ** (gravitySlider.value/100)));
        } else if (gravityRight.checked == true) {
            physProps.gravity = new Vector2(1 + 1 * (10 ** (gravitySlider.value/100)), 0);}
            var puck1 = Hungrypuck[0];
            var puck2 = Hungrypuck[1];
            puck1.pos.y = -0.1 * puck1.radius;
            puck2.pos.y = -0.1 * puck2.radius;
            doShower = true;
            doFountain = false;}
    document.getElementById("fountain").oninput = function() {
        if (gravityDown.checked == true) {
            physProps.gravity = new Vector2(0, 1 + -1 * (10 ** (gravitySlider.value/100)));
        } else if (gravityRight.checked == true) {
            physProps.gravity = new Vector2(1 + 1 * (10 ** (gravitySlider.value/100)), 0);
        }
        var puck1 = Hungrypuck[0];
        var puck2 = Hungrypuck[1];
        puck1.pos.y = -0.1 * puck1.radius;
        puck2.pos.y = -0.1 * puck2.radius;
        doShower = false;
        doFountain = true;}
    document.getElementById("ballRestSlider").oninput = function() {
        // Logarithmic growth mapping for fine control near 1.0
        // t in [0,1], ballRest in [0,1]
        const t = parseFloat(this.value) / 100;
        const k = 1000000; // shape parameter; ~0.95 at midpoint when k≈1e6
        physProps.ballRest = Math.log(1 + k * t) / Math.log(1 + k);
        if (ballRestSlider.value < 1) {
            physProps.ballRest = 0;}}
    document.getElementById('repulsionButton').oninput = function() {
        if (repulsionButton.checked == true) {  
            ballRepulsion = true;
        } else {
            ballRepulsion = false;}}
    document.getElementById("repulsionForceSlider").oninput = function() {
	    physProps.repulsionForce = repulsionForceSlider.value / 10;}
    document.getElementById("velColorMapSlider").oninput = function() {
        physProps.velColorMap = velColorMapSlider.value;}
    document.getElementById("baseColorSlider").oninput = function() {
        physProps.baseColor = baseColorSlider.value * 1;}
    document.getElementById("ballsInput").onchange = function() {
        makeBalls();}
    
    // Particle count slider handlers
    document.getElementById("ballsSlider").oninput = function() {
        var sliderValue = this.value;
        var particleCount = sliderValue * sliderValue;
        document.getElementById("particleCountDisplay").textContent = particleCount;
    };
    
    document.getElementById("ballsSlider").onmouseup = function() {
        var sliderValue = this.value;
        var particleCount = sliderValue * sliderValue;
        // Update the hidden ballsInput value for compatibility
        ballsInput.value = particleCount;
        makeBalls();
    };
    
    // Handle keyboard events on slider
    document.getElementById("ballsSlider").onkeyup = function() {
        var sliderValue = this.value;
        var particleCount = sliderValue * sliderValue;
        // Update the hidden ballsInput value for compatibility
        ballsInput.value = particleCount;
        makeBalls();
    };
    
    // Helper function to sync slider and display with ballsInput value
    function syncParticleCountControls() {
        var particleCount = ballsInput.value * 1;
        var sliderValue = Math.round(Math.sqrt(particleCount));
        
        // Clamp slider value to valid range
        sliderValue = Math.max(2, Math.min(100, sliderValue));
        
        // Update slider position and display
        document.getElementById("ballsSlider").value = sliderValue;
        document.getElementById("particleCountDisplay").textContent = sliderValue * sliderValue;
    }
    
    document.getElementById("saturationSlider").oninput = function() {
        ballSaturation = saturationSlider.value * 1;}
     document.getElementById("lightnessSlider").oninput = function() {
        ballLightness = lightnessSlider.value * 1;}
    document.getElementById("misterSpeedSlider").oninput = function() {
        misterSpeed = misterSpeedSlider.value / 100;}
    document.getElementById("dumpSlider").oninput = function() {
        dumpSqueeze = dumpSlider.value / 100;}
    document.getElementById("dumpMoveSlider").oninput = function() {
        dumpShift = dumpMoveSlider.value / 100 * simWidth;}
    document.getElementById("rowsInput").oninput = function() {
        makeBumpers();}
    document.getElementById("bumperRadiusInput").oninput = function() {
        makeBumpers();}
    document.getElementById("smallBallInput").oninput = function() {
        makeBalls();}
    document.getElementById("bigBallInput").oninput = function() {
        makeBalls();}
    document.getElementById("cluster").oninput = function() {
        makeBalls();}
    document.getElementById("array").oninput = function() {
        makeBalls();}
    document.getElementById("showHungryPuckButton").oninput = function() {
        if (showHungryPuckButton.checked == true)
        fountain.checked = true;}
    document.getElementById('showBumperEntry').oninput = function() {
        if (showBumperEntry.checked == true) {
            showBumpers = true;
        } else {
            showBumpers = false;}}
    document.getElementById('showHungryPuckButton').oninput = function() {
        if (showHungryPuckButton.checked == true) {
            showEaters = true;
        } else {
            showEaters = false;}}
    document.getElementById('showPuckButton').oninput = function() {
        if (showPuckButton.checked == true) {
            for (var p = 0; p < Puck.length; p++) {
                if (Puck[p].special !== true && Puck[p].cycle !== true) {
                    Puck[p].radius = 0;
                    Puck[p].puckArriving = true;
                }
            }
            showPucks = true;
        } else {
            showPucks = false;}}
    document.getElementById('showHeartButton').oninput = function() {
        if (showHeartButton.checked == true) {
            // find heart puck by property
            for (var p = 0; p < Puck.length; p++) {
                if (Puck[p].special === true) {
                    Puck[p].radius = 0;
                    Puck[p].puckArriving = true;
                    // Reset heartbeat timing and insert a 1s delay before resuming pulses
                    const nowPerf = performance.now();
                    Puck[p].hbResumeAt = nowPerf + heartResumeDelayMs;
                    Puck[p].hbState = 'pause';
                    Puck[p].hbTimeInState = 0.0;
                    Puck[p].hbLastTime = nowPerf;
                    Puck[p].radius = Puck[p].OGradius;
                    break;
                }
            }
            showHeart = true;
        } else {
            showHeart = false;}}
    document.getElementById('showCyclePuckButton').oninput = function() {
        if (showCyclePuckButton.checked == true) {
            // trigger arrival effect on cycle puck(s)
            for (var p = 0; p < Puck.length; p++) {
                if (Puck[p].cycle === true) {
                    // Hold at base for a short delay before resuming cycle (mirror post-drag behavior)
                    const nowPerf = performance.now();
                    Puck[p].cycResumeAt = nowPerf + 3000; // 3s pause on toggle-on
                    Puck[p].cycState = 'grow';
                    Puck[p].cycTimeInState = 0.0;
                    Puck[p].cycLastTime = nowPerf;
                    Puck[p].radius = Puck[p].OGradius; // ensure base size during pause
                }
            }
            showCycle = true;
        } else {
            showCycle = false;
        }
    }
    document.getElementById('puckRadiusSlider').oninput = function() {
        for (p = 0; p < Puck.length; p++) {
            puck = Puck[p];
            if (p == 0) {
                puck.radius = 1.0 * puckRadiusSlider.value / 1000;
                puck.OGradius = puck.radius;
            }
            if (p == 1 || p == 2 || p == 3) {
                puck.radius = 0.5 * puckRadiusSlider.value / 1000;
                puck.OGradius = puck.radius;}}}
    document.getElementById('cornerRadiusSlider').oninput = function() {
        cornerRad = 1 * cornerRadiusSlider.value;
        if (cornerRadiusSlider.value < 100) {
            for (var c = 0; c < Corners.length; c++) {
                corner = Corners[c]; 
                if (screenVertical == true) {
                    corner.radius = 0.01 * cornerRad * 0.5 * simWidth;
                } else {
                    corner.radius = 0.01 * cornerRad * 0.5 * simHeight;
                }
                if (corner.corner == 'northwest' || corner.corner == 'southwest') {
                    corner.pos.x = 0;
                } else if (corner.corner == 'northeast' || corner.corner == 'southeast') {
                    corner.pos.x = simWidth;}}
        } else {
            for (var c = 0; c < Corners.length; c++) {
                corner = Corners[c]; 
                if (screenVertical == true) {
                    corner.radius = 0.5 * simWidth;
                } else {
                    corner.radius = 0.5 * simHeight;
                }
                // shift corners
                // calculate distance between corners
                var cornerSeparation = simWidth - 2 * corner.radius;
                var cornerClosureRatio = 1 - 0.01 * (200 - cornerRadiusSlider.value);
                var maximumShift = 0.5 * simWidth - corner.radius;
                var shiftAmount = Math.min(maximumShift, cornerSeparation * cornerClosureRatio);
                
                if (cornerClosureRatio > 0) {
                    if (corner.corner == 'northwest' || corner.corner == 'southwest') {
                        corner.pos.x = shiftAmount;
                    } else if (corner.corner == 'northeast' || corner.corner == 'southeast') {
                        corner.pos.x = simWidth - shiftAmount;}}}}}
    document.getElementById('misterMode').oninput = function() {
        fountain.checked = true;
        doFountain = true;
        if (misterMode.value == "idle") {
            mrMode = 'idle';
        } else if (misterMode.value == "billiard") {
            mrMode = 'billiard';
            mrMr = MisterMister[0];
            mrMr.vel.x = .5;
            mrMr.vel.y = 0.2;
        } else if (misterMode.value == "typewriter") {
            mrMode = 'typewriter';
        } else if (misterMode.value == "printer") {
            mrMode = 'printer';
        } else if (misterMode.value == "scanner") {
            mrMode = 'scanner';
        } else if (misterMode.value == "circle") {
            mrMode = 'circle';
        } else if (misterMode.value == "oval") {
            mrMode = 'oval';
        } else if (misterMode.value == "bernoulli") {
            mrMode = 'bernoulli';
        } else if (misterMode.value == "worm") {
            mrMode = 'worm';
            wormButton.checked = true;
            doWorm = true;}}
    document.getElementById('ceilingButton').oninput = function() {
        if (ceilingButton.checked == true) {
            doCeiling = true;
        } else {
            doCeiling = false;}}
    document.getElementById('floorButton').oninput = function() {
        if (floorButton.checked == true) {
            doFloor = true;
        } else {
            doFloor = false;}}
    document.getElementById('leftWallButton').oninput = function() {
        if (leftWallButton.checked == true) {
            doLeftWall = true;
        } else {
            doLeftWall = false;}}
    document.getElementById('rightWallButton').oninput = function() {
        if (rightWallButton.checked == true) {
            doRightWall = true;
        } else {
            doRightWall = false;}}
    document.getElementById('oneShotButton').oninput = function() {
        if (oneShotButton.checked == true) {
            doOneShot = true;
        } else {
            doOneShot = false;}}
    document.getElementById('yeetSlider').oninput = function() {
        yeet = 1.0 * yeetSlider.value;}
    document.getElementById('wormButton').oninput = function() {
        if (wormButton.checked == true) {
            doWorm = true;
            document.body.classList.add('worm-on');
        } else {
            doWorm = false;
            document.body.classList.remove('worm-on');
        }}
    document.getElementById('wormStartRadiusSlider').oninput = function() {
        WormProps.startRadius = 0.001 * wormStartRadiusSlider.value;
        makeWorm();}
    document.getElementById('wormEndRadiusSlider').oninput = function() {
        WormProps.endRadius = 0.001 * wormEndRadiusSlider.value;
        makeWorm();}
    document.getElementById('wormNumNodesSlider').oninput = function() {
        WormProps.numNodes = 1 * wormNumNodesSlider.value;
        makeWorm();}
    document.getElementById('sprinklerSpeedSlider').oninput = function() {
        sprinklerSpeed = 0.0001 * sprinklerSpeedSlider.value;};
    // Initialize worm UI knob theme on load
    document.body.classList.toggle('worm-on', document.getElementById('wormButton').checked);
    
    document.getElementById('smallTracerButton').oninput = function() {
        doTracer = noTracerButton.checked;
        doSmallTracer = true;
        doMediumTracer = false;
        doBigTracer = false;
        if (doTracer) selectTracerBall();
    }
    document.getElementById('mediumTracerButton').oninput = function() {
        doTracer = noTracerButton.checked;
        doMediumTracer = true;
        doSmallTracer = false;
        doBigTracer = false;
        if (doTracer) selectTracerBall();
    }
    document.getElementById('bigTracerButton').oninput = function() {
        doTracer = noTracerButton.checked;
        doBigTracer = true;
        doMediumTracer = false;
        doSmallTracer = false;
        if (doTracer) selectTracerBall();
    }
    document.getElementById('noTracerButton').oninput = function() {
        if (!noTracerButton.checked) {
            // Master unchecked => cease traces
            doTracer = false;
            // Keep the size selection state, but stop tracing and clear traces
            for (let i = 0; i < Balls.length; i++) {
                if (Balls[i].tracerBall === true) {
                    Balls[i].resetTrace();
                }
                Balls[i].tracerBall = false;
                Balls[i].tracer = false;
            }
        } else {
            // Master checked => enable based on chosen size mode
            doSmallTracer = smallTracerButton.checked;
            doMediumTracer = mediumTracerButton.checked;
            doBigTracer = bigTracerButton.checked;
            if (doSmallTracer || doMediumTracer || doBigTracer) {
                doTracer = true;
                selectTracerBall();
            } else {
                // If none selected, default to medium
                doMediumTracer = true;
                doTracer = true;
                mediumTracerButton.checked = true;
                selectTracerBall();
            }
        }
    }
    
    document.getElementById("renderType").oninput = function() {
       if (this.value === 'drawSpheres') {
            doSpheres = true;
            doDiscs = false;
            doCircles = false;
            saturationSlider.value = 80;
            ballSaturation = 80;
            lightnessSlider.value = 55;
            ballLightness = 45;
            physProps.repulsionDist = 4;
            if (wasGummi == true) {
                ballsInput.value = 4096;
                if (typeof syncParticleCountControls === 'function') syncParticleCountControls();
                bigBallInput.value = 15;
                smallBallInput.value = 3;
                wasGummi = false;
                makeBalls();
            }
       } else if (this.value === 'drawDiscs') {
            doDiscs = true;
            doSpheres = false;
            doCircles = false;
            saturationSlider.value = 90;
            ballSaturation = 90;
            lightnessSlider.value = 40;
            ballLightness = 40;
            physProps.repulsionDist = 4;
            if (wasGummi == true) {
                ballsInput.value = 4096;
                if (typeof syncParticleCountControls === 'function') syncParticleCountControls();
                bigBallInput.value = 15;
                smallBallInput.value = 3;
                repulsionForceSlider.value = 20;
                wasGummi = false;
                makeBalls();
            }
       } else if (this.value === 'drawCircles') {
            doCircles = true;
            doDiscs = false;
            doSpheres = false;
            saturationSlider.value = 100;
            ballSaturation = 100;
            lightnessSlider.value = 70;
            ballLightness = lightnessSlider.value * 1;
            physProps.repulsionDist = 4;
            if (wasGummi == true) {
                ballsInput.value = 4096;
                if (typeof syncParticleCountControls === 'function') syncParticleCountControls();
                bigBallInput.value = 15;
                smallBallInput.value = 3;
                repulsionForceSlider.value = 20;
                wasGummi = false;
                makeBalls();
            }
       } else if (this.value === 'drawGummies') {
            doGummi = true;
            wasGummi = true;
            doDiscs = false;
            doSpheres = false;
            doCircles = false;
            saturationSlider.value = 100;
            ballSaturation = 100;
            lightnessSlider.value = 70;
            ballLightness = lightnessSlider.value * 1;
            physProps.repulsionDist = 1.5;
            ballsInput.value = 225;
            if (typeof syncParticleCountControls === 'function') syncParticleCountControls();
            bigBallInput.value = 80;
            smallBallInput.value = 20;
            repulsionForceSlider.value = 10;
            makeBalls();
        }};

    //  end get world properties from sliders ----------

    //  MOUSE STUFF AND TOUCH STUFF  -------------------------------------------------------------------
    
    let cursorX = simWidth / 2;
    let cursorY = 0;
    let newX = 0, newY = 0, startX = 0, startY = 0;
    let dX = 0, dY = 0; // Mouse offset for dragging
    canvas.addEventListener('mousedown', mouseDownHandler);
    canvas.addEventListener('mouseup', mouseUp);
    canvas.addEventListener('touchstart', touchStartHandler, {passive: false});
    canvas.addEventListener('touchend', touchEndHandler, {passive: false});
    canvas.addEventListener('touchcancel', touchEndHandler, {passive: false});
    // Double-click anywhere on the canvas to restart the simulation without reloading the page
    canvas.addEventListener('dblclick', function() {
        // Clear and rebuild the particle set (preserves UI state)
        if (typeof forcedWipeRestart === 'function') {
            forcedWipeRestart();
        } else if (typeof makeBalls === 'function') {
            makeBalls();
        }
        // If tracing is enabled, reselect the tracer so the trail restarts correctly
        if (typeof selectTracerBall === 'function' && typeof doTracer !== 'undefined') {
            if (doTracer && (doSmallTracer || doMediumTracer || doBigTracer)) {
                selectTracerBall();
            }
        }
    });
    
    function mouseDownHandler(ev) {
        const e = ev || window.event;
    puck1 = Puck[0];
    puck2 = Puck[1];
    puck3 = Puck[2]; // heart (special)
    puck4 = Puck[3]; // cycle
        hungryPuck = Hungrypuck[0];
        hungryPuck2 = Hungrypuck[1];
        misterMister = MisterMister[0];

        bounds = canvas.getBoundingClientRect();
		mX = e.clientX - bounds.left - canvas.clientLeft;
        mY = e.clientY - bounds.top - canvas.clientTop;

		cursorX = mX / cScale;
        cursorY = (canvas.height - mY) / cScale;
        mousePos = new Vector2(cursorX, cursorY);

        startX = e.clientX;
        startY = canvas.height - e.clientY;

        firstCornerX = mX;
        firstCornerY = mY;
        
        // ESTABLISH OBJECT DISTANCES TO MOUSE POSITION  ------------------------
        dirHungryPuck = new Vector2();
		dirHungryPuck.subtractVectors(mousePos, hungryPuck.pos);
		dHungryPuck = dirHungryPuck.length();

        dirHungryPuck2 = new Vector2();
		dirHungryPuck2.subtractVectors(mousePos, hungryPuck2.pos);
		dHungryPuck2 = dirHungryPuck2.length();

        dirMisterMister = new Vector2();
		dirMisterMister.subtractVectors(mousePos, misterMister.pos);
		dMisterMister = dirMisterMister.length();

        dirPuck1 = new Vector2();
		dirPuck1.subtractVectors(mousePos, puck1.pos);
		dPuck1 = dirPuck1.length();

        dirPuck2 = new Vector2();
		dirPuck2.subtractVectors(mousePos, puck2.pos);
		dPuck2 = dirPuck2.length();

    dirPuck3 = new Vector2();
    dirPuck3.subtractVectors(mousePos, puck3.pos);
    dPuck3 = dirPuck3.length();

    dirPuck4 = new Vector2();
    dirPuck4.subtractVectors(mousePos, puck4.pos);
    dPuck4 = dirPuck4.length();

        if (showBumpers == true) {
            // Calculate bumper array bounds if bumpers exist
            var bumperArrayBottom = -Infinity;
            var bumperArrayTop = Infinity;
            if (Bumpers.length > 0) {
                var lowestBumper = Bumpers[0];
                var highestBumper = Bumpers[Bumpers.length - 1];
                bumperArrayBottom = lowestBumper.pos.y - lowestBumper.radius;
                bumperArrayTop = highestBumper.pos.y + highestBumper.radius;
            }
        }
        
    // CHOOSE FOREGROUND OBJECTS UNDER CURSOR TO MOVE  --------------------- 
        if (dMisterMister < misterMister.radius) {
            dX = startX / cScale - misterMister.pos.x;
            dY = startY / cScale - misterMister.pos.y;
            document.addEventListener('mousemove', mouseMisterMisterMove);
            document.addEventListener('touchmove', touchMisterMisterMove, {passive: false});
        } else {
        if (dHungryPuck2 < hungryPuck2.radius) {
            dX = startX / cScale - hungryPuck2.pos.x;
            dY = startY / cScale - hungryPuck2.pos.y;
            document.addEventListener('mousemove', mouseHungryPuck2Move);
            document.addEventListener('touchmove', touchHungryPuck2Move, {passive: false});
        } else {
		if (dHungryPuck < hungryPuck.radius) {
            dX = startX / cScale - hungryPuck.pos.x;
            dY = startY / cScale - hungryPuck.pos.y;
            document.addEventListener('mousemove', mouseHungryPuckMove);
            document.addEventListener('touchmove', touchHungryPuckMove, {passive: false});
        } else {
        if (dPuck3 < puck3.radius) {
            dX = startX / cScale - puck3.pos.x;
            dY = startY / cScale - puck3.pos.y;
            mouseDown = true;
            document.addEventListener('mousemove', mousePuck2Move);
            document.addEventListener('touchmove', touchPuck2Move, {passive: false});
        } else {
        if (dPuck4 < puck4.radius) {
            dX = startX / cScale - puck4.pos.x;
            dY = startY / cScale - puck4.pos.y;
            mouseDown = true;
            document.addEventListener('mousemove', mousePuck3Move);
            document.addEventListener('touchmove', touchPuck3Move, {passive: false});
        } else {
        if (dPuck2 < puck2.radius) {
            dX = startX / cScale - puck2.pos.x;
            dY = startY / cScale - puck2.pos.y;
            mouseDown = true;
            document.addEventListener('mousemove', mousePuck1Move);
            document.addEventListener('touchmove', touchPuck1Move, {passive: false});
        } else {
        if (dPuck1 < puck1.radius) {
            dX = startX / cScale - puck1.pos.x;
            dY = startY / cScale - puck1.pos.y;
            mouseDown = true;
            document.addEventListener('mousemove', mousePuck0Move);
            document.addEventListener('touchmove', touchPuck0Move, {passive: false});
        } else {
        if (showBumpers == true && Bumpers.length > 0 && mousePos.y < bumperArrayTop && mousePos.y > bumperArrayBottom) {
            dY = startY / cScale - (bumperArrayTop + bumperArrayBottom) / 2;
            // Store initial positions of all bumpers for relative movement
            initialBumperPositions = [];
            for (var i = 0; i < Bumpers.length; i++) {
                initialBumperPositions[i] = Bumpers[i].pos.y;
            }
            document.addEventListener('mousemove', mouseBumperMove);
            document.addEventListener('touchmove', touchBumperMove, {passive: false});
        } else {
            // Nothing else selected: update spray direction immediately and start tracking drag
            setNewDir(e);
            mouseDown = true;
            document.addEventListener('mousemove', setNewDir, false);
            document.addEventListener('touchmove', setNewDir, {passive: false});
    }}}}}}}}
    }

    function setNewDir(e) {
        const ev = e || window.event;
        if (!ev) return;
        const rect = canvas.getBoundingClientRect();
        const clientX = ev.clientX;
        const clientY = ev.clientY;
        if (typeof clientX !== 'number' || typeof clientY !== 'number') return;

        // Convert to simulation coordinates
        const mx = (clientX - rect.left - canvas.clientLeft) / cScale;
        const my = (canvas.height - (clientY - rect.top - canvas.clientTop)) / cScale;

    const misterMister = MisterMister[0];
    // Center of particle spawn region (use center, not random). Ignore ball.radius for direction.
    // spawnX center: mr.pos.x - 0.35R + 0.5*(0.9R) = mr.pos.x + 0.10R
    const originX = misterMister.pos.x + 0.10 * misterMister.radius;
    // spawnY center differs by mode:
    //  worm:    mr.pos.y - 0.30R  (from -0.3R - 0.35R + 0.5*0.7R)
    //  default: mr.pos.y - 0.70R  (from -0.65R - 0.35R + 0.5*0.6R)
    const originYOffset = (typeof mrMode === 'string' && mrMode === 'worm') ? 0.30 : 0.70;
    const originY = misterMister.pos.y - originYOffset * misterMister.radius;
    // Angle from spawn-region center to cursor
    misterMister.respawnDir = Math.atan2(my - originY, mx - originX);
    }

    function mouseBumperMove() {
        newY = event.clientY;   
        var currentMouseY = (simHeight - newY / cScale);
        var targetCenterY = currentMouseY - dY;
        var initialCenterY = (initialBumperPositions[0] + initialBumperPositions[initialBumperPositions.length - 1]) / 2;
        var offsetY = targetCenterY - initialCenterY;
        
        for (var t = 0; t < Bumpers.length; t++) {
            bumper = Bumpers[t];
            bumper.pos.y = initialBumperPositions[t] + offsetY;
        }
    }
    function mouseHungryPuckMove() {
        hungryPuck = Hungrypuck[0];
        newX = event.clientX;
        newY = event.clientY;   
        startX = event.clientX;
        startY = event.clientY;
        hungryPuck.pos.x = (newX / cScale) - dX;
        hungryPuck.pos.y = (simHeight - newY / cScale) - dY;
    }
    function mouseHungryPuck2Move() {
        hungryPuck2 = Hungrypuck[1];
        newX = event.clientX;
        newY = event.clientY;   
        startX = event.clientX;
        startY = event.clientY;
        hungryPuck2.pos.x = (newX / cScale) - dX;
        hungryPuck2.pos.y = (simHeight - newY / cScale) - dY;
    }
    function mouseMisterMisterMove() {
        misterMister = MisterMister[0];
        newX = event.clientX;
        newY = event.clientY;   
        startX = event.clientX;
        startY = event.clientY;
        misterMister.pos.x = (newX / cScale) - dX;
        misterMister.pos.y = (simHeight - newY / cScale) - dY;
    }
    function mousePuckMove(p) {
        return function(event) {
            puck = Puck[p];
            newX = event.clientX;
            newY = event.clientY;   
            startX = event.clientX;
            startY = event.clientY;
            puck.puckMoved = true;
            puck.moving = true;
            
            // Store previous position for velocity calculation
            puck.prevPos.set(puck.pos);
            
            // Update position
            puck.pos.x = (newX / cScale) - dX;
            puck.pos.y = (simHeight - newY / cScale) - dY;
            
            // Calculate velocity based on position change
            puck.vel.subtractVectors(puck.pos, puck.prevPos);
            // Scale velocity by frame rate approximation (assuming 60fps)
            puck.vel.scale(60);
        };
    }
    
    // Create the specific puck move functions
    var mousePuck0Move = mousePuckMove(0);
    var mousePuck1Move = mousePuckMove(1);
    var mousePuck2Move = mousePuckMove(2);
    var mousePuck3Move = mousePuckMove(3);
    
    function mouseUp() {
        document.removeEventListener('mousemove', mouseHungryPuckMove);
        document.removeEventListener('mousemove', mouseHungryPuck2Move);
        document.removeEventListener('mousemove', mousePuck0Move);
        document.removeEventListener('mousemove', mousePuck1Move);
        document.removeEventListener('mousemove', mousePuck2Move);
    document.removeEventListener('mousemove', mousePuck3Move);
        document.removeEventListener('mousemove', mouseMisterMisterMove);
        document.removeEventListener('mousemove', mouseBumperMove);
        document.removeEventListener('mousemove', setNewDir);
        
        // Also remove touch move listeners
        document.removeEventListener('touchmove', touchHungryPuckMove);
        document.removeEventListener('touchmove', touchHungryPuck2Move);
        document.removeEventListener('touchmove', touchPuck0Move);
        document.removeEventListener('touchmove', touchPuck1Move);
        document.removeEventListener('touchmove', touchPuck2Move);
    document.removeEventListener('touchmove', touchPuck3Move);
        document.removeEventListener('touchmove', touchMisterMisterMove);
        document.removeEventListener('touchmove', touchBumperMove);
        
        mouseDown = false;
        mouseUpTime = Date.now();
        const nowPerf = performance.now();
        for (var p = 0; p < Puck.length; p++) {
            if (Puck[p].puckMoved == true) {
                Puck[p].puckFadingIn = true;
                Puck[p].puckMoved = false;
                // If this is the special heart puck, reset heartbeat phase and delay 1s before resuming pulses
                if (Puck[p].special === true) {
                    Puck[p].hbResumeAt = nowPerf + heartResumeDelayMs; // delay after release
                    Puck[p].hbState = 'pause';
                    Puck[p].hbTimeInState = 0.0;
                    Puck[p].hbLastTime = nowPerf; // avoid dt spike
                    Puck[p].radius = Puck[p].OGradius; // ensure base size during pause
                }
                // If this is the cycle puck, pause cycling for 3s after release and restart at cycle beginning
                if (Puck[p].cycle === true) {
                    Puck[p].cycResumeAt = nowPerf + 3000; // 3 second delay
                    Puck[p].cycState = 'grow';
                    Puck[p].cycTimeInState = 0.0;
                    Puck[p].cycLastTime = nowPerf; // avoid dt spike
                    Puck[p].radius = Puck[p].OGradius; // hold at base size during pause
                }
            }
            Puck[p].moving = false;
        }
    }

    let touchDown = false;
    
    function touchStartHandler(event) {
        event.preventDefault(); // Prevent scrolling and other default touch behaviors
        
        // Use the first touch point
        var touch = event.touches[0];
        if (!touch) return;
        
        // Create a synthetic event object that mimics the mouse event structure
        var syntheticEvent = {
            clientX: touch.clientX,
            clientY: touch.clientY
        };
        
        // Store the original event object temporarily
        var originalEvent = window.event;
        window.event = syntheticEvent;
        
        // Call the existing mouse down handler
        mouseDownHandler();
        
        // Restore the original event
        window.event = originalEvent;
        
        touchDown = true;
    }
    
    function touchEndHandler(event) {
        event.preventDefault();
        
        if (touchDown) {
            // Remove touch move listeners
            document.removeEventListener('touchmove', touchHungryPuckMove);
            document.removeEventListener('touchmove', touchHungryPuck2Move);
            document.removeEventListener('touchmove', touchPuck0Move);
            document.removeEventListener('touchmove', touchPuck1Move);
            document.removeEventListener('touchmove', touchPuck2Move);
            document.removeEventListener('touchmove', touchMisterMisterMove);
            document.removeEventListener('touchmove', touchBumperMove);
            
            // Call the existing mouse up handler
            mouseUp();
            
            touchDown = false;
        }
    }
    
    // Touch move functions that mirror the mouse move functions
    function touchBumperMove(event) {
        event.preventDefault();
        var touch = event.touches[0];
        if (!touch) return;
        
        var originalEvent = window.event;
        window.event = { clientY: touch.clientY };
        mouseBumperMove();
        window.event = originalEvent;
    }
    
    function touchHungryPuckMove(event) {
        event.preventDefault();
        var touch = event.touches[0];
        if (!touch) return;
        
        var originalEvent = window.event;
        window.event = { clientX: touch.clientX, clientY: touch.clientY };
        mouseHungryPuckMove();
        window.event = originalEvent;
    }
    
    function touchHungryPuck2Move(event) {
        event.preventDefault();
        var touch = event.touches[0];
        if (!touch) return;
        
        var originalEvent = window.event;
        window.event = { clientX: touch.clientX, clientY: touch.clientY };
        mouseHungryPuck2Move();
        window.event = originalEvent;
    }
    
    function touchMisterMisterMove(event) {
        event.preventDefault();
        var touch = event.touches[0];
        if (!touch) return;
        
        var originalEvent = window.event;
        window.event = { clientX: touch.clientX, clientY: touch.clientY };
        mouseMisterMisterMove();
        window.event = originalEvent;
    }
    
    function touchPuckMove(p) {
        return function(event) {
            event.preventDefault();
            var touch = event.touches[0];
            if (!touch) return;
            
            var originalEvent = window.event;
            window.event = { clientX: touch.clientX, clientY: touch.clientY };
            
            puck = Puck[p];
            newX = window.event.clientX;
            newY = window.event.clientY;   
            startX = window.event.clientX;
            startY = window.event.clientY;
            puck.puckMoved = true;
            puck.moving = true;
            
            // Store previous position for velocity calculation
            puck.prevPos.set(puck.pos);
            
            // Update position
            puck.pos.x = (newX / cScale) - dX;
            puck.pos.y = (simHeight - newY / cScale) - dY;
            
            // Calculate velocity based on position change
            puck.vel.subtractVectors(puck.pos, puck.prevPos);
            // Scale velocity by frame rate approximation (assuming 60fps)
            puck.vel.scale(60);
            
            window.event = originalEvent;
        };
    }
    
    // Create the specific touch puck move functions
    var touchPuck0Move = touchPuckMove(0);
    var touchPuck1Move = touchPuckMove(1);
    var touchPuck2Move = touchPuckMove(2);
    var touchPuck3Move = touchPuckMove(3);
    

    //  end mouse and touch stuff
    
	//  BASIC FUNCTIONS -----------------------------------------------------------------------
	
    class Vector2 {
		constructor(x = 0.0, y = 0.0) {
			this.x = x; 
			this.y = y;
		}
		set(v) {
			this.x = v.x; 
            this.y = v.y;
		}
		clone() {
			return new Vector2(this.x, this.y);
		}
		add(v, s=1) {
			this.x += v.x * s;
			this.y += v.y * s;
			return this;
		}
		addVectors(a, b) {
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			return this;
		}
		subtract(v, s = 1.0) {
			this.x -= v.x * s;
			this.y -= v.y * s;
			return this;
		}
		subtractVectors(a, b) {
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			return this;			
		}
		length() {
			return Math.sqrt(this.x * this.x + this.y * this.y);
		}
		scale(s) {
			this.x *= s;
			this.y *= s;
		}
		dot(v) {
			return this.x * v.x + this.y * v.y;
		}
        perp() {
			return new Vector2(-this.y, this.x);
		}
	}

    function closestPointOnSegment(p, a, b) 
	{
		var ab = new Vector2();
		ab.subtractVectors(b, a);
		var t = ab.dot(ab);
		if (t == 0.0)
			return a.clone();
		t = Math.max(0.0, Math.min(1.0, (p.dot(ab) - a.dot(ab)) / t));
		var closest = a.clone();
		return closest.add(ab, t);
	}

    function cX(pos) {
        return pos.x * cScale;
    }
	function cY(pos) {
        return canvas.height - pos.y * cScale;
    }
    
    
    function wipeRestart() {
        c.fillStyle = 'hsl(0, 0%, 0%)';
        c.fillRect(0, 0, canvas.width, canvas.height);
        makeBalls()
    }
    function forcedWipeRestart() {
        c.fillStyle = 'hsl(0, 0%, 0%)';
        c.fillRect(0, 0, canvas.width, canvas.height);
        makeBalls()
    }
    function pause() {
		physProps.paused = !physProps.paused;
        let input = document.querySelectorAll('.checkbox-pause');
        if (physProps.paused == true) { 
            for (i = 0; i < input.length; i++) {
                input[i].checked = true;
            }
        } else {
            for (i = 0; i < input.length; i++) {
            input[i].checked = false;
            }
        }
	}
    // Momentary handlers for impulse buttons: brighten briefly, fire effect, then auto-dim
    function fireSplode() {
        const el = document.getElementById('splodeButton');
        if (el) el.checked = true;
        try { instantSplode(); } catch(e) {}
        // auto-uncheck to restore dim state
        setTimeout(()=>{ if (el) el.checked = false; }, 180);
    }
    function fireImplode() {
        const el = document.getElementById('implodeButton');
        if (el) el.checked = true;
        try { instantImplode(); } catch(e) {}
        setTimeout(()=>{ if (el) el.checked = false; }, 180);
    }
    function fireUnravel() {
        const el = document.getElementById('unravelButton');
        if (el) el.checked = true;
        try { delayedSplode(); } catch(e) {}
        setTimeout(()=>{ if (el) el.checked = false; }, 220);
    }
    
    // Continuous implode functionality
    let implodeInterval = null;
    
    function startContinuousImplode() {
        const el = document.getElementById('implodeButton');
        if (el) el.checked = true;
        
        // Start continuous implode effect
        if (implodeInterval) clearInterval(implodeInterval);
        implodeInterval = setInterval(() => {
            try { instantImplode(); } catch(e) {}
        }, 16); // ~60fps for smooth continuous effect
    }
    
    function stopContinuousImplode() {
        const el = document.getElementById('implodeButton');
        if (el) el.checked = false;
        
        // Stop continuous implode effect
        if (implodeInterval) {
            clearInterval(implodeInterval);
            implodeInterval = null;
        }
    }
    
	function pauseAndStep() {
        let input = document.querySelectorAll('.checkbox-pause');
        for (i = 0; i < input.length; i++) {
            input[i].checked = true;
        }
		physProps.paused = false;
		simulate();
		physProps.paused = true
	}
    function drawCircle(x, y, radius) {
        c.beginPath();			
		c.arc(x, y, radius, 0.0, 2.0 * Math.PI) 
		c.closePath();
	}
    function drawEllipse(x, y, radiusX, radiusY) {
        c.beginPath();			
		c.ellipse(x * cScale, y * cScale, radiusX * cScale, radiusY * cScale, 0, 0, 2 * Math.PI) 
		c.closePath();
	}

    // COLLISIONS AND BOUNDARIES =============================================================

    //  HANDLE WORM SEGMENT HITS --------------------------------------------------------
    function handleWormSegmentHits(ball, wormSegment, segmentRadius, segmentVelocity) {
        var dir = new Vector2();
        dir.subtractVectors(ball.pos, wormSegment);
        var d = dir.length();
        if (d == 0.0 || d >= ball.radius + segmentRadius)
            return;

        dir.scale(1.0 / d);
        var overlap = ball.radius + segmentRadius - d;
        var corr = overlap + 0.003; // Small buffer to prevent immediate re-collision
        ball.pos.add(dir, corr);

        var relativeVel = new Vector2();
        relativeVel.subtractVectors(ball.vel, segmentVelocity);
        var velAlongNormal = relativeVel.dot(dir);
        var massScale = 10000000;
        var segmentMass = massScale * segmentRadius * segmentRadius;
        // Only apply velocity impulse if objects are approaching each other
        if (velAlongNormal <= 0) {
            var e = physProps.puckRest;
            // Calculate impulse scalar
            var j = -(1 + e) * velAlongNormal;
            j /= (1 / ball.mass) + (1 / segmentMass);
            var impulse = new Vector2();
            impulse.set(dir);
            impulse.scale(j);
            
            ball.vel.add(impulse, 1 / ball.mass);
        }

        var v = ball.vel.dot(dir);
        ball.vel.add(dir, v * -10.0 * physProps.ballRest);
    }

    //  HANDLE BALL TO BALL HITS --------------------------------------------------------------------
	function handleBallHits(ball1, ball2) {
		var dir = new Vector2();
		dir.subtractVectors(ball2.pos, ball1.pos);
		var d = dir.length();
		if (d == 0.0 || d >= ball1.radius + ball2.radius)
			return;

		dir.scale(1.0 / d);
		var corr = (ball1.radius + ball2.radius - d) / 2.0 + 0.001; // Small buffer to prevent immediate re-collision
		var v1 = ball1.vel.dot(dir);
		var v2 = ball2.vel.dot(dir);
		var m1 = ball1.mass;
		var m2 = ball2.mass;
        if (physProps.ballRest == 0) {
            var newV1 = (m1 * v1 + m2 * v2) / (m1 + m2);
		    var newV2 = (m1 * v1 + m2 * v2) / (m1 + m2);
        } else {
            var newV1 = (m1 * v1 + m2 * v2 - m2 * (v1 - v2) * physProps.ballRest) / (m1 + m2);
		    var newV2 = (m1 * v1 + m2 * v2 - m1 * (v2 - v1) * physProps.ballRest) / (m1 + m2);
        }
		
        ball1.pos.add(dir, -corr);
		ball2.pos.add(dir, corr);
		ball1.vel.add(dir, newV1 - v1);
		ball2.vel.add(dir, newV2 - v2);
	}

    //  HANDLE BALL TO BALL COMPRESSION --------------------------------------------------------------------
	function handleBallRepulsion(ball1, ball2) {
		var dir = new Vector2();
		dir.subtractVectors(ball2.pos, ball1.pos);
		var d = dir.length();
		var repulsionThreshold = physProps.repulsionDist * (ball1.radius + ball2.radius);
		if (d == 0.0 || d >= repulsionThreshold)
			return;
		dir.scale(1.0 / d);
		var compression = Math.abs(repulsionThreshold - d);
		var force = physProps.repulsionForce * compression;
		var totalMass = ball1.mass + ball2.mass;
		var force1 = force * (ball2.mass / totalMass);
		var force2 = force * (ball1.mass / totalMass);
		
		ball1.vel.add(dir, -force1);
		ball2.vel.add(dir, force2);
	}

    //  HANDLE BUMPER HITS ------------------------------------------------------------------- 
	function handleBumperHits(ball, bumper) {
        var dir = new Vector2();
		dir.subtractVectors(ball.pos, bumper.pos);
		var d = dir.length();
		if (d == 0.0 || d >= ball.radius + bumper.radius)
			return;

		dir.scale(1.0 / d);
		var corr = (ball.radius + bumper.radius - d);
		var v = ball.vel.dot(dir);
        ball.pos.add(dir, corr);
        ball.vel.add(dir, v * -2.0 * physProps.bumperRest);

	}
    
    //  HANDLE PUCK TO BALL HITS  -------------------------------------------------------------------- 
	function handlePuckHits(ball, puck) {
        var dir = new Vector2();
		dir.subtractVectors(ball.pos, puck.pos);
		var d = dir.length();
		if (d == 0.0 || d >= ball.radius + puck.radius)
			return;

		dir.scale(1.0 / d);
		var overlap = ball.radius + puck.radius - d;
		
		// For puck collisions, push the ball out completely to prevent clipping
		// Use a slightly larger separation to ensure clean separation
		var corr = overlap + 0.001; // Small buffer to prevent immediate re-collision
		ball.pos.add(dir, corr);

        // Effective surface velocity along the collision normal
        // Includes translational puck motion and radial surface motion from pulsing
        var u_n = 0.0;
        if (puck.moving == true) {
            u_n += puck.vel.dot(dir);
        }
        if (puck.special === true && Math.abs(puck.radiusRate) > 1e-6) {
            u_n += puck.radiusRate; // outward positive along dir
        }

        // Ball normal velocity component
        var v_n = ball.vel.dot(dir);

        // If the ball is approaching the moving surface (in surface frame), reflect with restitution
        if (v_n < u_n) {
            var e = physProps.puckRest;
            // Set new normal component: v'_n = u_n - e * (v_n - u_n) = (1+e)u_n - e v_n
            var v_n_prime = (1 + e) * u_n - e * v_n;
            var delta = v_n_prime - v_n; // change to apply along normal
            ball.vel.add(dir, delta);
        }
	}

    //  HANDLE CORNER HITS  --------------------------------------------------------------------
    function handleCornerHits(ball1, corner) {
        // Find arc center based on corner position and type
        let arcCenterX, arcCenterY;
        if (corner.corner === 'northwest') {
            arcCenterX = corner.pos.x + corner.radius; 
            arcCenterY = corner.pos.y + corner.radius;
        } else if (corner.corner === 'northeast') {
            arcCenterX = corner.pos.x - corner.radius; 
            arcCenterY = corner.pos.y + corner.radius;
        } else if (corner.corner === 'southwest') {
            arcCenterX = corner.pos.x + corner.radius; 
            arcCenterY = corner.pos.y - corner.radius;
        } else { // southeast
            arcCenterX = corner.pos.x - corner.radius; 
            arcCenterY = corner.pos.y - corner.radius;
        }
        
        const dx = ball1.pos.x - arcCenterX;
        const dy = ball1.pos.y - arcCenterY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Check if ball is colliding with the inside of the arc
        if (distance > corner.radius - ball1.radius) {
            // Surface normal points from arc center toward ball
            const normalX = dx / distance;
            const normalY = dy / distance;
            
            ball1.pos.x = arcCenterX + normalX * (corner.radius - ball1.radius);
            ball1.pos.y = arcCenterY + normalY * (corner.radius - ball1.radius);
            
            const dot = ball1.vel.x * normalX + ball1.vel.y * normalY;
            ball1.vel.x -= 2 * dot * normalX;
            ball1.vel.y -= 2 * dot * normalY;
        }
    }
    
    //  HANDLE SHOWER  -------------------------------------------------------------------- 
    function goShower(ball) {
        if (doGravityDown == true) {
            ball.pos.y = simHeight + ball.radius + 30 * Math.random() * ball.radius;
            ball.pos.x = dumpShift + ((Math.random() * simWidth * dumpSqueeze) + ((1.0 / (2 * dumpSqueeze)) - 0.5) * simWidth * dumpSqueeze);
            ball.vel.x = 0;
            ball.vel.y = 0;
        } else if (doGravityRight == true) {
            ball.pos.x = -ball.radius - 30 * Math.random() * ball.radius;
            ball.pos.y = dumpShift + ((Math.random() * simHeight * dumpSqueeze) + ((1.0 / (2 * dumpSqueeze)) - 0.5) * simHeight * dumpSqueeze);
            ball.vel.x = 0;
            ball.vel.y = 0;
        }
    }
    
    //  HANDLE MR. MISTER go fountain --------------------------------------------------------------------
    function goFountain(ball) {
        if (mrMode == "typewriter" && goLeft == true) {
            return;
        }
        var mrMr = MisterMister[0];
        if (mrMode == "worm") {
            ball.immuneToWorm = true;
            ball.immunityFramesLeft = 10; 
            if (mrMr.pos.x < 0 || mrMr.pos.x > simWidth || 
                mrMr.pos.y < 0 || mrMr.pos.y > simHeight) {
                return;
            }
            var spawnX = mrMr.pos.x - (0.35 * mrMr.radius - ball.radius) + (Math.random() * (0.9 * mrMr.radius - 6 * ball.radius));
            var spawnY = mrMr.pos.y - 0.3 * mrMr.radius - (0.35 * mrMr.radius - ball.radius) + (Math.random() * (0.7 * mrMr.radius - 4 * ball.radius));
            ball.pos.x = Math.max(0, Math.min(simWidth, spawnX));
            ball.pos.y = Math.max(0, Math.min(simHeight, spawnY));
            var velX = 0.01 * yeet * Math.cos(mrMr.respawnDir + alpha);
            var velY = 0.01 * yeet * Math.sin(mrMr.respawnDir + alpha);
        } else {
            var spawnX = mrMr.pos.x - (0.35 * mrMr.radius - ball.radius) + (Math.random() * (0.9 * mrMr.radius - 6 * ball.radius));
            var spawnY = mrMr.pos.y - 0.65 * mrMr.radius - (0.35 * mrMr.radius - ball.radius) + (Math.random() * (0.6 * mrMr.radius - 4 * ball.radius));
            ball.pos.x = Math.max(0, Math.min(simWidth, spawnX));
            ball.pos.y = Math.max(0, Math.min(simHeight, spawnY));
            if (sprinklerSpeed > 0 && fountainSpinMode == "sweep") {
                var velX = 0.01 * yeet * Math.cos(mrMr.respawnDir + alpha);
                var velY = 0.01 * yeet * Math.sin(mrMr.respawnDir + alpha);
            } else {
                var velX = 0.01 * yeet * Math.cos(mrMr.respawnDir);
                var velY = 0.01 * yeet * Math.sin(mrMr.respawnDir);
            }
        }
        
        ball.vel.x = velX;
        ball.vel.y = velY;
    }

    //  HUNGRY PUCK HITS  --------------------------------------------------------------------
	function handleHungryPuckHits(ball, hungryPuck) {
        var dir = new Vector2();
		dir.subtractVectors(ball.pos, hungryPuck.pos);
		var d = dir.length();
		if (d == 0.0 || d > ball.radius + hungryPuck.radius)
			return;

		dir.scale(1.0 / d);
        // FOUNTAIN AND SWEEPER SETUP FOR HUNGRY PUCK--------------------------------------------------
        var sprinklerSpeed = 0.0001;
        if (fountainSpinMode == 'cw') {
            alpha += sprinklerSpeed * -1.0 * physProps.dt;
            if (alpha > 2*Math.PI || alpha < -2*Math.PI) {
                alpha = 0
            }
        } else if (fountainSpinMode == 'ccw') {
            alpha += sprinklerSpeed * 1.0 * physProps.dt;
            if (alpha > 2*Math.PI || alpha < -2*Math.PI) {
                alpha = 0
            }
        } else {
            alpha += sprinklerSpeed * -1.0 * physProps.dt;
            if (alpha > 2*Math.PI || alpha < -2*Math.PI) {
                alpha = 0
            }
        }

        // HANDLE SHOWER AND FOUNTAIN FOR HUNGRY PUCK -------------------------------------------------------------  
        if (doOneShot == false) {
            if (doShower == true) {
                goShower(ball); 
            }
            
            if (doFountain == true) {
                goFountain(ball);
            }
        }
    }

    //  HANDLE BOUNDARIES = FLOOR, WALLS, CEILING -------------------------------------------------------
	function handleOutOfBounds(ball, worldSize) {
        // FOUNTAIN AND SWEEPER SETUP ----------------------------------------------------
        if (fountainSpinMode == 'cw') {
            sweepAngle = 2 * Math.PI;
            alpha += sprinklerSpeed * -1.0 * physProps.dt;
            if (alpha > 2 * Math.PI || alpha < -2 * Math.PI) {
                alpha = 0;
            }
        } else if (fountainSpinMode == 'ccw') {
            sweepAngle = 2 * Math.PI;
            alpha += sprinklerSpeed * 1.0 * physProps.dt;
            if (alpha > 2 * Math.PI || alpha < -2 * Math.PI) {
                alpha = 0;
            }
        } else {
            sweepAngle = 0.35 * Math.PI;
            alpha += sprinklerSpeed * sweepDir * physProps.dt;
            if (alpha > (sweepAngle * 1.01) || alpha < (-sweepAngle * 1.01)) { // small chance of stalling
                alpha = 0
            }
            if (alpha > sweepAngle || alpha < -sweepAngle) {
                sweepDir *= -1;
            }
        }

        // HANDLE WALL HITS ------------------------------------------------------------  
        if (doCeiling == true) {
            if (ball.pos.y > worldSize.y - ball.radius) {
                ball.pos.y = worldSize.y - ball.radius;
                ball.vel.y = -ball.vel.y * physProps.ceilingRest;
		    }
        }
        if (doFloor == true) {
            if (ball.pos.y < ball.radius) {
		        ball.pos.y = ball.radius;
		        ball.vel.y = -ball.vel.y * physProps.floorRest;
		        }
        }
        if (doLeftWall == true) {
            if (cornerRad <= 100) {
                if (ball.pos.x < ball.radius) {
                    ball.pos.x = ball.radius;
                    ball.vel.x = -ball.vel.x * physProps.wallRest;
                }
            } else {
                NWCorner = Corners[0];
                if (ball.pos.x < NWCorner.pos.x + ball.radius) {
                    ball.pos.x = NWCorner.pos.x + ball.radius
                    ball.vel.x = -ball.vel.x * physProps.wallRest;
                }
            }
        }
        if (doRightWall == true) {
            if (cornerRad <= 100) {
                if (ball.pos.x > worldSize.x - ball.radius) {
                    ball.pos.x = worldSize.x - ball.radius;
                    ball.vel.x = -ball.vel.x * physProps.wallRest;
                }    
            } else {
                NECorner = Corners[1];
                if (ball.pos.x > NECorner.pos.x - ball.radius) {
                    ball.pos.x = NECorner.pos.x - ball.radius;
                    ball.vel.x = -ball.vel.x * physProps.wallRest;
                }  
            }
        }

        // HANDLE BOUNDS FOR SHOWER AND FOUNTAIN -------------------------------------------------------------  
        if (doOneShot == false) {
            if (doShower == true) {
                if (ball.pos.y < -2.0 * ball.radius || 
                    ball.pos.y > simHeight + 2.0 * ball.radius ||
                    ball.pos.x < -2.0 * ball.radius || 
                    ball.pos.x > simWidth + 2.0 * ball.radius) {
                    goShower(ball);
                }
            } 
            var hP = MisterMister[0];
            var dir = hP.respawnDir;
            var velX = yeet / 100 * Math.cos(dir + alpha);
            velY = yeet / 100 * Math.sin(dir + alpha);
            if (doFountain == true) {
                if (ball.pos.y < -2.0 * ball.radius || 
                    ball.pos.y > simHeight + 2.0 * ball.radius ||
                    ball.pos.x < -2.0 * ball.radius || 
                    ball.pos.x > simWidth + 2.0 * ball.radius) {
                    
                    // Additional check for worm mode: only respawn if Mr. Mister is within bounds
                    if (mrMode == "worm") {
                        
                        if (hP.pos.x >= 0 && hP.pos.x <= simWidth && 
                            hP.pos.y >= 0 && hP.pos.y <= simHeight) {
                            goFountain(ball);
                        }
                        // If Mr. Mister is outside bounds in worm mode, don't respawn the particle
                    } else {
                        // Normal respawn behavior for other modes
                        goFountain(ball);
                    }
                }
            }
        }
	}

    // HANDLE MR. MISTER BOUNDS ------------------------------------------------------------  
    function handleMrMrBounds(hungryPuck, worldSize) {
        mrMr = MisterMister[0];
            if (mrMr.pos.y > worldSize.y - mrMr.radius) {
                mrMr.pos.y = worldSize.y - mrMr.radius;
                mrMr.vel.y = -mrMr.vel.y;
            }
            if (mrMr.pos.y < mrMr.radius) {
                mrMr.pos.y = mrMr.radius;
                mrMr.vel.y = -mrMr.vel.y;
            }
            if (mrMr.pos.x < mrMr.radius) {
                mrMr.pos.x = mrMr.radius;
                mrMr.vel.x = -mrMr.vel.x;
            }
            if (mrMr.pos.x > worldSize.x - mrMr.radius) {
                mrMr.pos.x = worldSize.x - mrMr.radius;
                mrMr.vel.x = -mrMr.vel.x;
            }
    }

    //  WORLD PROPERTIES INIT DEFINITIONS ----------------------------------------------
	var physProps = {
		gravity : new Vector2(0, 0),
		substeps: 1,
		dt : 1 / (60 * 1), // updated when substeps changes
		worldSize : new Vector2(simWidth, simHeight),

		ballRest : 0,
        bumperRest : 0.95,
        floorRest : 1.0,
        wallRest : 1.0,
        ceilingRest : 1.0,
        puckRest: 0.95,
        persistence: 0,
        paused : false,
        repulsionForce: 2,
        repulsionDist: 4,
        velColorMap: 0,
        baseColor: 0,
	}

    var WormProps = {
        gravity : new Vector2(0, 0),
        dt : 1 / 60,
        wormSubSteps : 10,
        paused : true,
        phase: 0.0,
    
        wiggleActive: false,
        wiggleFrame: 0,
        wigglePerFrameVelY: 0.0,
        wigglePerFrameVelX: 0.0,
        wigglePerFrameVel: 0.0,
        wiggleDir: 1,
        prevHeadVY: 0.0,
        wiggleToggle: 1, // alternates sign each cycle
        wiggleAdvancePerFrame: 0.0,
        startRadius: 0,
        endRadius: 0,
        numNodes: 0,
        
        // Worm delay properties
        isHiding: false,
        hideStartTime: 0,
        hideDelay: 10000, // 10 seconds in milliseconds
    }
    
    // Function to update dt when substeps change
    function updateSubsteps(newSubsteps) {
        physProps.substeps = newSubsteps;
        physProps.dt = 1 / (60 * physProps.substeps);
    }
    
	//  SETUP SCENE ======================================================
	function setupScene() {
        let input = document.querySelectorAll('.checkbox-pause');
        for (i = 0; i < input.length; i++) {
            input[i].checked = false;
        }
        currentDate = new Date();
        mSecs = currentDate.getMilliseconds();
        dumpSqueeze2 = 0.2;
        alpha = 0;
        sweepDir = 1;
        dir = 0;
        huePos = 0;
        delta = 0;
        mrMrTimer = 0;
        mouseUpTime = 0;
        mouseDownTime = 0;
        
        goLeft = false;
        spawnLeft = true;
        showEaters = false;
        mrMode = "";

        doCeiling = ceilingButton.checked;
        doFloor = floorButton.checked;
        doLeftWall = leftWallButton.checked;
        doRightWall = rightWallButton.checked;
        dumpShift = 0.01 * dumpMoveSlider.value * simWidth;
        dumpSqueeze = 0.01 * dumpSlider.value;
        showBumpers = showBumperEntry.checked;
        showPucks = showPuckButton.checked;
        showHeart = showHeartButton.checked;
        showCycle = (typeof showCyclePuckButton !== 'undefined') ? showCyclePuckButton.checked : true;
        doShower = shower.checked;
        doFountain = fountain.checked;
        
        doSmallTracer = smallTracerButton.checked;
        doMediumTracer = mediumTracerButton.checked;
        doBigTracer = bigTracerButton.checked;
        if (doSmallTracer == true || doMediumTracer == true || doBigTracer == true) {
            doTracer = true;
        } else {
            doTracer = false;
        }

        sprinklerSpeed = 0.0001 * sprinklerSpeedSlider.value;
        respawnDir = 0;
        
        ballRepulsion = repulsionButton.checked;
        misterSpeed = 0.01 * misterSpeedSlider.value;
        ballSaturation = 1.0 * saturationSlider.value;
        ballLightness = 1.0 * lightnessSlider.value;
        persistence = 1.0 * persistenceSlider.value;
        cornerRad = 1.0 * cornerRadiusSlider.value;

        doSpheres = false;
        doDiscs = true;
        doCircles = false;
        doGummi = false;
        wasGummi = false;

        doOneShot = oneShotButton.checked;
        yeet = 1.0 * yeetSlider.value;
        doGravityDown = gravityDown.checked;
        doGravityRight = gravityRight.checked;
        doWorm = wormButton.checked;

        physProps.baseColor = 1.0 * baseColorSlider.value;

        physProps.velColorMap = velColorMapSlider.value;
        // Initialize ball restitution from slider using the same log mapping
        (function(){
            const el = document.getElementById('ballRestSlider');
            if (el) {
                const t = parseFloat(el.value) / 100;
                const k = 1000000;
                physProps.ballRest = Math.log(1 + k * t) / Math.log(1 + k);
                if (ballRestSlider.value < 1) {
                    physProps.ballRest = 0;
                }
            }
        })();

        WormProps.startRadius = 0.001 * wormStartRadiusSlider.value,
        WormProps.endRadius = 0.001 * wormEndRadiusSlider.value,
        WormProps.numNodes = 1 * wormNumNodesSlider.value,
        
        fountainSpinMode = 'sweep';

        makePucks();
        makeHungryPucks();
        makeMisterMister();
        
        if (firstRun == true) {
            makeBalls();
            makeCorners()
            makeBumpers();
            makeWorm();
            firstRun = false;
        }
    }

    // Splode timing (ms): delay between each ball's impulse
    const SPL0DE_DELAY_MS = 1; // tune this to control pacing
    // Apply outward impulse to all balls with a small staggered delay per index
    function delayedSplode() {
        const cx = 0.5 * simWidth;
        const cy = 0.5 * simHeight;
        // Base impulse magnitude (scaled like before)
        const baseSpeed = 50 * physProps.dt;
        // Schedule each ball's impulse with an increasing timeout
        for (let i = Balls.length - 1; i >= 0; i--) {
            const b = Balls[i];
            const delay = (Balls.length - 1 - i) * SPL0DE_DELAY_MS;
            setTimeout(() => {
                // Guard in case balls array was rebuilt
                if (!b || !b.pos || !b.vel) return;
                const d = new Vector2();
                d.subtractVectors(b.pos, new Vector2(cx, cy));
                const angle = Math.atan2(d.y, d.x);
                b.vel.x += baseSpeed * Math.cos(angle);
                b.vel.y += baseSpeed * Math.sin(angle);
            }, delay);
        }
    }

    function instantSplode() {
        const baseSpeed = 50 * physProps.dt;
        for (let i = Balls.length - 1; i >= 0; i--) {
            var ball = Balls[i];
            var d = new Vector2();
            d.subtractVectors(ball.pos, new Vector2(0.5 * simWidth, 0.5 * simHeight));
            const angle = Math.atan2(d.y, d.x);
            ball.vel.x += baseSpeed * Math.cos(angle);
            ball.vel.y += baseSpeed * Math.sin(angle);
        }
    }

    function instantImplode() {
        const baseSpeed = 50 * physProps.dt;
        for (let i = Balls.length - 1; i >= 0; i--) {
            var ball = Balls[i];
            var d = new Vector2();
            d.subtractVectors(ball.pos, new Vector2(0.5 * simWidth, 0.5 * simHeight));
            const angle = Math.atan2(d.y, d.x);
            ball.vel.x -= baseSpeed * Math.cos(angle);
            ball.vel.y -= baseSpeed * Math.sin(angle);
        }
    }

	//  BALL CONSTRUCTOR  -----------------------------------------------------------------------
	class BALL {
		constructor(radius, mass, pos, vel, saturation, whiteBall, tracerBall, smallBallRadius, bigBallRadius) {
			this.radius = radius;
			this.mass = mass;
			this.pos = pos.clone();
			this.vel = vel.clone();
            this.color = 0;
            this.saturation = saturation;
            this.whiteBall = whiteBall;
            this.immuneToWorm = false;
            this.immunityFramesLeft = 0; 
            this.tracerBall = tracerBall;
            // Smoothed heading for image-based rendering (gummi)
            this.headingAngle = 0;          // radians, screen-space orientation
            this.headingInitialized = false; // initialize on first valid velocity
            this.artificialMovement = false; // Flag to track when ball is being repositioned artificially
            if (tracerBall == true) {
                if (doSmallTracer == true) {
                    this.radius = smallBallRadius;
                } else 
                if (doBigTracer == true) {
                    this.radius = bigBallRadius;
                } else 
                if (doMediumTracer == true) {
                    this.radius = 0.5 * (smallBallRadius + bigBallRadius);
                }  
                this.trail = new Float32Array(1500); // Increased size to accommodate flags
                this.trailFirst = 0;
                this.trailLast = 0;
                this.tracer = true;
                this.speedHue = 0;
                this.speedHueRatio = 1;
            }
		}
        get top() {
            return this.pos.y + this.radius;
        }
        get bottom() {
            return this.pos.y - this.radius;
        }
        get left() {
            return this.pos.x - this.radius;
        }
        get right() {
            return this.pos.x + this.radius;
        }
        updateTrace() {
            // Check if ball is outside simulation boundaries
            var isOutsideBounds = (this.pos.x < 0 || this.pos.x > simWidth || 
                                 this.pos.y < 0 || this.pos.y > simHeight);
            
            if (isOutsideBounds) {
                this.artificialMovement = true; // Mark as outside/artificial movement
                return; // Don't record trace when outside
            }
            
            // Ball is back inside bounds - resume normal tracing (don't reset trace)
            var wasArtificial = this.artificialMovement;
            if (this.artificialMovement) {
                this.artificialMovement = false; // Resume normal tracing
            }
            
            // Record normal trace point (x, y, discontinuity_flag)
            this.trail[this.trailLast] = this.pos.x;
            this.trail[this.trailLast + 1] = this.pos.y;
            this.trail[this.trailLast + 2] = wasArtificial ? 1.0 : 0.0; // Flag discontinuity
            this.trailLast = (this.trailLast + 3) % this.trail.length;
            if (this.trailLast == this.trailFirst)
                this.trailFirst = (this.trailFirst + 3) % this.trail.length;
        }
        resetTrace() {
            this.trailFirst = 0;
            this.trailLast = 0;
        }
		simulate() {
			this.vel.add(physProps.gravity, physProps.dt);
            const maxSpeed = 1;
            const speed = this.vel.length();
            if (speed > maxSpeed) {
                this.vel.x *= maxSpeed / this.vel.length();
                this.vel.y *= maxSpeed / this.vel.length();
            }
			this.pos.add(this.vel, physProps.dt)
            this.speedHue = physProps.baseColor + this.vel.length() * physProps.velColorMap;
            
            if (this.speedHue > physProps.baseColor + 330) {
                this.speedHue = physProps.baseColor + 330;
            }
            
            //if (this.speedHue > 330) {
            //    this.speedHue = 330;
            //}
            this.speedHueRatio = Math.min(0.8 + 0.2 * speed);
		}
        drawTrace() {
            c.lineCap = 'round';
            c.lineWidth = Math.max(0.005, this.radius) * cScale;
            if (this.trailLast != this.trailFirst) {
                var i = this.trailFirst;
                var segmentCount = 0;
                var totalSegments = 0;
                
                // First, count total segments
                var tempI = this.trailFirst;
                while (tempI != this.trailLast) {
                    totalSegments++;
                    tempI = (tempI + 3) % this.trail.length;
                }
                
                // Draw each segment with fading
                i = this.trailFirst;
                var prevX = this.trail[i] * cScale;
                var prevY = canvas.height - this.trail[i + 1] * cScale;
                i = (i + 3) % this.trail.length;
                
                while (i != this.trailLast) {
                    var currentX = this.trail[i] * cScale;
                    var currentY = canvas.height - this.trail[i + 1] * cScale;
                    var isDiscontinuity = this.trail[i + 2] > 0.5; // Check discontinuity flag
                    
                    // Skip drawing if this point represents a discontinuity (post-teleportation)
                    if (!isDiscontinuity) {
                        // Calculate fade: older segments are more transparent
                        var fadeRatio = segmentCount / totalSegments;
                        var alpha = 1.0 - fadeRatio; // Start opaque, fade to transparent
                        
                        c.strokeStyle = `hsl(200, 60%, 70%, ${1 - alpha})`;
                        c.beginPath();
                        c.moveTo(prevX, prevY);
                        c.lineTo(currentX, currentY);
                        c.stroke();
                    }
                    // If isDiscontinuity is true, skip drawing this segment (creates gap)
                    
                    prevX = currentX;
                    prevY = currentY;
                    segmentCount++;
                    i = (i + 3) % this.trail.length;
                }
            }
        }
        draw() {
            if (doDiscs == true) {
                drawCircle(cX(this.pos), cY(this.pos), this.radius * cScale);    
                if (this.whiteBall == true || this.tracerBall == true) {
                    // reg color
                    c.fillStyle = `hsl(0, 0%, ${ballLightness + 20}%)`;
                    // hi color
                    c.strokeStyle = `hsl(0, 0%, ${ballLightness + 50}%)`;
                    c.lineWidth = 0.2 * this.radius * cScale;
                } else {
                    // reg color   
                    c.fillStyle = `hsl(${this.speedHue}, ${ballSaturation * this.saturation}%, ${this.speedHueRatio * ballLightness}%)`;
                    // hi color
                    c.strokeStyle = `hsl(${this.speedHue}, ${ballSaturation * this.saturation}%, ${this.speedHueRatio * ballLightness + 25}%)`;
                    c.lineWidth = 0.2 * this.radius * cScale;
                }
                c.fill();
                c.stroke();
            } else if (doSpheres == true) {
                const shineOffsetX = cScale * this.radius * 0.3; // old masterShineShiftX;
                const shineOffsetY = cScale * this.radius * 0.4; // old masterShineShiftY;
                const shineVector = Math.sqrt(shineOffsetX * shineOffsetX + shineOffsetY * shineOffsetY);
                const shineRadius = 0.5 * cScale * this.radius + shineVector;
                const shading = c.createRadialGradient(
                    cX(this.pos) - shineOffsetX, 
                    cY(this.pos) - shineOffsetY, 
                    shineRadius, 
                    cX(this.pos) - shineOffsetX, 
                    cY(this.pos) - shineOffsetY, 
                    0);
                shading.addColorStop(0, `hsl(${this.speedHue}, ${ballSaturation * this.saturation}%, ${this.speedHueRatio * ballLightness - 15}%)`);
                shading.addColorStop(1, `hsl(${this.speedHue}, ${ballSaturation * this.saturation}%, ${this.speedHueRatio * ballLightness + 25}%)`);
                drawCircle(cX(this.pos), cY(this.pos), this.radius * cScale);
                c.fillStyle = shading;
                c.fill()
            } else if (doCircles == true) {
                drawCircle(cX(this.pos), cY(this.pos), this.radius * cScale);    
                c.strokeStyle = `hsl(${this.speedHue}, ${ballSaturation * this.saturation}%, ${this.speedHueRatio * ballLightness}%)`;
                c.lineWidth = 0.2 * this.radius * cScale;
                c.stroke();
            } else if (doGummi == true) {
                const x = cX(this.pos);
                const y = cY(this.pos);
                const rpx = this.radius * cScale;
                if (gummiReady && gummiImage && gummiImage.complete && gummiImage.width > 0 && gummiImage.height > 0) {
                    // Compute and smooth screen-space rotation angle from velocity (y down)
                    const speed = this.vel.length();
                    if (speed > 1e-6) {
                        const target = Math.atan2(-this.vel.y, this.vel.x);
                        if (!this.headingInitialized) {
                            this.headingAngle = target;
                            this.headingInitialized = true;
                        } else {
                            // Smooth with exponential filter using dt-based alpha
                            const TWO_PI = Math.PI * 2;
                            let diff = target - this.headingAngle;
                            // Wrap to [-PI, PI]
                            diff = ((diff + Math.PI) % TWO_PI + TWO_PI) % TWO_PI - Math.PI;
                            const tau = gummiHeadingTau; // seconds time constant (tunable)
                            const alpha = 1 - Math.exp(-physProps.dt / Math.max(1e-6, tau));
                            this.headingAngle += alpha * diff;
                        }
                    }
                    const angle = (this.headingAngle || 0) + gummiHeadingOffset;
                    // Preserve aspect ratio: scale so the largest image dimension fits the diameter
                    const iw = gummiImage.width;
                    const ih = gummiImage.height;
                    const s = (2 * rpx) / Math.max(iw, ih);
                    const dw = iw * s;
                    const dh = ih * s;
                    // Slightly inset the clipping radius to avoid visual edge cropping
                    const clipR = Math.max(0, rpx - 0.5);
                    c.save();
                    c.translate(x, y);
                    c.rotate(angle);
                    // Circular clip centered at the ball
                    c.beginPath();
                    c.arc(0, 0, clipR, 0, 2 * Math.PI);
                    c.closePath();
                    c.clip();
                    // Center the image on the ball after rotation
                    c.drawImage(gummiImage, -dw / 2, -dh / 2, dw, dh);
                    // Tint the grayscale image to match ball color behavior
                    const prevOp = c.globalCompositeOperation;
                    c.globalCompositeOperation = 'multiply';
                    c.fillStyle = `hsl(${this.speedHue}, ${ballSaturation * this.saturation}%, ${this.speedHueRatio * ballLightness}%)`;
                    // Cover the clipped circle area for consistent tinting
                    c.fillRect(-clipR, -clipR, 2 * clipR, 2 * clipR);
                    c.globalCompositeOperation = prevOp;
                    c.restore();
                } else {
                    // Fallback: draw a simple disc until the image is loaded
                    drawCircle(x, y, rpx);
                    c.fillStyle = `hsl(${this.speedHue}, ${ballSaturation * this.saturation}%, ${this.speedHueRatio * ballLightness}%)`;;
                    c.fill();
                }
            }
        }
	}

    //  MAKE BALLS -------------------------------------------
    //  SQUARE ARRAY 
    function makeBalls() {
        Balls = [];
        var smallBallRadius = smallBallInput.value / 1000;
        var bigBallRadius = bigBallInput.value / 1000;
        var maxBallRadius = Math.max(smallBallRadius, bigBallRadius);
        var getNumBalls = ballsInput.value * 1;
        var ballJitter = 0.20;
        var brakes = 0;
        var dumpSqueeze = dumpSlider.value / 100;
        var dumpSqueeze2 = 0.2;
        var dumpShift = dumpMoveSlider.value / 100 * simWidth;
        var velX = 0;
        var velY = 0;
        // On program start or any reset that calls makeBalls(), delay the heart puck 4x
        // the standard resume delay so the first visible beat begins cleanly after a brief intro pause.
        if (typeof Puck !== 'undefined' && Array.isArray(Puck) && Puck.length > 0) {
            const nowPerf = performance.now();
            for (var i = 0; i < Puck.length; i++) {
                var heartPuck = Puck[i];
                if (heartPuck && heartPuck.special === true) {
                    heartPuck.hbResumeAt = nowPerf + 4 * heartResumeDelayMs;
                    heartPuck.hbState = 'pause';
                    heartPuck.hbTimeInState = 0.0;
                    heartPuck.hbLastTime = nowPerf;
                    heartPuck.radius = heartPuck.OGradius;
                    break;
                }
            }
        }
        if (array.checked == true) {  
            var numCols = Math.floor(Math.sqrt(getNumBalls));
            var numRows = Math.floor(Math.sqrt(getNumBalls));
            var countDifference = getNumBalls - (numCols * numRows);
            var addedRows = Math.ceil(countDifference / numCols);
            var boxWidth = (numCols * 2.0 * maxBallRadius);
            var boxHeight = ((numRows + addedRows) * 2.0 * maxBallRadius);
            var horizBias = 0.5 * (simWidth - boxWidth);
            var vertBias = 0.5 * (simHeight - boxHeight);
            var middleRow = Math.floor((numRows + addedRows) / 2);
            var middleCol = Math.floor(numCols / 2);
            for (var j = 0; j < (numRows + addedRows); j++) {
                for (var i = 0; i < numCols; i++) {
                    if (smallBallRadius == 0) {
                        var radius = bigBallRadius;
                    } else {
                        var radius = smallBallRadius + Math.random() * (bigBallRadius - smallBallRadius);
                    }          
                    var mass = 2 * Math.PI * radius * radius; 
                    var vel = new Vector2((-0.5 + 1.0 * Math.random()) * brakes, (-0.5 + 1.0 * Math.random()) * brakes);
                    var boxedPosX = (i + 1) * (boxWidth / (numCols +1)) + (Math.random() * radius * ballJitter) + horizBias;
                    var boxedPosY = (j + 1) * (boxHeight / (numRows + 1)) + vertBias;
                    var pos = new Vector2(boxedPosX, boxedPosY);
                    var saturation = 0.5 + 0.5 * Math.random();
                    if (Math.random() * 100 < 5) {
                            var whiteBall = true;
                        } else {
                            var whiteBall = false;
                        }
                    var tracerBall = (j == middleRow && i == middleCol);
                    if (Balls.length < getNumBalls) {
                        Balls.push(new BALL(radius, mass, pos, vel, saturation, whiteBall, tracerBall, smallBallRadius, bigBallRadius));
                    }
                }
            }
        }
        //  ROUND CLUSTER - SINGLE TIGHT SPIRAL
        if (cluster.checked == true) {
            var centerX = 0.5 * simWidth;
            var centerY = 0.5 * simHeight;
            var ballDiameter = bigBallRadius * 2;
            var angle = 0;
            var spiralRadius = 0;
            
            for (var q = 0; q < getNumBalls; q++) {
                // Determine ball radius first
                if (smallBallRadius == 0) {
                    var radius = bigBallRadius;
                } else {
                    var radius = smallBallRadius + Math.random() * (bigBallRadius - smallBallRadius);
                }
                
                // Place first ball at center
                if (q == 0) {
                    var circleXpos = centerX;
                    var circleYpos = centerY;
                } else {
                    // Calculate position on spiral
                    var circleXpos = centerX + Math.cos(angle) * spiralRadius;
                    var circleYpos = centerY + Math.sin(angle) * spiralRadius;
                    
                    // Calculate next position based on ball diameter
                    // Angular step ensures balls are spaced by their diameter along the arc
                    var arcLength = ballDiameter * 1.05; // Small gap between balls
                    var angleStep = arcLength / Math.max(spiralRadius, ballDiameter);
                    angle += angleStep;
                    
                    // Increase radius slowly: one ball diameter per full rotation (2π)
                    spiralRadius += (ballDiameter * angleStep) / (2 * Math.PI);
                }
                
                var mass = 2 * Math.PI * radius * radius; 
                var pos = new Vector2(circleXpos, circleYpos);   
                
                // Give balls slight outward velocity based on their position
                var outwardAngle = Math.atan2(circleYpos - centerY, circleXpos - centerX);
                var vel = new Vector2(Math.cos(outwardAngle) * brakes, Math.sin(outwardAngle) * brakes);
                
                if (Math.random() * 100 < 5) {
                    var whiteBall = true;
                } else {
                    var whiteBall = false;
                }
                if (q == 0) {
                    var tracerBall = true;
                } else {
                    var tracerBall = false;
                }   
                var saturation = 0.5 + 0.5 * Math.random();

                Balls.push(new BALL(radius, mass, pos, vel, saturation, whiteBall, tracerBall, smallBallRadius, bigBallRadius));
            }   
        }
    }

    // Dynamically reassign the tracer ball without respawning all balls
    function selectTracerBall() {
        if (!Array.isArray(Balls) || Balls.length === 0) return;

        // Determine target radius based on mode
        const sR = smallBallInput.value / 1000;
        const bR = bigBallInput.value / 1000;
        let targetR = 0.5 * (sR + bR); // default medium
        if (doSmallTracer === true) targetR = sR;
        else if (doBigTracer === true) targetR = bR;

        // Clear any current tracer flags and remember previous tracer to stop tracing
        let prevTracer = null;
        for (let i = 0; i < Balls.length; i++) {
            if (Balls[i].tracerBall === true) {
                prevTracer = Balls[i];
            }
            Balls[i].tracerBall = false;
            Balls[i].tracer = false;
            // restore color behavior; whiteBall remains whatever it was
        }

        // Choose the ball whose radius is closest to targetR
        let bestIdx = 0;
        let bestDiff = Number.POSITIVE_INFINITY;
        for (let i = 0; i < Balls.length; i++) {
            const diff = Math.abs(Balls[i].radius - targetR);
            if (diff < bestDiff) { bestDiff = diff; bestIdx = i; }
        }

        // Assign new tracer flags and ensure it has a trail buffer
        const tracer = Balls[bestIdx];
        tracer.tracerBall = true;
        tracer.tracer = true;
        tracer.whiteBall = true; // ensure white visual for the tracer
        if (!tracer.trail || tracer.trail.length === 0) {
            tracer.trail = new Float32Array(1500);
        }
        tracer.resetTrace();
    }

    //  CORNER CONSTRUCTOR  ---------------------------------------------------------------------
    class CORNER {
		constructor(pos, corner) {
			this.pos = pos.clone();
            this.corner = corner;
            this.radius = 0.01 * cornerRad * 0.5 * simHeight;
            if (screenVertical == true) {
                this.radius = 0.01 * cornerRad * 0.5 * simWidth;
            } else {
                this.radius = 0.01 * cornerRad * 0.5 * simHeight;
            }
        }
        get left() {
            return this.pos.x - this.radius;
        }
        get right() {
            return this.pos.x + this.radius;
        }
        draw() {
            // Use canvas gradient that matches page background for seamless edges
            if (!cornerFillGradient) { updateCornerFillGradient(); }
            c.fillStyle = cornerFillGradient; 
            var budge = 0;
            if (this.corner == 'northwest') {
                c.beginPath();
                c.moveTo(0, 0);
                c.lineTo(this.radius * cScale, 0);
                c.arc((this.pos.x + this.radius - budge) * cScale, (this.pos.y + this.radius - budge) * cScale, this.radius * cScale, 1.5 * Math.PI, Math.PI, true);
                c.lineTo(0, this.radius * cScale);
                c.closePath();
                c.fill();
            }
            if (this.corner == 'southwest') {
                c.beginPath();
                c.moveTo(0, simHeight * cScale);
                c.lineTo(0, (simHeight - this.radius) * cScale);
                c.arc((this.pos.x + this.radius - budge) * cScale, (this.pos.y - this.radius + budge) * cScale, this.radius * cScale, Math.PI, 0.5 * Math.PI, true);
                c.lineTo(this.radius * cScale, simHeight * cScale);
                c.closePath();
                c.fill();
            }
            if (this.corner == 'southeast') {
                c.beginPath();
                c.moveTo(simWidth * cScale, simHeight * cScale);
                c.lineTo((simWidth - this.radius) * cScale, simHeight * cScale);
                c.arc((this.pos.x - this.radius + budge) * cScale, (this.pos.y - this.radius + budge) * cScale, this.radius * cScale, 0.5 * Math.PI, 0, true);
                c.lineTo(simWidth * cScale, (simHeight - this.radius) * cScale);
                c.closePath();
                c.fill();
            }   
            if (this.corner == 'northeast') {
                c.beginPath();
                c.moveTo(simWidth * cScale, 0);
                c.lineTo(simWidth * cScale, this.radius * cScale);
                c.arc((this.pos.x - this.radius + budge) * cScale, (this.pos.y + this.radius - budge) * cScale, this.radius * cScale, 0, 1.5 * Math.PI, true);
                c.lineTo((simWidth - this.radius) * cScale, 0);
                c.closePath();
                c.fill();
            }
            
            // Draw the arc outlines
            c.strokeStyle = 'hsl(0, 0%, 60%)';
            c.lineWidth = 0.007 * cScale;
            c.lineCap = 'butt';
            var budge = 0.0035;
            if (this.corner == 'northwest') {
                c.beginPath();
                c.arc((this.pos.x + this.radius + budge) * cScale, (this.pos.y + this.radius + budge) * cScale, this.radius * cScale, Math.PI, 1.5 * Math.PI, false);
            }
            if (this.corner == 'southwest') {
                c.beginPath();
                c.arc((this.pos.x + this.radius + budge) * cScale, (this.pos.y - this.radius - budge) * cScale, this.radius * cScale, 0.5 * Math.PI, 1.0 * Math.PI, false);
            }
            if (this.corner == 'southeast') {
                c.beginPath();
                c.arc((this.pos.x - this.radius - budge) * cScale, (this.pos.y - this.radius - budge) * cScale, this.radius * cScale, 2 * Math.PI, 0.5 * Math.PI, false);
            }   
            if (this.corner == 'northeast') {
                c.beginPath();
                c.arc((this.pos.x - this.radius - budge) * cScale, (this.pos.y + this.radius + budge) * cScale, this.radius * cScale, 1.5 * Math.PI, 2 * Math.PI, false);
            }
            c.stroke();
            c.lineWidth = 0.009 * cScale;
            // top edge (ceiling)
            if (doCeiling == true) {
                c.beginPath();
                // Connect to actual corner positions when corners exist
                var leftCorner = Corners.find(c => c.corner === 'northwest');
                var rightCorner = Corners.find(c => c.corner === 'northeast');
                var leftX = (doLeftWall && this.radius > 0) ? (leftCorner.pos.x + this.radius + budge) * cScale : budge * cScale;
                var rightX = (doRightWall && this.radius > 0) ? (rightCorner.pos.x - this.radius - budge) * cScale : (simWidth - budge) * cScale;
                c.moveTo(leftX, budge * cScale);
                c.lineTo(rightX, budge * cScale);
                c.closePath();
                c.stroke();
            }
            // bottom edge (floor)
            if (doFloor == true) {
                c.beginPath();
                // Connect to actual corner positions when corners exist
                var leftCorner = Corners.find(c => c.corner === 'southwest');
                var rightCorner = Corners.find(c => c.corner === 'southeast');
                var leftX = (doLeftWall && this.radius > 0) ? (leftCorner.pos.x + this.radius + budge) * cScale : budge * cScale;
                var rightX = (doRightWall && this.radius > 0) ? (rightCorner.pos.x - this.radius - budge) * cScale : (simWidth - budge) * cScale;
                c.moveTo(leftX, (simHeight - budge) * cScale);
                c.lineTo(rightX, (simHeight - budge) * cScale);
                c.closePath();
                c.stroke();
            }
            
            // When corners move inward, we normally skip side outlines in horizontal mode,
            // but if either ceiling or floor is disabled, keep drawing the side outlines.
            if (cornerRad >= 100 && screenVertical == false && doCeiling && doFloor) {  
                return;
            }
            // left edge
            budge = 0.0;
            c.lineWidth = 0.015 * cScale;
            if (doLeftWall == true) {
                c.beginPath();
                // When corner radius > 0, connect to corner arcs; when corner radius = 0 or adjacent wall disabled, extend to edge
                var topY = (!doCeiling && cornerRad > 100) ? 0 : ((doCeiling && this.radius > 0) ? (this.radius + budge) * cScale : budge * cScale);
                var bottomY = (!doFloor && cornerRad > 100) ? (simHeight * cScale) : ((doFloor && this.radius > 0) ? (simHeight - this.radius - budge) * cScale : (simHeight - budge) * cScale);
                var leftWallX;
                if (cornerRad > 100 && (!doCeiling || !doFloor)) {
                    var leftCorner = (Corners && Corners.find(c => c.corner === 'northwest')) || (Corners && Corners.find(c => c.corner === 'southwest'));
                    if (leftCorner && typeof leftCorner.pos?.x === 'number') {
                        // Align with the vertical boundary defined by the corner center X
                        leftWallX = (leftCorner.pos.x + budge) * cScale;
                    } else {
                        leftWallX = budge * cScale; // fallback
                    }
                } else {
                    leftWallX = budge * cScale;
                }
                c.moveTo(leftWallX, topY);
                c.lineTo(leftWallX, bottomY);
                c.closePath();
                c.stroke();

                // Fill outside area to the left when corridor is constricted and a horizontal boundary is open
                if (cornerRad > 100 && (!doCeiling || !doFloor)) {
                    var prevFill = c.fillStyle;
                    // Match corner fill gradient
                    if (!cornerFillGradient) { updateCornerFillGradient(); }
                    c.fillStyle = cornerFillGradient;
                    c.beginPath();
                    c.rect(0, topY, Math.max(0, leftWallX), Math.max(0, bottomY - topY));
                    c.fill();
                    c.fillStyle = prevFill;
                }
            }  
            // right edge
            if (doRightWall == true) {
                c.beginPath();
                // When corner radius > 0, connect to corner arcs; when corner radius = 0 or adjacent wall disabled, extend to edge
                var topY = (!doCeiling && cornerRad > 100) ? 0 : ((doCeiling && this.radius > 0) ? (this.radius + budge) * cScale : budge * cScale);
                var bottomY = (!doFloor && cornerRad > 100) ? (simHeight * cScale) : ((doFloor && this.radius > 0) ? (simHeight - this.radius - budge) * cScale : (simHeight - budge) * cScale);
                var rightWallX;
                if (cornerRad > 100 && (!doCeiling || !doFloor)) {
                    var rightCorner = (Corners && Corners.find(c => c.corner === 'northeast')) || (Corners && Corners.find(c => c.corner === 'southeast'));
                    if (rightCorner && typeof rightCorner.pos?.x === 'number') {
                        // Align with the vertical boundary defined by the corner center X
                        rightWallX = (rightCorner.pos.x) * cScale;
                    } else {
                        rightWallX = (simWidth - budge) * cScale; // fallback
                    }
                } else {
                    rightWallX = (simWidth - budge) * cScale;
                }
                c.moveTo(rightWallX, topY);
                c.lineTo(rightWallX, bottomY);
                c.closePath();
                c.stroke();

                // Fill outside area to the right when corridor is constricted and a horizontal boundary is open
                if (cornerRad > 100 && (!doCeiling || !doFloor)) {
                    var prevFill2 = c.fillStyle;
                    // Match corner fill gradient
                    if (!cornerFillGradient) { updateCornerFillGradient(); }
                    c.fillStyle = cornerFillGradient;
                    c.beginPath();
                    var rx = Math.min(rightWallX, simWidth * cScale);
                    c.rect(rx, topY, Math.max(0, simWidth * cScale - rx), Math.max(0, bottomY - topY));
                    c.fill();
                    c.fillStyle = prevFill2;
                }
            }
        }
    }

    class WORM {
        constructor(masses, lengths, angles, radii) {
            this.masses = [0.0];
            this.lengths = [0.0];
            this.radii = [0.0];
            this.pos = [{x:0.0, y:0.0}];
            this.prevPos = [{x:0.0, y:0.0}];
            this.vel = [{x:0.0, y:0.0}];
            this.theta = [0.0];
            this.omega = [0.0];
            this.waver = 0.0;

            var x = 0.0, y = 0.0;
            for (var i = 0; i < masses.length; i++) {
                var mi = masses[i];
                var li = lengths[i];
                var ai = angles[i];
                var ri = radii[i];
                this.masses.push(mi);
                this.lengths.push(li);
                this.radii.push(ri);
                this.theta.push(ai);
                this.omega.push(0.0);

                x = 0;
                y += li * Math.cos(ai);
                this.pos.push({ x:x, y:y});
                this.prevPos.push({ x:x, y:y});
                this.vel.push({x:0, y:0});
            }
        }
        simulate(dt) {
            var p = this;
            for (var i = 1; i < p.masses.length; i++) {
                p.prevPos[i].x = p.pos[i].x;
                p.prevPos[i].y = p.pos[i].y;
                p.pos[i].x += p.vel[i].x * dt;
                p.pos[i].y += p.vel[i].y * dt;
            }
            for (var i = 1; i < p.masses.length; i++) {
                var dx = p.pos[i].x - p.pos[i-1].x;
                var dy = p.pos[i].y - p.pos[i-1].y;
                var d = Math.sqrt(dx * dx + dy * dy);
                if (d > 1e-9) {
                    var w0 = p.masses[i - 1] > 0.0 ? 1.0 / p.masses[i - 1] : 0.0;
                    var w1 = p.masses[i] > 0.0 ? 1.0 / p.masses[i] : 0.0;
                    var corr = (p.lengths[i] - d) / d / (w0 + w1);
                    p.pos[i - 1].x -= w0 * corr * dx; 
                    p.pos[i - 1].y -= w0 * corr * dy; 
                    p.pos[i].x += w1 * corr * dx; 
                    p.pos[i].y += w1 * corr * dy; 
                }
            }
                // --- Joint angle limits: iterate interior joints and prevent acute folding
                for (var i = 1; i < p.pos.length - 1; i++) {
                    var A = p.pos[i-1];
                    var B = p.pos[i];
                    var C = p.pos[i+1];
                    // vectors from joint B
                    var vBAx = A.x - B.x, vBAy = A.y - B.y;
                    var vBCx = C.x - B.x, vBCy = C.y - B.y;
                    var lenBA = Math.sqrt(vBAx*vBAx + vBAy*vBAy);
                    var lenBC = Math.sqrt(vBCx*vBCx + vBCy*vBCy);
                    if (lenBA < 1e-9 || lenBC < 1e-9) continue;
                    // compute angle between vBA and vBC (0..PI)
                    var dot = (vBAx * vBCx + vBAy * vBCy) / (lenBA * lenBC);
                    dot = Math.max(-1, Math.min(1, dot));
                    var angle = Math.acos(dot);
                    if (angle < MIN_JOINT_ANGLE) {
                        // need to increase angle to MIN_JOINT_ANGLE by rotating vBC around B
                        var targetAngle = MIN_JOINT_ANGLE;
                        var delta = targetAngle - angle; // positive
                        // determine rotation direction using cross product (z-component)
                        var cross = vBAx * vBCy - vBAy * vBCx;
                        var sign = (cross >= 0) ? 1 : -1;
                        // compute current angle of vBC
                        var cur = Math.atan2(vBCy, vBCx);
                        // rotate by sign * delta
                        var newAngle = cur + sign * delta;
                        // place C at new location preserving segment length lenBC (should be p.lengths[i+1])
                        var newCx = B.x + Math.cos(newAngle) * lenBC;
                        var newCy = B.y + Math.sin(newAngle) * lenBC;
                        // apply small smoothing: lerp between old and new to avoid jitter
                        var smooth = 0.9; // keep most of the correction
                        p.pos[i+1].x = newCx * smooth + C.x * (1 - smooth);
                        p.pos[i+1].y = newCy * smooth + C.y * (1 - smooth);
                        // update prevPos to avoid large velocity spikes
                        p.prevPos[i+1].x = p.pos[i+1].x - (p.pos[i+1].x - p.prevPos[i+1].x) * 0.5;
                        p.prevPos[i+1].y = p.pos[i+1].y - (p.pos[i+1].y - p.prevPos[i+1].y) * 0.5;
                    }
                }
            for (var i = 1; i < p.masses.length; i++) {
                p.vel[i].x = 0.99 * (p.pos[i].x - p.prevPos[i].x) / dt;
                p.vel[i].y = 0.99 * (p.pos[i].y - p.prevPos[i].y) / dt;

            }
        }
        draw() {
            var p = this;
            
            //  SPINE  ----------
            /*c.strokeStyle = "green";
            c.lineWidth = 10;
            // draw the polyline starting at the visible head (pos[1]) so the
            // invisible pivot (pos[0]) doesn't create an extra leading link
            if (p.pos.length > 1) {
                c.beginPath();
                c.moveTo(cX(p.pos[1]), cY(p.pos[1]));
                for (var i = 2; i < p.pos.length; i++)
                    c.lineTo(cX(p.pos[i]), cY(p.pos[i]));
                c.stroke();
            }*/

            //  CIRCLES  ----------
            for (var i = 1; i < p.pos.length; i++) {
                var ri = (i < p.radii.length && typeof p.radii[i] === 'number') ? p.radii[i] : 0.02;
                var r = ri;
                c.beginPath();
                c.arc(
                    cX(p.pos[i]), cY(p.pos[i]), cScale * r, 0.0, 2 * Math.PI);
                c.closePath();
                var sphereGradient = c.createRadialGradient(
                        (cX(p.pos[i]) - (0.2 * r * cScale)), 
                        (cY(p.pos[i]) - (0.4 * r * cScale)), 
                        0, 
                        (cX(p.pos[i]) - (0.2 * r * cScale)), 
                        (cY(p.pos[i]) - (0.4 * r * cScale)), 
                        1.2 * r * cScale
                    );
                var highlight = 'hsl(30, 80%, 80%)';
                var midtone = 'hsl(30, 80%, 60%)';
                var shadow = 'hsl(30, 80%, 10%)';
                sphereGradient.addColorStop(0.0, highlight);
                sphereGradient.addColorStop(0.15, midtone);
                sphereGradient.addColorStop(1.0, shadow);
                c.fillStyle = sphereGradient;
                c.fill();
                c.lineWidth = .02 * cScale;  
                c.strokeStyle = "blue";       
                c.fillStyle = "darkblue";
                //c.fill();
                //c.stroke();
            }
            // pivot (pos[0]) is intentionally not drawn so the first visible
            // circle (pos[1]) is the head of the chain.
        }
    }

    function simulateWorm() {
        var sdt = WormProps.dt / WormProps.wormSubSteps;

        for (var step = 0; step < WormProps.wormSubSteps; step++) {
            WormProps.SpaceWorm.simulate(sdt, WormProps.gravity);
        }

        // Wiggle trigger: when head vertical velocity crosses zero (top/bottom of stroke)
        var p = WormProps.SpaceWorm;
        if (!WormProps.wiggleActive && p && p.vel && p.vel.length > 1) {
            var headVY = p.vel[1].y;
            // detect zero crossing (sign change) with a small threshold to avoid noise
            if (Math.abs(headVY) < WIGGLE_VY_ZERO_THRESHOLD && Math.abs(WormProps.prevHeadVY) >= WIGGLE_VY_ZERO_THRESHOLD) {
                // alternate wiggle direction each cycle for visual variation
                WormProps.wiggleToggle *= -1;
                var dir = WormProps.wiggleToggle; // -1 or +1
                WormProps.wiggleDir = dir;
                // vertical per-frame impulse in sim units
                var totalSimY = (WIGGLE_DISTANCE_PIXELS / cScale) * dir;
                WormProps.wigglePerFrameVel = (totalSimY / (WIGGLE_FRAMES * WormProps.dt));
                // horizontal propulsion per-frame (sim units)
                var totalSimX = (WIGGLE_X_PIXELS / cScale) * dir;
                WormProps.wigglePerFrameVelX = (totalSimX / (WIGGLE_FRAMES * WormProps.dt));
                // small pivot advance per frame to push the worm forward during wiggle
                var totalAdvanceSim = (WIGGLE_X_PIXELS * 0.5 / cScale) * dir; // proportional to X pixels
                WormProps.wiggleAdvancePerFrame = totalAdvanceSim / WIGGLE_FRAMES;
                WormProps.wiggleActive = true;
                WormProps.wiggleFrame = 0;
            }
            WormProps.prevHeadVY = headVY;
        }
        if (WormProps.wiggleActive) {
            var p = WormProps.SpaceWorm;
            if (p && p.pos.length > 1) {
                // apply per-frame vertical impulse to head (pos[1])
                p.pos[1].y += WormProps.wigglePerFrameVel * WormProps.dt;
                // apply small horizontal impulse to head
                p.pos[1].x += WormProps.wigglePerFrameVelX * WormProps.dt;
                // nudge prevPos to create a velocity impulse for the solver
                p.prevPos[1].y = p.pos[1].y - WormProps.wigglePerFrameVel * WormProps.dt * 0.5;
                p.prevPos[1].x = p.pos[1].x - WormProps.wigglePerFrameVelX * WormProps.dt * 0.5;
                // also advance the pivot a little to visualize propulsion
                p.pos[0].x += WormProps.wiggleAdvancePerFrame;
                p.prevPos[0].x += WormProps.wiggleAdvancePerFrame * 0.5;
            }
            WormProps.wiggleFrame++;
            if (WormProps.wiggleFrame >= WIGGLE_FRAMES) {
                WormProps.wiggleActive = false;
                WormProps.wiggleAdvancePerFrame = 0.0;
            }
        }

        // Run movement/wrap logic once per frame (per dT) instead of every substep.
        if (WormProps.SpaceWorm && !WormProps.isHiding) {
            var p = WormProps.SpaceWorm;
            // regular horizontal advance of the pivot (scaled to dT)
            // apply once per full time-step
            p.pos[0].x += ADVANCE_SPEED;
            // traveling-wave body undulation (fish-like propulsion)
            // advance the global wave phase
            WormProps.phase += WAVE_PHASE_INCREMENT;
            // compute amplitude in sim units
            var ampPixels = canvas.height * WAVE_AMPLITUDE_RATIO;
            var ampSim = ampPixels / cScale;
            // For each node, compute a target lateral position from a traveling sinusoid
            for (var i = 1; i < p.pos.length; i++) {
                // spatial phase lag increases toward the tail
                var nodePhase = WormProps.phase - (i * WAVE_NODE_LAG);
                var targetY = SPAWN_INITIAL_Y_SIM + ampSim * Math.sin(nodePhase);
                // nudge current node toward the target wave position (smooth steering)
                var deltaY = (targetY - p.pos[i].y) * WAVE_NUDGE;
                p.pos[i].y += deltaY;
                // update prevPos slightly so the solver sees an effective lateral velocity impulse
                p.prevPos[i].y += deltaY * 0.5;
                // compute lateral velocity (sim units / dt)
                var lateralV = (p.pos[i].y - p.prevPos[i].y) / WormProps.dt;
                // convert a portion of lateral motion into forward thrust
                // larger nodes (near the head) produce slightly less per-node thrust
                var sizeFactor = (i < p.radii.length ? p.radii[i] : 0.02);
                var thrust = -Math.sign(lateralV) * Math.abs(lateralV) * THRUST_COEFF * (sizeFactor * 50);
                // apply small forward displacement to simulate reaction against fluid
                p.pos[i].x += thrust;
                p.prevPos[i].x += thrust * 0.5;
            }
            // keep pivot vertically anchored to the spawn baseline so the whole body follows
            p.pos[0].y = SPAWN_INITIAL_Y_SIM + ampSim * Math.sin(WormProps.phase - (0 * WAVE_NODE_LAG));
        }
        
        // Handle worm wrap-around and delay logic
        if (WormProps.SpaceWorm) {
            var p = WormProps.SpaceWorm;

            // If the entire chain has passed the right edge, start hiding delay
            // or check if delay has elapsed to reappear on left side
            var minX = Infinity, maxX = -Infinity;
            for (var i = 0; i < p.pos.length; i++) {
                if (p.pos[i].x < minX) minX = p.pos[i].x;
                if (p.pos[i].x > maxX) maxX = p.pos[i].x;
            }
            var canvasRightSim = canvas.width / cScale;
            // Check when the last circle (tail) has fully passed the right edge.
            // Compute the left edge of the last circle (center.x - radius) in sim units
            var lastIdx = p.pos.length - 1;
            var lastRadius = (lastIdx < p.radii.length) ? p.radii[lastIdx] : 0.02;
            var lastLeftEdge = p.pos[lastIdx].x - lastRadius;
            
            if (lastLeftEdge > canvasRightSim && !WormProps.isHiding) {
                // Worm has completely passed right edge - start hiding period
                WormProps.isHiding = true;
                WormProps.hideStartTime = Date.now();
            } else if (WormProps.isHiding) {
                // Check if hiding delay has elapsed
                var currentTime = Date.now();
                if (currentTime - WormProps.hideStartTime >= WormProps.hideDelay) {
                    // Delay has elapsed - use original repositioning logic
                    WormProps.isHiding = false;
                    // spawnGap in sim units: pick either a pixel-based min or a fraction of canvas width
                    var spawnGapSim = Math.max(SPAWN_GAP_MIN_PIXELS / cScale, SPAWN_GAP_WIDTH_FACTOR * canvas.width / cScale, SPAWN_GAP_MIN_SIM);
                    var shiftSim = - (maxX + spawnGapSim);
                    for (var i = 0; i < p.pos.length; i++) {
                        p.pos[i].x += shiftSim;
                        p.prevPos[i].x += shiftSim; // keep prevPos in sync to avoid velocity spikes
                    }
                }
                // If still hiding, don't move the worm at all
            }
        }
    }

    //  MAKE WORM  ---------------------------------
    function makeWorm() {
        //  WORM CONSTANTS -----------
        steps = 100;
        // Tunable constants (edit these to change motion/spawn behavior)
        ADVANCE_SPEED = 0.01;                 // sim units per frame (horizontal advance)
        // Fish-style traveling wave (body undulation) parameters
        WAVE_AMPLITUDE_RATIO = 0.07;         // body wave amplitude as fraction of canvas height
        WAVE_PHASE_INCREMENT = 0.1;          // how fast the wave travels along the body (temporal frequency)
        WAVE_NODE_LAG = 0.7;                  // phase lag per node (spatial wave number)
        WAVE_NUDGE = 0.65;                    // how strongly nodes are nudged toward the target wave each frame (0..1)
        THRUST_COEFF = 0.0018;                // how much lateral motion converts to forward thrust (tweakable)
        // Joint angle limiting prevents the chain folding inward on itself.
        // Joint angle is measured between vectors (pos[i-1]-pos[i]) and (pos[i+1]-pos[i]).
        // A straight chain has angle ~= PI; we require angle >= MIN_JOINT_ANGLE.
        MIN_JOINT_ANGLE = Math.PI * 0.6;      // minimum allowed interior joint angle (radians). Lower -> more flexible.
        SPAWN_GAP_MIN_SIM = 0.1;               // min spawn gap in sim units used at setup
        SPAWN_GAP_MIN_PIXELS = 50;             // min spawn gap in pixels used at wrap-time
        SPAWN_GAP_WIDTH_FACTOR = 0.1;          // alternative spawn gap as fraction of canvas width (in sim units)
        // Wiggle tuning: quick impulse parameters. Wiggle will be triggered
        // when the head vertical velocity crosses zero (top/bottom of stroke).
        WIGGLE_FRAMES = 6;                     // frames over which the wiggle is applied
        WIGGLE_DISTANCE_PIXELS = 24;           // total vertical travel during wiggle (pixels)
        WIGGLE_X_PIXELS = 0;                   // total horizontal propulsion applied during wiggle (pixels)
        WIGGLE_VY_ZERO_THRESHOLD = 0.005;     // threshold to treat vy as zero
        // Initial spawn position in simulation units. These must be numeric values
        // (no fallback to computed defaults). Edit these to choose the pivot start.
        SPAWN_INITIAL_X_SIM = 0; // e.g. -2.0 puts pivot 2 sim units left of x=0
        SPAWN_INITIAL_Y_SIM = 0.5 * simHeight; // explicit vertical spawn position
        //leadRradius = 0.15;
        //minRradius = 0.05;
        //numNodes = 20;
        leadRradius = WormProps.startRadius;
        minRradius = WormProps.endRadius;
        numNodes = WormProps.numNodes;

        var angles = [];
        var lengths = [];
        var masses = [];
        var radii = [];
        if (numNodes == 1) {
            radii.push(leadRradius);
        } else {
            // progression from leadRradius to minRradius
            var ratio = Math.pow(minRradius / leadRradius, 1.0 / (numNodes - 1));
            for (var i = 0; i < numNodes; i++)
                radii.push(leadRradius * Math.pow(ratio, i));
        }
        //  Lengths are chosen so neighboring circles touch (center distance = r_prev + r_curr).
        //  lengths: distance from pivot to first node, then between nodes so circles touch
        lengths = [];
        var pivotRadius = leadRradius; // make pivot radius match lead so the first length fits
        for (var i = 0; i < numNodes; i++) {
            if (i == 0)
                lengths.push(1.03 * (pivotRadius + radii[0])); // extra space from pivot to head
            else
                lengths.push(1.03 * (radii[i - 1] + radii[i]));
        }
        //  set mass
        var massScale = 10000000;
        for (var i = 0; i < radii.length; i++) {
            masses.push(Math.max(0.0001, radii[i] * radii[i] * massScale));
        }

        WormProps.SpaceWorm = new WORM(masses, lengths, angles, radii);
        
        // Initialize worm delay state
        WormProps.isHiding = false;
        WormProps.hideStartTime = 0;
        
        // spawn the  chain
        (function(){
            var p = WormProps.SpaceWorm;
            if (!p) return;
            // compute total span from pivot to last node in sim units
            var totalSpan = 0.0;
            for (var i = 1; i < p.lengths.length; i++) {
                totalSpan += p.lengths[i];
            }
            // spawnGapSim: how far left of x=0 the rightmost node should be
            var spawnGapSim = Math.max(
                SPAWN_GAP_MIN_SIM, 
                SPAWN_GAP_WIDTH_FACTOR * canvas.width / cScale, 
                SPAWN_GAP_MIN_PIXELS / cScale
            );
            // startX is where the pivot (pos[0]) will be placed — use the
            // explicit SPAWN_INITIAL_X_SIM constant (no fallback).
            p.pos[0].x = SPAWN_INITIAL_X_SIM;
            // use explicit SPAWN_INITIAL_Y_SIM for vertical placement
            p.pos[0].y = SPAWN_INITIAL_Y_SIM;
            p.prevPos[0].x = p.pos[0].x;
            p.prevPos[0].y = p.pos[0].y;
            for (var i = 1; i < p.pos.length; i++) {
                // place each subsequent node to the LEFT of the previous one
                p.pos[i].x = p.pos[i-1].x - p.lengths[i];
                p.pos[i].y = SPAWN_INITIAL_Y_SIM;
                p.prevPos[i].x = p.pos[i].x;
                p.prevPos[i].y = p.pos[i].y;
            }
        })();
    }

    //  DEFINE CORNERS  ---------------------------------------------------------------------
    function makeCorners() {
        Corners = [];
        Corners.push(new CORNER(new Vector2(0, 0), 'northwest'));
        Corners.push(new CORNER(new Vector2(simWidth, 0), 'northeast'));
        Corners.push(new CORNER(new Vector2(0, simHeight), 'southwest'));
        Corners.push(new CORNER(new Vector2(simWidth, simHeight), 'southeast'));
    }

    //  DEFINE BUMPERS --------------------------------------------------------------
    function makeBumpers() {
        Bumpers = [];
        bumperRows = rowsInput.value;
        bumperRadius = bumperRadiusInput.value / 1000;
        gapMultiplier = 1.1;
        smallBumperRatio = 0.75;
        vertBumperPadding = 0.30;
        var smallBallRadius = smallBallInput.value / 1000;
        var bigBallRadius = bigBallInput.value / 1000;
        var maxBallRadius = Math.max(smallBallRadius, bigBallRadius);
        bumperSpacing = (2 * maxBallRadius) * gapMultiplier;
        combinedSpacing = (2 * bumperRadius) + bumperSpacing;
        verticalBPD = vertBumperPadding * combinedSpacing;
        combinedVerticalSpacing = (2 * bumperRadius) + bumperSpacing + verticalBPD;
        paddingCorrectionShift = -0.5 * ((bumperRows - 1) * verticalBPD);
        if (Math.trunc(simWidth / combinedSpacing) % 2 == 0) {
            bumperCols = Math.trunc(simWidth / combinedSpacing); 
        } else {
            bumperCols = Math.trunc(simWidth / combinedSpacing) + 1; 
        }
        bumperBarLengthX = ((bumperCols - 1.0) * bumperSpacing) + ((2.0 * (bumperCols -1.0)) * bumperRadius);
        bumperBarLengthY = ((bumperRows - 1.0) * bumperSpacing) + ((2.0 * (bumperRows -1.0)) * bumperRadius);
        centeringOffsetX = (simWidth / 2.0) - (bumperBarLengthX / 2.0);
        centeringOffsetY = (simHeight / 2.0) - (bumperBarLengthY / 2.0) + (-0.3 * simHeight + paddingCorrectionShift);
        bottomMargin = ((simHeight - bumperBarLengthY) / 2) + 2 * bumperRadius;
        topMargin = ((simHeight - bumperBarLengthY) / 2) + bumperBarLengthY + 2 * bumperRadius; 
        centeringOffsetY - combinedVerticalSpacing/2
        numBumpers = 0;
        for (p = -1; p < bumperCols; p++) {
            for (q = 0; q < bumperRows; q++) {
                if (q % 2 == 0) {
                    Bumpers.push(new BUMPER(bumperRadius, new Vector2((p * combinedSpacing) + (combinedSpacing / 2.0) + centeringOffsetX, (q * combinedVerticalSpacing) + centeringOffsetY)));        
                    numBumpers += 1;
                } else if (p > -1) {
                    Bumpers.push(new BUMPER(bumperRadius * smallBumperRatio, new Vector2((p * combinedSpacing) + centeringOffsetX, (q * combinedVerticalSpacing) + centeringOffsetY)));    
                    numBumpers += 1;
                }
            }
        }
    }

    //  BUMPER CONSTRUCTOR  ---------------------------------------------------------------------
	class BUMPER {
		constructor(radius, pos) {
			this.radius = radius;
			this.pos = pos.clone();
            this.OGpos = pos.clone();
		}
        get left() {
            return this.pos.x - this.radius;
        }
        get right() {
            return this.pos.x + this.radius;
        }
        draw() {
            drawCircle(cX(this.pos), cY(this.pos), this.radius * cScale);
            c.fillStyle = `hsl(0, 0%, 70%)`;
            c.fill();
            drawCircle(cX(this.pos), cY(this.pos), (this.radius - .002 * simWidth) * cScale);
            c.fillStyle = `hsl(0, 0%, 30%)`;
            c.fill();
        }
	}

    //  PUCK CONSTRUCTOR -----------------------------------------------------------------------
    class PUCK {
		constructor(radius, pos, color, special) {
			this.radius = radius;
            this.OGradius = radius;
			this.pos = pos.clone();
            this.vel = new Vector2(0, 0);
            this.prevPos = pos.clone();
            this.color = color;
            this.special = special;
            this.cycle = false; // custom cyclic radius behavior (Puck[3])
            this.mass = 0.001 * radius;
            this.puckFadingIn = false;
            this.moving = false;
            this.puckArriving = false;
            this.radiusRate = 0.0; // dR/dt for pulsing surface velocity

            // Heartbeat properties for special puck (Puck[2])
            if (special == true) {
                this.heartBpm = 40;
                this.heartPeriod = 60.0 / this.heartBpm; // seconds per beat
                // Durations within a single beat (must sum <= heartPeriod)
                // Fast rise, slower fall for each pulse, brief gap between pulses, then long pause
                this.hbDur = {
                    p1Rise: 0.02,
                    p1Fall: 0.20,
                    between: 0.01,
                    p2Rise: 0.1,
                    p2Fall: 0.20
                };
                this.hbPause = Math.max(0, this.heartPeriod - (this.hbDur.p1Rise + this.hbDur.p1Fall + this.hbDur.between + this.hbDur.p2Rise + this.hbDur.p2Fall));
                // State machine
                this.hbState = 'p1Rise';
                this.hbTimeInState = 0.0;
                this.hbLastTime = performance.now();
                // Post-drag resume control (ms timestamp from performance.now(); 0 = inactive)
                this.hbResumeAt = 0;
                // Visual scaling
                this.hbAmp = 0.5;      // max +% radius at first peak
                // Between-pulses baseline: fraction between base (1.0) and first peak (1.0 + hbAmp)
                // 0.0 => base radius, 1.0 => first peak radius
                this.hbBetweenFrac = 0.85; // barely shrink between pulses
            }
		}
        // Initialize the cycle puck state machine (called after setting this.cycle=true)
        initCycle() {
            this.cycPeriod = 5.0; // total seconds
            this.cycDur = { grow: 0.3, shrink: 2.0, recover: 2.0 };
            this.cycState = 'grow';
            this.cycTimeInState = 0.0;
            this.cycLastTime = performance.now();
            this.cycMax = 5.0;   // 4x base
            this.cycMin = 1.0;   // 0.5x base
            // Delay cycling at startup for 6 seconds
            this.cycResumeAt = this.cycLastTime + 6000; // ms timestamp
        }

        simulate() {
            // HEART SPECIAL -------------------------------------------------
            if (this.special) {
                // Special puck heartbeat animation (time-based, independent of framerate)
            const now = performance.now();

            // If the puck is being dragged/moved, reset to base size and hold state timing (no pulses while moving)
            if (this.moving) {
                // No pulsing while being dragged; also clear surface speed
                this.radiusRate = 0.0;
                this.radius = this.OGradius;
                // Prevent dt from accumulating during drag
                this.hbLastTime = now;
                return;
            }

            // If a post-release delay is active, hold at base until resume time
            if (this.hbResumeAt && now < this.hbResumeAt) {
                this.radiusRate = 0.0;
                this.radius = this.OGradius;
                // Prevent dt accumulation while waiting
                this.hbLastTime = now;
                return;
            }
            // If we just reached resume time, restart beat at beginning after 1s delay
            if (this.hbResumeAt && now >= this.hbResumeAt) {
                this.hbResumeAt = 0;
                this.hbState = 'p1Rise';
                this.hbTimeInState = 0.0;
                this.hbLastTime = now;
            }

            const dt = Math.max(0, (now - this.hbLastTime) / 1000.0);
            this.hbLastTime = now;

            // Helper easing functions
            const easeOutCubic = (t)=> 1 - Math.pow(1 - t, 3); // quick start, slow end (fast rise)
            const easeInCubic  = (t)=> Math.pow(t, 3);         // slow start, quick end (slow fall perception)

            // Advance state machine
            let advance = (duration)=> {
                this.hbTimeInState += dt;
                if (this.hbTimeInState >= duration) {
                    this.hbTimeInState -= duration;
                    return true; // signal to move to next state
                }
                return false;
            };

            // Calculate current radius scale based on state
            const d = this.hbDur;
            const baselineBetween = 1.0 + this.hbBetweenFrac * this.hbAmp; // target level between pulses
            let scale = 1.0;
            switch (this.hbState) {
                case 'p1Rise': {
                    if (advance(d.p1Rise)) { this.hbState = 'p1Fall'; }
                    const t = Math.min(1, this.hbTimeInState / d.p1Rise);
                    scale = 1.0 + this.hbAmp * easeOutCubic(t);
                    break;
                }
                case 'p1Fall': {
                    if (advance(d.p1Fall)) { this.hbState = 'between'; }
                    const t = Math.min(1, this.hbTimeInState / d.p1Fall);
                    // Fall from first peak down to the configured between-baseline (avoid deep dip)
                    const start = 1.0 + this.hbAmp;
                    const end = baselineBetween;
                    scale = end + (start - end) * (1.0 - easeInCubic(t));
                    break;
                }
                case 'between': {
                    if (advance(d.between)) { this.hbState = 'p2Rise'; }
                    // Hold at a configurable level between base and the first peak
                    scale = baselineBetween;
                    break;
                }
                case 'p2Rise': {
                    if (advance(d.p2Rise)) { this.hbState = 'p2Fall'; }
                    const t = Math.min(1, this.hbTimeInState / d.p2Rise);
                    // Rise from the between-baseline up to the second peak (no initial drop)
                    const peak2 = 1.0 + this.hbAmp;
                    scale = baselineBetween + (peak2 - baselineBetween) * easeOutCubic(t);
                    break;
                }
                case 'p2Fall': {
                    if (advance(d.p2Fall)) { this.hbState = (this.hbPause > 0 ? 'pause' : 'p1Rise'); }
                    const t = Math.min(1, this.hbTimeInState / d.p2Fall);
                    scale = 1.0 + this.hbAmp * (1.0 - easeInCubic(t));
                    break;
                }
                case 'pause': default: {
                    if (advance(this.hbPause)) { this.hbState = 'p1Rise'; }
                    scale = 1.0;
                    break;
                }
            }

            // Compute surface radial speed from radius change
            const newRadius = this.OGradius * scale;
            const safeDt = Math.max(1e-6, dt);
            this.radiusRate = (newRadius - this.radius) / safeDt;
            this.radius = newRadius;
                return;
            }

            // CYCLE SPECIAL (Puck[3]) -------------------------------------
            if (this.cycle) {
                const now = performance.now();
                if (this.moving) {
                    this.radiusRate = 0.0;
                    this.radius = this.OGradius;
                    this.cycLastTime = now;
                    return;
                }

                // Hold at base until resume time (startup or post-drag)
                if (this.cycResumeAt && now < this.cycResumeAt) {
                    this.radiusRate = 0.0;
                    this.radius = this.OGradius;
                    this.cycLastTime = now; // prevent dt accumulation
                    return;
                }
                if (this.cycResumeAt && now >= this.cycResumeAt) {
                    // Resume cycling from beginning after delay
                    this.cycResumeAt = 0;
                    this.cycState = 'grow';
                    this.cycTimeInState = 0.0;
                    this.cycLastTime = now;
                }

                const dt = Math.max(0, (now - this.cycLastTime) / 1000.0);
                this.cycLastTime = now;

                // Easing helpers
                const easeInQuad = (t)=> t*t;      // accelerating
                const easeOutQuad = (t)=> 1-(1-t)*(1-t); // decelerating

                // Advance within state
                const adv = (dur)=>{
                    this.cycTimeInState += dt;
                    if (this.cycTimeInState >= dur) {
                        this.cycTimeInState -= dur;
                        return true;
                    }
                    return false;
                };

                let scale = 1.0;
                switch (this.cycState) {
                    case 'grow': {
                        if (adv(this.cycDur.grow)) { this.cycState = 'shrink'; }
                        const t = Math.min(1, this.cycTimeInState / this.cycDur.grow);
                        // ease-in from 1.0 -> 4.0
                        scale = 1.0 + (this.cycMax - 1.0) * easeInQuad(t);
                        break;
                    }
                    case 'shrink': {
                        if (adv(this.cycDur.shrink)) { this.cycState = 'recover'; }
                        const t = Math.min(1, this.cycTimeInState / this.cycDur.shrink);
                        // linear from 4.0 -> 0.5
                        scale = this.cycMax + (this.cycMin - this.cycMax) * t;
                        break;
                    }
                    case 'recover': default: {
                        if (adv(this.cycDur.recover)) { this.cycState = 'grow'; }
                        const t = Math.min(1, this.cycTimeInState / this.cycDur.recover);
                        // ease-out from 0.5 -> 1.0
                        scale = this.cycMin + (1.0 - this.cycMin) * easeOutQuad(t);
                        break;
                    }
                }

                const newRadius = this.OGradius * scale;
                const safeDt = Math.max(1e-6, dt);
                this.radiusRate = (newRadius - this.radius) / safeDt;
                this.radius = newRadius;
                return;
            }

            // DEFAULT: Non-special arrival growth behavior -----------------
            for (var r = 0; r < this.OGradius; r++) {
                if (this.radius >= this.OGradius) {
                    this.radius = this.OGradius;
                    this.puckArriving = false;
                } else {
                    this.radius += this.OGradius * 0.0001;
                }
            }
            return;
        }
        draw() {
            if (this.puckFadingIn == true) {
                var fadeInTimer = 400; 
                var timeSinceMouseUp = Date.now() - mouseUpTime;
                var alphaPercent = timeSinceMouseUp / fadeInTimer;
                if (timeSinceMouseUp >= fadeInTimer) {
                    this.puckFadingIn = false;
                }
            } else {
                var alphaPercent = 1;
            }
            // DRAW HEART PUCK  -----------
            if (this.special == true) {
                if (this.moving == false) {  // stationary heartbeat renderingb ----------
                    drawCircle(cX(this.pos), cY(this.pos), 0.985 * this.radius * cScale);
                    const grd = c.createRadialGradient(
                        cX(this.pos), 
                        cY(this.pos), 
                        0, 
                        cX(this.pos), 
                        cY(this.pos), 
                        1.3 *this.radius * cScale);
                    grd.addColorStop(1, `hsla(220, 70%, 30%, ${alphaPercent * 0.4})`);
                    grd.addColorStop(0.5, `hsla(220, 60%, 5%, ${alphaPercent * 0.4})`);
                    c.fillStyle = grd;
                    c.fill();
                    c.strokeStyle = `hsla(0, 0%, 60%, ${alphaPercent})`;
                    c.lineWidth = 0.01 * cScale;
                    c.stroke();

                    c.fillStyle = `hsla(320, 80%, 50%, ${alphaPercent})`;
                    c.textBaseline = 'middle';
                    c.textAlign = "center";
                    c.font = `${(0.60 * this.OGradius + 0.5 * this.radius) * cScale}px monospace`;
                    c.fillText("♥", this.pos.x * cScale, (simHeight - this.pos.y + 0.20 * this.OGradius) * cScale);
                } else {  // moving heartbeat rendering  ----------
                    drawCircle(cX(this.pos), cY(this.pos), this.radius * cScale);
                    const grd = c.createRadialGradient(
                        cX(this.pos), 
                        cY(this.pos), 
                        0, 
                        cX(this.pos), 
                        cY(this.pos), 
                        1.0 *this.radius * cScale);
                    grd.addColorStop(0, `hsla(220, 70%, 15%, ${alphaPercent * 0.2})`);
                    grd.addColorStop(1.0, `hsla(220, 70%, 8%, ${alphaPercent * 0.2})`);
                    c.fillStyle = grd;
                    c.fill();

                    c.fillStyle = `hsla(320, 80%, 50%, ${alphaPercent - 0.9})`;
                    c.textBaseline = 'middle';
                    c.textAlign = "center";
                    c.font = `${(0.60 * this.OGradius + 0.5 * this.radius) * cScale}px monospace`;
                    c.fillText("♥", this.pos.x * cScale, (simHeight - this.pos.y + 0.20 * this.OGradius) * cScale);
                }
            } else { 
                // DRAW NORMAL PUCK  -----------
                if (this.moving == false) {
                drawCircle(cX(this.pos), cY(this.pos), 0.985 * this.radius * cScale);
                const grd = c.createRadialGradient(
                    cX(this.pos), 
                    cY(this.pos), 
                    0, 
                    cX(this.pos), 
                    cY(this.pos), 
                    1.3 *this.radius * cScale);
                grd.addColorStop(1, `hsla(220, 70%, 30%, ${alphaPercent * 0.4})`);
                grd.addColorStop(0.5, `hsla(220, 60%, 5%, ${alphaPercent * 0.4})`);
                c.fillStyle = grd;
                c.fill();

                c.strokeStyle = `hsla(0, 0%, 60%, ${alphaPercent})`;
                c.lineWidth = 0.01 * cScale;
                c.stroke();

                // Cycle puck center icon (✢) when this is the cycle puck
                if (this.cycle === true) {
                    const baseFontPx = (0.5 * this.OGradius) * cScale; // constant base size
                    // Slow growth like heart: effective size ~ OGradius + 0.5 * radius
                    const scaleFactor = Math.max(0.0001, (this.OGradius + 0.5 * this.radius) / (1.5 * this.OGradius));
                    const cx = this.pos.x * cScale;
                    const cy = (simHeight - this.pos.y) * cScale; // keep baseline anchored
                    c.save();
                    c.translate(Math.round(cx) + 0.5, Math.round(cy) + 0.5);
                    c.scale(scaleFactor, scaleFactor);
                    c.fillStyle = `hsla(190, 80%, 55%, ${alphaPercent})`;
                    c.textBaseline = 'middle';
                    c.textAlign = 'center';
                    c.font = `${baseFontPx}px verdana`;
                    c.fillText("!!!", 0, 0);
                    c.restore();
                }
                } else { // moving normal puck ----------
                    drawCircle(cX(this.pos), cY(this.pos), this.radius * cScale);
                    const grd = c.createRadialGradient(
                        cX(this.pos), 
                        cY(this.pos), 
                        0, 
                        cX(this.pos), 
                        cY(this.pos), 
                        1.0 *this.radius * cScale);
                    grd.addColorStop(0, `hsla(220, 70%, 15%, ${alphaPercent * 0.2})`);
                    grd.addColorStop(1.0, `hsla(220, 70%, 8%, ${alphaPercent * 0.2})`);
                    c.fillStyle = grd;
                    c.fill();

                    // Cycle puck center icon (✢) when moving, more subtle alpha
                    if (this.cycle === true) {
                        const baseFontPx = (0.5 * this.OGradius) * cScale;
                        // Slow growth like heart: effective size ~ OGradius + 0.5 * radius
                        const scaleFactor = Math.max(0.0001, (this.OGradius + 0.5 * this.radius) / (1.5 * this.OGradius));
                        const cx = this.pos.x * cScale;
                        const cy = (simHeight - this.pos.y) * cScale; // keep offset constant, not scaling with radius
                        c.save();
                        c.translate(Math.round(cx) + 0.5, Math.round(cy) + 0.5);
                        c.scale(scaleFactor, scaleFactor);
                        c.fillStyle = `hsla(190, 80%, 55%, ${Math.max(0, alphaPercent - 0.9)})`;
                        c.textBaseline = 'middle';
                        c.textAlign = 'center';
                        c.font = `${baseFontPx}px verdana`;
                        c.fillText("!!!", 0, 0);
                        c.restore();
                    }
                }
            }
        }
        get left() {
            return this.pos.x - this.radius;
        }
        get right() {
            return this.pos.x + this.radius;
        }
	}
    
    //  HUNGRY PUCK CONSTRUCTOR ----------------------------------------------------------------
    class HUNGRYPUCK {
		constructor(radius, pos, vel, color) {
			this.radius = radius;
			this.pos = pos.clone();
            this.vel = vel.clone();
            this.color = color;
		}
        get left() {
            return this.pos.x - this.radius;
        }
        get right() {
            return this.pos.x + this.radius;
        }
        draw1() {
            // body
            const grd = c.createRadialGradient(cX(this.pos), cY(this.pos), 1.2 * this.radius * cScale, 
            cX(this.pos), cY(this.pos), 1.6 * this.radius * cScale);
            grd.addColorStop(0.0, `hsla(0, 0%, 0%, 100%)`);
            grd.addColorStop(1.0, `hsla(0, 0%, 0%, 0%)`);
            c.fillStyle = grd;
            drawCircle(cX(this.pos), cY(this.pos), 1.6 * this.radius * cScale);
            c.fill();
            // eyes
            c.strokeStyle = "hsl(120, 50%, 50%)";
            c.lineWidth = 0.04 * this.radius * cScale;
            c.beginPath();
            c.moveTo(cX(this.pos) + 0.2 * this.radius * cScale, cY(this.pos) - 0.2 * this.radius * cScale);
            c.lineTo(cX(this.pos) + 0.5 * this.radius * cScale, cY(this.pos) - 0.3 * this.radius * cScale);
            c.stroke();
            c.beginPath();
            c.moveTo(cX(this.pos) - 0.2 * this.radius * cScale, cY(this.pos) - 0.2 * this.radius * cScale);
            c.lineTo(cX(this.pos) - 0.5 * this.radius * cScale, cY(this.pos) - 0.3 * this.radius * cScale);
            c.stroke();
            // mouth
            c.strokeStyle = "hsl(90, 40%, 20%)";
            c.lineWidth = 0.06 * this.radius * cScale;
            c.beginPath();
            c.arc(cX(this.pos), cY(this.pos), 0.9 * this.radius * cScale, 0, Math.PI) 
            c.stroke();
            // dimples
            c.fillStyle = "hsl(90, 40%, 30%)";
            drawCircle(cX(this.pos) + 0.9 * this.radius * cScale, cY(this.pos), 0.07 * this.radius * cScale);
            c.fill();
            drawCircle(cX(this.pos) - 0.9 * this.radius * cScale, cY(this.pos), 0.07 * this.radius * cScale);
            c.fill();   
        }
        draw2() {
            // body
            const grd = c.createRadialGradient(cX(this.pos), cY(this.pos), 1.2 * this.radius * cScale, 
            cX(this.pos), cY(this.pos), 1.6 * this.radius * cScale);
            grd.addColorStop(0.0, `hsla(0, 0%, 0%, 100%)`);
            grd.addColorStop(1.0, `hsla(0, 0%, 0%, 0%)`);
            c.fillStyle = grd;
            drawCircle(cX(this.pos), cY(this.pos), 1.6 * this.radius * cScale);
            c.fill();
            // eyes
            c.strokeStyle = "hsl(335, 70%, 60%)";
            c.lineWidth = 0.04 * this.radius * cScale;
            c.beginPath();
            c.moveTo(cX(this.pos) + 0.25 * this.radius * cScale, cY(this.pos) - 0.2 * this.radius * cScale);
            c.lineTo(cX(this.pos) + 0.55 * this.radius * cScale, cY(this.pos) - 0.25 * this.radius * cScale);
            c.stroke();
            c.beginPath();
            c.moveTo(cX(this.pos) - 0.25 * this.radius * cScale, cY(this.pos) - 0.2 * this.radius * cScale);
            c.lineTo(cX(this.pos) - 0.55 * this.radius * cScale, cY(this.pos) - 0.25 * this.radius * cScale);
            c.stroke();
            // mouth
            c.strokeStyle = "hsl(335, 50%, 45%)";
            c.lineWidth = 0.05 * this.radius * cScale;
            c.beginPath();
            c.arc(cX(this.pos), cY(this.pos) + 0.4 * this.radius * cScale, 0.2 * this.radius * cScale, Math.PI, 0);
            c.stroke();
            // cheeks
            c.fillStyle = "hsl(335, 40%, 20%)";
            drawCircle(cX(this.pos) + 0.8 * this.radius * cScale, cY(this.pos) + 0.2 * this.radius * cScale, 0.2 * this.radius * cScale);
            c.fill();
            drawCircle(cX(this.pos) - 0.8 * this.radius * cScale, cY(this.pos) + 0.2 * this.radius * cScale, 0.2 * this.radius * cScale);
            c.fill();
        }
	}

    //  MR. MISTER CONSTRUCTOR ----------------------------------------------------------------
    class MISTERMISTER {
		constructor(pos, vel, color) {
			this.pos = pos.clone();
            this.vel = vel.clone();
            this.color = color;
            this.radius = 0.15;
            this.respawnDir = 0;
		}
        get left() {
            return this.pos.x - this.radius;
        }
        get right() {
            return this.pos.x + this.radius;
        }
        simulate() {
            if (mrMode == 'billiard') {
                this.pos.add(this.vel, physProps.dt)
            }
            if (mrMode == "typewriter") {
                if (goLeft == false) {
                    this.pos.x += this.vel.x * physProps.dt * misterSpeed;
                        if (this.pos.x > simWidth) {
                            goLeft = true;
                        }
                }
                if (goLeft == true) {
                    this.pos.x -= this.vel.x * 5 * physProps.dt * misterSpeed;
                        if (this.pos.x < 0) {
                            goLeft = false;
                        };
                }
            }
            if (mrMode == "printer") {
                if (goLeft == false) {
                    this.pos.x += this.vel.x * physProps.dt * misterSpeed;
                        if (this.pos.x > simWidth) {
                            goLeft = true;
                        }
                }
                if (goLeft == true) {
                    this.pos.x -= this.vel.x * physProps.dt * misterSpeed;
                        if (this.pos.x < 0) {
                            goLeft = false;
                        };
                }
            }
            if (mrMode == "scanner") {
                if (this.pos.x < 1.5 * this.radius + simWidth) {
                    this.pos.x += this.vel.x * physProps.dt * misterSpeed;
                }
                if (this.pos.x > 1.5 * this.radius + simWidth) {
                    this.pos.x = -1.5 * this.radius;
                }
            }
            if (mrMode == "circle") {
                delta += physProps.dt * misterSpeed;
                this.pos.x = 0.5 * simWidth + 0.2 * simWidth * Math.cos(delta);
                this.pos.y = 0.5 * simHeight + 0.2 * simWidth * Math.sin(delta);
            }
            if (mrMode == "oval") {
                delta += physProps.dt * misterSpeed;
                this.pos.x = 0.5 * simWidth + 0.3 * simWidth * Math.cos(delta);
                this.pos.y = 0.5 * simHeight + 0.3 * simHeight * Math.sin(delta);
            }
            if (mrMode == "bernoulli") {
                delta += physProps.dt * misterSpeed;
                var pathScale = 2 / (3 - Math.cos(2 * delta));
                this.pos.x = (0.5 * simWidth) + (0.4 * simWidth) * pathScale * Math.cos(delta);
                this.pos.y = (0.5 * simHeight) + (0.3 * simWidth) * pathScale * Math.sin(2 * delta) / 2;
            }
            if (mrMode == "worm") {
                if (WormProps.SpaceWorm && WormProps.SpaceWorm.pos.length > 1) {
                    this.pos.x = WormProps.SpaceWorm.pos[1].x;
                    this.pos.y = WormProps.SpaceWorm.pos[1].y;
                } else {
                    this.pos.x = 0.5 * simWidth;
                    this.pos.y = 0.5 * simHeight;
                }
            }
        }
        draw() {
            mrMrTimer += .05;
            var eyeLight = 30 + 70 * Math.abs(Math.sin(mrMrTimer));
            // body
            if (mrMode != 'worm') {
                const grd = c.createRadialGradient(cX(this.pos), cY(this.pos), 1.2 * 0.15 * cScale, 
                cX(this.pos), cY(this.pos), 1.6 * 0.15 * cScale);
                grd.addColorStop(0.0, `hsla(0, 0%, 0%, 100%)`);
                grd.addColorStop(1.0, `hsla(0, 0%, 0%, 0%)`);
                c.fillStyle = grd;
                c.strokeStyle = `hsl(200, 80%, ${eyeLight}%)`;
                drawCircle(cX(this.pos), cY(this.pos), 1.6 * 0.15 * cScale);
            } else {
                var sphereGradient = c.createRadialGradient(
                (cX(this.pos) - (this.radius * cScale)), 
                (cY(this.pos) - (0.4 * this.radius * cScale)), 
                0, 
                (cX(this.pos) - (0.2 * this.radius * cScale)), 
                (cY(this.pos) - (0.4 * this.radius * cScale)), 
                this.radius * cScale
                );
                var highlight = 'hsl(30, 80%, 80%)';
                var midtone = 'hsl(30, 80%, 60%)';
                var shadow = 'hsl(30, 80%, 10%)';
                sphereGradient.addColorStop(0.0, highlight);
                sphereGradient.addColorStop(0.15, midtone);
                sphereGradient.addColorStop(1.0, shadow);
                c.fillStyle = sphereGradient;
                c.strokeStyle = `hsl(200, 80%, ${eyeLight -40}%)`;
                drawCircle(cX(this.pos), cY(this.pos), 1.0 * 0.15 * cScale);
            }
            c.fill();
            // eyes  ----------
            c.lineWidth = 0.05 * 0.2 * cScale;
            c.beginPath();
            c.moveTo(cX(this.pos) + 0.35 * 0.15 * cScale, cY(this.pos) - 0.1 * 0.15 * cScale);
            c.lineTo(cX(this.pos) + 0.7 * 0.15 * cScale, cY(this.pos) - 0.1 * 0.15 * cScale);
            c.stroke();
            c.beginPath();
            c.moveTo(cX(this.pos) - 0.3 * 0.15 * cScale, cY(this.pos) - 0.1 * 0.15 * cScale);
            c.lineTo(cX(this.pos) - 0.65 * 0.15 * cScale, cY(this.pos) - 0.1 * 0.15 * cScale);
            c.stroke();
            // mouth  ----------
            if (mrMode == 'worm') {
                c.fillStyle = `black`;
                c.lineWidth = 0.05 * 0.2 * cScale;
                c.beginPath();
                c.ellipse(
                cX(this.pos), 
                cY(this.pos) + 0.45 * 0.15 * cScale, 
                0.45 * 0.15 * cScale, 
                0.35 * 0.15 * cScale, 
                0, 
                0, 
                2 * Math.PI, false);
                c.fillStyle = `black`;
            } else {
                c.fillStyle = `hsl(200, 80%, ${40 - eyeLight / 3}%)`;
                c.lineWidth = 0.05 * 0.2 * cScale;
                c.beginPath();
                c.ellipse(
                cX(this.pos), 
                cY(this.pos) + 0.7 * 0.15 * cScale, 
                0.45 * 0.15 * cScale, 
                0.35 * 0.15 * cScale, 
                0, 
                0, 
                2 * Math.PI, false);
            }
            
            c.fill();
            c.stroke();
        }
	}

    //  DEFINE PUCKS MAKE PUCKS -----------------------------------------------------------------         
    function makePucks() {
        Puck = [];
        puck1color = `hsla(70, 20%, 40%, 65%)`;
        puck2color = `hsla(160, 20%, 30%, 65%)`;
        // NORMAL PUCKS  ----------------------------------------------------------
        Puck.push (new PUCK(
            1.0 * puckRadiusSlider.value / 1000, 
            new Vector2(0.35 * simWidth, 
                0.2 * simHeight), 
                puck2color, 
                false));
        Puck.push (new PUCK(0.5 * puckRadiusSlider.value / 1000, 
            new Vector2(0.7 * simWidth, 
                0.8 * simHeight), 
                puck1color, 
                false));
        //  HEARTBEAT PUCK  ----------------------------------------------------------
        Puck.push (new PUCK(1.0 * puckRadiusSlider.value / 1000, 
            new Vector2(0.65 * canvas.width / cScale, 
                0.1 * canvas.height / cScale), 
                puck2color, 
                true));
        //  CYCLE PUCK (Puck[3])  ---------------------------------------------------
        Puck.push (new PUCK(0.5 * puckRadiusSlider.value / 1000,
            new Vector2(0.5 * simWidth, 
                0.9 * simHeight), 
                puck1color, 
                false));
            // mark last puck as cycle-type and init its state machine
            if (Puck.length > 3) {
                Puck[3].cycle = true;
                if (typeof Puck[3].initCycle === 'function') {
                    Puck[3].initCycle();
                }
            }
        }
    
    //  DEFINE HUNGRY PUCKS ----------------------------------------------------------        
    function makeHungryPucks() {
        Hungrypuck = [];
        hungryPuckVel = new Vector2(0, 0);
        Hungrypuck.push (new HUNGRYPUCK(0.15, new Vector2(0.7 * simWidth, -0.1 * 0.15), hungryPuckVel, `hsl(0, 50%, 50%)`));
        Hungrypuck.push (new HUNGRYPUCK(0.15, new Vector2(0.3 * simWidth, -0.1 * 0.15), hungryPuckVel, `hsl(0, 50%, 50%)`));
    }
    
    // DEFINE MR. MISTER  ------------------------------------------------------------
    function makeMisterMister() {
        MisterMister = [];
        mrMrVel = new Vector2(1, 0);
        MisterMister.push (new MISTERMISTER(new Vector2(
            0.3 * simWidth, 
            0.85 * simHeight), 
            mrMrVel, 
            `hsl(0, 50%, 50%)`));
    }

    // END OF PUSH DEFINITIONS =======================================================

    //  SIMULATION --------------------------------------------------------------------------
	function simulate() {
        if (physProps.paused)
            return;	

        //  DRAW WORM ---------------------------------------------------------------------
        if (doWorm == true) {
            simulateWorm();
        }

        //  MR. & MRS. MISTER  ----------------------------------
        if (doFountain == true) {
            var mrMr = MisterMister[0];
            mrMr.simulate();
        }

        //  BALLS ----------------------------------
        // Precompute bumper sweep structures once per frame
        let bumperCtx = null;
        if (showBumpers && Array.isArray(Bumpers) && Bumpers.length) {
            const lowest = Bumpers[0];
            const highest = Bumpers[Bumpers.length - 1];
            const arrayBottom = lowest.pos.y - lowest.radius;
            const arrayTop = highest.pos.y + highest.radius;
            const sortedBumpers = Bumpers.slice().sort((a,b)=>a.left-b.left);
            bumperCtx = { arrayBottom, arrayTop, sortedBumpers };
        }

        // Phase 1: integrate & per-ball updates (no ball-ball collisions yet)
        for (let i = 0; i < Balls.length; i++) {
            const b = Balls[i];
            b.simulate();
            if (doTracer && b.tracerBall) b.updateTrace();
            // Worm immunity countdown
            if (b.immuneToWorm) {
                if (typeof b.immunityFramesLeft === 'undefined') b.immunityFramesLeft = 10;
                if (b.immunityFramesLeft > 0) {
                    b.immunityFramesLeft--;
                    if (b.immunityFramesLeft <= 0) b.immuneToWorm = false;
                }
            }
            // Hungry puck interaction (uses current position only; order independent)
            if (showEaters) {
                for (let h = 0; h < Hungrypuck.length; h++) {
                    const hp = Hungrypuck[h];
                    if (hp.right > b.left && Math.abs(b.pos.y - hp.pos.y) <= b.radius + hp.radius) {
                        handleHungryPuckHits(b, hp);
                    }
                }
            }
            // Puck special arrival sims
            for (let p = 0; p < Puck.length; p++) {
                const puck = Puck[p];
                const shouldSim = puck.puckArriving || (puck.special && showHeart) || (puck.cycle && showCycle);
                if (shouldSim) puck.simulate();
            }
            // Puck collisions
            for (let p = 0; p < Puck.length; p++) {
                const puck = Puck[p];
                if (puck.special && !showHeart) continue;
                if (puck.cycle && !showCycle) continue;
                if (!puck.special && !puck.cycle && !showPucks) continue;
                if (puck.right < b.left) continue;
                if (Math.abs(b.pos.y - puck.pos.y) <= b.radius + puck.radius) handlePuckHits(b, puck);
            }
            // Worm segment collisions (broad-phase bbox + narrow-phase) kept as-is
            if (!b.immuneToWorm && doWorm && WormProps.SpaceWorm && WormProps.SpaceWorm.pos.length > 1) {
                const worm = WormProps.SpaceWorm;
                let wormMinX = Infinity, wormMaxX = -Infinity, wormMinY = Infinity, wormMaxY = -Infinity;
                for (let w = 0; w < worm.pos.length; w++) {
                    const sr = (w < worm.radii.length && typeof worm.radii[w] === 'number') ? worm.radii[w] : 0.02;
                    wormMinX = Math.min(wormMinX, worm.pos[w].x - sr);
                    wormMaxX = Math.max(wormMaxX, worm.pos[w].x + sr);
                    wormMinY = Math.min(wormMinY, worm.pos[w].y - sr);
                    wormMaxY = Math.max(wormMaxY, worm.pos[w].y + sr);
                }
                if (b.pos.x + b.radius >= wormMinX && b.pos.x - b.radius <= wormMaxX && b.pos.y + b.radius >= wormMinY && b.pos.y - b.radius <= wormMaxY) {
                    for (let w = 0; w < worm.pos.length; w++) {
                        const sr = (w < worm.radii.length && typeof worm.radii[w] === 'number') ? worm.radii[w] : 0.02;
                        const dx = b.pos.x - worm.pos[w].x;
                        const dy = b.pos.y - worm.pos[w].y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist <= b.radius + sr) handleWormSegmentHits(b, worm.pos[w], sr, worm.vel[w]);
                    }
                }
            }
            // Corner collisions
            for (let v = 0; v < Corners.length; v++) {
                const corner = Corners[v];
                let skip = false;
                if (corner.corner == 'northwest') skip = !doFloor || !doLeftWall;
                else if (corner.corner == 'northeast') skip = !doFloor || !doRightWall;
                else if (corner.corner == 'southwest') skip = !doCeiling || !doLeftWall;
                else skip = !doCeiling || !doRightWall;
                if (skip) continue;
                let check = false;
                if (corner.corner == 'northwest' || corner.corner == 'southwest') check = corner.right > b.left && Math.abs(b.pos.y - corner.pos.y) <= b.radius + corner.radius;
                else check = corner.left < b.left && Math.abs(b.pos.y - corner.pos.y) <= b.radius + corner.radius;
                if (check) handleCornerHits(b, corner);
            }
            // Bounds
            if (mrMode == 'billiard') handleMrMrBounds(MisterMister[0], physProps.worldSize);
            handleOutOfBounds(b, physProps.worldSize);
            // Bumpers (after position update; broad-phase by vertical slice)
            if (bumperCtx) {
                if (b.bottom <= bumperCtx.arrayTop && b.top >= bumperCtx.arrayBottom) {
                    for (let k = 0; k < bumperCtx.sortedBumpers.length; k++) {
                        const bumper = bumperCtx.sortedBumpers[k];
                        if (bumper.left > b.right) break;
                        if (Math.abs(b.pos.y - bumper.pos.y) <= b.radius + bumper.radius) handleBumperHits(b, bumper);
                    }
                }
            }
        }

        // Phase 2: ball-ball collisions (broad-phase)
        const useSpatial = Balls.length > 3600; // threshold; tweak as needed
        if (!useSpatial) {
            // Original sweep & prune with sort (but only once per frame, not per substep loop)
            const sorted = Balls.slice().sort((a,b)=>a.left-b.left);
            for (let i = 0; i < sorted.length; i++) {
                const a = sorted[i];
                for (let j = i+1; j < sorted.length; j++) {
                    const b = sorted[j];
                    if (ballRepulsion) {
                        // Early-out when beyond repulsion span on X
                        const span = physProps.repulsionDist * (a.radius + b.radius);
                        if ((b.left - a.right) > span) break;
                    } else {
                        if (b.left > a.right) break; // no more overlapping on x
                    }
                    // Radial tests to avoid axis-aligned artifacts (square patterns)
                    const dx = a.pos.x - b.pos.x;
                    const dy = a.pos.y - b.pos.y;
                    const dist2 = dx*dx + dy*dy;
                    const sumR = a.radius + b.radius;
                    const sumR2 = sumR * sumR;
                    if (ballRepulsion) {
                        const rep = physProps.repulsionDist * sumR;
                        if (dist2 < rep*rep) handleBallRepulsion(a,b);
                        if (dist2 <= sumR2) handleBallHits(a,b);
                    } else {
                        if (dist2 <= sumR2) handleBallHits(a,b);
                    }
                }
            }
        } else {
            // Uniform grid spatial hash
            let maxR = 0;
            for (let i=0;i<Balls.length;i++) if (Balls[i].radius>maxR) maxR = Balls[i].radius;
            const cellSize = Math.max( (ballRepulsion? physProps.repulsionDist:1) * (2*maxR), 2*maxR );
            const cols = Math.max(1, Math.floor(simWidth / cellSize) + 1);
            const rows = Math.max(1, Math.floor(simHeight / cellSize) + 1);
            const grid = new Array(cols * rows);
            for (let g=0; g<grid.length; g++) grid[g] = [];
            for (let i=0;i<Balls.length;i++) {
                const b = Balls[i];
                let cx = Math.floor(b.pos.x / cellSize);
                let cy = Math.floor(b.pos.y / cellSize);
                if (cx<0) cx=0; if (cx>=cols) cx=cols-1;
                if (cy<0) cy=0; if (cy>=rows) cy=rows-1;
                grid[cy*cols+cx].push(b);
            }
            for (let cy=0; cy<rows; cy++) {
                for (let cx=0; cx<cols; cx++) {
                    const cellIndex = cy*cols+cx;
                    const cellBalls = grid[cellIndex];
                    if (!cellBalls.length) continue;
                    // Same-cell pairs (unique)
                    for (let i=0;i<cellBalls.length;i++) {
                        for (let j=i+1;j<cellBalls.length;j++) {
                            const a = cellBalls[i], b = cellBalls[j];
                            const dx = a.pos.x - b.pos.x, dy = a.pos.y - b.pos.y;
                            const dist2 = dx*dx + dy*dy;
                            const sumR = a.radius + b.radius, sumR2 = sumR*sumR;
                            if (ballRepulsion) {
                                const rep = physProps.repulsionDist * sumR;
                                if (dist2 < rep*rep) handleBallRepulsion(a,b);
                                if (dist2 <= sumR2) handleBallHits(a,b);
                            } else {
                                if (dist2 <= sumR2) handleBallHits(a,b);
                            }
                        }
                    }
                    // Neighbor cells (unique offsets to avoid double-processing)
                    const neighborOffsets = [ [1,0], [1,1], [0,1], [-1,1] ];
                    for (const [dxCell, dyCell] of neighborOffsets) {
                        const nx = cx + dxCell, ny = cy + dyCell;
                        if (nx < 0 || ny < 0 || nx >= cols || ny >= rows) continue;
                        const neighborBalls = grid[ny*cols+nx];
                        if (!neighborBalls.length) continue;
                        for (let i=0;i<cellBalls.length;i++) {
                            for (let j=0;j<neighborBalls.length;j++) {
                                const a = cellBalls[i], b = neighborBalls[j];
                                const dx = a.pos.x - b.pos.x, dy = a.pos.y - b.pos.y;
                                const dist2 = dx*dx + dy*dy;
                                const sumR = a.radius + b.radius, sumR2 = sumR*sumR;
                                if (ballRepulsion) {
                                    const rep = physProps.repulsionDist * sumR;
                                    if (dist2 < rep*rep) handleBallRepulsion(a,b);
                                    if (dist2 <= sumR2) handleBallHits(a,b);
                                } else {
                                    if (dist2 <= sumR2) handleBallHits(a,b);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    //  DRAW EVERYTHING -----------------------------------------------------------------
	function drawEverything() {
        wipeOpacity = Math.pow(2.718, persistence / -10);
        c.fillStyle = `hsla(0, 0%, 0%, ${wipeOpacity})`;
        c.fillRect(0, 0, canvas.width, canvas.height);

        // Ensure the corner/mask gradient tracks the viewport each frame
        updateCornerFillGradient();

        // DRAW GRID -----------------------------------------------------------------
        if (persistence < 20) {
            var gridSpacing = .07;
            var horizGrids = simWidth / gridSpacing;
            var vertGrids = simHeight / gridSpacing;
            // Calculate center positions for heavy lines
            var centerX = simWidth * 0.5;
            var centerY = simHeight * 0.5;
            var centerGridX = Math.round(centerX / gridSpacing);
            var centerGridY = Math.round(centerY / gridSpacing);
            c.setLineDash([4, 4]);
            // Draw vertical lines
            for (var h = 1; h < horizGrids; h++) {
                // Make line heavy if it's at center or every 5th line from center
                var distanceFromCenter = Math.abs(h - centerGridX);
                if (distanceFromCenter % 5 == 0) {
                    c.lineWidth = 2;
                } else {
                    c.lineWidth = 1;
                }
                c.beginPath();
                c.moveTo(h * gridSpacing * cScale, 0);
                c.lineTo(h * gridSpacing * cScale, simHeight * cScale);
                c.strokeStyle = `hsl(0, 0%, 15%)`;
                c.stroke();
            }
            // Draw horizontal lines
            for (var v = 1; v < vertGrids; v++) {
                // Make line heavy if it's at center or every 5th line from center
                var distanceFromCenter = Math.abs(v - centerGridY);
                if (distanceFromCenter % 5 == 0) {
                    c.lineWidth = 2;
                } else {
                    c.lineWidth = 1;
                }
                c.beginPath();
                c.moveTo(0, v * gridSpacing * cScale);
                c.lineTo(simWidth * cScale, v * gridSpacing * cScale);
                c.stroke();
            }
            c.setLineDash([0, 0]);
        }
        //  DRAW WORM ---------------------------------------------------------------------
        if (doWorm == true && mrMode == "worm") {
             WormProps.SpaceWorm.draw()
        }
        // DRAW MR. MISTER --------------------------------------------------------------
        if (doFountain == true) {
            MrMr = MisterMister[0];
            MrMr.draw();
        }
        //  DRAW BALLS-------------------------------------------------------------------
        for (i = 0; i < Balls.length; i++) {
			ball = Balls[i];
            if (doTracer == true && ball.tracerBall == true) {
                ball.drawTrace(); 
            }
            ball.draw();
		}
        //  DRAW WORM ---------------------------------------------------------------------
        if (doWorm == true && mrMode != "worm") {
             WormProps.SpaceWorm.draw()
        }
        //  DRAW BUMPERS ----------------------------------------------------------------
        if (showBumpers == true) {
            for (k = 0; k < Bumpers.length; k++) {
            bumpers = Bumpers[k];   
            bumpers.draw();
            }
        }
        //  DRAW HUNGRY PUCKS ---------------------------------------------------------------     
        if (showEaters == true) {
            // draw first hungry puck
            var hungryPuck = Hungrypuck[0];
            hungryPuck.draw1();
            
            // draw second hungry puck
            var hungryPuck = Hungrypuck[1];
            hungryPuck.draw2();
        }
        //  DRAW PUCKS ----------------------------------------------------------------         
        for (p=0; p < Puck.length; p++) { 
            var puck = Puck[p];
            // Respect toggles for each puck type
            if (puck.special === true && !showHeart) continue;
            if (puck.cycle === true && !showCycle) continue;
            if (puck.special !== true && puck.cycle !== true && !showPucks) continue;
            puck.draw();
        }
        //  DRAW CORNERS  ---------------------------------------------------------------------
        for (var v = 0; v < Corners.length; v++) {
            corner = Corners[v];
            
            // Skip drawing corners on open sides based on boundary settings
            var shouldSkipCorner = false;
            if (corner.corner == 'northwest') {
                shouldSkipCorner = !doCeiling || !doLeftWall;
            } else if (corner.corner == 'northeast') {
                shouldSkipCorner = !doCeiling || !doRightWall;
            } else if (corner.corner == 'southwest') {
                shouldSkipCorner = !doFloor || !doLeftWall;
            } else if (corner.corner == 'southeast') {
                shouldSkipCorner = !doFloor || !doRightWall;
            }
            
            if (!shouldSkipCorner) {
                corner.draw();
            }
        } 
        if (!doCeiling && !doFloor) {
            var leftXSim = 0;
            var rightXSim = simWidth;
            if (cornerRad > 100 && Array.isArray(Corners) && Corners.length >= 2) {
                var nw = Corners[0]; 
                var ne = Corners[1]; 
                if (nw && typeof nw.pos?.x === 'number') leftXSim = nw.pos.x;
                if (ne && typeof ne.pos?.x === 'number') rightXSim = ne.pos.x;
            }
            // Fill masks beyond the left/right bounds using the same gradient as corners
            if (!cornerFillGradient) { updateCornerFillGradient(); }
            var prevFill = c.fillStyle;
            c.fillStyle = cornerFillGradient;
            var leftPX = Math.max(0, leftXSim * cScale);
            var rightPX = Math.min(simWidth * cScale, rightXSim * cScale);
            // Left mask: from canvas left to left bound
            if (doLeftWall == true && leftPX > 0) {
                c.beginPath();
                c.rect(0, 0, leftPX, simHeight * cScale);
                c.fill();
            }
            // Right mask: from right bound to canvas right
            if (doRightWall == true && rightPX < simWidth * cScale) {
                c.beginPath();
                c.rect(rightPX, 0, (simWidth * cScale - rightPX), simHeight * cScale);
                c.fill();
            }
            c.fillStyle = prevFill;
            c.strokeStyle = 'hsl(0, 0%, 60%)';
            c.lineWidth = 0.012 * cScale;
            c.lineCap = 'butt';
            // Left bound
            if (doLeftWall == true) {
                c.beginPath();
                c.moveTo(leftXSim * cScale, 0);
                c.lineTo(leftXSim * cScale, simHeight * cScale);
                c.stroke();
            }
            // Right bound
            if (doRightWall == true) {
                c.beginPath();
                c.moveTo(rightXSim * cScale, 0);
                c.lineTo(rightXSim * cScale, simHeight * cScale);
                c.stroke();
            }
        }
	}

    //  MAIN SEQUENCE ----------------------------------------------------------------------------
	firstRun = true;
    setupScene();
    
    function update() {
        // Run multiple simulation substeps per frame
        for (let substep = 0; substep < physProps.substeps; substep++) {
            simulate();
        }
        drawEverything();
        requestAnimationFrame(update);
    }
    
    update();

</script> 
</body>
</html>