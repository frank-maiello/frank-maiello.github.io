<!-- 
SL0SH :: repulsive particle simulation ::
copyright 2025 :: Frank Maiello :: maiello.frank@gmail.com ::

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. In no event shall the author or copyright holders be liable for any claim, damages, or other liability, whether in an action of contract, tort or otherwise, arising from, our of or in, connection with the software or the use of other dealings in the Software.
-->

<!DOCTYPE html>
<html>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
	<head>
		<title>Slosh 2.2
        </title>
        <style>
			body {font-family: monospace; 
                font-size: 14px;
                color: hsl(0, 0%, 60%);
                text-align: center;
                text-shadow: 3px 4px 10px hsl(0, 0%, 0%);
                margin: 0;
                padding-left: 10px;
                padding-right: 10px;
                padding-top: 10px;
                /* Touch optimization */
                -webkit-touch-callout: none;
                -webkit-user-select: none;
                -khtml-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
                -webkit-tap-highlight-color: transparent;
                }
            h1 {font-family: verdana;
                font-size: 12px;
                text-align: center;
                color: hsl(0, 0%, 55%);}
            h2 {font-family: monospace;
                font-size: 0px;
                text-align: center;}
            h3 {font-family: monospace;
                font-size: 2px;
                text-align: center;}
           
            /* FPS Counter */
            .fps-counter {
                position: absolute;
                display: none; /* Hidden by default */
                /* No fixed right/top/left/bottom here; set by JS for canvas-relative positioning */
                white-space: nowrap;
                text-align: right;
                font-family: monospace;
                font-size: 14px;
                color: hsl(170, 75%, 50%);
                background: hsla(0, 0%, 0%, 0.7);
                padding: 4px 8px;
                border-radius: 4px;
                text-shadow: 1px 1px 2px hsl(0, 0%, 0%);
                z-index: 1000;
                pointer-events: none;
            }
            .fps-counter.visible {
                display: block;
            }

            /* NYC Subway Line Button Styles */
            .subway-btn {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                width: 36px;
                height: 36px;
                border-radius: 50%;
                text-align: center;
                vertical-align: middle;
                font-family: "Helvetica Neue", Helvetica, Arial, "Liberation Sans", sans-serif;
                font-weight: bold;
                font-size: 20px;
                color: #fff;
                border: none;
                box-shadow: 2px 3px 8px rgba(0,0,0,0.25);
                margin: 0 2px;
                margin-top: 5px;
                margin-bottom: 10px;
                cursor: default;
                padding: 0;
                transition: filter 0.2s;
                text-shadow: 0 1px 2px #0008;
                background: transparent;
            }
            .subway-btn:active, .subway-btn:focus {
                filter: brightness(0.85);
                outline: none;
            }
            /* Line colors */
            .subway-a { background: #0039A6; }
            .subway-c { background: #0039A6; }
            .subway-j { background: #996633; }
            .subway-z { background: #EE7624; }
            .subway-2 { background: #EE352E; }
            .subway-3 { background: #EE352E; }
            .subway-4 { background: #00933C; }
            .subway-5 { background: #00933C; }
            .subway-j, .subway-z { color: #fff; }

            /* Bright green border for saved preset indicator */
            .subway-btn-saved {
                border: 3px solid #39FF14 !important;
                box-shadow: 0 0 0 2px #39FF14, 2px 3px 8px rgba(0,0,0,0.25);
            }
            /* B, D, F, M (Bright Orange) */
            .subway-b { background: #FF6319; font-family: "Helvetica Neue", Helvetica, Arial, "Liberation Sans", sans-serif; color: #fff; }
            .subway-d { background: #FF6319; font-family: "Helvetica Neue", Helvetica, Arial, "Liberation Sans", sans-serif; color: #fff; }
            .subway-f { background: #FF6319; font-family: "Helvetica Neue", Helvetica, Arial, "Liberation Sans", sans-serif; color: #fff; }
            .subway-m { background: #FF6319; font-family: "Helvetica Neue", Helvetica, Arial, "Liberation Sans", sans-serif; color: #fff; }
            /* N, Q, R, W (Yellow) */
            .subway-n { background: #FFD300; color: #000; font-family: "Helvetica Neue", Helvetica, Arial, "Liberation Sans", sans-serif; }
            .subway-q { background: #FFD300; color: #000; font-family: "Helvetica Neue", Helvetica, Arial, "Liberation Sans", sans-serif; }
            .subway-r { background: #FFD300; color: #000; font-family: "Helvetica Neue", Helvetica, Arial, "Liberation Sans", sans-serif; }
            .subway-w { background: #FFD300; color: #000; font-family: "Helvetica Neue", Helvetica, Arial, "Liberation Sans", sans-serif; }
            
            /* Independent scaling for PATH logo button (preset17Btn) */
            #preset17Btn > img {
                margin-left: 8px;
                width: 2.2em !important;
                height: 2.2em !important;
            } 
        </style>
	</head>

<body> 
    <body style="background: linear-gradient(to bottom, hsl(0, 0%, 0%) 0%, hsl(195, 64%, 8%) 100%); background-attachment: fixed; margin-left: 0px;"> 
    
    <canvas id="myCanvas" style="border:0px solid hsl(0, 0%, 50%); margin-top: 5px; margin-left: 10px; display: block; cursor: default;"></canvas>
    <div id="fpsCounter" class="fps-counter">--</div>

    <!--
    <span style="white-space: nowrap; margin-left: 10px;">
    <button id="preset1Btn" class="subway-btn subway-a" title="Long Press to Save">A</button>
    <button id="preset2Btn" class="subway-btn subway-c" title="Long Press to Save">C</button>
    <button id="preset3Btn" class="subway-btn subway-j" title="Long Press to Save">J</button>
    <button id="preset4Btn" class="subway-btn subway-z" title="Long Press to Save">Z</button>
    <button id="preset5Btn" class="subway-btn subway-2" title="Long Press to Save">2</button>
    <button id="preset6Btn" class="subway-btn subway-3" title="Long Press to Save">3</button>
    <button id="preset7Btn" class="subway-btn subway-4" title="Long Press to Save">4</button>
    <button id="preset8Btn" class="subway-btn subway-5" title="Long Press to Save">5</button>
    <button id="preset9Btn" class="subway-btn subway-b" title="Long Press to Save">B</button>
    <button id="preset10Btn" class="subway-btn subway-d" title="Long Press to Save">D</button>
    <button id="preset11Btn" class="subway-btn subway-f" title="Long Press to Save">F</button>
    <button id="preset12Btn" class="subway-btn subway-m" title="Long Press to Save">M</button>
    </span>
    <span style="white-space: nowrap">
    <button id="preset13Btn" class="subway-btn subway-n" title="Long Press to Save">N</button>
    <button id="preset14Btn" class="subway-btn subway-q" title="Long Press to Save">Q</button>
    <button id="preset15Btn" class="subway-btn subway-r" title="Long Press to Save">R</button>
    <button id="preset16Btn" class="subway-btn subway-w" title="Long Press to Save">W</button>
    <button id="preset19Btn" class="subway-btn subway-svg" title="Long Press to Save"><img src="s-bahn-logo.svg" alt="S-Bahn" style="width:1.7em;height:1.7em;vertical-align:middle;"></button>
    <button id="preset18Btn" class="subway-btn subway-svg" title="Long Press to Save"><img src="u-bahn-logo.svg" alt="U-Bahn" style="width:1.7em;height:1.7em;vertical-align:middle;"></button>
    <button id="preset17Btn" class="subway-btn subway-svg path-logo-btn" title="Long Press to Save"><img src="path-logo.svg" alt="Path" class="path-logo-img" style="width:1.7em;height:1.7em;vertical-align:middle;"></button>
    <span style="display:inline-block; vertical-align:top; margin-left:8px; line-height:1;">
    <span style="font-size:10px; font-style:italic; color:#757575; display:block; text-align:left; line-height:1.1; position:relative; top:1.2em;">
    long press<br>to save
    </span></span></span><br>
    -->
<script>

// Global layout orientation flag for canvas/menu logic and CORNER calculations
var screenVertical = false;

// Bumper configuration (previously controlled by sliders, now by mouse wheel)
var bumperRows = 3;  // Default: 3 rows
var bumperRadius = 0.040;  // Default: 40/1000 = 0.040

// Fountain state cycling (0-4)
var fountainState = 0; // 0=off, 1=normal, 2=sweep, 3=cw, 4=ccw

// --- PRESET SAVE/LOAD LOGIC ---
const PRESET_KEYS = [
    'slosh_preset_1',
    'slosh_preset_2',
    'slosh_preset_3',
    'slosh_preset_4',
    'slosh_preset_5',
    'slosh_preset_6',
    'slosh_preset_7',
    'slosh_preset_8',
    'slosh_preset_9',
    'slosh_preset_10',
    'slosh_preset_11',
    'slosh_preset_12',
    'slosh_preset_13',
    'slosh_preset_14',
    'slosh_preset_15',
    'slosh_preset_16',
    'slosh_preset_17',
    'slosh_preset_18',
    'slosh_preset_19'
];

// Default presets: captured at first DOMContentLoaded
let DEFAULT_PRESETS = null;

// List of all control IDs to save/restore
const CONTROL_IDS = [
    // Checkboxes (spawn controls now handled by ReSpawn menu)
    'showPuckButton','flyingPuckButton','orbitButton','yinYangButton','showCyclePuckButton','showHeartButton','wormButton','showBumperEntry','showBlowerButton','doTracerButton',
    // Tracer radios
    'smallTracerButton','mediumTracerButton','bigTracerButton',
    // Pause
    'x'
];

function getControlState() {
    const state = {};
    // Save Heartbeat puck position (first Puck with .heartBeat === true)
    if (typeof Puck !== 'undefined' && Array.isArray(Puck)) {
        const heart = Puck.find(p => p && p.heartBeat === true);
        if (heart && heart.pos) {
            state._heartPuckPos = {x: heart.pos.x, y: heart.pos.y};
        }
        const cycle = Puck.find(p => p && p.cycle === true);
        if (cycle && cycle.pos) {
            state._cyclePuckPos = {x: cycle.pos.x, y: cycle.pos.y};
        }
    }
    for (const id of CONTROL_IDS) {
        const el = document.getElementById(id);
        if (!el) continue;
        if (el.type === 'checkbox') {
            state[id] = el.checked;
        } else if (el.type === 'radio') {
            // For radio, only save if checked
            state[id] = el.checked;
        } else if (el.tagName === 'SELECT') {
            state[id] = el.value;
        } else {
            state[id] = el.value;
        }
    }
    // Save particle quantity (square root of count)
    state.ballsSlider = particlesMenuQuantity;
    
    // --- Save positions of all movable pucks ---
    // Save Puck positions (array of {x, y})
    if (typeof Puck !== 'undefined' && Array.isArray(Puck)) {
        state._puckPositions = Puck.map(p => p && p.pos ? {x: p.pos.x, y: p.pos.y} : null);
    }
    // Save Blower positions (array of {x, y})
    if (typeof Blower !== 'undefined' && Array.isArray(Blower)) {
        state._blowerPositions = Blower.map(p => p && p.pos ? {x: p.pos.x, y: p.pos.y} : null);
    }
    // Save Hungrypuck positions (array of {x, y})
    if (typeof Hungrypuck !== 'undefined' && Array.isArray(Hungrypuck)) {
        state._hungrypuckPositions = Hungrypuck.map(p => p && p.pos ? {x: p.pos.x, y: p.pos.y} : null);
    }
    // Save MisterMister positions (array of {x, y})
    if (typeof MisterMister !== 'undefined' && Array.isArray(MisterMister)) {
        state._misterPositions = MisterMister.map(p => p && p.pos ? {x: p.pos.x, y: p.pos.y} : null);
    }
    // Save color wheel values
    state._colorWheelHue = colorWheelHue;
    state._colorWheelSat = colorWheelSat;
    state._colorWheelLight = colorWheelLight;
    state._colorWheelPersistence = colorWheelPersistence;
    state._colorWheelVelMap = colorWheelVelMap;
    state._colorWheelCenterX = colorWheelCenterX;
    state._colorWheelCenterY = colorWheelCenterY;
    // Save physics menu values
    state._physicsMenuRepulsionForce = physicsMenuRepulsionForce;
    state._physicsMenuRepulsionDist = physicsMenuRepulsionDist;
    state._physicsMenuRepulsionOn = physicsMenuRepulsionOn;
    state._physicsMenuBallRest = physicsMenuBallRest;
    state._physicsMenuBounceOn = physicsMenuBounceOn;
    state._physicsMenuTime = physicsMenuTime;
    state._physicsMenuSpeed = physicsMenuSpeed;
    state._physicsMenuCenterX = physicsMenuCenterX;
    state._physicsMenuCenterY = physicsMenuCenterY;
    state._physicsMenuSubsteps = physicsMenuSubsteps;
    state._physicsMenuFpsOn = physicsMenuFpsOn;
    
    // Save walls menu values
    state._wallsMenuCornerRadius = wallsMenuCornerRadius;
    state._wallsMenuLeftWall = wallsMenuLeftWall;
    state._wallsMenuRightWall = wallsMenuRightWall;
    state._wallsMenuCeiling = wallsMenuCeiling;
    state._wallsMenuFloor = wallsMenuFloor;
    state._wallsMenuCenterX = wallsMenuCenterX;
    state._wallsMenuCenterY = wallsMenuCenterY;
    
    return state;
}

function setControlState(state) {
    // Restore Heartbeat puck position
    if (state._heartPuckPos && typeof Puck !== 'undefined' && Array.isArray(Puck)) {
        const heart = Puck.find(p => p && p.heartBeat === true);
        if (heart && heart.pos) {
            heart.pos.x = state._heartPuckPos.x;
            heart.pos.y = state._heartPuckPos.y;
        }
    }
    // Restore Cycle puck position
    if (state._cyclePuckPos && typeof Puck !== 'undefined' && Array.isArray(Puck)) {
        const cycle = Puck.find(p => p && p.cycle === true);
        if (cycle && cycle.pos) {
            cycle.pos.x = state._cyclePuckPos.x;
            cycle.pos.y = state._cyclePuckPos.y;
        }
    }
    for (const id of CONTROL_IDS) {
        if (!(id in state)) continue;
        const el = document.getElementById(id);
        if (!el) continue;
        if (el.type === 'checkbox' || el.type === 'radio') {
            el.checked = !!state[id];
            el.dispatchEvent(new Event('input', {bubbles:true}));
        } else if (el.tagName === 'SELECT') {
            el.value = state[id];
            el.dispatchEvent(new Event('input', {bubbles:true}));
        } else {
            el.value = state[id];
            el.dispatchEvent(new Event('input', {bubbles:true}));
        }
    }
    // Particle count from preset (square root stored)
    if ('ballsSlider' in state) {
        particlesMenuQuantity = state['ballsSlider'];
        adjustParticleCount(particlesMenuQuantity * particlesMenuQuantity);
    }
    if (typeof makeBalls === 'function') makeBalls();
    // --- Ensure shower/fountain simulation state matches respawn menu after preset load ---
    // Note: shower/fountain state is now controlled by respawnMenuSpawnType in the ReSpawn menu
    // The doShower and doFountain variables are set automatically based on respawnMenuSpawnType
    
    // --- Restore positions of all movable pucks if present in state ---
    // Restore Puck positions
    if (state._puckPositions && typeof Puck !== 'undefined' && Array.isArray(Puck)) {
        for (let i = 0; i < state._puckPositions.length && i < Puck.length; ++i) {
            const pos = state._puckPositions[i];
            if (pos && Puck[i] && Puck[i].pos) {
                Puck[i].pos.x = pos.x;
                Puck[i].pos.y = pos.y;
            }
        }
    }
    // Restore Blower positions
    if (state._blowerPositions && typeof Blower !== 'undefined' && Array.isArray(Blower)) {
        for (let i = 0; i < state._blowerPositions.length && i < Blower.length; ++i) {
            const pos = state._blowerPositions[i];
            if (pos && Blower[i] && Blower[i].pos) {
                Blower[i].pos.x = pos.x;
                Blower[i].pos.y = pos.y;
            }
        }
    }
    // Restore Hungrypuck positions
    if (state._hungrypuckPositions && typeof Hungrypuck !== 'undefined' && Array.isArray(Hungrypuck)) {
        for (let i = 0; i < state._hungrypuckPositions.length && i < Hungrypuck.length; ++i) {
            const pos = state._hungrypuckPositions[i];
            if (pos && Hungrypuck[i] && Hungrypuck[i].pos) {
                Hungrypuck[i].pos.x = pos.x;
                Hungrypuck[i].pos.y = pos.y;
            }
        }
    }
    // Restore MisterMister positions
    if (state._misterPositions && typeof MisterMister !== 'undefined' && Array.isArray(MisterMister)) {
        for (let i = 0; i < state._misterPositions.length && i < MisterMister.length; ++i) {
            const pos = state._misterPositions[i];
            if (pos && MisterMister[i] && MisterMister[i].pos) {
                MisterMister[i].pos.x = pos.x;
                MisterMister[i].pos.y = pos.y;
            }
        }
    }
    // Restore color wheel values
    if (state._colorWheelHue !== undefined) {
        colorWheelHue = state._colorWheelHue;
        physProps.baseColor = colorWheelHue;
    }
    if (state._colorWheelSat !== undefined) {
        colorWheelSat = state._colorWheelSat;
        ballSaturation = colorWheelSat;
    }
    if (state._colorWheelLight !== undefined) {
        colorWheelLight = state._colorWheelLight;
        ballLightness = colorWheelLight;
    }
    if (state._colorWheelPersistence !== undefined) {
        colorWheelPersistence = state._colorWheelPersistence;
        persistence = colorWheelPersistence;
    }
    if (state._colorWheelVelMap !== undefined) {
        colorWheelVelMap = state._colorWheelVelMap;
        physProps.velColorMap = colorWheelVelMap;
    }
    if (state._colorWheelCenterX !== undefined) {
        colorWheelCenterX = state._colorWheelCenterX;
    }
    if (state._colorWheelCenterY !== undefined) {
        colorWheelCenterY = state._colorWheelCenterY;
    }
    // Restore physics menu values
    if (state._physicsMenuRepulsionForce !== undefined) {
        physicsMenuRepulsionForce = state._physicsMenuRepulsionForce;
        physProps.repulsionForce = physicsMenuRepulsionForce / 10;
    }
    if (state._physicsMenuRepulsionDist !== undefined) {
        physicsMenuRepulsionDist = state._physicsMenuRepulsionDist;
        physProps.repulsionDist = physicsMenuRepulsionDist;
    }
    if (state._physicsMenuRepulsionOn !== undefined) {
        physicsMenuRepulsionOn = state._physicsMenuRepulsionOn;
        ballRepulsion = physicsMenuRepulsionOn;
    }
    if (state._physicsMenuBallRest !== undefined) {
        physicsMenuBallRest = state._physicsMenuBallRest;
        physProps.ballRest = physicsMenuBallRest / 100;
    }
    if (state._physicsMenuBounceOn !== undefined) {
        physicsMenuBounceOn = state._physicsMenuBounceOn;
    }
    if (state._physicsMenuTime !== undefined) {
        physicsMenuTime = state._physicsMenuTime;
        physProps.dt = 1 / (Math.floor(Math.exp(((140 - 0.1 * physicsMenuTime) / 10))) + 6);
    }
    if (state._physicsMenuSpeed !== undefined) {
        physicsMenuSpeed = state._physicsMenuSpeed;
        physProps.maxSpeed = 0.1 * physicsMenuSpeed;
    }
    if (state._physicsMenuCenterX !== undefined) {
        physicsMenuCenterX = state._physicsMenuCenterX;
    }
    if (state._physicsMenuCenterY !== undefined) {
        physicsMenuCenterY = state._physicsMenuCenterY;
    }
    if (state._physicsMenuSubsteps !== undefined) {
        physicsMenuSubsteps = state._physicsMenuSubsteps;
        updateSubsteps(physicsMenuSubsteps);
    }
    if (state._physicsMenuFpsOn !== undefined) {
        physicsMenuFpsOn = state._physicsMenuFpsOn;
        if (physicsMenuFpsOn) {
            startFPSCounter();
        } else {
            stopFPSCounter();
        }
    }
    
    // Restore walls menu values
    if (state._wallsMenuCornerRadius !== undefined) {
        wallsMenuCornerRadius = state._wallsMenuCornerRadius;
        cornerRad = wallsMenuCornerRadius;
    }
    if (state._wallsMenuLeftWall !== undefined) {
        wallsMenuLeftWall = state._wallsMenuLeftWall;
        doLeftWall = wallsMenuLeftWall;
    }
    if (state._wallsMenuRightWall !== undefined) {
        wallsMenuRightWall = state._wallsMenuRightWall;
        doRightWall = wallsMenuRightWall;
    }
    if (state._wallsMenuCeiling !== undefined) {
        wallsMenuCeiling = state._wallsMenuCeiling;
        doCeiling = wallsMenuCeiling;
    }
    if (state._wallsMenuFloor !== undefined) {
        wallsMenuFloor = state._wallsMenuFloor;
        doFloor = wallsMenuFloor;
    }
    if (state._wallsMenuCenterX !== undefined) {
        wallsMenuCenterX = state._wallsMenuCenterX;
    }
    if (state._wallsMenuCenterY !== undefined) {
        wallsMenuCenterY = state._wallsMenuCenterY;
    }
}

function savePreset(idx) {
    const state = getControlState();
    try {
        localStorage.setItem(PRESET_KEYS[idx], JSON.stringify(state));
    } catch (e) {
        // Fallback to cookies if localStorage fails
        const cookieStr = PRESET_KEYS[idx] + '=' + encodeURIComponent(JSON.stringify(state)) + ';path=/;max-age=31536000';
        document.cookie = cookieStr;
        setTimeout(() => {
            const cookies = document.cookie;
            if (!cookies.includes(PRESET_KEYS[idx])) {
                alert('Warning: Preset could not be saved. Your browser may be blocking cookies and localStorage.');
            }
        }, 100);
    }
}

function loadPreset(idx) {
    const key = PRESET_KEYS[idx];
    let val = null;
    // Try localStorage first
    try {
        val = localStorage.getItem(key);
    } catch (e) {
        val = null;
    }
    // Fallback to cookies if not found
    if (!val) {
        const cookies = document.cookie.split(';');
        for (const c of cookies) {
            const trimmed = c.trim();
            if (trimmed.startsWith(key + '=')) {
                val = trimmed.substring(key.length + 1);
                try {
                    val = decodeURIComponent(val);
                } catch (e) {}
                break;
            }
        }
    }
    if (val) {
        try {
            const state = JSON.parse(val);
            setControlState(state);
        } catch (e) { alert('Failed to load preset: ' + e); }
    } else {
        alert('No preset saved in this slot.');
    }
}

// Button logic: left-click loads, long press (hold 700ms) saves
function setupPresetButtons() {
    for (let i = 0; i < 19; ++i) {
        const btn = document.getElementById('preset' + (i+1) + 'Btn');
        if (!btn) continue;
        let pressTimer = null;
        let longPressTriggered = false;

        // Helper to clear timer
        function clearTimer() {
            if (pressTimer) { clearTimeout(pressTimer); pressTimer = null; }
            longPressTriggered = false;
        }

        btn.addEventListener('mousedown', function(e) {
            if (e.button !== 0) return; // Only left mouse
            longPressTriggered = false;
            pressTimer = setTimeout(() => {
                savePreset(i);
                btn.classList.add('preset-saved');
                setTimeout(() => btn.classList.remove('preset-saved'), 400);
                longPressTriggered = true;
            }, 700);
        });
        btn.addEventListener('mouseup', function(e) {
            if (pressTimer) {
                clearTimeout(pressTimer);
                if (!longPressTriggered && e.button === 0) {
                    loadPreset(i);
                }
            }
        });
        btn.addEventListener('mouseleave', clearTimer);
        btn.addEventListener('touchstart', function(e) {
            longPressTriggered = false;
            pressTimer = setTimeout(() => {
                savePreset(i);
                btn.classList.add('preset-saved');
                setTimeout(() => btn.classList.remove('preset-saved'), 400);
                longPressTriggered = true;
            }, 700);
        }, {passive: true});
        btn.addEventListener('touchend', function(e) {
            if (pressTimer) {
                clearTimeout(pressTimer);
                if (!longPressTriggered) {
                    loadPreset(i);
                }
            }
        }, {passive: true});
        btn.addEventListener('touchmove', clearTimer, {passive: true});
        btn.addEventListener('contextmenu', function(e) { e.preventDefault(); });
    }
}

// Add a visual feedback style for save
const style = document.createElement('style');
style.textContent = `.preset-saved { box-shadow: 0 0 0 3px hsl(108, 80%, 70%) !important; }`;
document.head.appendChild(style);


// On DOMContentLoaded, capture current state as defaults and setup buttons
window.addEventListener('DOMContentLoaded', function() {
    // Capture current state for all 19 default presets
    DEFAULT_PRESETS = [];
    const state = getControlState();
    for (let i = 0; i < 19; ++i) {
        // Deep copy for each slot
        DEFAULT_PRESETS.push(JSON.parse(JSON.stringify(state)));
    }
    setupPresetButtons();
});

    //  FPS COUNTER VARIABLES ----------------------------------------------------------------
    let fpsCounter = {
        lastTime: performance.now(),
        frameCount: 0,
        frameTimes: [],
        maxSamples: 10, // Use 10 frames for more responsive averaging
        displayFps: 0,
        updateCounter: 0,
        updateInterval: 5 // Update display every 5 frames for faster response
    };

    // Gummi Bear image for ball rendering (scaled to ball radius)
    var gummiImage = new Image();
    var gummiReady = false;
    var doGummi = false; // fourth ball rendering style
    // Faster response = smaller tau; controls heading smoothing speed (seconds)
    var gummiHeadingTau = 0.05;
    // Orientation offset so the TOP of the image leads along the velocity vector
    var gummiHeadingOffset = Math.PI / 2;
    
    // Tracer variables for particle tracking
    var doTracer = false;
    var doSmallTracer = false;
    var doMediumTracer = false;
    var doBigTracer = false;
    gummiImage.onload = function() { gummiReady = true; };
    // Image file is in the same folder
    gummiImage.src = 'gummibear_bw.png';

    var aeolusImage = new Image();
    var aeolusReady = false;
    aeolusImage.onload = function() { aeolusReady = true; };
    aeolusImage.src = 'aeolus.png';

    var pepeImage = new Image();
    var pepeReady = false;
    pepeImage.onload = function() { pepeReady = true; };
    pepeImage.src = 'pepe.png';

    //  CANVAS SETUP AND SCALING --------------------------------------------------------------
    canvas = document.getElementById("myCanvas");
    c = canvas.getContext("2d");
    canvas.style.cursor = "default";
    const menuStart = document.querySelector('h3'); // menu starts after <h3><br><br></h3>
    
    function layoutCanvasAndMenu() {
        // Snapshot current relative positions of menus before canvas dimensions change
        let menuSnapshots = {};
        if (canvas.width > 0 && canvas.height > 0) {
            menuSnapshots = {
                physics: { rx: physicsMenuCenterX / canvas.width, ry: physicsMenuCenterY / canvas.height },
                particles: { rx: particlesMenuCenterX / canvas.width, ry: particlesMenuCenterY / canvas.height },
                gravity: { rx: gravityMenuX / canvas.width, ry: gravityMenuY / canvas.height },
                respawn: { rx: respawnMenuCenterX / canvas.width, ry: respawnMenuCenterY / canvas.height },
                walls: { rx: wallsMenuCenterX / canvas.width, ry: wallsMenuCenterY / canvas.height },
                colorWheel: { rx: colorWheelCenterX / canvas.width, ry: colorWheelCenterY / canvas.height },
                toys: { rx: toysMenuCenterX / canvas.width, ry: toysMenuCenterY / canvas.height },
                mainMenu: { rx: mainMenuX / canvas.width, rtx: mainMenuTargetX / canvas.width }
            };
        }
        
        // Not fullscreen: canvas and menu fit in window, no scroll
        canvas.style.position = 'static';
        canvas.style.width = '';
        canvas.style.height = '';
        
        // Use same simple sizing logic as handleResizeRestart
        if (window.innerWidth <= window.innerHeight) {
            screenVertical = true;
            canvas.width  = window.innerWidth - 40;
            canvas.height = window.innerHeight - 120; 
        } else {
            screenVertical = false;
            canvas.width  = window.innerWidth - 40;
            canvas.height = window.innerHeight - 30;
        }
        
        if (menuStart) menuStart.style.marginTop = '0px';
        // Do not force overflowY to hidden; allow scrolling if needed, but canvas is sized so menu is visible without scrolling
        
        // Recompute simulation scaling & world dimensions
        simMinWidth = 2.0;
        cScale = Math.min(canvas.width, canvas.height) / simMinWidth;
        simWidth = canvas.width / cScale;
        simHeight = canvas.height / cScale;
        topMargin = 0;
        bottomMargin = 0;
        if (typeof updateCornerFillGradient === 'function') updateCornerFillGradient();
        
        // Re-apply preserved relative positions to menus using NEW canvas dimensions
        if (canvas.width > 0 && canvas.height > 0 && menuSnapshots.physics) {
            physicsMenuCenterX = menuSnapshots.physics.rx * canvas.width;
            physicsMenuCenterY = menuSnapshots.physics.ry * canvas.height;
            particlesMenuCenterX = menuSnapshots.particles.rx * canvas.width;
            particlesMenuCenterY = menuSnapshots.particles.ry * canvas.height;
            gravityMenuX = menuSnapshots.gravity.rx * canvas.width;
            gravityMenuY = menuSnapshots.gravity.ry * canvas.height;
            respawnMenuCenterX = menuSnapshots.respawn.rx * canvas.width;
            respawnMenuCenterY = menuSnapshots.respawn.ry * canvas.height;
            wallsMenuCenterX = menuSnapshots.walls.rx * canvas.width;
            wallsMenuCenterY = menuSnapshots.walls.ry * canvas.height;
            colorWheelCenterX = menuSnapshots.colorWheel.rx * canvas.width;
            colorWheelCenterY = menuSnapshots.colorWheel.ry * canvas.height;
            toysMenuCenterX = menuSnapshots.toys.rx * canvas.width;
            toysMenuCenterY = menuSnapshots.toys.ry * canvas.height;
            mainMenuX = menuSnapshots.mainMenu.rx * canvas.width;
            mainMenuTargetX = menuSnapshots.mainMenu.rtx * canvas.width;
            
            // If main menu is visible, keep it centered
            if (mainMenuVisible) {
                mainMenuTargetX = (canvas.width - calculateMainMenuWidth()) / 2;
                mainMenuX = mainMenuTargetX;
            }
        }
    }
    // (Moved event listeners and initial call below, after gradient logic)

    // Responsive resize handling: recompute canvas size and restart simulation WITHOUT reloading page
    // (preserves all current UI control states: sliders, checkboxes, radios, selects)
    let _resizeDebounce = null;
    function handleResizeRestart() {
        // Snapshot current relative positions of pucks and related actors before dimensions change
        const oldSimWidth = simWidth;
        const oldSimHeight = simHeight;
        const puckSnapshots = (typeof Puck !== 'undefined' && Array.isArray(Puck)) ? Puck.map(p => ({ p, rx: p.pos.x / oldSimWidth, ry: p.pos.y / oldSimHeight })) : [];
        const BlowerSnapshots = (typeof Blower !== 'undefined' && Array.isArray(Blower)) ? Blower.map(p => ({ p, rx: p.pos.x / oldSimWidth, ry: p.pos.y / oldSimHeight })) : [];
        const hungrySnapshots = (typeof Hungrypuck !== 'undefined' && Array.isArray(Hungrypuck)) ? Hungrypuck.map(p => ({ p, rx: p.pos.x / oldSimWidth, ry: p.pos.y / oldSimHeight })) : [];
        const misterSnapshots = (typeof MisterMister !== 'undefined' && Array.isArray(MisterMister)) ? MisterMister.map(p => ({ p, rx: p.pos.x / oldSimWidth, ry: p.pos.y / oldSimHeight })) : [];
        
        // Snapshot current relative positions of menus before canvas dimensions change
        let menuSnapshots = {};
        if (canvas.width > 0 && canvas.height > 0) {
            menuSnapshots = {
                physics: { rx: physicsMenuCenterX / canvas.width, ry: physicsMenuCenterY / canvas.height },
                particles: { rx: particlesMenuCenterX / canvas.width, ry: particlesMenuCenterY / canvas.height },
                gravity: { rx: gravityMenuX / canvas.width, ry: gravityMenuY / canvas.height },
                respawn: { rx: respawnMenuCenterX / canvas.width, ry: respawnMenuCenterY / canvas.height },
                walls: { rx: wallsMenuCenterX / canvas.width, ry: wallsMenuCenterY / canvas.height },
                colorWheel: { rx: colorWheelCenterX / canvas.width, ry: colorWheelCenterY / canvas.height },
                toys: { rx: toysMenuCenterX / canvas.width, ry: toysMenuCenterY / canvas.height },
                mainMenu: { rx: mainMenuX / canvas.width, rtx: mainMenuTargetX / canvas.width }
            };
        }
        
        // (If later we need worm node preservation, we can snapshot here similarly.)
        // Determine orientation & set canvas dimensions (mirrors initial logic)
        if (window.innerWidth <= window.innerHeight) {
            screenVertical = true;
            canvas.width  = window.innerWidth - 40;
            canvas.height = window.innerHeight - 120; 
        } else {
            screenVertical = false;
            canvas.width  = window.innerWidth - 40;
            canvas.height = window.innerHeight - 30;
        }
        // Recompute simulation scaling & world dimensions
        cScale    = Math.min(canvas.width, canvas.height) / simMinWidth;
        simWidth  = canvas.width / cScale;
        simHeight = canvas.height / cScale;
        if (typeof physProps === 'object' && physProps.worldSize) {
            physProps.worldSize.x = simWidth;
            physProps.worldSize.y = simHeight;
        }
        // Helper clamp to keep actors within new bounds (optional: allow slight overshoot)
        function clampActorPos(actor) {
            if (!actor || !actor.pos) return;
            if (actor.pos.x < 0) actor.pos.x = 0;
            if (actor.pos.x > simWidth) actor.pos.x = simWidth;
            if (actor.pos.y < 0) actor.pos.y = 0;
            if (actor.pos.y > simHeight) actor.pos.y = simHeight;
        }
        // Re-apply preserved relative positions to pucks & friends using NEW sim dimensions
        puckSnapshots.forEach(s => { s.p.pos.x = s.rx * simWidth; s.p.pos.y = s.ry * simHeight; clampActorPos(s.p); });
        hungrySnapshots.forEach(s => { s.p.pos.x = s.rx * simWidth; s.p.pos.y = s.ry * simHeight; clampActorPos(s.p); });
        misterSnapshots.forEach(s => { s.p.pos.x = s.rx * simWidth; s.p.pos.y = s.ry * simHeight; clampActorPos(s.p); });
        
        // Re-apply preserved relative positions to menus using NEW canvas dimensions
        if (canvas.width > 0 && canvas.height > 0) {
            physicsMenuCenterX = menuSnapshots.physics.rx * canvas.width;
            physicsMenuCenterY = menuSnapshots.physics.ry * canvas.height;
            particlesMenuCenterX = menuSnapshots.particles.rx * canvas.width;
            particlesMenuCenterY = menuSnapshots.particles.ry * canvas.height;
            gravityMenuX = menuSnapshots.gravity.rx * canvas.width;
            gravityMenuY = menuSnapshots.gravity.ry * canvas.height;
            respawnMenuCenterX = menuSnapshots.respawn.rx * canvas.width;
            respawnMenuCenterY = menuSnapshots.respawn.ry * canvas.height;
            wallsMenuCenterX = menuSnapshots.walls.rx * canvas.width;
            wallsMenuCenterY = menuSnapshots.walls.ry * canvas.height;
            colorWheelCenterX = menuSnapshots.colorWheel.rx * canvas.width;
            colorWheelCenterY = menuSnapshots.colorWheel.ry * canvas.height;
            toysMenuCenterX = menuSnapshots.toys.rx * canvas.width;
            toysMenuCenterY = menuSnapshots.toys.ry * canvas.height;
            mainMenuX = menuSnapshots.mainMenu.rx * canvas.width;
            mainMenuTargetX = menuSnapshots.mainMenu.rtx * canvas.width;
            
            // If main menu is visible, update target to stay centered
            if (mainMenuVisible) {
                mainMenuTargetX = (canvas.width - calculateMainMenuWidth()) / 2;
                mainMenuX = mainMenuTargetX; // Snap to position immediately during resize
            }
        }
        
        // Rebuild gradient matching background for new geometry
        updateCornerFillGradient();
        // Clear existing frame
        c.fillStyle = 'hsl(0, 0%, 0%)';
        c.fillRect(0, 0, canvas.width, canvas.height);
        // Recreate geometry dependent on dimensions
    if (typeof makeCorners === 'function' && typeof Corners !== 'undefined' && Array.isArray(Corners)) makeCorners();
    if (typeof updateCornerGeometry === 'function') updateCornerGeometry();
    if (typeof makeBumpers === 'function') makeBumpers();
        // Restart dynamic actors & particles
    if (typeof makeBalls === 'function') makeBalls();
    if (typeof syncParticleCountControls === 'function') syncParticleCountControls();
    if (typeof makeWorm === 'function' && typeof doWorm !== 'undefined' && doWorm) { makeWorm(); }
        // Re-select tracer if tracing enabled so trail restarts cleanly
        if (typeof selectTracerBall === 'function' && typeof doTracer !== 'undefined') {
            if (doTracer && (doSmallTracer || doMediumTracer || doBigTracer)) {
                selectTracerBall();
            }
        }
    }
    window.addEventListener('resize', () => {
        if (_resizeDebounce) clearTimeout(_resizeDebounce);
        _resizeDebounce = setTimeout(() => {
            handleResizeRestart();
            positionFpsCounter(); // Reposition FPS counter after resize
        }, 150); // debounce to avoid rapid churn
    });
    // Gradient used to fill canvas corners/masks to match page background
    let cornerFillGradient = null;
    // Tunables
    const heartResumeDelayMs = 1500; // Pause after release/toggle before heartbeat resumes
    function updateCornerFillGradient() {
        // Align the canvas gradient with the page's background gradient (to bottom)
        // using viewport-relative coordinates so the transition is seamless.
        const rect = canvas.getBoundingClientRect();
        const y0 = -rect.top;                 // where the canvas starts relative to viewport (px)
        const y1 = y0 + window.innerHeight;   // viewport bottom relative to canvas
        const g = c.createLinearGradient(0, y0, 0, y1);
        // Match body CSS: linear-gradient(to bottom, hsl(0, 0%, 0%) 0%, hsl(195, 64%, 8%) 100%)
        g.addColorStop(0.0, 'hsl(0, 0%, 0%)');
        g.addColorStop(1.0, 'hsl(195, 64%, 8%)');
        cornerFillGradient = g;
    }
    // Initialize gradient now
    updateCornerFillGradient();
    // Keep it updated on scroll (viewport relative) for a fixed page background
    window.addEventListener('scroll', updateCornerFillGradient, { passive: true });

    // Now that gradient logic is initialized, set up layout event listeners and initial call
    document.addEventListener('fullscreenchange', layoutCanvasAndMenu);
    window.addEventListener('resize', layoutCanvasAndMenu);
    layoutCanvasAndMenu();
    
    //  KEYBOARD SHORTCUTS -----------------------------------------------------
    
    document.addEventListener('keydown', event => {
        switch(event.key) {
            case 'n': physProps.paused = false; simulate(); physProps.paused = true; break;
            case 'N': physProps.paused = false; simulate(); physProps.paused = true; break;
            case 'm': physProps.paused = !physProps.paused; break;
            case 'M': physProps.paused = !physProps.paused; break;
            case 'p': physProps.paused = !physProps.paused; break;
            case 'P': physProps.paused = !physProps.paused; break;
            case 'r': forcedWipeRestart();
            case 'R': forcedWipeRestart();
            case 'c': 
            case 'C': 
                // Capture current menu positions (press 'c' key)
                captureMenuPositions();
                break;
        }
    });

    //  GET WORLD PROPERTIES FROM SLIDERS ---------------------------------------------
    
    // Note: Fountain/Shower controls are now handled by the ReSpawn menu system
    // The respawnMenuSpawnType variable controls whether 'shower' or 'fountain' mode is active
    
    // ===== MAIN MENU SYSTEM =====
    // Main menu state
    var mainMenuVisible = false;
    var mainMenuAnimating = false;
    var mainMenuX = 0; // Current X position (animates from off-screen left)
    var mainMenuTargetX = 0; // Target X position
    const mainMenuSlideSpeed = 60; // Pixels per frame for slide animation (used for slide out)
    const mainMenuPadding = 20; // Pixels from top
    const mainMenuCornerRadius = 10;
    const mainMenuHeight = 75;
    const mainMenuBarAlpha = 0.85;
    
    // Spring animation for opening
    var mainMenuVelocity = 0; // Current velocity for spring animation
    var mainMenuUsingSpring = false; // Whether to use spring animation (true for opening, false for closing)
    const mainMenuSpringStrength = 0.3; // Spring force coefficient
    const mainMenuSpringDamping = 0.7; // Damping factor (0-1, lower = more bouncy)
    
    // Ellipsis button (always visible in top-left)
    const ellipsisSize = 40;
    const ellipsisMargin = 10;
    
    // Pause button blink effect
    var pauseButtonBlinkTimer = 0;
    const pauseButtonBlinkCycle = 1.8; // Total cycle time in seconds (0.8s lit + 0.2s dimmed)
    const pauseButtonDimDuration = 0.3; // Duration of dim phase in seconds
    
    // Main menu items with their properties
    const mainMenuItems = [
        {id: 'particles', label: 'Particles', color: 'hsl(23, 70%, 60%)', checked: true, variable: 'particlesMenuVisible'},
        {id: 'physics', label: 'Fizix', color: 'hsl(140, 80%, 60%)', checked: false, variable: 'physicsMenuVisible'},
        {id: 'gravity', label: 'Gravity', color: 'hsl(230, 90%, 65%)', checked: false, variable: 'gravityMenuVisible'},
        {id: 'walls', label: 'Walls', color: 'hsl(0, 95%, 50%)', checked: false, variable: 'wallsMenuVisible'},
        {id: 'respawn', label: 'ReSpawn', color: 'hsl(320, 100%, 50%)', checked: false, variable: 'respawnMenuVisible'},
        {id: 'toys', label: 'Toys', color: 'hsl(45, 80%, 50%)', checked: false, variable: 'toysMenuVisible'},
        {id: 'color', label: 'Color', color: '', checked: false, variable: 'colorWheelVisible', multiColor: true},
        {id: 'pause', label: 'Pause', color: 'hsl(0, 0%, 80%)', checked: false, isPause: true}
    ];
    
    // Calculate main menu width based on items
    function calculateMainMenuWidth() {
        const itemWidth = 90;
        const itemSpacing = 10;
        const sidePadding = 20;
        return (mainMenuItems.length * itemWidth) + ((mainMenuItems.length - 1) * itemSpacing) + (sidePadding * 2);
    }
    
    // Color Wheel Setup - draws on main canvas
    var colorWheelHue = 180;
    var colorWheelSat = 70;
    var colorWheelLight = 30;
    var colorWheelPersistence = 12;
    var colorWheelVelMap = 100;
    var colorWheelVisible = false;
    var colorWheelOpacity = 0;
    var colorWheelAnimating = false;
    var colorWheelTargetOpacity = 0;
    var colorWheelDragging = false;
    var colorWheelDraggingControl = null; // Tracks which control: 'wheel', 'lightness', 'sensitivity', 'persistence'
    var colorWheelPositionDragging = false;
    var colorWheelDragOffsetX = 0;
    var colorWheelDragOffsetY = 0;
    
    // Global interaction lock - prevents multiple objects from being interacted with simultaneously
    var globalInteractionLock = false;
    
    // Cached color wheel icon for main menu
    var colorWheelIconCanvas = null;
    var colorWheelIconCtx = null;
    
    // Offscreen canvas for full color wheel (for color menu)
    var colorWheelOffscreenCanvas = null;
    var colorWheelOffscreenCtx = null;
    var colorWheelNeedsRedraw = true;
    
    // Initialize offscreen canvas early
    function initColorWheelOffscreenCanvas() {
        if (!colorWheelOffscreenCanvas) {
            const radius = 83.5; // colorWheelSize / 2
            colorWheelOffscreenCanvas = document.createElement('canvas');
            // Add padding to prevent cropping at edges
            colorWheelOffscreenCanvas.width = radius * 2 + 4;
            colorWheelOffscreenCanvas.height = radius * 2 + 4;
            colorWheelOffscreenCtx = colorWheelOffscreenCanvas.getContext('2d');
            
            // Render the color wheel to the offscreen canvas
            const offCtx = colorWheelOffscreenCtx;
            const offCenterX = radius + 2;
            const offCenterY = radius + 2;
            const lightness = 50; // Default lightness
            
            for (let angle = 0; angle < 360; angle += 2) {
                for (let r = 0; r <= radius; r += 2) {
                    const hue = angle;
                    const saturation = (r / radius) * 100;
                    
                    offCtx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                    const x = offCenterX + r * Math.cos(angle * Math.PI / 180);
                    const y = offCenterY + r * Math.sin(angle * Math.PI / 180);
                    offCtx.fillRect(x - 1, y - 1, 3, 3);
                }
            }
            
            colorWheelNeedsRedraw = false;
        }
    }
    
    // Color wheel dimensions (in canvas pixels)
    var colorWheelSize = 167;
    var colorWheelCenterX = 0;
    var colorWheelCenterY = 0;
    var colorWheelRadius = 0;
    var colorWheelManuallyMoved = false;
    
    // Physics Menu Setup - draws on main canvas
    var physicsMenuRepulsionForce = 20;
    var physicsMenuRepulsionDist = 4;
    var physicsMenuRepulsionOn = true;
    var physicsMenuBallRest = 0;
    var physicsMenuBounceOn = false;
    var physicsMenuTime = 1000;
    var physicsMenuSpeed = 20;
    var physicsMenuSubsteps = 1;
    var physicsMenuFpsOn = false;
    var physicsMenuVisible = false;
    var physicsMenuOpacity = 0;
    var physicsMenuAnimating = false;
    var physicsMenuTargetOpacity = 0;
    var physicsMenuDragging = false;
    var physicsMenuDraggingControl = null; // Tracks which slider is being dragged
    var physicsMenuPositionDragging = false;
    var physicsMenuDragOffsetX = 0;
    var physicsMenuDragOffsetY = 0;
    var physicsMenuManuallyMoved = false;
    
    // Physics menu dimensions (in canvas pixels)
    var physicsMenuWidth = 240;
    var physicsMenuHeight = 250;
    var physicsMenuCenterX = 0;
    var physicsMenuCenterY = 0;
    
    // Gravity menu variables
    var gravityMenuX = 0;
    var gravityMenuY = 0;
    var gravityMenuRadius = 80;
    var gravityMenuVisible = false;
    var gravityMenuOpacity = 0;
    var gravityMenuAnimating = false;
    var gravityMenuTargetOpacity = 0;
    var gravityMenuDragging = false;
    var gravityMenuDraggingControl = null; // Tracks which control is being dragged ('rotation' or 'gravity')
    var gravityMenuPositionDragging = false;
    var gravityMenuDragOffsetX = 0;
    var gravityMenuDragOffsetY = 0;
    var gravityMenuManuallyMoved = false;
    
    // Gravity rotation slider variables
    var gravityRotationSlider = 0.5; // 0-1 range, 0.5 is center (no rotation)
    var gravityRotationSpeed = 0; // Current rotation speed in radians per frame
    var gravityRotationSliderDragging = false; // Track if user is actively dragging the slider
    
    // Walls menu variables
    var wallsMenuVisible = false;
    var wallsMenuOpacity = 0;
    var wallsMenuAnimating = false;
    var wallsMenuTargetOpacity = 0;
    var wallsMenuDragging = false;
    var wallsMenuDraggingControl = null; // Tracks which slider is being dragged
    var wallsMenuPositionDragging = false;
    var wallsMenuDragOffsetX = 0;
    var wallsMenuDragOffsetY = 0;
    var wallsMenuManuallyMoved = false;
    
    // Walls menu dimensions (same width as physics and particles menus)
    var wallsMenuWidth = 240;
    var wallsMenuHeight = 258;
    var wallsMenuCenterX = 0;
    var wallsMenuCenterY = 0;
    
    // Wall state variables (replacing the HTML controls)
    var wallsMenuCornerRadius = 100;
    var wallsMenuLeftWall = true;
    var wallsMenuRightWall = true;
    var wallsMenuCeiling = true;
    var wallsMenuFloor = true;
    
    // ReSpawn menu variables
    var respawnMenuVisible = false;
    var respawnMenuOpacity = 0;
    var respawnMenuAnimating = false;
    var respawnMenuTargetOpacity = 0;
    var respawnMenuDragging = false;
    var respawnMenuPositionDragging = false;
    var respawnMenuDragOffsetX = 0;
    var respawnMenuDragOffsetY = 0;
    var respawnMenuManuallyMoved = false;
    
    // ReSpawn menu dimensions (same width as other menus)
    var respawnMenuWidth = 240;
    var respawnMenuHeight = 340; 
    var respawnMenuCenterX = 0;
    var respawnMenuCenterY = 0;
    
    // ReSpawn menu state variables (replacing the HTML controls)
    var respawnMenuOneShot = false;
    var respawnMenuHungryPuck = false;
    var respawnMenuSpawnType = 'shower'; // 'shower' or 'fountain'
    var respawnMenuLayoutType = 'cluster'; // 'cluster' or 'array'
    var respawnMenuMisterMode = 'idle';
    var respawnMenuMisterModeExpanded = false; // Track if dropdown is expanded
    
    // Toys menu variables
    var toysMenuVisible = false;
    var toysMenuOpacity = 0;
    var toysMenuAnimating = false;
    var toysMenuTargetOpacity = 0;
    var toysMenuDragging = false;
    var toysMenuPositionDragging = false;
    var toysMenuDragOffsetX = 0;
    var toysMenuDragOffsetY = 0;
    var toysMenuManuallyMoved = false;
    
    // Toys menu items array
    var toysMenuItems = [];
    
    // Toys menu dimensions (in canvas pixels)
    var toysMenuWidth = 280;
    var toysMenuHeight = 418;
    var toysMenuCenterX = 0;
    var toysMenuCenterY = 0;
    
    // Default relative menu positions (as percentages of canvas width/height)
    // Set these values after positioning menus where you want them
    var defaultMenuPositions = {
        physics: { x: 0.3347305389221557, y: 0.49340285815231294 },
        particles: { x: 0.22237619002832038, y: 0.3068240625649903 },
        gravity: { x: 0.41377245508982036, y: 0.2829643888354187 },
        respawn: { x: 0.5718562874251497, y: 0.2897016361886429 },
        walls: { x: 0.5, y: 0.6246390760346487 },
        colorWheel: { x: 0.6491017964071857, y: 0.717516843118383 },
        toys: { x: 0.7658682634730539, y: 0.352261790182868 }
    };
    
    // Function to capture current menu positions as relative coordinates
    function captureMenuPositions() {
        if (canvas.width > 0 && canvas.height > 0) {
            const positions = {
                physics: { 
                    x: physicsMenuCenterX / canvas.width, 
                    y: physicsMenuCenterY / canvas.height 
                },
                particles: { 
                    x: particlesMenuCenterX / canvas.width, 
                    y: particlesMenuCenterY / canvas.height 
                },
                gravity: { 
                    x: gravityMenuX / canvas.width, 
                    y: gravityMenuY / canvas.height 
                },
                respawn: { 
                    x: respawnMenuCenterX / canvas.width, 
                    y: respawnMenuCenterY / canvas.height 
                },
                walls: { 
                    x: wallsMenuCenterX / canvas.width, 
                    y: wallsMenuCenterY / canvas.height 
                },
                colorWheel: { 
                    x: colorWheelCenterX / canvas.width, 
                    y: colorWheelCenterY / canvas.height 
                },
                toys: { 
                    x: toysMenuCenterX / canvas.width, 
                    y: toysMenuCenterY / canvas.height 
                }
            };
            console.log('Current menu positions (copy to defaultMenuPositions):');
            console.log(JSON.stringify(positions, null, 4));
            return positions;
        }
    }
    
    // Function to apply default relative positions
    function applyDefaultMenuPositions() {
        if (canvas.width > 0 && canvas.height > 0) {
            // Only apply default positions if they've been set (not 0.0)
            // Don't set ManuallyMoved flag here - let the first open handle collision detection
            if (defaultMenuPositions.physics.x > 0.0 || defaultMenuPositions.physics.y > 0.0) {
                physicsMenuCenterX = defaultMenuPositions.physics.x * canvas.width;
                physicsMenuCenterY = defaultMenuPositions.physics.y * canvas.height;
            }
            if (defaultMenuPositions.particles.x > 0.0 || defaultMenuPositions.particles.y > 0.0) {
                particlesMenuCenterX = defaultMenuPositions.particles.x * canvas.width;
                particlesMenuCenterY = defaultMenuPositions.particles.y * canvas.height;
            }
            if (defaultMenuPositions.gravity.x > 0.0 || defaultMenuPositions.gravity.y > 0.0) {
                gravityMenuX = defaultMenuPositions.gravity.x * canvas.width;
                gravityMenuY = defaultMenuPositions.gravity.y * canvas.height;
            }
            if (defaultMenuPositions.respawn.x > 0.0 || defaultMenuPositions.respawn.y > 0.0) {
                respawnMenuCenterX = defaultMenuPositions.respawn.x * canvas.width;
                respawnMenuCenterY = defaultMenuPositions.respawn.y * canvas.height;
            }
            if (defaultMenuPositions.walls.x > 0.0 || defaultMenuPositions.walls.y > 0.0) {
                wallsMenuCenterX = defaultMenuPositions.walls.x * canvas.width;
                wallsMenuCenterY = defaultMenuPositions.walls.y * canvas.height;
            }
            if (defaultMenuPositions.colorWheel.x > 0.0 || defaultMenuPositions.colorWheel.y > 0.0) {
                colorWheelCenterX = defaultMenuPositions.colorWheel.x * canvas.width;
                colorWheelCenterY = defaultMenuPositions.colorWheel.y * canvas.height;
            }
            if (defaultMenuPositions.toys && (defaultMenuPositions.toys.x > 0.0 || defaultMenuPositions.toys.y > 0.0)) {
                toysMenuCenterX = defaultMenuPositions.toys.x * canvas.width;
                toysMenuCenterY = defaultMenuPositions.toys.y * canvas.height;
            }
        }
    }

    // Menu z-order system - menus are drawn in this order (first = bottom, last = top)
    var menuDrawOrder = ['colorWheel', 'physicsMenu', 'wallsMenu', 'particlesMenu', 'gravityMenu', 'respawnMenu', 'toysMenu'];
    
    // Function to bring menu to front
    function bringMenuToFront(menuName) {
        const index = menuDrawOrder.indexOf(menuName);
        if (index > -1) {
            menuDrawOrder.splice(index, 1);
            menuDrawOrder.push(menuName);
        }
    }
    
    // Global wall state variables (used by physics system)
    var doLeftWall = true;
    var doRightWall = true;
    var doCeiling = true;
    var doFloor = true;
    var cornerRad = 100;
    
    // Initialize Corners array
    var Corners = [];
    
    // Particles Menu Setup - draws on main canvas
    var particlesMenuQuantity = 71; // Square root (1-100), actual count = quantity^2
    var particlesMenuSmallRadius = 7;
    var particlesMenuLargeRadius = 13;
    var particlesMenuRenderType = 'drawDiscs'; // 'drawSpheres', 'drawDiscs', 'drawCircles', 'drawRings', 'drawGummies'
    var particlesMenuRenderTypeExpanded = false; // Track if dropdown is expanded
    var particlesMenuVisible = true;
    var particlesMenuOpacity = 1;
    var particlesMenuAnimating = false;
    var particlesMenuTargetOpacity = 1;
    var particlesMenuDragging = false;
    var particlesMenuDraggingControl = null; // Tracks which slider is being dragged
    var particlesMenuPositionDragging = false;
    var particlesMenuDragOffsetX = 0;
    var particlesMenuDragOffsetY = 0;
    var particlesMenuManuallyMoved = false;
    
    // Particles menu dimensions (in canvas pixels)
    var particlesMenuWidth = 240;
    var particlesMenuHeight = 220;  // Reduced by 20px (half slider height)
    var particlesMenuCenterX = 0;
    var particlesMenuCenterY = 0;
    
    function updatePhysicsMenuPosition() {
        // Position to the right of particles menu with spacing
        const spacing = 30; // Gap between menus
        const particlesMenuRight = particlesMenuCenterX + particlesMenuWidth / 2;
        physicsMenuCenterX = particlesMenuRight + spacing + physicsMenuWidth / 2;
        physicsMenuCenterY = canvas.height / 2;
    }
    
    function updateParticlesMenuPosition() {
        // Calculate total width of all menus and spacing to center the group
        const spacing = 30; // Gap between menus
        const gravityMenuSize = gravityMenuRadius * 2 + 50;
        const totalWidth = particlesMenuWidth + spacing + physicsMenuWidth + spacing + gravityMenuSize + spacing + respawnMenuWidth + spacing + colorWheelSize;
        const groupStartX = (canvas.width - totalWidth) / 2;
        
        particlesMenuCenterX = groupStartX + particlesMenuWidth / 2;
        particlesMenuCenterY = canvas.height / 2 - 50;
    }
    
    function updateColorWheelPosition() {
        // Position to the right of respawn menu with spacing
        const spacing = 30; // Gap between menus
        const respawnMenuRight = respawnMenuCenterX + respawnMenuWidth / 2;
        colorWheelCenterX = respawnMenuRight + spacing + colorWheelSize / 2 + 12;
        colorWheelCenterY = canvas.height / 2;
        colorWheelRadius = colorWheelSize / 2;
    }
    
    function updateRespawnMenuPosition() {
        // Position to the right of gravity menu with spacing
        const spacing = 30; // Gap between menus
        const gravityMenuSize = gravityMenuRadius * 2 + 50;
        const gravityMenuRight = gravityMenuX + gravityMenuSize / 2;
        respawnMenuCenterX = gravityMenuRight + spacing + respawnMenuWidth / 2;
        respawnMenuCenterY = canvas.height / 2;
    }
    
    function updateToysMenuPosition() {
        if (!canvas) return;
        // Default to left bottom area if not set
        if (toysMenuCenterX === 0 && toysMenuCenterY === 0) {
            toysMenuCenterX = canvas.width * 0.25;
            toysMenuCenterY = canvas.height * 0.75;
        }
    }
    
    // Consolidated function to draw menu background, border, and close button
    function drawMenuBackground(ctx, centerX, centerY, width, height, options = {}) {
        // Default options
        const {
            backgroundAlpha = 0.7,
            borderPadding = 8,
            topOffset = -8,
            bottomOffset = 16,
            leftOffset = 0,
            rightOffset = 0,
            showCloseButton = true,
            backgroundColor = 'rgba(20, 20, 20, 0.7)'
        } = options;
        
        // Calculate final dimensions
        const finalWidth = width + 2*borderPadding + leftOffset + rightOffset;
        const finalHeight = height + Math.abs(topOffset) + bottomOffset;
        const rectX = centerX - width/2 - borderPadding - leftOffset/2;
        const rectY = centerY - height/2 + topOffset;
        const cornerRadius = 12;
        
        // Draw semi-transparent background with linear gradient (less transparent at top, more at bottom)
        const gradient = ctx.createLinearGradient(rectX, rectY, rectX, rectY + finalHeight);
        gradient.addColorStop(0, 'hsla(0, 0%, 5%, 0.7)'); // Less transparent at top
        //gradient.addColorStop(0.4, 'hsla(0, 0%, 20%, 0.7)'); // Less transparent at top
        gradient.addColorStop(1, 'hsla(0, 0%, 10%, 0.5)'); // More transparent at bottom
        ctx.fillStyle = gradient;
        
        // Draw rounded rectangle for background
        ctx.beginPath();
        ctx.moveTo(rectX + cornerRadius, rectY);
        ctx.lineTo(rectX + finalWidth - cornerRadius, rectY);
        ctx.arcTo(rectX + finalWidth, rectY, rectX + finalWidth, rectY + cornerRadius, cornerRadius);
        ctx.lineTo(rectX + finalWidth, rectY + finalHeight - cornerRadius);
        ctx.arcTo(rectX + finalWidth, rectY + finalHeight, rectX + finalWidth - cornerRadius, rectY + finalHeight, cornerRadius);
        ctx.lineTo(rectX + cornerRadius, rectY + finalHeight);
        ctx.arcTo(rectX, rectY + finalHeight, rectX, rectY + finalHeight - cornerRadius, cornerRadius);
        ctx.lineTo(rectX, rectY + cornerRadius);
        ctx.arcTo(rectX, rectY, rectX + cornerRadius, rectY, cornerRadius);
        ctx.closePath();
        ctx.fill();
        
        // Draw border with rounded corners
        ctx.strokeStyle = 'hsl(0, 0%, 60%)';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Draw close button (red circle with X) in top-left corner
        if (showCloseButton) {
            const closeButtonX = rectX + 20;
            const closeButtonY = rectY + 20;
            const closeButtonRadius = 10;
            
            ctx.beginPath();
            ctx.arc(closeButtonX, closeButtonY, closeButtonRadius, 0, Math.PI * 2);
            ctx.fillStyle = 'hsl(0, 70%, 30%)';
            ctx.fill();
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            //ctx.stroke();
            
            // Draw X symbol
            ctx.beginPath();
            const xSize = 4;
            ctx.moveTo(closeButtonX - xSize, closeButtonY - xSize);
            ctx.lineTo(closeButtonX + xSize, closeButtonY + xSize);
            ctx.moveTo(closeButtonX + xSize, closeButtonY - xSize);
            ctx.lineTo(closeButtonX - xSize, closeButtonY + xSize);
            ctx.stroke();
        }
        
        // Return close button bounds for hit testing
        return showCloseButton ? {
            closeButtonX: rectX + 20,
            closeButtonY: rectY + 20,
            closeButtonRadius: 12
        } : null;
    }
    
    // ===== MAIN MENU DRAWING FUNCTIONS =====
    
    // Create cached color wheel icon for main menu
    function createColorWheelIcon() {
        if (colorWheelIconCanvas) return; // Already created
        
        // Use the full color wheel offscreen canvas if it exists
        if (colorWheelOffscreenCanvas) {
            const size = 24;
            colorWheelIconCanvas = document.createElement('canvas');
            colorWheelIconCanvas.width = size;
            colorWheelIconCanvas.height = size;
            colorWheelIconCtx = colorWheelIconCanvas.getContext('2d');
            
            // Draw scaled down version from the offscreen canvas
            const sourceSize = colorWheelOffscreenCanvas.width;
            colorWheelIconCtx.drawImage(colorWheelOffscreenCanvas, 0, 0, sourceSize, sourceSize, 0, 0, size, size);
            return;
        }
        
        // Fallback: create it from scratch if offscreen canvas doesn't exist yet
        const size = 24;
        const padding = 2;
        colorWheelIconCanvas = document.createElement('canvas');
        colorWheelIconCanvas.width = size + padding * 2;
        colorWheelIconCanvas.height = size + padding * 2;
        colorWheelIconCtx = colorWheelIconCanvas.getContext('2d');
        
        const centerX = size / 2 + padding;
        const centerY = size / 2 + padding;
        const radius = size / 2;
        
        // Draw the hue/saturation wheel with padding
        for (let angle = 0; angle < 360; angle += 3) {
            for (let r = 0; r <= radius; r += 1) {
                const hue = angle;
                const saturation = (r / radius) * 100;
                const lightness = 50;
                
                colorWheelIconCtx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                const x = centerX + r * Math.cos(angle * Math.PI / 180);
                const y = centerY + r * Math.sin(angle * Math.PI / 180);
                colorWheelIconCtx.fillRect(x - 1, y - 1, 2, 2);
            }
        }
    }
    
    function drawEllipsisButton() {
        const ctx = c;
        const x = ellipsisMargin + ellipsisSize / 2;
        const y = ellipsisMargin + ellipsisSize / 2;
        
        // Draw semi-transparent background circle
        ctx.globalAlpha = 0.7;
        ctx.fillStyle = 'rgba(30, 30, 30, 0.9)';
        ctx.beginPath();
        ctx.arc(x, y, ellipsisSize / 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw border
        ctx.strokeStyle = 'hsl(0, 0%, 60%)';
        ctx.lineWidth = 2;
        //ctx.stroke();
        
        // Draw three dots (ellipsis)
        ctx.fillStyle = 'hsl(0, 0%, 80%)';
        const dotRadius = 3;
        const dotSpacing = 8;
        const startX = x - dotSpacing;
        
        for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.arc(startX + i * dotSpacing, y, dotRadius, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.globalAlpha = 1;
    }
    
    //  draw main menu  ----------
    function drawMainMenu() {
        if (!mainMenuVisible && mainMenuX <= -calculateMainMenuWidth()) {
            return; // Completely off-screen, skip drawing
        }
        
        const ctx = c;
        const menuWidth = calculateMainMenuWidth();
        const menuHeight = mainMenuHeight;
        const itemWidth = 90;
        const itemSpacing = 10;
        const sidePadding = 20;
        
        ctx.save();
        ctx.globalAlpha = mainMenuBarAlpha;
        
        // Draw rounded rectangle background bar
        const barX = mainMenuX;
        const barY = mainMenuPadding;
        
        ctx.fillStyle = 'rgba(20, 20, 20, 0.85)';
        ctx.beginPath();
        ctx.moveTo(barX + mainMenuCornerRadius, barY);
        ctx.lineTo(barX + menuWidth - mainMenuCornerRadius, barY);
        ctx.arcTo(barX + menuWidth, barY, barX + menuWidth, barY + mainMenuCornerRadius, mainMenuCornerRadius);
        ctx.lineTo(barX + menuWidth, barY + menuHeight - mainMenuCornerRadius);
        ctx.arcTo(barX + menuWidth, barY + menuHeight, barX + menuWidth - mainMenuCornerRadius, barY + menuHeight, mainMenuCornerRadius);
        ctx.lineTo(barX + mainMenuCornerRadius, barY + menuHeight);
        ctx.arcTo(barX, barY + menuHeight, barX, barY + menuHeight - mainMenuCornerRadius, mainMenuCornerRadius);
        ctx.lineTo(barX, barY + mainMenuCornerRadius);
        ctx.arcTo(barX, barY, barX + mainMenuCornerRadius, barY, mainMenuCornerRadius);
        ctx.closePath();
        ctx.fill();
        
        // Draw border
        //ctx.strokeStyle = 'hsl(0, 0%, 60%)';
        //ctx.lineWidth = 2;
        //ctx.stroke();
        
        ctx.restore();
        ctx.globalAlpha = 1;
        
        // Draw menu items
        let currentX = mainMenuX + sidePadding;
        
        for (const item of mainMenuItems) {
            drawMainMenuItem(item, currentX, barY + menuHeight / 2, itemWidth, menuHeight - 10);
            currentX += itemWidth + itemSpacing;
        }
    }
    
    function drawMainMenuItem(item, x, centerY, width, height) {
        const ctx = c;
        const padding = 8;
        const cornerRadius = 8;
        
        // Determine if item is checked
        let isChecked = false;
        if (item.isPause) {
            isChecked = physProps.paused;
        } else if (item.variable) {
            isChecked = eval(item.variable); // Get the menu visibility state
        }
        
        // Draw item background (checkbox style)
        const bgAlpha = isChecked ? 0.6 : 0.3;
        ctx.globalAlpha = bgAlpha;
        
        const rectX = x;
        const rectY = centerY - height / 2;
        
        /*
        if (isChecked) {
            // Filled when checked
            ctx.fillStyle = item.color || 'hsl(0, 0%, 50%)';
            ctx.beginPath();
            ctx.moveTo(rectX + cornerRadius, rectY);
            ctx.lineTo(rectX + width - cornerRadius, rectY);
            ctx.arcTo(rectX + width, rectY, rectX + width, rectY + cornerRadius, cornerRadius);
            ctx.lineTo(rectX + width, rectY + height - cornerRadius);
            ctx.arcTo(rectX + width, rectY + height, rectX + width - cornerRadius, rectY + height, cornerRadius);
            ctx.lineTo(rectX + cornerRadius, rectY + height);
            ctx.arcTo(rectX, rectY + height, rectX, rectY + height - cornerRadius, cornerRadius);
            ctx.lineTo(rectX, rectY + cornerRadius);
            ctx.arcTo(rectX, rectY, rectX + cornerRadius, rectY, cornerRadius);
            ctx.closePath();
            ctx.fill();
        }

        // Draw border
        ctx.globalAlpha = 1;
        ctx.strokeStyle = item.color || 'hsl(0, 0%, 60%)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(rectX + cornerRadius, rectY);
        ctx.lineTo(rectX + width - cornerRadius, rectY);
        ctx.arcTo(rectX + width, rectY, rectX + width, rectY + cornerRadius, cornerRadius);
        ctx.lineTo(rectX + width, rectY + height - cornerRadius);
        ctx.arcTo(rectX + width, rectY + height, rectX + width - cornerRadius, rectY + height, cornerRadius);
        ctx.lineTo(rectX + cornerRadius, rectY + height);
        ctx.arcTo(rectX, rectY + height, rectX, rectY + height - cornerRadius, cornerRadius);
        ctx.lineTo(rectX, rectY + cornerRadius);
        ctx.arcTo(rectX, rectY, rectX + cornerRadius, rectY, cornerRadius);
        ctx.closePath();
        //ctx.stroke();
        */

        ctx.globalAlpha = 1;
        // Draw icon above label
        const iconY = 5 + (rectY + height * 0.35);
        const iconColor = isChecked ? 'hsla(190, 85%, 55%, 1.0)' : 'hsla(190, 45%, 20%, 1)';
        
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = iconColor;
        
        // Draw icon based on item type
        if (item.id === 'particles') {
            ctx.font = 'bold 44px verdana';
            ctx.fillText('#', rectX + width / 2, iconY - 0);
        } else if (item.id === 'physics') {
            ctx.font = 'italic bold 36px sans-serif';
            ctx.fillText('f(x)', rectX + width / 2, iconY - 4);
        } else if (item.id === 'gravity') {
            ctx.font = 'bold 48px times-new-roman';
            ctx.fillText('G', rectX + width / 2, iconY - 0);
        } else if (item.id === 'walls') {
            // Draw rounded rectangle with arrow
            ctx.strokeStyle = iconColor;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.roundRect(
                rectX + width / 2 - 30, 
                iconY - 20, 
                60, 
                34, 
                15);
            ctx.stroke();
            ctx.font = '60px sans-serif';
            ctx.fillText('', rectX + width / 2, iconY - 5);
        } else if (item.id === 'respawn') {
            ctx.font = 'bold 60px verdana';
            ctx.fillText('', rectX + width / 2, iconY - 2);
        } else if (item.id === 'toys') {
            ctx.font = 'bold 38px monospace';
            ctx.fillStyle = iconColor;
            if (!isChecked) {
                ctx.globalAlpha = 0.4;
            }
            //ctx.fillText('', rectX + width / 2, iconY - 3);
            ctx.fillText('', rectX + width / 2, iconY - 0);
            ctx.globalAlpha = 1;
        } else if (item.id === 'color') {
            // Draw color wheel icon using cached canvas
            if (!colorWheelIconCanvas) {
                createColorWheelIcon();
            }
            
            const iconSize = 36;
            const cx = rectX + width / 2;
            const cy = iconY - 6;
            
            // Apply dimming if not checked
            if (!isChecked) {
                ctx.globalAlpha = 0.4;
            }
            
            // Draw the cached color wheel image
            ctx.drawImage(colorWheelIconCanvas, cx - iconSize / 2, cy - iconSize / 2, iconSize, iconSize);
            
            ctx.globalAlpha = 1;
            
            // Draw border if checked
            if (isChecked) {
                ctx.strokeStyle = 'hsl(190, 85%, 60%)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(cx, cy, iconSize / 2, 0, Math.PI * 2);
                ctx.stroke();
            }
        } else if (item.isPause) {
            // Draw pause icon (two vertical bars)
            const barWidth = 6;
            const barHeight = 24;
            const barSpacing = 6;
            const cx = rectX + width / 2;
            const cy = iconY - 6;
            
            // Apply blinking effect when paused
            let iconColorWithBlink = iconColor;
            if (isChecked) {
                // Calculate blink phase (0.8s lit, 0.2s dim)
                const cyclePosition = pauseButtonBlinkTimer % pauseButtonBlinkCycle;
                const isDimPhase = cyclePosition >= (pauseButtonBlinkCycle - pauseButtonDimDuration);
                
                if (isDimPhase) {
                    // Dim the color during the blink
                    iconColorWithBlink = 'hsla(190, 45%, 25%, 0.4)';
                }
            }
            
            ctx.fillStyle = iconColorWithBlink;
            // Left bar
            ctx.fillRect(cx - barSpacing / 2 - barWidth, cy - barHeight / 2, barWidth, barHeight);
            // Right bar
            ctx.fillRect(cx + barSpacing / 2, cy - barHeight / 2, barWidth, barHeight);
        }
        
        // Draw label below icon
        const labelY = rectY + height * 0.8;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = '16px verdana';
        
        if (item.multiColor && item.id === 'color') {
            // Draw "Color" with each letter in different color
            const colors = ['hsl(0, 80%, 50%)', 'hsl(40, 80%, 50%)', 'hsl(120, 80%, 50%)', 'hsl(200, 80%, 50%)', 'hsl(280, 80%, 50%)'];
            const letters = ['C', 'o', 'l', 'o', 'r'];
            const letterSpacing = 10.5;
            const startX = rectX + width / 2 - (letters.length * letterSpacing) / 2;
            
            for (let i = 0; i < letters.length; i++) {
                ctx.fillStyle = colors[i];
                ctx.fillText(letters[i], startX + i * letterSpacing + 4.5, labelY + 4);
            }
        } else {
            ctx.fillStyle = item.color;
            ctx.fillText(item.label, rectX + width / 2, labelY + 4);
        }
    }
    
    function animateMainMenu() {
        if (!mainMenuAnimating) return;
        
        if (mainMenuUsingSpring) {
            // Spring animation for opening (bouncy)
            const diff = mainMenuTargetX - mainMenuX;
            
            // Apply spring force
            const springForce = diff * mainMenuSpringStrength;
            mainMenuVelocity += springForce;
            
            // Apply damping
            mainMenuVelocity *= mainMenuSpringDamping;
            
            // Update position
            mainMenuX += mainMenuVelocity;
            
            // Stop when settled (small diff and small velocity)
            if (Math.abs(diff) < 0.5 && Math.abs(mainMenuVelocity) < 0.5) {
                mainMenuX = mainMenuTargetX;
                mainMenuAnimating = false;
                mainMenuVelocity = 0;
            }
        } else {
            // Simple slide animation for closing
            const diff = mainMenuTargetX - mainMenuX;
            
            if (Math.abs(diff) < 1) {
                mainMenuX = mainMenuTargetX;
                mainMenuAnimating = false;
            } else {
                mainMenuX += Math.sign(diff) * Math.min(mainMenuSlideSpeed, Math.abs(diff));
            }
        }
    }
    
    function updatePauseButtonBlink(dt) {
        // Update blink timer when paused
        if (physProps.paused) {
            pauseButtonBlinkTimer += dt;
        } else {
            pauseButtonBlinkTimer = 0; // Reset when not paused
        }
    }
    
    function toggleMainMenu() {
        mainMenuVisible = !mainMenuVisible;
        mainMenuAnimating = true;
        
        if (mainMenuVisible) {
            // Slide in from the left with spring animation - center horizontally on canvas
            mainMenuX = -calculateMainMenuWidth(); // Start off-screen left
            mainMenuTargetX = (canvas.width - calculateMainMenuWidth()) / 2;
            mainMenuUsingSpring = true;
            mainMenuVelocity = 0; // Reset velocity
        } else {
            // Slide out to the right (off-screen) - simple slide
            mainMenuTargetX = canvas.width;
            mainMenuUsingSpring = false;
            mainMenuVelocity = 0;
        }
    }
    
    function drawColorMenu() {
        if (colorWheelOpacity <= 0) return;
        
        const ctx = c;
        const size = colorWheelSize;
        const centerX = colorWheelCenterX;
        const centerY = colorWheelCenterY;
        const radius = colorWheelRadius;
        
        // Create offscreen canvas if needed
        if (!colorWheelOffscreenCanvas) {
            colorWheelOffscreenCanvas = document.createElement('canvas');
            // Add padding to prevent cropping at edges
            colorWheelOffscreenCanvas.width = radius * 2 + 4;
            colorWheelOffscreenCanvas.height = radius * 2 + 4;
            colorWheelOffscreenCtx = colorWheelOffscreenCanvas.getContext('2d');
            colorWheelNeedsRedraw = true;
        }
        
        // Redraw offscreen canvas if lightness changed
        if (colorWheelNeedsRedraw) {
            const offCtx = colorWheelOffscreenCtx;
            // Center with padding to prevent edge cropping
            const offCenterX = radius + 2;
            const offCenterY = radius + 2;
            
            // Clear the offscreen canvas
            offCtx.clearRect(0, 0, colorWheelOffscreenCanvas.width, colorWheelOffscreenCanvas.height);
            
            // Draw the hue/saturation wheel to offscreen canvas
            for (let angle = 0; angle < 360; angle += 2) {
                for (let r = 0; r <= radius; r += 2) {
                    const hue = angle;
                    const saturation = (r / radius) * 100;
                    const lightness = colorWheelLight;
                    
                    offCtx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                    const x = offCenterX + r * Math.cos(angle * Math.PI / 180);
                    const y = offCenterY + r * Math.sin(angle * Math.PI / 180);
                    offCtx.fillRect(x - 1, y - 1, 3, 3);
                }
            }
            colorWheelNeedsRedraw = false;
            
            // Invalidate icon cache so it uses the new color wheel
            colorWheelIconCanvas = null;
        }
        
        // Save context state and apply global alpha
        ctx.save();
        ctx.globalAlpha = colorWheelOpacity;
        
        // Draw menu background, border, and close button
        drawMenuBackground(ctx, centerX, centerY, size, size, {
            topOffset: -38,
            bottomOffset: 100,
            rightOffset: 70
        });
        
        // Draw title
        ctx.fillStyle = 'hsl(0, 0%, 70%)';
        ctx.font = 'bold 20px verdana, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        // Always center heading on menu width
        ctx.fillText('Color', colorWheelCenterX + 30, centerY - size/2 - 18);
        
        // Draw the color wheel from offscreen canvas
        // The offscreen canvas is (radius*2 + 4) in size, with wheel centered at (radius+2, radius+2)
        const offscreenSize = radius * 2 + 4;
        const wheelDrawX = centerX - radius - 2 + 12;
        const wheelDrawY = centerY - radius - 2;
        ctx.drawImage(colorWheelOffscreenCanvas, wheelDrawX, wheelDrawY);
        
        // The actual visual center of the wheel (used for mouse interaction)
        const actualWheelCenterX = wheelDrawX + radius + 2;
        const actualWheelCenterY = wheelDrawY + radius + 2;
        
        // Draw lightness slider (vertical bar on the right)
        const barX = centerX + radius + 32;
        const barY = centerY - radius;
        const barWidth = 20;
        const barHeight = radius * 2;
        
        for (let i = 0; i <= barHeight; i++) {
            const lightness = 100 - (i / barHeight) * 95 + 5; // 5-100%
            ctx.fillStyle = `hsl(${colorWheelHue}, ${colorWheelSat}%, ${lightness}%)`;
            ctx.fillRect(barX, barY + i, barWidth, 1);
        }
        
        // Draw lightness bar border
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1;
        ctx.strokeRect(barX, barY, barWidth, barHeight);

        // Draw vertical 'Lightness' label to the left of the slider
            ctx.save();
            ctx.font = 'bold 14px verdana, sans-serif';
            ctx.fillStyle = 'hsl(0, 0%, 0%)';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            // Position: left of the slider, vertically centered
            const labelX = barX + 11; // 11px left of slider
            const labelY = barY + barHeight / 2;
            ctx.translate(labelX, labelY);
            ctx.rotate(-Math.PI / 2); // 90 degrees counterclockwise
            ctx.fillText('Lightness', 0, 0);
            ctx.restore();
        
        // Draw marker for current hue/saturation position
        const markerAngle = colorWheelHue * Math.PI / 180;
        const markerDist = (colorWheelSat / 100) * radius;
        // Use the actual wheel center position
        const markerX = actualWheelCenterX + markerDist * Math.cos(markerAngle);
        const markerY = actualWheelCenterY + markerDist * Math.sin(markerAngle);
        
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(markerX, markerY, 8, 0, Math.PI * 2);
        ctx.stroke();
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(markerX, markerY, 8, 0, Math.PI * 2);
        ctx.stroke();
        
        // Draw lightness marker
        const lightY = barY + (100 - colorWheelLight + 5) / 95 * barHeight;
        ctx.fillStyle = 'white';
        ctx.fillRect(barX - 3, lightY - 2, barWidth + 6, 4);
        ctx.strokeStyle = 'black';
        ctx.strokeRect(barX - 3, lightY - 2, barWidth + 6, 4);
        
        // Draw sensitivity slider (horizontal bar at top)
        const velBarX = centerX - radius + 14;
        const velBarY = centerY + radius + 20;
        const velBarWidth = radius * 2;
        const velBarHeight = 20;
        
        // Draw velocity bar gradient (gray scale, brighter means more sensitive)
        for (let i = 0; i <= velBarWidth; i++) {
            const brightness = 30 + (i / velBarWidth) * 40; // darker to lighter
            ctx.fillStyle = `hsl(170, 70%, ${brightness}%)`;
            ctx.fillRect(velBarX + i, velBarY, 1, velBarHeight);
        }
        
        // Draw velocity bar border
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1;
        ctx.strokeRect(velBarX, velBarY, velBarWidth, velBarHeight);
        
        // Draw velocity marker
        const velX = velBarX + (colorWheelVelMap / 500) * velBarWidth;
        ctx.fillStyle = 'white';
        ctx.fillRect(velX - 2, velBarY - 3, 4, velBarHeight + 6);
        ctx.strokeStyle = 'black';
        ctx.strokeRect(velX - 2, velBarY - 3, 4, velBarHeight + 6);
        
        // Draw velocity label
        ctx.fillStyle = 'black';
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Sensitivity', velBarX + velBarWidth / 2, velBarY + velBarHeight/2);
        
        // Draw persistence slider (horizontal bar below sensitivity)
        const persBarX = centerX - radius + 14;
        const persBarY = centerY + radius + 57;
        const persBarWidth = radius * 2;
        const persBarHeight = 20;
        
        // Draw persistence bar gradient (gray scale)
        for (let i = 0; i <= persBarWidth; i++) {
            const alpha = (i / persBarWidth) * 30; // 0-30 range
            const brightness = 30 + (i / persBarWidth) * 40; // darker to lighter
            ctx.fillStyle = `hsl(200, 70%, ${brightness}%)`;
            ctx.fillRect(persBarX + i, persBarY, 1, persBarHeight);
        }
        
        // Draw persistence bar border
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1;
        ctx.strokeRect(persBarX, persBarY, persBarWidth, persBarHeight);
        
        // Draw persistence marker
        const persX = persBarX + (colorWheelPersistence / 30) * persBarWidth;
        ctx.fillStyle = 'white';
        ctx.fillRect(persX - 2, persBarY - 3, 4, persBarHeight + 6);
        ctx.strokeStyle = 'black';
        ctx.strokeRect(persX - 2, persBarY - 3, 4, persBarHeight + 6);
        
        // Draw persistence label
        ctx.fillStyle = 'black';
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Persistence', persBarX + persBarWidth / 2, persBarY + persBarHeight/2);
        
        // Restore context state
        ctx.restore();
    }
    
    // Animate color wheel opacity
    function animateColorWheelOpacity() {
        if (!colorWheelAnimating) return;
        
        const fadeInSpeed = 0.1;
        const fadeOutSpeed = 0.3; // Twice as fast
        const fadeSpeed = colorWheelTargetOpacity > colorWheelOpacity ? fadeInSpeed : fadeOutSpeed;
        const diff = colorWheelTargetOpacity - colorWheelOpacity;
        
        if (Math.abs(diff) < 0.01) {
            colorWheelOpacity = colorWheelTargetOpacity;
            colorWheelAnimating = false;
            if (colorWheelOpacity <= 0) {
                colorWheelVisible = false;
            }
        } else {
            colorWheelOpacity += diff * fadeSpeed;
        }
    }
    
    function animatePhysicsMenuOpacity() {
        if (!physicsMenuAnimating) return;
        
        const fadeInSpeed = 0.1;
        const fadeOutSpeed = 0.2; // Twice as fast
        const fadeSpeed = physicsMenuTargetOpacity > physicsMenuOpacity ? fadeInSpeed : fadeOutSpeed;
        const diff = physicsMenuTargetOpacity - physicsMenuOpacity;
        
        if (Math.abs(diff) < 0.01) {
            physicsMenuOpacity = physicsMenuTargetOpacity;
            physicsMenuAnimating = false;
            if (physicsMenuOpacity <= 0) {
                physicsMenuVisible = false;
            }
        } else {
            physicsMenuOpacity += diff * fadeSpeed;
        }
    }
    
    function drawPhysicsMenu() {
        if (physicsMenuOpacity <= 0) return;
        
        const ctx = c;
        const w = physicsMenuWidth;
        const h = physicsMenuHeight;
        const centerX = physicsMenuCenterX;
        const centerY = physicsMenuCenterY;
        const checkboxPadding = 8;
        const sliderSpacing = 35;
        
        // Save context state and apply global alpha
        ctx.save();
        ctx.globalAlpha = physicsMenuOpacity;
        
        // Draw menu background, border, and close button
        drawMenuBackground(ctx, centerX, centerY, w, h);
        
        // Draw title
        ctx.fillStyle = 'hsl(0, 0%, 70%)';
        ctx.font = 'bold 20px verdana, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Physics', centerX, centerY - h/2 + 12);
        
        // Starting Y position for first slider
        let currentY = centerY - h/2 + 50;
        
        // Slider dimensions
        const sliderStartX = centerX - w/2 + 35;
        const sliderWidth = w - 50;
        const sliderHeight = 20;
        
        // 1. Repulsion Force slider with checkbox
        const repulsionCheckX = centerX - w/2 + checkboxPadding;
        const repulsionCheckSize = 14;
        
        // Draw checkbox
        ctx.fillStyle = physicsMenuRepulsionOn ? 'hsl(120, 60%, 40%)' : 'hsl(0, 0%, 30%)';
        ctx.fillRect(repulsionCheckX, currentY - repulsionCheckSize/2, repulsionCheckSize, repulsionCheckSize);
        ctx.strokeStyle = 'hsl(0, 0%, 60%)';
        ctx.lineWidth = 1;
        ctx.strokeRect(repulsionCheckX, currentY - repulsionCheckSize/2, repulsionCheckSize, repulsionCheckSize);
        
        if (physicsMenuRepulsionOn) {
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(repulsionCheckX + 3, currentY);
            ctx.lineTo(repulsionCheckX + 6, currentY + 4);
            ctx.lineTo(repulsionCheckX + 11, currentY - 4);
            ctx.stroke();
        }
        
        // Draw slider (horizontal bar style like color wheel)
        // Draw gradient bar
        for (let i = 0; i <= sliderWidth; i++) {
            const brightness = 30 + (i / sliderWidth) * 40;
            ctx.fillStyle = `hsl(30, 70%, ${brightness}%)`;
            ctx.fillRect(sliderStartX + i, currentY - sliderHeight/2, 1, sliderHeight);
        }
        
        // Draw border
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1;
        ctx.strokeRect(sliderStartX, currentY - sliderHeight/2, sliderWidth, sliderHeight);
        
        // Draw marker
        const repulsionPercent = (physicsMenuRepulsionForce - 1) / (20 - 1);
        const repulsionHandleX = sliderStartX + repulsionPercent * sliderWidth;
        ctx.fillStyle = 'white';
        ctx.fillRect(repulsionHandleX - 2, currentY - sliderHeight/2 - 3, 4, sliderHeight + 6);
        ctx.strokeStyle = 'black';
        ctx.strokeRect(repulsionHandleX - 2, currentY - sliderHeight/2 - 3, 4, sliderHeight + 6);
        
        // Draw label inside slider (after gradient so it's on top)
        ctx.fillStyle = 'black';
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Repulsion Force', sliderStartX + sliderWidth/2, currentY);
        
        currentY += sliderSpacing;
        
        // 2. Repulsion Distance slider
        // Draw gradient bar
        for (let i = 0; i <= sliderWidth; i++) {
            const brightness = 30 + (i / sliderWidth) * 40;
            ctx.fillStyle = `hsl(45, 70%, ${brightness}%)`;
            ctx.fillRect(sliderStartX + i, currentY - sliderHeight/2, 1, sliderHeight);
        }
        
        // Draw border
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1;
        ctx.strokeRect(sliderStartX, currentY - sliderHeight/2, sliderWidth, sliderHeight);
        
        // Draw marker
        const repulsionDistPercent = physicsMenuRepulsionDist / 10;
        const repulsionDistHandleX = sliderStartX + repulsionDistPercent * sliderWidth;
        ctx.fillStyle = 'white';
        ctx.fillRect(repulsionDistHandleX - 2, currentY - sliderHeight/2 - 3, 4, sliderHeight + 6);
        ctx.strokeStyle = 'black';
        ctx.strokeRect(repulsionDistHandleX - 2, currentY - sliderHeight/2 - 3, 4, sliderHeight + 6);
        
        // Draw label inside slider (after gradient so it's on top)
        ctx.fillStyle = 'black';
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Repulsion Distance', sliderStartX + sliderWidth/2, currentY);
        
        currentY += sliderSpacing;
        
        // 3. Ball Rest (Restitution) slider with checkbox
        const bounceCheckX = centerX - w/2 + checkboxPadding;
        
        // Draw checkbox
        ctx.fillStyle = physicsMenuBounceOn ? 'hsl(120, 60%, 40%)' : 'hsl(0, 0%, 30%)';
        ctx.fillRect(bounceCheckX, currentY - repulsionCheckSize/2, repulsionCheckSize, repulsionCheckSize);
        ctx.strokeStyle = 'hsl(0, 0%, 60%)';
        ctx.lineWidth = 1;
        ctx.strokeRect(bounceCheckX, currentY - repulsionCheckSize/2, repulsionCheckSize, repulsionCheckSize);
        
        if (physicsMenuBounceOn) {
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(bounceCheckX + 3, currentY);
            ctx.lineTo(bounceCheckX + 6, currentY + 4);
            ctx.lineTo(bounceCheckX + 11, currentY - 4);
            ctx.stroke();
        }
        
        // Draw slider (horizontal bar style)
        // Draw gradient bar
        for (let i = 0; i <= sliderWidth; i++) {
            const brightness = 30 + (i / sliderWidth) * 40;
            ctx.fillStyle = `hsl(200, 70%, ${brightness}%)`;
            ctx.fillRect(sliderStartX + i, currentY - sliderHeight/2, 1, sliderHeight);
        }
        
        // Draw border
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1;
        ctx.strokeRect(sliderStartX, currentY - sliderHeight/2, sliderWidth, sliderHeight);
        
        // Draw marker
        const ballRestPercent = physicsMenuBallRest / 100;
        const ballRestHandleX = sliderStartX + ballRestPercent * sliderWidth;
        ctx.fillStyle = 'white';
        ctx.fillRect(ballRestHandleX - 2, currentY - sliderHeight/2 - 3, 4, sliderHeight + 6);
        ctx.strokeStyle = 'black';
        ctx.strokeRect(ballRestHandleX - 2, currentY - sliderHeight/2 - 3, 4, sliderHeight + 6);
        
        // Draw label inside slider (after gradient so it's on top)
        ctx.fillStyle = 'black';
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Restitution', sliderStartX + sliderWidth/2, currentY);
        
        currentY += sliderSpacing;
        
        // 4. Time slider
        // Draw gradient bar
        for (let i = 0; i <= sliderWidth; i++) {
            const brightness = 30 + (i / sliderWidth) * 40;
            ctx.fillStyle = `hsl(170, 70%, ${brightness}%)`;
            ctx.fillRect(sliderStartX + i, currentY - sliderHeight/2, 1, sliderHeight);
        }
        
        // Draw border
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1;
        ctx.strokeRect(sliderStartX, currentY - sliderHeight/2, sliderWidth, sliderHeight);
        
        // Draw marker
        const timePercent = (physicsMenuTime - 500) / (1000 - 500);
        const timeHandleX = sliderStartX + timePercent * sliderWidth;
        ctx.fillStyle = 'white';
        ctx.fillRect(timeHandleX - 2, currentY - sliderHeight/2 - 3, 4, sliderHeight + 6);
        ctx.strokeStyle = 'black';
        ctx.strokeRect(timeHandleX - 2, currentY - sliderHeight/2 - 3, 4, sliderHeight + 6);
        
        // Draw label inside slider (after gradient so it's on top)
        ctx.fillStyle = 'black';
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Time', sliderStartX + sliderWidth/2, currentY);
        
        currentY += sliderSpacing;
        
        // 5. Speed Limit slider
        // Draw gradient bar
        for (let i = 0; i <= sliderWidth; i++) {
            const brightness = 30 + (i / sliderWidth) * 40;
            ctx.fillStyle = `hsl(150, 70%, ${brightness}%)`;
            ctx.fillRect(sliderStartX + i, currentY - sliderHeight/2, 1, sliderHeight);
        }
        
        // Draw border
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1;
        ctx.strokeRect(sliderStartX, currentY - sliderHeight/2, sliderWidth, sliderHeight);
        
        // Draw marker
        const speedPercent = (physicsMenuSpeed - 1) / (50 - 1);
        const speedHandleX = sliderStartX + speedPercent * sliderWidth;
        ctx.fillStyle = 'white';
        ctx.fillRect(speedHandleX - 2, currentY - sliderHeight/2 - 3, 4, sliderHeight + 6);
        ctx.strokeStyle = 'black';
        ctx.strokeRect(speedHandleX - 2, currentY - sliderHeight/2 - 3, 4, sliderHeight + 6);
        
        // Draw label inside slider (after gradient so it's on top)
        ctx.fillStyle = 'black';
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Speed Limit', sliderStartX + sliderWidth/2, currentY);
        
        currentY += sliderSpacing;
        
        // 6. Substeps slider (half width, 4 detents) with FPS toggle
        const substepsSliderWidth = sliderWidth / 2;
        
        // Draw gradient bar (using cyan/teal color like Time slider)
        for (let i = 0; i <= substepsSliderWidth; i++) {
            const brightness = 30 + (i / substepsSliderWidth) * 40;
            ctx.fillStyle = `hsl(180, 70%, ${brightness}%)`;
            ctx.fillRect(sliderStartX + i, currentY - sliderHeight/2, 1, sliderHeight);
        }
        
        // Draw border
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1;
        ctx.strokeRect(sliderStartX, currentY - sliderHeight/2, substepsSliderWidth, sliderHeight);
        
        // Draw marker (handle)
        const substepsPercent = (physicsMenuSubsteps - 1) / 3; // 0 to 1 for values 1-4
        const substepsHandleX = sliderStartX + substepsPercent * substepsSliderWidth;
        ctx.fillStyle = 'white';
        ctx.fillRect(substepsHandleX - 2, currentY - sliderHeight/2 - 3, 4, sliderHeight + 6);
        ctx.strokeStyle = 'black';
        ctx.strokeRect(substepsHandleX - 2, currentY - sliderHeight/2 - 3, 4, sliderHeight + 6);
        
        // Draw label inside slider (after gradient so it's on top)
        ctx.fillStyle = 'black';
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Substeps', sliderStartX + substepsSliderWidth/2, currentY);
        
        // Draw value display to the right of slider
        ctx.fillStyle = 'hsl(0, 0%, 80%)';
        ctx.font = '12px monospace';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        ctx.fillText(physicsMenuSubsteps.toString(), sliderStartX + substepsSliderWidth + 10, currentY);
        
        // Draw FPS toggle button (film strip style) to the right
        const fpsButtonX = sliderStartX + substepsSliderWidth + 40;
        const fpsButtonY = currentY;
        const fpsButtonWidth = 50;
        const fpsButtonHeight = 28;
        const sprocketSize = 5;
        const sprocketSpacing = 10;
        
        // Main film strip background (black when on, dark gray when off)
        ctx.fillStyle = physicsMenuFpsOn ? 'hsl(0, 0%, 8%)' : 'hsl(0, 0%, 15%)';
        ctx.fillRect(fpsButtonX, fpsButtonY - fpsButtonHeight/2, fpsButtonWidth, fpsButtonHeight);
        
        // Draw sprocket holes 
        ctx.fillStyle = physicsMenuFpsOn ? 'hsl(170, 75%, 70%)' : 'hsl(0, 0%, 0%)';
        for (let i = 0; i < 3; i++) {
            const sprocketY = fpsButtonY - fpsButtonHeight/2 + 4 + (i * sprocketSpacing);
            ctx.beginPath();
            ctx.fillRect(fpsButtonX + 5 - sprocketSize/2, sprocketY - sprocketSize/2, sprocketSize, sprocketSize);  
            ctx.fillRect(fpsButtonX + fpsButtonWidth - 5 - sprocketSize/2, sprocketY - sprocketSize/2, sprocketSize, sprocketSize);
        }
        
        // Draw FPS text (brighter when on)
        ctx.fillStyle = physicsMenuFpsOn ? 'hsl(170, 75%, 70%)' : 'hsl(0, 0%, 50%)';
        ctx.font = 'bold 14px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('FPS', fpsButtonX + fpsButtonWidth/2, fpsButtonY + 1);
        
        // Restore context state
        ctx.restore();
    }
    
    // Animate gravity menu opacity
    function animateGravityMenuOpacity() {
        if (!gravityMenuAnimating) return;
        
        const fadeInSpeed = 0.1;
        const fadeOutSpeed = 0.3;
        const fadeSpeed = gravityMenuTargetOpacity > gravityMenuOpacity ? fadeInSpeed : fadeOutSpeed;
        const diff = gravityMenuTargetOpacity - gravityMenuOpacity;
        
        if (Math.abs(diff) < 0.01) {
            gravityMenuOpacity = gravityMenuTargetOpacity;
            gravityMenuAnimating = false;
            if (gravityMenuOpacity <= 0) {
                gravityMenuVisible = false;
            }
        } else {
            gravityMenuOpacity += diff * fadeSpeed;
        }
    }
    
    function animateParticlesMenuOpacity() {
        if (!particlesMenuAnimating) return;
        
        const fadeInSpeed = 0.1;
        const fadeOutSpeed = 0.3;
        const fadeSpeed = particlesMenuTargetOpacity > particlesMenuOpacity ? fadeInSpeed : fadeOutSpeed;
        const diff = particlesMenuTargetOpacity - particlesMenuOpacity;
        
        if (Math.abs(diff) < 0.01) {
            particlesMenuOpacity = particlesMenuTargetOpacity;
            particlesMenuAnimating = false;
            if (particlesMenuOpacity <= 0) {
                particlesMenuVisible = false;
            }
        } else {
            particlesMenuOpacity += diff * fadeSpeed;
        }
    }
    
    // Animate walls menu opacity
    function animateWallsMenuOpacity() {
        if (!wallsMenuAnimating) return;
        
        const fadeInSpeed = 0.1;
        const fadeOutSpeed = 0.2;
        const fadeSpeed = wallsMenuTargetOpacity > wallsMenuOpacity ? fadeInSpeed : fadeOutSpeed;
        const diff = wallsMenuTargetOpacity - wallsMenuOpacity;
        
        if (Math.abs(diff) < 0.01) {
            wallsMenuOpacity = wallsMenuTargetOpacity;
            wallsMenuAnimating = false;
            if (wallsMenuOpacity <= 0) {
                wallsMenuVisible = false;
            }
        } else {
            wallsMenuOpacity += diff * fadeSpeed;
        }
    }
    
    function drawWallsMenu() {
        if (wallsMenuOpacity <= 0) return;
        
        const ctx = c;
        const w = wallsMenuWidth;
        const h = wallsMenuHeight;
        const centerX = wallsMenuCenterX;
        const centerY = wallsMenuCenterY;
        
        // Save context state and apply global alpha
        ctx.save();
        ctx.globalAlpha = wallsMenuOpacity;
        
        // Draw menu background, border, and close button
        drawMenuBackground(ctx, centerX, centerY, w, h, {
            backgroundColor: 'rgba(20, 20, 20, 0.85)',
            bottomOffset: 25
        });
        
        // Draw title
        ctx.fillStyle = 'hsl(0, 0%, 70%)';
        ctx.font = 'bold 20px verdana, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Walls', centerX, centerY - h/2 + 12);
        
        // Draw scale representation of walls and corners (twice as tall)
        const wallsAreaLeft = centerX - w/2 + 30;
        const wallsAreaRight = centerX + w/2 - 30;
        const wallsAreaTop = centerY - h/2 + 59;
        const wallsAreaBottom = centerY - 11; // Leave room for slider below
        const wallsAreaWidth = wallsAreaRight - wallsAreaLeft;
        const wallsAreaHeight = (wallsAreaBottom - wallsAreaTop) * 2; // Make twice as tall
        
        // Adjust bottom to accommodate the taller representation
        const actualWallsAreaBottom = wallsAreaTop + wallsAreaHeight;
        
        // Define checkbox size
        const checkboxSize = 18;
        
        // Calculate corner behavior based on slider value (simple approach)
        const currentCornerRad = wallsMenuCornerRadius;
        let displayRadius, leftCornerX, rightCornerX;
        
        if (currentCornerRad <= 100) {
            displayRadius = (currentCornerRad / 100) * (wallsAreaHeight / 2);
            leftCornerX = wallsAreaLeft;
            rightCornerX = wallsAreaRight;
        } else {
            displayRadius = wallsAreaHeight / 2;
            const closureRatio = (currentCornerRad - 100) / 50;
            const stageOneVisualLeft = wallsAreaLeft + displayRadius;
            const stageOneVisualRight = wallsAreaRight - displayRadius;
            const maxInwardMovement = (stageOneVisualRight - stageOneVisualLeft) / 2;
            const inwardMovement = closureRatio * maxInwardMovement;
            leftCornerX = stageOneVisualLeft + inwardMovement;
            rightCornerX = stageOneVisualRight - inwardMovement;
        }
        
        // Calculate checkbox positions (keep on correct side of walls)
        let actualLeftWallX, actualRightWallX;
        if (currentCornerRad <= 100) {
            // Stage 1: Walls are at the corner positions
            actualLeftWallX = leftCornerX;
            actualRightWallX = rightCornerX;
        } else {
            // Stage 2: Walls are at the outer edges of the circles
            actualLeftWallX = leftCornerX - displayRadius;
            actualRightWallX = rightCornerX + displayRadius;
        }
        
        const leftCheckX = actualLeftWallX - checkboxSize - 10;
        const rightCheckX = actualRightWallX + 10;
        const checkboxY = (wallsAreaTop + actualWallsAreaBottom) / 2 - checkboxSize/2;
        
        // Left wall
        if (wallsMenuLeftWall) {
            ctx.strokeStyle = `hsl(0, 70%, 40%)`;
            ctx.lineWidth = 10;
        } else {
            ctx.strokeStyle = 'hsl(0, 0%, 30%)';
            ctx.lineWidth = 2;
        }
        const leftWallY1 = wallsAreaTop + displayRadius;
        const leftWallY2 = actualWallsAreaBottom - displayRadius;
        ctx.beginPath();
        ctx.moveTo(leftCornerX, leftWallY1);
        ctx.lineTo(leftCornerX, leftWallY2);
        ctx.stroke();
        
        // Left wall checkbox
        ctx.fillStyle = wallsMenuLeftWall ? 'hsl(120, 60%, 40%)' : 'hsl(0, 0%, 30%)';
        ctx.beginPath();
        ctx.arc(leftCheckX + checkboxSize/2, checkboxY + checkboxSize/2, checkboxSize/2, 0, 2 * Math.PI);
        ctx.fill();
        
        // Right wall
        if (wallsMenuRightWall) {
            ctx.strokeStyle = `hsl(0, 70%, 40%)`;
            ctx.lineWidth = 10;
        } else {
            ctx.strokeStyle = 'hsl(0, 0%, 30%)';
            ctx.lineWidth = 2;
        }
        const rightWallY1 = wallsAreaTop + displayRadius;
        const rightWallY2 = actualWallsAreaBottom - displayRadius;
        ctx.beginPath();
        ctx.moveTo(rightCornerX, rightWallY1);
        ctx.lineTo(rightCornerX, rightWallY2);
        ctx.stroke();
        
        // Right wall checkbox
        ctx.fillStyle = wallsMenuRightWall ? 'hsl(120, 60%, 40%)' : 'hsl(0, 0%, 30%)';
        ctx.beginPath();
        ctx.arc(rightCheckX + checkboxSize/2, checkboxY + checkboxSize/2, checkboxSize/2, 0, 2 * Math.PI);
        ctx.fill();
        
        // Top wall (ceiling) - horizontal line connecting the corners
        if (wallsMenuCeiling) {
            ctx.strokeStyle = `hsl(0, 70%, 40%)`;
            ctx.lineWidth = 10;
            let ceilingX1, ceilingX2;
            if (currentCornerRad <= 100) {
                // Stage 1: Connect to corner arcs
                ceilingX1 = leftCornerX + displayRadius;
                ceilingX2 = rightCornerX - displayRadius;
            } else {
                // Stage 2: Connect to half circles on sides
                ceilingX1 = leftCornerX;
                ceilingX2 = rightCornerX;
            }
            if (ceilingX2 > ceilingX1) { // Only draw if corners don't overlap
                ctx.beginPath();
                ctx.moveTo(ceilingX1, wallsAreaTop);
                ctx.lineTo(ceilingX2, wallsAreaTop);
                ctx.stroke();
            }
        } 
        
        // Ceiling checkbox
        const ceilingCheckX = wallsAreaLeft + (wallsAreaWidth / 2) - checkboxSize/2;
        const ceilingCheckY = wallsAreaTop - checkboxSize - 10;
        ctx.fillStyle = wallsMenuCeiling ? 'hsl(120, 60%, 40%)' : 'hsl(0, 0%, 30%)';
        ctx.beginPath();
        ctx.arc(ceilingCheckX + checkboxSize/2, ceilingCheckY + checkboxSize/2, checkboxSize/2, 0, 2 * Math.PI);
        ctx.fill();
        
        // Bottom wall (floor) - horizontal line connecting the corners
        if (wallsMenuFloor) {
            ctx.strokeStyle = `hsl(0, 70%, 40%)`;
            ctx.lineWidth = 10;
            let floorX1, floorX2;
            if (currentCornerRad <= 100) {
                // Stage 1: Connect to corner arcs
                floorX1 = leftCornerX + displayRadius;
                floorX2 = rightCornerX - displayRadius;
            } else {
                // Stage 2: Connect to half circles on sides
                floorX1 = leftCornerX;
                floorX2 = rightCornerX;
            }
            if (floorX2 > floorX1) { // Only draw if corners don't overlap
                ctx.beginPath();
                ctx.moveTo(floorX1, actualWallsAreaBottom);
                ctx.lineTo(floorX2, actualWallsAreaBottom);
                ctx.stroke();
            }
        } 
        
        // Floor checkbox
        const floorCheckX = wallsAreaLeft + (wallsAreaWidth / 2) - checkboxSize/2;
        const floorCheckY = actualWallsAreaBottom + 10;
        ctx.fillStyle = wallsMenuFloor ? 'hsl(120, 60%, 40%)' : 'hsl(0, 0%, 30%)';
        ctx.beginPath();
        ctx.arc(floorCheckX + checkboxSize/2, floorCheckY + checkboxSize/2, checkboxSize/2, 0, 2 * Math.PI);
        ctx.fill();
        
        // Draw corners based on slider position
        if (displayRadius > 0) {
            ctx.strokeStyle = `hsl(0, 70%, 40%)`;
            ctx.lineWidth = 10;
            
            if (currentCornerRad <= 100) {
                // Stage 1 (0-100): Draw arcs in each corner of the rectangle
                // Top-left corner arc (only if both left wall and ceiling are enabled)
                if (wallsMenuLeftWall && wallsMenuCeiling) {
                    ctx.beginPath();
                    ctx.arc(leftCornerX + displayRadius, wallsAreaTop + displayRadius, displayRadius, Math.PI, Math.PI * 3/2);
                    ctx.stroke();
                }
                
                // Top-right corner arc (only if both right wall and ceiling are enabled)
                if (wallsMenuRightWall && wallsMenuCeiling) {
                    ctx.beginPath();
                    ctx.arc(rightCornerX - displayRadius, wallsAreaTop + displayRadius, displayRadius, Math.PI * 3/2, 0);
                    ctx.stroke();
                }
                
                // Bottom-left corner arc (only if both left wall and floor are enabled)
                if (wallsMenuLeftWall && wallsMenuFloor) {
                    ctx.beginPath();
                    ctx.arc(leftCornerX + displayRadius, actualWallsAreaBottom - displayRadius, displayRadius, Math.PI/2, Math.PI);
                    ctx.stroke();
                }
                
                // Bottom-right corner arc (only if both right wall and floor are enabled)
                if (wallsMenuRightWall && wallsMenuFloor) {
                    ctx.beginPath();
                    ctx.arc(rightCornerX - displayRadius, actualWallsAreaBottom - displayRadius, displayRadius, 0, Math.PI/2);
                    ctx.stroke();
                }
                
            } else {
                // Stage 2 (100-150): Draw half circles on the sides only
                const wallsAreaCenterY = wallsAreaTop + (wallsAreaHeight / 2);
                // Left side half circle (only if left wall is enabled)
                if (wallsMenuLeftWall) {
                    ctx.beginPath();
                    ctx.arc(leftCornerX, wallsAreaCenterY, displayRadius, Math.PI/2, Math.PI * 3/2);
                    ctx.stroke();
                }
                
                // Right side half circle (only if right wall is enabled)
                if (wallsMenuRightWall) {
                    ctx.beginPath();
                    ctx.arc(rightCornerX, wallsAreaCenterY, displayRadius, Math.PI * 3/2, Math.PI/2);
                    ctx.stroke();
                }
            }
        }
        
        // Draw corner radius slider (positioned with simple coordinates for consistency)
        const sliderY = centerY + h/2 - 22; // Moved down by 9 pixels
        const sliderLeft = centerX - w/2 + 40;
        const sliderWidth = w - 80;
        const sliderHeight = 30; // 50% taller than original 20
        
        // Draw slider track gradient
        for (let i = 0; i <= sliderWidth; i++) {
            const brightness = 30 + (i / sliderWidth) * 40;
            ctx.fillStyle = `hsl(30, 70%, ${brightness}%)`;
            
            ctx.fillRect(sliderLeft + i, sliderY - sliderHeight/2, 1, sliderHeight);
        }
        
        // Draw slider border
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1;
        ctx.strokeRect(sliderLeft, sliderY - sliderHeight/2, sliderWidth, sliderHeight);
        
        // Draw slider handle
        const radiusPercent = 1 - (wallsMenuCornerRadius / 150); // Reversed to match input direction
        const handleX = sliderLeft + radiusPercent * sliderWidth;
        ctx.fillStyle = 'white';
        ctx.fillRect(handleX - 2, sliderY - sliderHeight/2 - 3, 4, sliderHeight + 6);
        ctx.strokeStyle = 'black';
        ctx.strokeRect(handleX - 2, sliderY - sliderHeight/2 - 3, 4, sliderHeight + 6);
        
        // Draw slider label
        ctx.fillStyle = 'black';
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Play Area', sliderLeft + sliderWidth/2, sliderY);
        
        // Restore context state
        ctx.restore();
    }
    
    // Handle walls menu interactions
    function handleWallsMenuInteraction(canvasX, canvasY) {
        if (!wallsMenuVisible) return false;
        
        const w = wallsMenuWidth;
        const h = wallsMenuHeight;
        const centerX = wallsMenuCenterX;
        const centerY = wallsMenuCenterY;
        
        const sliderY = centerY + h/2 - 22;
        const sliderLeft = centerX - w/2 + 40;
        const sliderWidth = w - 80;
        const sliderHeight = 30;
        
        // If already dragging the slider, update it regardless of mouse position
        if (wallsMenuDragging && wallsMenuDraggingControl === 'cornerRadius') {
            const percent = Math.max(0, Math.min(1, 1 - (canvasX - sliderLeft) / sliderWidth)); // Reversed direction
            wallsMenuCornerRadius = percent * 150;
            cornerRad = wallsMenuCornerRadius;
            updateCornerGeometry();
            return 'slider';
        }
        
        // Check if click is within walls menu bounds - skip if already dragging
        if (!wallsMenuDragging) {
            if (canvasX < centerX - w/2 || canvasX > centerX + w/2 ||
                canvasY < centerY - h/2 || canvasY > centerY + h/2) {
                return false;
            }
        }
        
        // Check corner radius slider FIRST (before any complex calculations)
        if (canvasX >= sliderLeft && canvasX <= sliderLeft + sliderWidth &&
            canvasY >= sliderY - sliderHeight/2 && canvasY <= sliderY + sliderHeight/2) {
            wallsMenuDraggingControl = 'cornerRadius';
            const percent = 1 - (canvasX - sliderLeft) / sliderWidth; // Reversed direction
            wallsMenuCornerRadius = percent * 150;
            cornerRad = wallsMenuCornerRadius; // Update global variable
            
            // Update corner geometry with the new radius/position values
            updateCornerGeometry();
            
            return 'slider';
        }
        
        // Check close button - only when not dragging
        if (!wallsMenuDragging) {
            const closeButtonX = centerX - w/2 + 12;
            const closeButtonY = centerY - h/2 + 12;
            const closeButtonRadius = 12;
            const closeDistX = canvasX - closeButtonX;
            const closeDistY = canvasY - closeButtonY;
            if (Math.sqrt(closeDistX * closeDistX + closeDistY * closeDistY) < closeButtonRadius) {
                wallsMenuTargetOpacity = 0;
                wallsMenuAnimating = true;
                return 'close';
            }
        }
        
        // Define walls area for checkbox detection (using taller representation)
        const wallsAreaLeft = centerX - w/2 + 30;
        const wallsAreaRight = centerX + w/2 - 30;
        const wallsAreaTop = centerY - h/2 + 59;
        const wallsAreaBottom = centerY - 11;
        const wallsAreaHeight = (wallsAreaBottom - wallsAreaTop) * 2; // Make twice as tall
        const actualWallsAreaBottom = wallsAreaTop + wallsAreaHeight;
        const checkboxSize = 18;
        
        // Calculate corner behavior based on slider value (same as drawing)
        const currentCornerRad = wallsMenuCornerRadius;
        let displayRadius, leftCornerX, rightCornerX;
        
        if (currentCornerRad <= 100) {
            displayRadius = (currentCornerRad / 100) * (wallsAreaHeight / 2);
            leftCornerX = wallsAreaLeft;
            rightCornerX = wallsAreaRight;
        } else {
            displayRadius = wallsAreaHeight / 2;
            const closureRatio = (currentCornerRad - 100) / 50;
            const stageOneVisualLeft = wallsAreaLeft + displayRadius;
            const stageOneVisualRight = wallsAreaRight - displayRadius;
            const maxInwardMovement = (stageOneVisualRight - stageOneVisualLeft) / 2;
            const inwardMovement = closureRatio * maxInwardMovement;
            leftCornerX = stageOneVisualLeft + inwardMovement;
            rightCornerX = stageOneVisualRight - inwardMovement;
        }
        
        // Check wall checkboxes (using same positioning logic as drawing)
        let actualLeftWallX, actualRightWallX;
        if (currentCornerRad <= 100) {
            // Stage 1: Walls are at the corner positions
            actualLeftWallX = leftCornerX;
            actualRightWallX = rightCornerX;
        } else {
            // Stage 2: Walls are at the outer edges of the circles
            actualLeftWallX = leftCornerX - displayRadius;
            actualRightWallX = rightCornerX + displayRadius;
        }
        
        const leftCheckX = actualLeftWallX - checkboxSize - 10;
        const rightCheckX = actualRightWallX + 10;
        const checkboxY = (wallsAreaTop + actualWallsAreaBottom) / 2 - checkboxSize/2;
        
        // Left wall checkbox
        if (canvasX >= leftCheckX && canvasX <= leftCheckX + checkboxSize &&
            canvasY >= checkboxY && canvasY <= checkboxY + checkboxSize) {
            wallsMenuLeftWall = !wallsMenuLeftWall;
            doLeftWall = wallsMenuLeftWall;
            return 'checkbox';
        }
        
        // Right wall checkbox
        if (canvasX >= rightCheckX && canvasX <= rightCheckX + checkboxSize &&
            canvasY >= checkboxY && canvasY <= checkboxY + checkboxSize) {
            wallsMenuRightWall = !wallsMenuRightWall;
            doRightWall = wallsMenuRightWall;
            return 'checkbox';
        }
        
        // Ceiling checkbox
        const ceilingCheckX = (wallsAreaLeft + wallsAreaRight) / 2 - checkboxSize/2;
        const ceilingCheckY = wallsAreaTop - checkboxSize - 10;
        if (canvasX >= ceilingCheckX && canvasX <= ceilingCheckX + checkboxSize &&
            canvasY >= ceilingCheckY && canvasY <= ceilingCheckY + checkboxSize) {
            wallsMenuCeiling = !wallsMenuCeiling;
            doCeiling = wallsMenuCeiling;
            return 'checkbox';
        }
        
        // Floor checkbox
        const floorCheckX = (wallsAreaLeft + wallsAreaRight) / 2 - checkboxSize/2;
        const floorCheckY = actualWallsAreaBottom + 10;
        if (canvasX >= floorCheckX && canvasX <= floorCheckX + checkboxSize &&
            canvasY >= floorCheckY && canvasY <= floorCheckY + checkboxSize) {
            wallsMenuFloor = !wallsMenuFloor;
            doFloor = wallsMenuFloor;
            return 'checkbox';
        }
        
        return 'drag';
    }
    
    function animateRespawnMenuOpacity() {
        if (!respawnMenuAnimating) return;
        
        const fadeInSpeed = 0.1;
        const fadeOutSpeed = 0.2;
        const fadeSpeed = respawnMenuTargetOpacity > respawnMenuOpacity ? fadeInSpeed : fadeOutSpeed;
        const diff = respawnMenuTargetOpacity - respawnMenuOpacity;
        
        if (Math.abs(diff) < 0.01) {
            respawnMenuOpacity = respawnMenuTargetOpacity;
            respawnMenuAnimating = false;
            if (respawnMenuOpacity <= 0) {
                respawnMenuVisible = false;
            }
        } else {
            respawnMenuOpacity += diff * fadeSpeed;
        }
    }
    
    function drawRespawnMenu() {
        if (respawnMenuOpacity <= 0) return;
        
        const ctx = c;
        const w = respawnMenuWidth;
        const h = respawnMenuHeight;
        const centerX = respawnMenuCenterX;
        const centerY = respawnMenuCenterY;
        const checkboxPadding = 8;
        const checkboxSize = 16;
        
        // Save context state and apply global alpha
        ctx.save();
        ctx.globalAlpha = respawnMenuOpacity;
        
        // Draw menu background, border, and close button
        drawMenuBackground(ctx, centerX, centerY, w, h, {
            titleOffsetY: -h/2 + 30
        });
        
        // Draw title
        ctx.fillStyle = 'hsl(0, 0%, 70%)';
        ctx.font = 'bold 20px verdana, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('ReSpawn', centerX, centerY - h/2 + 12);
        
        let currentY = centerY - h/2 + 50;
        
        // 1. One Shot checkbox
        const oneShotCheckX = centerX - w/2 + checkboxPadding;
        ctx.strokeStyle = !respawnMenuOneShot ? 'hsl(320, 100%, 50%)' : 'hsl(0, 0%, 60%)';
        ctx.lineWidth = 2;
        ctx.strokeRect(oneShotCheckX, currentY - checkboxSize/2, checkboxSize, checkboxSize);
        if (!respawnMenuOneShot) {
            ctx.strokeStyle = 'hsl(320, 100%, 50%)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(oneShotCheckX + 4, currentY);
            ctx.lineTo(oneShotCheckX + 6, currentY + 4);
            ctx.lineTo(oneShotCheckX + 12, currentY - 4);
            ctx.stroke();
        }
        ctx.fillStyle = 'hsl(0, 0%, 80%)';
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText('Re-spawn', oneShotCheckX + checkboxSize + 10, currentY + 2);

        // Draw red slash through recycle symbol when respawn is unchecked (respawnMenuOneShot is true)
        if (respawnMenuOneShot) {
            ctx.fillStyle = 'hsl(320, 23%, 25%)';
            ctx.font = '40px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(' \u267B', oneShotCheckX + 110, currentY + 2);  // recycle symbol
            
            ctx.strokeStyle = 'hsl(0, 80%, 40%)';  // Red color
            ctx.lineWidth = 4;
            ctx.beginPath();
            // Draw diagonal slash through the recycle symbol
            const symbolX = oneShotCheckX + 110 + 10;  // Center of symbol
            const symbolY = currentY + 2 - 5;  // Center of symbol vertically
            const slashSize = 18;  // Half the diagonal length
            ctx.moveTo(symbolX + 2 * slashSize, symbolY - slashSize);
            ctx.lineTo(symbolX + 0.5 *slashSize, symbolY + 1.2 * slashSize);
            ctx.stroke();
        } else {
            ctx.fillStyle = 'hsl(320, 100%, 70%)';
            ctx.font = '40px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(' \u267B', oneShotCheckX + 110, currentY + 2);  // recycle symbol
        }
        
        currentY += 35;
        
        // 2. Hungry Puck checkbox
        const hungryCheckX = centerX - w/2 + checkboxPadding;
        ctx.strokeStyle = respawnMenuHungryPuck ? 'hsl(320, 100%, 50%)' : 'hsl(0, 0%, 60%)';
        ctx.lineWidth = 2;
        ctx.strokeRect(hungryCheckX, currentY - checkboxSize/2, checkboxSize, checkboxSize);
        if (respawnMenuHungryPuck) {
            ctx.strokeStyle = 'hsl(320, 100%, 50%)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(hungryCheckX + 4, currentY);
            ctx.lineTo(hungryCheckX + 7, currentY + 4);
            ctx.lineTo(hungryCheckX + 12, currentY - 4);
            ctx.stroke();
        }
        ctx.font = 'bold 14px sans-serif';
        ctx.fillStyle = 'hsl(0, 0%, 80%)';
        ctx.textAlign = 'left';
        ctx.fillText('Eaters on/off', hungryCheckX + checkboxSize + 10, currentY + 2);

        var hungruPuckIconX = hungryCheckX + 195;
        var hungruPuckIconY = currentY;
        var hungryRadius = 15;

        // draw hungry puck icon
        // body
        const grd = c.createRadialGradient(
            hungruPuckIconX, 
            hungruPuckIconY, 
            1.2 * hungryRadius, 
            hungruPuckIconX, 
            hungruPuckIconY, 
            1.6 * hungryRadius);
        grd.addColorStop(0.0, `hsla(0, 0%, 0%, 100%)`);
        grd.addColorStop(1.0, `hsla(0, 0%, 0%, 0%)`);
        ctx.fillStyle = grd;
        drawCircle(hungruPuckIconX, hungruPuckIconY, 1.6 * hungryRadius);
        ctx.fill();
        
        if (respawnMenuHungryPuck) {
            // eyes
            ctx.strokeStyle = 'hsl(320, 100%, 80%)';
            ctx.lineWidth = 0.1 * hungryRadius;
            ctx.beginPath();
            ctx.moveTo(hungruPuckIconX + 0.2 * hungryRadius, hungruPuckIconY - 0.2 * hungryRadius);
            ctx.lineTo(hungruPuckIconX + 0.5 * hungryRadius, hungruPuckIconY - 0.3 * hungryRadius);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(hungruPuckIconX - 0.2 * hungryRadius, hungruPuckIconY - 0.2 * hungryRadius);
            ctx.lineTo(hungruPuckIconX - 0.5 * hungryRadius, hungruPuckIconY - 0.3 * hungryRadius);
            ctx.stroke();
            // mouth
            ctx.strokeStyle = 'hsl(320, 50%, 60%)';
            ctx.lineWidth = 0.1 * hungryRadius;
            ctx.beginPath();
            ctx.arc(hungruPuckIconX, hungruPuckIconY, 0.9 * hungryRadius, 0, Math.PI) 
            ctx.stroke();
            // dimples
            ctx.fillStyle = 'hsl(320, 50%, 65%)';
            drawCircle(hungruPuckIconX + 0.9 * hungryRadius, hungruPuckIconY, 0.09 * hungryRadius);
            ctx.fill();
            drawCircle(hungruPuckIconX - 0.9 * hungryRadius, hungruPuckIconY, 0.09 * hungryRadius);
            ctx.fill();   
        } else 
        if (!respawnMenuHungryPuck) {
            // eyes
            ctx.strokeStyle = 'hsl(0, 0%, 40%)';
            ctx.lineWidth = 0.1 * hungryRadius;
            ctx.beginPath();
            ctx.moveTo(hungruPuckIconX + 0.2 * hungryRadius, hungruPuckIconY - 0.2 * hungryRadius);
            ctx.lineTo(hungruPuckIconX + 0.5 * hungryRadius, hungruPuckIconY - 0.3 * hungryRadius);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(hungruPuckIconX - 0.2 * hungryRadius, hungruPuckIconY - 0.2 * hungryRadius);
            ctx.lineTo(hungruPuckIconX - 0.5 * hungryRadius, hungruPuckIconY - 0.3 * hungryRadius);
            ctx.stroke();
            // mouth
            ctx.strokeStyle = 'hsl(0, 0%, 30%)';
            ctx.lineWidth = 0.1 * hungryRadius;
            ctx.beginPath();
            ctx.arc(hungruPuckIconX, hungruPuckIconY, 0.9 * hungryRadius, 0, Math.PI) 
            ctx.stroke();
            // dimples
            ctx.fillStyle = 'hsl(0, 0%, 35%)';
            drawCircle(hungruPuckIconX + 0.9 * hungryRadius, hungruPuckIconY, 0.09 * hungryRadius);
            ctx.fill();
            drawCircle(hungruPuckIconX - 0.9 * hungryRadius, hungruPuckIconY, 0.09 * hungryRadius);
            ctx.fill();   
            ctx.strokeStyle = 'hsl(0, 0%, 20%)';  // Red color
            ctx.lineWidth = 4;
            ctx.beginPath();
            // Draw diagonal slash through the recycle symbol
            const symbolY = currentY - 3;  // Center of symbol vertically
            const slashSize = 22;  // Half the diagonal length
            ctx.moveTo(hungruPuckIconX + 0.75 * slashSize, symbolY - slashSize);
            ctx.lineTo(hungruPuckIconX - 0.75 *slashSize, symbolY + slashSize);
            ctx.strokeStyle = 'hsl(0, 80%, 40%)';
            ctx.stroke();
        }

        currentY += 40;
        
        // 3. Layout Type radio buttons
        ctx.font = 'italic 14px sans-serif';
        ctx.fillStyle = 'hsl(0, 0%, 80%)';
        ctx.fillText('Initial Layout...', centerX - w/2 + checkboxPadding, currentY);
        
        currentY += 25;
        
        // Cluster radio
        const clusterRadioX = centerX - w/2 + checkboxPadding + 20;
        ctx.strokeStyle = respawnMenuLayoutType === 'cluster' ? 'hsl(320, 100%, 50%)' : 'hsl(0, 0%, 60%)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(clusterRadioX + 8, currentY + 3, 8, 0, Math.PI * 2);
        ctx.stroke();
        if (respawnMenuLayoutType === 'cluster') {
            ctx.fillStyle = 'hsl(320, 100%, 50%)';
            ctx.beginPath();
            ctx.arc(clusterRadioX + 8, currentY + 3, 4, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.fillStyle = 'hsl(0, 0%, 80%)';
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText('Cluster', clusterRadioX + 20, currentY + 4);

        // Draw cluster icon: ring of 8 tiny discs
        ctx.fillStyle = 'hsl(320, 100%, 80%)';
        const clusterIconCenterX = clusterRadioX + 123;
        const clusterIconCenterY = currentY + 2;
        const ringRadius = 20;
        const clusterDiscRadius = 2;
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * 2 * Math.PI;
            const x = clusterIconCenterX + ringRadius * Math.cos(angle);
            const y = clusterIconCenterY + ringRadius * Math.sin(angle);
            ctx.beginPath();
            ctx.arc(x, y, clusterDiscRadius, 0, Math.PI * 2);
            ctx.fill();
        }
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * 2 * Math.PI;
            const x = clusterIconCenterX + 0.55 * ringRadius * Math.cos(angle + Math.PI / 8);
            const y = clusterIconCenterY + 0.55 * ringRadius * Math.sin(angle + Math.PI / 8);
            ctx.beginPath();
            ctx.arc(x, y, clusterDiscRadius, 0, Math.PI * 2);
            ctx.fill();
        }
        for (let i = 0; i < 4; i++) {
            const angle = (i / 4) * 2 * Math.PI;
            const x = clusterIconCenterX + 0.25 * ringRadius * Math.cos(angle);
            const y = clusterIconCenterY + 0.25 * ringRadius * Math.sin(angle);
            ctx.beginPath();
            ctx.arc(x, y, clusterDiscRadius, 0, Math.PI * 2);
            ctx.fill();
        }
        
        
        currentY += 25;
        
        // Array radio
        const arrayRadioX = centerX - w/2 + checkboxPadding + 20;
        ctx.strokeStyle = respawnMenuLayoutType === 'array' ? 'hsl(320, 100%, 50%)' : 'hsl(0, 0%, 60%)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(arrayRadioX + 8, currentY + 3, 8, 0, Math.PI * 2);
        ctx.stroke();
        if (respawnMenuLayoutType === 'array') {
            ctx.fillStyle = 'hsl(320, 100%, 50%)';
            ctx.beginPath();
            ctx.arc(arrayRadioX + 8, currentY + 3, 4, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.fillStyle = 'hsl(0, 0%, 80%)';
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText('Array', arrayRadioX + 20, currentY + 4);

        // Draw array icon: 4x4 grid of tiny discs
        ctx.fillStyle = 'hsl(320, 100%, 80%)';
        const arrayIconStartX = arrayRadioX + 160;
        const arrayIconStartY = currentY - 15;
        const gridSpacing = 10;
        const arrayDiscRadius = 2;
        for (let row = 0; row < 4; row++) {
            for (let col = 0; col < 4; col++) {
                const x = arrayIconStartX + col * gridSpacing;
                const y = arrayIconStartY + row * gridSpacing;
                ctx.beginPath();
                ctx.arc(x, y, arrayDiscRadius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        currentY += 40;
        
        // 4. Spawn Type radio buttons
        ctx.font = 'italic 14px sans-serif';
        ctx.fillStyle = 'hsl(0, 0%, 80%)';
        ctx.fillText('Re-spawn from...', centerX - w/2 + checkboxPadding, currentY);
        
        currentY += 25;
        
        // Shower radio
        const showerRadioX = centerX - w/2 + checkboxPadding + 20;
        ctx.strokeStyle = respawnMenuSpawnType === 'shower' ? 'hsl(320, 100%, 50%)' : 'hsl(0, 0%, 60%)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(showerRadioX + 8, currentY + 3, 8, 0, Math.PI * 2);
        ctx.stroke();
        if (respawnMenuSpawnType === 'shower') {
            ctx.fillStyle = 'hsl(320, 100%, 50%)';
            ctx.beginPath();
            ctx.arc(showerRadioX + 8, currentY + 3, 4, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.font = 'bold 14px sans-serif';
        ctx.fillStyle = 'hsl(0, 0%, 80%)';
        ctx.fillText('Shower', showerRadioX + 20, currentY + 4);

        ctx.fillStyle = 'hsl(320, 100%, 80%)';
        ctx.font = '40px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText(' \u2602', showerRadioX + 95, currentY);
        
        currentY += 25;
        
        // Fountain radio (Mr. Mister)
        const fountainRadioX = centerX - w/2 + checkboxPadding + 20;
        ctx.strokeStyle = respawnMenuSpawnType === 'fountain' ? 'hsl(320, 100%, 50%)' : 'hsl(0, 0%, 60%)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(fountainRadioX + 8, currentY + 3, 8, 0, Math.PI * 2);
        ctx.stroke();
        if (respawnMenuSpawnType === 'fountain') {
            ctx.fillStyle = 'hsl(320, 100%, 50%)';
            ctx.beginPath();
            ctx.arc(fountainRadioX + 8, currentY + 3, 4, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.fillStyle = 'hsl(0, 0%, 80%)';
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText('Mr. Mister', fountainRadioX + 20, currentY + 4);
    
        var misterIconX = fountainRadioX + 175;
        var misterIconY = currentY;
        
        //draw Mr. Mister icon
        // body - draw circle directly with canvas
        const iconRadius = 20;
        const shade = ctx.createRadialGradient(
            misterIconX - 5, 
            misterIconY - 5, 
            5, 
            misterIconX, 
            misterIconY, 
            iconRadius);
        shade.addColorStop(0.0, `hsla(320, 80%, 85%, 1.0)`);
        shade.addColorStop(1.0, `hsla(320, 80%, 55%, 1.0)`);
        ctx.fillStyle = shade;
        ctx.beginPath();
        ctx.arc(misterIconX, misterIconY, iconRadius, 0, Math.PI * 2);
        ctx.fill();
    
        // eyes - scaled for larger icon
        ctx.strokeStyle = `hsl(0, 0%, 20%)`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(misterIconX - 12, misterIconY - 4);
        ctx.lineTo(misterIconX - 4, misterIconY - 4);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(misterIconX + 4, misterIconY - 4);
        ctx.lineTo(misterIconX + 12, misterIconY - 4);
        ctx.stroke();
        
        // mouth - scaled ellipse
        ctx.beginPath();
        ctx.ellipse(
            misterIconX, 
            misterIconY + 8, 
            8, 
            6, 
            0, 
            0, 
            2 * Math.PI, false);
        ctx.fillStyle = `hsl(0, 0%, 0%)`;
        ctx.fill();
        
        currentY += 37;  // Increased from 25 to move dropdown down by ~half dropdown height
        
        const dropdownHeight = 24;
        const dropdownWidth = w - 40;  // Equal 20px spacing on both sides
        const dropdownX = centerX - w/2 + 20;
        const misterModes = [
            { value: 'idle', label: 'mouse' },
            { value: 'worm', label: 'worm' },
            { value: 'scanner', label: 'scan' },
            { value: 'printer', label: 'printer' },
            { value: 'typewriter', label: 'typewriter' },
            { value: 'circle', label: 'circle' },
            { value: 'oval', label: 'oval' },
            { value: 'bernoulli', label: 'figure-8' },
            { value: 'billiard', label: 'pong' }
        ];
        
        // Find currently selected mode
        const selectedMode = misterModes.find(m => m.value === respawnMenuMisterMode) || misterModes[0];
        
        if (respawnMenuMisterModeExpanded) {
            // Draw all options when expanded
            misterModes.forEach((mode, index) => {
                const optionY = currentY + index * dropdownHeight;
                const isSelected = respawnMenuMisterMode === mode.value;
                
                // Draw option background
                if (isSelected) {
                    ctx.fillStyle = 'hsl(30, 70%, 35%)';
                } else {
                    ctx.fillStyle = 'hsl(0, 0%, 20%)';
                }
                ctx.fillRect(dropdownX, optionY, dropdownWidth, dropdownHeight - 2);
                
                // Draw option border
                ctx.strokeStyle = isSelected ? 'hsl(30, 70%, 55%)' : 'hsl(0, 0%, 40%)';
                ctx.lineWidth = isSelected ? 2 : 1;
                ctx.strokeRect(dropdownX, optionY, dropdownWidth, dropdownHeight - 2);
                
                // Draw option text
                ctx.fillStyle = isSelected ? 'hsl(320, 80%, 95%)' : 'hsl(320, 80%, 70%)';
                ctx.font = isSelected ? 'bold 16px sans-serif' : '16px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(mode.label, dropdownX + 8, optionY + dropdownHeight/2 - 1);
            });
        } else {
            // Draw only selected option when collapsed
            ctx.fillStyle = 'hsl(0, 0%, 20%)';
            ctx.fillRect(dropdownX, currentY, dropdownWidth, dropdownHeight);
            
            ctx.strokeStyle = 'hsl(0, 0%, 60%)';
            ctx.lineWidth = 1;
            ctx.strokeRect(dropdownX, currentY, dropdownWidth, dropdownHeight);
            
            // Make text dim when Mr. Mister is not selected
            ctx.fillStyle = respawnMenuSpawnType === 'fountain' ? 'hsl(320, 80%, 55%)' : 'hsl(320, 80%, 30%)';
            ctx.font = '16px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(selectedMode.label, dropdownX + 8, currentY + dropdownHeight/2 - 1);
            
            // Draw dropdown arrow
            ctx.fillStyle = respawnMenuSpawnType === 'fountain' ? 'hsl(0, 0%, 70%)' : 'hsl(0, 0%, 30%)';
            const arrowX = dropdownX + dropdownWidth - 15;
            const arrowY = currentY + dropdownHeight/2;
            ctx.beginPath();
            ctx.moveTo(arrowX - 4, arrowY - 2);
            ctx.lineTo(arrowX, arrowY + 2);
            ctx.lineTo(arrowX + 4, arrowY - 2);
            ctx.fill();
        }
        
        ctx.restore();
    }
    
    function respawnMenuHitTest(mouseX, mouseY) {
        const w = respawnMenuWidth;
        const h = respawnMenuHeight;
        const centerX = respawnMenuCenterX;
        const centerY = respawnMenuCenterY;
        
        // Calculate dropdown position exactly like drawing
        let currentY = centerY - h/2 + 50;
        currentY += 35; // After One Shot
        currentY += 40; // After Hungry Puck 
        currentY += 25; // After Layout label (to cluster)
        currentY += 25; // After cluster radio (to array)
        currentY += 40; // After array radio (to spawn type label)
        currentY += 25; // After spawn type label (to shower)
        currentY += 25; // After shower radio (to fountain)
        currentY += 37; // After fountain radio (to dropdown)
        
        const dropdownHeight = 24;
        const dropdownWidth = w - 40;
        const dropdownX = centerX - w/2 + 20;
        const misterModes = ['idle', 'worm', 'scanner', 'printer', 'typewriter', 'circle', 'oval', 'bernoulli', 'billiard'];
        
        // Check expanded dropdown options FIRST (before bounds) - exact copy of particles pattern
        if (respawnMenuMisterModeExpanded) {
            for (let i = 0; i < misterModes.length; i++) {
                const optionY = currentY + i * dropdownHeight;
                if (mouseX >= dropdownX && mouseX <= dropdownX + dropdownWidth &&
                    mouseY >= optionY && mouseY <= optionY + dropdownHeight - 2) {
                    return 'misterMode_' + i;
                }
            }
        }
        
        // Check if inside menu bounds - exact copy of particles pattern
        const borderPadding = 20;
        const menuLeft = centerX - w/2 - borderPadding;
        const menuRight = centerX + w/2 + borderPadding;
        const menuTop = centerY - h/2 - borderPadding;
        const menuBottom = centerY + h/2 + borderPadding;
        
        if (mouseX < menuLeft || mouseX > menuRight || mouseY < menuTop || mouseY > menuBottom) {
            return null;
        }
        
        // Check dropdown toggle when collapsed
        if (!respawnMenuMisterModeExpanded && respawnMenuSpawnType === 'fountain') {
            if (mouseX >= dropdownX && mouseX <= dropdownX + dropdownWidth &&
                mouseY >= currentY && mouseY <= currentY + dropdownHeight - 2) {
                return 'misterModeToggle';
            }
        }
        
        return 'drag';
    }
    
    function handleRespawnMenuInteraction(canvasX, canvasY) {
        if (!respawnMenuVisible) return false;
        
        const hitTest = respawnMenuHitTest(canvasX, canvasY);
        if (!hitTest) return false;
        
        // Handle dropdown option selection
        if (hitTest && hitTest.startsWith('misterMode_')) {
            const index = parseInt(hitTest.split('_')[1]);
            const misterModeValues = ['idle', 'worm', 'scanner', 'printer', 'typewriter', 'circle', 'oval', 'bernoulli', 'billiard'];
            respawnMenuMisterMode = misterModeValues[index];
            mrMode = respawnMenuMisterMode;
            respawnMenuMisterModeExpanded = false;
            return 'dropdown';
        }
        
        // Handle dropdown toggle
        if (hitTest === 'misterModeToggle') {
            respawnMenuMisterModeExpanded = !respawnMenuMisterModeExpanded;
            return 'dropdown';
        }
        
        // Continue with existing logic for other controls...
        const centerX = respawnMenuCenterX;
        const centerY = respawnMenuCenterY;
        const w = respawnMenuWidth;
        const h = respawnMenuHeight;
        const checkboxPadding = 8;
        const checkboxSize = 16;
        
        // Check close button
        const closeButtonX = centerX - w/2 - 8 + 20;
        const closeButtonY = centerY - h/2 - 8 + 20;
        const closeButtonRadius = 12;
        const dxClose = canvasX - closeButtonX;
        const dyClose = canvasY - closeButtonY;
        const distClose = Math.sqrt(dxClose * dxClose + dyClose * dyClose);
        
        if (distClose <= closeButtonRadius) {
            respawnMenuTargetOpacity = 0;
            respawnMenuAnimating = true;
            document.getElementById('respawnMenuToggle').checked = false;
            return true;
        }
        
        // Calculate dropdown position for hit testing (matches drawing exactly)
        let dropdownTestY = centerY - h/2 + 50;
        dropdownTestY += 35; // After One Shot
        dropdownTestY += 35; // After Hungry Puck 
        dropdownTestY += 40; // After Spawn Type label
        dropdownTestY += 25; // After radio buttons
        dropdownTestY += 37; // At dropdown position
        
        const dropdownTestHeight = 24;
        const dropdownTestWidth = w - 40;
        const dropdownTestX = centerX - w/2 + 20;
        const misterModeValues = ['idle', 'worm', 'scanner', 'printer', 'typewriter', 'circle', 'oval', 'bernoulli', 'billiard'];
        
        // If dropdown is expanded, check dropdown options FIRST (before menu bounds)
        if (respawnMenuMisterModeExpanded) {
            for (let i = 0; i < misterModeValues.length; i++) {
                const optionY = dropdownTestY + i * dropdownTestHeight;
                if (canvasX >= dropdownTestX && canvasX <= dropdownTestX + dropdownTestWidth &&
                    canvasY >= optionY && canvasY <= optionY + dropdownTestHeight - 2) {
                    return 'misterMode_' + i;
                }
            }
        }
        
        // Calculate dynamic bounds based on dropdown state
        let dynamicHeight = h;
        if (respawnMenuMisterModeExpanded) {
            dynamicHeight = h + (misterModeValues.length - 1) * dropdownTestHeight;
        }
        
        // Check if within menu bounds (using dynamic height)
        if (canvasX < centerX - w/2 - 20 || canvasX > centerX + w/2 + 20 ||
            canvasY < centerY - h/2 - 20 || canvasY > centerY - h/2 + dynamicHeight + 20) {
            return false;
        }
        
        let currentY = centerY - h/2 + 50;
        
        // One Shot checkbox
        const oneShotCheckX = centerX - w/2 + checkboxPadding;
        if (canvasX >= oneShotCheckX && canvasX <= oneShotCheckX + checkboxSize &&
            canvasY >= currentY - checkboxSize/2 && canvasY <= currentY + checkboxSize/2) {
            respawnMenuOneShot = !respawnMenuOneShot;
            doOneShot = respawnMenuOneShot; // Sync with application variable
            return 'checkbox';
        }
        
        currentY += 35;
        
        // Hungry Puck checkbox
        const hungryCheckX = centerX - w/2 + checkboxPadding;
        if (canvasX >= hungryCheckX && canvasX <= hungryCheckX + checkboxSize &&
            canvasY >= currentY - checkboxSize/2 && canvasY <= currentY + checkboxSize/2) {
            respawnMenuHungryPuck = !respawnMenuHungryPuck;
            showEaters = respawnMenuHungryPuck; // Sync with application variable
            return 'checkbox';
        }
        
        currentY += 40;
        
        // Layout type radios
        currentY += 25;
        
        const clusterRadioX = centerX - w/2 + checkboxPadding + 20;
        if (canvasX >= clusterRadioX && canvasX <= clusterRadioX + 16 &&
            canvasY >= currentY - 8 && canvasY <= currentY + 8) {
            respawnMenuLayoutType = 'cluster';
            if (typeof makeBalls === 'function') makeBalls();
            return 'radio';
        }
        
        currentY += 25;
        
        const arrayRadioX = centerX - w/2 + checkboxPadding + 20;
        if (canvasX >= arrayRadioX && canvasX <= arrayRadioX + 16 &&
            canvasY >= currentY - 8 && canvasY <= currentY + 8) {
            respawnMenuLayoutType = 'array';
            if (typeof makeBalls === 'function') makeBalls();
            return 'radio';
        }
        
        currentY += 40;
        currentY += 25;
        
        // Spawn type radios
        const showerRadioX = centerX - w/2 + checkboxPadding + 20;
        if (canvasX >= showerRadioX && canvasX <= showerRadioX + 16 &&
            canvasY >= currentY - 8 && canvasY <= currentY + 8) {
            respawnMenuSpawnType = 'shower';
            doShower = true;
            doFountain = false;
            return 'radio';
        }
        
        currentY += 25;
        
        const fountainRadioX = centerX - w/2 + checkboxPadding + 20;
        if (canvasX >= fountainRadioX && canvasX <= fountainRadioX + 16 &&
            canvasY >= currentY - 8 && canvasY <= currentY + 8) {
            respawnMenuSpawnType = 'fountain';
            doShower = false;
            doFountain = true;
            return 'radio';
        }
        
        currentY += 37;  // Match drawing position
        
        // Check dropdown toggle (collapsed state only - expanded already checked above)
        if (!respawnMenuMisterModeExpanded && respawnMenuSpawnType === 'fountain') {
            const dropdownHeight = 24;
            const dropdownWidth = w - 40;
            const dropdownX = centerX - w/2 + 20;
            if (canvasX >= dropdownX && canvasX <= dropdownX + dropdownWidth &&
                canvasY >= currentY && canvasY <= currentY + dropdownHeight - 2) {
                respawnMenuMisterModeExpanded = !respawnMenuMisterModeExpanded;
                return 'dropdown';
            }
        }
        
        return 'drag';
    }
    
    function animateToysMenuOpacity() {
        if (!toysMenuAnimating) return;
        
        const fadeInSpeed = 0.1;
        const fadeOutSpeed = 0.2;
        const fadeSpeed = toysMenuTargetOpacity > toysMenuOpacity ? fadeInSpeed : fadeOutSpeed;
        const diff = toysMenuTargetOpacity - toysMenuOpacity;
        
        if (Math.abs(diff) < 0.01) {
            toysMenuOpacity = toysMenuTargetOpacity;
            toysMenuAnimating = false;
            if (toysMenuOpacity <= 0) {
                toysMenuVisible = false;
            }
        } else {
            toysMenuOpacity += diff * fadeSpeed;
        }
    }
    
    function drawToysMenu() {
        if (toysMenuOpacity <= 0) return;
        
        const ctx = c;
        const w = toysMenuWidth;
        const h = toysMenuHeight;
        const centerX = toysMenuCenterX;
        const centerY = toysMenuCenterY;
        
        // Save context state and apply global alpha
        ctx.save();
        ctx.globalAlpha = toysMenuOpacity;
        
        // Draw menu background, border, and close button
        drawMenuBackground(ctx, centerX, centerY, w, h);
        
        // Draw title
        ctx.fillStyle = 'hsl(0, 0%, 70%)';
        ctx.font = 'bold 20px verdana, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Toys', centerX, centerY - h/2 + 12);
        
        // Grid layout for toy icons
        const iconSize = 51;
        const iconSpacing = 64;
        const gridCols = 4;
        const gridRows = 5;
        const startX = centerX - (gridCols - 1) * iconSpacing / 2;
        const startY = centerY - h/2 + 60;
        
        // Initialize toys menu items if not already done, or if tracer buttons are missing
        if (toysMenuItems.length === 0 || !toysMenuItems.find(item => item && item.id === 'smallTracerButton')) {
            toysMenuItems = [
                { id: 'showPuckButton', icon: '\u261C', checked: showPucks, color: 'hsl(190, 85%, 55%)' },
                { id: 'showCyclePuckButton', icon: '\u26A0', checked: false, color: 'hsl(190, 80%, 55%)' },
                { id: 'showHeartButton', icon: '\u2665', checked: false, color: 'hsl(338, 100%, 72%)' },
                { id: 'flyingPuckButton', icon: '\u2604', checked: false, color: 'hsl(190, 85%, 55%)' },
                { id: 'wormButton', icon: '\u223F', checked: false, color: 'hsl(23, 70%, 60%)' },
                { id: 'orbitButton', icon: '\u21BB', checked: false, color: 'hsl(120, 80%, 50%)' },
                { id: 'yinYangButton', icon: '\u262F', checked: false, color: 'hsl(120, 80%, 50%)' },
                null, // Empty slot (was blower)
                { id: 'showBumperEntry', icon: '\u2684', checked: false, color: 'hsl(190, 85%, 55%)' },
                null, // Empty slot
                null, // Empty slot
                null, // Empty slot
                { id: 'smallTracerButton', icon: '\u2710', checked: doSmallTracer, color: 'hsl(170, 20%, 60%)' },
                { id: 'mediumTracerButton', icon: '\u2710', checked: doMediumTracer, color: 'hsl(170, 20%, 60%)' },
                { id: 'bigTracerButton', icon: '\u2710', checked: doBigTracer, color: 'hsl(170, 20%, 60%)' },
                null, // Empty slot
                { id: 'showBlowerButton', icon: '', image: 'aeolus.png', checked: blowerState > 0, color: 'hsl(190, 85%, 55%)' },
                { id: 'showImploderButton', icon: '\u{1F9F2}', checked: typeof Magnet !== 'undefined' && Magnet.length > 0 && Magnet[0].active, color: 'hsl(320, 85%, 55%)' },
                { id: 'showStinkerButton', icon: '', image: 'pepe.png', checked: typeof Stinker !== 'undefined' && Stinker.length > 0 && Stinker[0].active, color: 'hsl(120, 85%, 55%)' },
                null  // Empty slot
            ];
        }
        
        // Draw toy icons in grid
        toysMenuItems.forEach((toy, index) => {
            // Skip null entries (empty slots)
            if (!toy) return;
            
            const col = index % gridCols;
            const row = Math.floor(index / gridCols);
            const x = startX + col * iconSpacing;
            const y = startY + row * iconSpacing;
            
            // Draw icon background
            ctx.fillStyle = toy.checked ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(x - iconSize/2, y - iconSize/2, iconSize, iconSize);
            ctx.strokeStyle = 'hsl(0, 0%, 60%)';
            ctx.lineWidth = 1;
            ctx.strokeRect(x - iconSize/2, y - iconSize/2, iconSize, iconSize);
            
            // Draw icon
            if (toy.image) {
                // Special handling for image-based icons like blower and stinker
                let img, imgReady;
                if (toy.image === 'aeolus.png') {
                    img = aeolusImage;
                    imgReady = aeolusReady;
                } else if (toy.image === 'pepe.png') {
                    img = pepeImage;
                    imgReady = pepeReady;
                } else {
                    img = new Image();
                    img.src = toy.image;
                    imgReady = img.complete;
                }
                
                if (imgReady && img && img.complete) {
                    ctx.save();
                    if (!toy.checked) {
                        // Dim the image when not checked
                        ctx.globalAlpha = 0.3;
                    }
                    const imageSize = iconSize * 0.8; // Slightly smaller than the box
                    
                    ctx.translate(x, y);
                    // Rotate 90 degrees counter-clockwise for blower image only
                    if (toy.image === 'aeolus.png') {
                        ctx.rotate(-Math.PI / 2); // -90 degrees
                    }
                    ctx.drawImage(img, -imageSize/2, -imageSize/2, imageSize, imageSize);
                    
                    ctx.restore();
                } else {
                    // Fallback to text while image loads
                    ctx.fillStyle = toy.checked ? toy.color : 'hsl(190, 45%, 20%)';
                    ctx.font = '12px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    if (toy.image === 'aeolus.png') {
                        ctx.fillText('Blow', x, y);
                    } else if (toy.image === 'pepe.png') {
                        ctx.fillText('Pepe', x, y);
                    }
                }
            } else {
                ctx.fillStyle = toy.checked ? toy.color : 'hsl(190, 45%, 20%)';

                // Adjust font size for tracer buttons
                let fontSize = 38;
                if (toy.id === 'smallTracerButton') {
                    fontSize = 23; // 40% smaller (38 * 0.6 = 22.8, rounded to 23)
                } else if (toy.id === 'bigTracerButton') {
                    fontSize = 53; // 40% larger (38 * 1.4 = 53.2, rounded to 53)
                }

                ctx.font = fontSize + 'px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                if (toy.id === 'showPuckButton') {
                    ctx.save();
                    ctx.translate(x - 2, y + 3);
                    ctx.rotate(40 * Math.PI / 180); // 50 degrees clockwise
                    ctx.scale(1.3, 1.3);
                    ctx.fillText(toy.icon, 0, 0);
                    ctx.restore();
                } else 
                if (toy.id === 'showCyclePuckButton') {
                    ctx.save();
                    ctx.translate(x + 1, y + 5);
                    ctx.scale(1.3, 1.3);
                    ctx.fillText(toy.icon, 0, 0);
                    ctx.restore();
                } else {
                if (toy.id === 'flyingPuckButton') {
                    ctx.save();
                    ctx.translate(x + 2, y + 1);
                    ctx.rotate(250 * Math.PI / 180); // 100 degrees clockwise
                    ctx.scale(1.4, 1.4);
                    ctx.fillText(toy.icon, 0, 0);
                    ctx.restore();
                } else {
                if (toy.id === 'yinYangButton') {
                    ctx.save();
                    ctx.translate(x + 0, y + 3);
                    ctx.scale(1.4, 1.4);
                    ctx.fillText(toy.icon, 0, 0);
                    ctx.restore();
                } else {
                if (toy.id === 'showBumperEntry') {
                    ctx.save();
                    ctx.translate(x + 0, y - 3);
                    ctx.scale(1.7, 1.7);
                    ctx.fillText(toy.icon, 0, 0);
                    ctx.restore();
                } else {
                if (toy.id === 'wormButton') {
                    ctx.save();
                    ctx.translate(x, y - 11);
                    ctx.scale(2.5, 2.5);
                    ctx.fillText(toy.icon, 0, 0);
                    ctx.restore();
                } else {
                if (toy.id === 'orbitButton') {
                    ctx.save();
                    ctx.translate(x, y - 4);
                    ctx.scale(2, 2);
                    ctx.fillText(toy.icon, 0, 0);
                    ctx.restore();
                } else {
                    if (toy.id === 'showImploderButton') {
                    ctx.save();
                    ctx.translate(x, y - 1);
                    ctx.rotate(Math.PI);
                    ctx.scale(1.0, 1.0);
                    ctx.fillText(toy.icon, 0, 0);
                    ctx.restore();
                } else {
                    ctx.fillText(toy.icon, x, y + 3);
                }
            }
    }}}}}}});
        
        // Restore context state
        ctx.restore();
    }
    
    function handleToysMenuInteraction(canvasX, canvasY) {
        if (!toysMenuVisible) return false;
        
        const w = toysMenuWidth;
        const h = toysMenuHeight;
        const centerX = toysMenuCenterX;
        const centerY = toysMenuCenterY;
        const borderPadding = 8;
        
        // Check if click is within toys menu bounds
        if (canvasX < centerX - w/2 - borderPadding || canvasX > centerX + w/2 + borderPadding ||
            canvasY < centerY - h/2 - 8 || canvasY > centerY + h/2 + 8) {
            return false;
        }
        
        // Check close button
        const closeButtonX = centerX - w/2 - borderPadding + 20;
        const closeButtonY = centerY - h/2 - 8 + 20;
        const closeButtonRadius = 12;
        const closeDistX = canvasX - closeButtonX;
        const closeDistY = canvasY - closeButtonY;
        if (Math.sqrt(closeDistX * closeDistX + closeDistY * closeDistY) < closeButtonRadius) {
            toysMenuTargetOpacity = 0;
            toysMenuAnimating = true;
            return 'close';
        }
        
        // Check toy icon clicks
        const iconSize = 51;
        const iconSpacing = 64;
        const gridCols = 4;
        const startX = centerX - (gridCols - 1) * iconSpacing / 2;
        const startY = centerY - h/2 + 60;
        
        for (let index = 0; index < toysMenuItems.length; index++) {
            const toy = toysMenuItems[index];
            // Skip null entries (empty slots)
            if (!toy) continue;
            
            const col = index % gridCols;
            const row = Math.floor(index / gridCols);
            const x = startX + col * iconSpacing;
            const y = startY + row * iconSpacing;
            
            if (canvasX >= x - iconSize/2 && canvasX <= x + iconSize/2 &&
                canvasY >= y - iconSize/2 && canvasY <= y + iconSize/2) {
                
                // Handle multi-state buttons specially (don't auto-toggle)
                if (toy.id === 'orbitButton' || toy.id === 'yinYangButton' || toy.id === 'wormButton' ||
                    toy.id === 'smallTracerButton' || toy.id === 'mediumTracerButton' || toy.id === 'bigTracerButton') {
                    // State cycling logic will handle the checked status
                } else {
                    // Normal toggle for other toys
                    toy.checked = !toy.checked;
                }
                
                // Apply the toy's effect based on its ID
                if (toy.id === 'showBumperEntry') {
                    showBumpers = toy.checked;
                    if (toy.checked) {
                        // Optionally re-create bumpers if needed
                        if (typeof makeBumpers === 'function' && (!Bumpers || Bumpers.length === 0)) {
                            makeBumpers();
                        }
                    } else {
                        // Hide bumpers
                        if (Array.isArray(Bumpers)) {
                            Bumpers.length = 0;
                        }
                    }
                } else 
                if (toy.id === 'showPuckButton') {
                    showPucks = toy.checked;
                    if (typeof Puck !== 'undefined' && Array.isArray(Puck)) {
                        for (var p = 0; p < Puck.length; p++) {
                            if (!Puck[p].heartBeat && !Puck[p].cycle && !Puck[p].flying && !Puck[p].orbit && !Puck[p].yinyang) {
                                if (toy.checked) {
                                    Puck[p].radius = Puck[p].OGradius && Puck[p].OGradius > 0 ? Puck[p].OGradius : 0.3;
                                    Puck[p].puckArriving = true;
                                } else {
                                    Puck[p].radius = 0;
                                    Puck[p].puckArriving = false;
                                }
                            }
                        }
                    }
                } else if (toy.id === 'showBlowerButton') {
                    if (toy.checked) {
                        blowerState = 1;
                        if (typeof blower !== 'undefined') blower.active = true;
                    } else {
                        blowerState = 0;
                        if (typeof blower !== 'undefined') blower.active = false;
                    }
                } else if (toy.id === 'showImploderButton') {
                    if (typeof Magnet !== 'undefined' && Magnet.length > 0) {
                        Magnet[0].active = !!toy.checked;
                    }
                } else if (toy.id === 'showHeartButton') {
                    if (toy.checked) {
                        for (var p = 0; p < Puck.length; p++) {
                            if (Puck[p].heartBeat === true) {
                                Puck[p].puckArriving = false;
                                const nowPerf = performance.now();
                                Puck[p].hbResumeAt = nowPerf + 1000; // 1s delay
                                Puck[p].hbState = 'pause';
                                Puck[p].hbTimeInState = 0.0;
                                Puck[p].hbLastTime = nowPerf;
                                Puck[p].radius = Puck[p].OGradius;
                                break;
                            }
                        }
                        showHeart = true;
                    } else {
                        showHeart = false;
                    }
                } else if (toy.id === 'showCyclePuckButton') {
                    if (toy.checked) {
                        for (var p = 0; p < Puck.length; p++) {
                            if (Puck[p].cycle === true) {
                                Puck[p].puckArriving = false;
                                const nowPerf = performance.now();
                                Puck[p].cycResumeAt = nowPerf + 3000; // 3s pause
                                Puck[p].cycState = 'grow';
                                Puck[p].cycTimeInState = 0.0;
                                Puck[p].cycLastTime = nowPerf;
                                Puck[p].radius = Puck[p].OGradius;
                            }
                        }
                        showCycle = true;
                    } else {
                        showCycle = false;
                    }
                } else if (toy.id === 'orbitButton') {
                    // Cycle through orbit states: 0 = off, 1 = normal, -1 = reverse
                    if (orbitState === 0) {
                        // Turn ON, normal direction
                        orbitState = 1;
                        orbitDirection = 1;
                        toy.checked = true;
                        // Deactivate yin-yang if active
                        const yinYangToy = toysMenuItems.find(item => item.id === 'yinYangButton');
                        if (yinYangToy) yinYangToy.checked = false;
                        yinYangState = 0;
                        showYinYang = false;
                        // Initialize orbit puck
                        for (var p = 0; p < Puck.length; p++) {
                            if (Puck[p].orbit === true) {
                                Puck[p].puckArriving = false;
                                Puck[p].radius = Puck[p].OGradius;
                                Puck[p].orbitAngle = 0;
                                Puck[p].orbitLastTime = performance.now();
                            }
                        }
                        showOrbit = true;
                    } else if (orbitState === 1) {
                        // Reverse direction
                        orbitState = -1;
                        orbitDirection = -1;
                        toy.checked = true; // keep checked in reverse state
                        showOrbit = true;
                    } else {
                        // Turn OFF
                        orbitState = 0;
                        orbitDirection = 1;
                        toy.checked = false;
                        showOrbit = false;
                    }
                } else if (toy.id === 'yinYangButton') {
                    // Cycle through yin-yang states: 0 = off, 1 = normal, -1 = reverse
                    if (yinYangState === 0) {
                        // Turn ON, normal direction
                        yinYangState = 1;
                        yinYangDirection = 1;
                        toy.checked = true;
                        // Deactivate orbit if active
                        const orbitToy = toysMenuItems.find(item => item.id === 'orbitButton');
                        if (orbitToy) orbitToy.checked = false;
                        orbitState = 0;
                        // Initialize both yin-yang orbit pucks
                        let found = 0;
                        for (var p = 0; p < Puck.length; p++) {
                            if (Puck[p].yinyang === true || (Puck[p].orbit === true && !Puck[p].yinyang && found === 0)) {
                                Puck[p].puckArriving = false;
                                Puck[p].radius = Puck[p].OGradius;
                                Puck[p].orbitAngle = found === 0 ? 0 : Math.PI;
                                Puck[p].orbitLastTime = performance.now();
                                found++;
                                if (found === 2) break;
                            }
                        }
                        showOrbit = true;
                        showYinYang = true;
                    } else if (yinYangState === 1) {
                        // Reverse direction for both pucks
                        yinYangState = -1;
                        yinYangDirection = -1;
                        toy.checked = true; // keep checked in reverse state
                        showOrbit = true;
                        showYinYang = true;
                    } else {
                        // Turn OFF
                        yinYangState = 0;
                        yinYangDirection = 1;
                        toy.checked = false;
                        showOrbit = false;
                        showYinYang = false;
                    }
                } else if (toy.id === 'wormButton') {
                    // Cycle through worm states: 0 = off, 1 = spheres, 2 = curves
                    if (wormState === 0) {
                        // Turn ON, spheres mode
                        wormState = 1;
                        toy.checked = true;
                        doWorm = true;
                        wormRenderMode = 'spheres';
                        makeWorm();
                        WormProps.isHiding = false;
                        WormProps.hideStartTime = 0;
                    } else if (wormState === 1) {
                        // Switch to curves mode
                        wormState = 2;
                        toy.checked = true; // keep checked
                        doWorm = true;
                        wormRenderMode = 'curves';
                        makeWorm();
                        WormProps.isHiding = false;
                        WormProps.hideStartTime = 0;
                    } else {
                        // Turn OFF
                        wormState = 0;
                        toy.checked = false;
                        doWorm = false;
                        WormProps.isHiding = false;
                        WormProps.hideStartTime = 0;
                        WormProps.SpaceWorm = null;
                    }
                } else if (toy.id === 'showImploderButton') {
                    if (toy.checked) {
                        if (typeof Magnet !== 'undefined' && Magnet.length > 0) {
                            Magnet[0].active = true;
                        }
                    } else {
                        if (typeof Magnet !== 'undefined' && Magnet.length > 0) {
                            Magnet[0].active = false;
                        }
                    }
                } else if (toy.id === 'showStinkerButton') {
                    if (toy.checked) {
                        if (typeof Stinker !== 'undefined' && Stinker.length > 0) {
                            Stinker[0].active = true;
                        }
                    } else {
                        if (typeof Stinker !== 'undefined' && Stinker.length > 0) {
                            Stinker[0].active = false;
                        }
                    }
                } else if (toy.id === 'flyingPuckButton') {
                    doFlyingPuck = toy.checked;
                } else if (toy.id === 'smallTracerButton') {
                    // Toggle small tracer - mutual exclusion with other tracers
                    const wasChecked = doSmallTracer;
                    
                    // Turn off all tracers first
                    doSmallTracer = false;
                    doMediumTracer = false;
                    doBigTracer = false;
                    doTracer = false;
                    
                    // Update UI state for all tracer buttons
                    const smallTracer = toysMenuItems.find(item => item && item.id === 'smallTracerButton');
                    const mediumTracer = toysMenuItems.find(item => item && item.id === 'mediumTracerButton');
                    const bigTracer = toysMenuItems.find(item => item && item.id === 'bigTracerButton');
                    if (smallTracer) smallTracer.checked = false;
                    if (mediumTracer) mediumTracer.checked = false;
                    if (bigTracer) bigTracer.checked = false;
                    
                    // If it wasn't checked before, turn on small tracer
                    if (!wasChecked) {
                        doSmallTracer = true;
                        doTracer = true;
                        if (smallTracer) smallTracer.checked = true;
                        selectTracerBall();
                    }
                } else if (toy.id === 'mediumTracerButton') {
                    // Toggle medium tracer - mutual exclusion with other tracers
                    const wasChecked = doMediumTracer;
                    
                    // Turn off all tracers first
                    doSmallTracer = false;
                    doMediumTracer = false;
                    doBigTracer = false;
                    doTracer = false;
                    
                    // Update UI state for all tracer buttons
                    const smallTracer = toysMenuItems.find(item => item && item.id === 'smallTracerButton');
                    const mediumTracer = toysMenuItems.find(item => item && item.id === 'mediumTracerButton');
                    const bigTracer = toysMenuItems.find(item => item && item.id === 'bigTracerButton');
                    if (smallTracer) smallTracer.checked = false;
                    if (mediumTracer) mediumTracer.checked = false;
                    if (bigTracer) bigTracer.checked = false;
                    
                    // If it wasn't checked before, turn on medium tracer
                    if (!wasChecked) {
                        doMediumTracer = true;
                        doTracer = true;
                        if (mediumTracer) mediumTracer.checked = true;
                        selectTracerBall();
                    }
                } else if (toy.id === 'bigTracerButton') {
                    // Toggle big tracer - mutual exclusion with other tracers
                    const wasChecked = doBigTracer;
                    
                    // Turn off all tracers first
                    doSmallTracer = false;
                    doMediumTracer = false;
                    doBigTracer = false;
                    doTracer = false;
                    
                    // Update UI state for all tracer buttons
                    const smallTracer = toysMenuItems.find(item => item && item.id === 'smallTracerButton');
                    const mediumTracer = toysMenuItems.find(item => item && item.id === 'mediumTracerButton');
                    const bigTracer = toysMenuItems.find(item => item && item.id === 'bigTracerButton');
                    if (smallTracer) smallTracer.checked = false;
                    if (mediumTracer) mediumTracer.checked = false;
                    if (bigTracer) bigTracer.checked = false;
                    
                    // If it wasn't checked before, turn on big tracer
                    if (!wasChecked) {
                        doBigTracer = true;
                        doTracer = true;
                        if (bigTracer) bigTracer.checked = true;
                        selectTracerBall();
                    }
                }
                
                return 'toy';
            }
        }
        
        // If not clicking on a toy icon or close button, allow dragging
        return 'drag';
    }
    
    function drawGravityMenu() {
        if (gravityMenuOpacity <= 0) return;
        
        const ctx = c;
        const centerX = gravityMenuX;
        const centerY = gravityMenuY;
        const radius = gravityMenuRadius;
        const size = radius * 2 + 50;
        
        ctx.save();
        ctx.globalAlpha = gravityMenuOpacity;
        
        // Draw menu background, border, and close button (expanded for rotation slider)
        drawMenuBackground(ctx, centerX, centerY, size, size, {
            topOffset: -38,
            bottomOffset: 55
        });
        
        // Draw title
        ctx.fillStyle = 'hsl(0, 0%, 70%)';
        ctx.font = 'bold 20px verdana, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Gravity', centerX, centerY - size/2 - 18);
        
        // Draw outer circle (15% larger for easier interaction)
        ctx.strokeStyle = 'hsl(0, 0%, 60%)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        const visualRadius = radius * 1.15;
        ctx.arc(centerX, centerY, visualRadius, 0, Math.PI * 2);
        ctx.stroke();
        
        // Draw semi-transparent fill inside circle
        ctx.fillStyle = 'hsla(0, 0%, 0%, 0.5)';
        ctx.beginPath();
        ctx.arc(centerX, centerY, visualRadius, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw crosshairs (15% larger to match circle)
        const crosshairRadius = radius * 1.15;
        ctx.strokeStyle = 'hsl(0, 0%, 40%)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(centerX - crosshairRadius, centerY);
        ctx.lineTo(centerX + crosshairRadius, centerY);
        ctx.moveTo(centerX, centerY - crosshairRadius);
        ctx.lineTo(centerX, centerY + crosshairRadius);
        ctx.stroke();
        
        // Draw center circle for zero gravity
        ctx.fillStyle = 'hsl(0, 0%, 0%)';
        ctx.beginPath();
        ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = 'hsl(0, 0%, 60%)';
        ctx.stroke();
        
        // Draw current gravity position
        const gx = physProps.gravity.x;
        const gy = physProps.gravity.y;
        const gmag = Math.sqrt(gx * gx + gy * gy);
        
        // Map gravity to circle position (joystick-style)
        const maxGravity = 1.0;
        const normalizedMag = Math.min(gmag / maxGravity, 1.0);
        const markerX = centerX + gx * radius / maxGravity;
        const markerY = centerY - gy * radius / maxGravity;
        
        if (gmag > 0.01) {
            // Draw line from center to marker (only if gravity is non-zero)
            ctx.strokeStyle = 'hsl(220, 80%, 50%)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(markerX, markerY);
            ctx.stroke();
        }
        
        // Always draw marker circle in blue
        ctx.fillStyle = 'hsl(220, 80%, 50%)';
        ctx.beginPath();
        ctx.arc(markerX, markerY, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Draw rotation slider at bottom of menu (always visible)
        const sliderY = centerY + size/2 + 15;
        const sliderStartX = centerX - 70;
        const sliderWidth = 140;
        const sliderHeight = 20; // Match other menu sliders
        
        // Draw gradient bar (using blue color to match gravity theme)
        for (let i = 0; i <= sliderWidth; i++) {
            const brightness = 30 + (i / sliderWidth) * 40;
            ctx.fillStyle = `hsl(220, 70%, ${brightness}%)`;
            ctx.fillRect(sliderStartX + i, sliderY - sliderHeight/2, 1, sliderHeight);
        }
        
        // Draw border
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1;
        ctx.strokeRect(sliderStartX, sliderY - sliderHeight/2, sliderWidth, sliderHeight);
        
        // Draw center line (no rotation position)
        const centerLineX = sliderStartX + sliderWidth / 2;
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(centerLineX, sliderY - sliderHeight/2);
        ctx.lineTo(centerLineX, sliderY + sliderHeight/2);
        ctx.stroke();
        
        // Draw marker (handle)
        const rotationHandleX = sliderStartX + gravityRotationSlider * sliderWidth;
        ctx.fillStyle = 'white';
        ctx.fillRect(rotationHandleX - 2, sliderY - sliderHeight/2 - 3, 4, sliderHeight + 6);
        ctx.strokeStyle = 'black';
        ctx.strokeRect(rotationHandleX - 2, sliderY - sliderHeight/2 - 3, 4, sliderHeight + 6);
        
        // Draw label inside slider (after gradient so it's on top)
        ctx.fillStyle = 'black';
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Rotation', sliderStartX + sliderWidth/2, sliderY);
        
        ctx.restore();
    }
    
    function handleGravityMenuInteraction(canvasX, canvasY) {
        if (!gravityMenuVisible) return false;
        
        const centerX = gravityMenuX;
        const centerY = gravityMenuY;
        const radius = gravityMenuRadius;
        const size = radius * 2 + 50;
        
        const sliderY = centerY + size/2 + 15;
        const sliderStartX = centerX - 70;
        const sliderWidth = 140;
        const sliderHeight = 20;
        
        // If already dragging the rotation slider, update it regardless of mouse position
        if (gravityMenuDragging && gravityMenuDraggingControl === 'rotation') {
            // Calculate slider position (0 to 1)
            const relativeX = canvasX - sliderStartX;
            const rawPosition = relativeX / sliderWidth;
            let newSliderPosition = Math.max(0, Math.min(1, rawPosition));
            
            // Add detent at center (snap to 0.5 if close)
            const detentRange = 0.05; // 5% range around center
            if (Math.abs(newSliderPosition - 0.5) < detentRange) {
                newSliderPosition = 0.5;
            }
            
            gravityRotationSlider = newSliderPosition;
            
            // Calculate rotation speed based on distance from center
            const centerDistance = Math.abs(gravityRotationSlider - 0.5);
            const maxRotationSpeed = 0.01; // radians per frame
            gravityRotationSpeed = centerDistance * 2 * maxRotationSpeed; // Scale to 0-maxSpeed
            
            // Set direction based on which side of center
            if (gravityRotationSlider < 0.5) {
                gravityRotationSpeed = gravityRotationSpeed; // Counter-clockwise (positive)
            } else if (gravityRotationSlider === 0.5) {
                gravityRotationSpeed = 0; // No rotation at center
            } else {
                gravityRotationSpeed = -gravityRotationSpeed; // Clockwise (negative)
            }
            
            return 'rotation-slider';
        }
        
        // Check close button - only when not dragging
        if (!gravityMenuDragging) {
            const closeButtonX = centerX - size/2 - 8 + 20;
            const closeButtonY = centerY - size/2 - 38 + 20;
            const closeButtonRadius = 12;
            const dxClose = canvasX - closeButtonX;
            const dyClose = canvasY - closeButtonY;
            const distClose = Math.sqrt(dxClose * dxClose + dyClose * dyClose);
            
            if (distClose <= closeButtonRadius) {
                gravityMenuTargetOpacity = 0;
                gravityMenuAnimating = true;
                document.getElementById('gravityMenuToggle').checked = false;
                return true;
            }
        }
        
        // Check if within menu bounds - skip when already dragging
        if (!gravityMenuDragging) {
            if (canvasX < centerX - size/2 - 20 || canvasX > centerX + size/2 + 20 ||
                canvasY < centerY - size/2 - 38 || canvasY > centerY + size/2 + 60) {
                return false;
            }
        }
        
        // Check rotation slider interaction (always available)
        if (canvasX >= sliderStartX && canvasX <= sliderStartX + sliderWidth &&
            canvasY >= sliderY - sliderHeight/2 && canvasY <= sliderY + sliderHeight/2) {
            
            gravityMenuDraggingControl = 'rotation';
            
            // Calculate slider position (0 to 1)
            const relativeX = canvasX - sliderStartX;
            const rawPosition = relativeX / sliderWidth;
            let newSliderPosition = Math.max(0, Math.min(1, rawPosition));
            
            // Add detent at center (snap to 0.5 if close)
            const detentRange = 0.05; // 5% range around center
            if (Math.abs(newSliderPosition - 0.5) < detentRange) {
                newSliderPosition = 0.5;
            }
            
            gravityRotationSlider = newSliderPosition;
            
            // Calculate rotation speed based on distance from center
            const centerDistance = Math.abs(gravityRotationSlider - 0.5);
            const maxRotationSpeed = 0.01; // radians per frame
            gravityRotationSpeed = centerDistance * 2 * maxRotationSpeed; // Scale to 0-maxSpeed
            
            // Set direction based on which side of center
            if (gravityRotationSlider < 0.5) {
                gravityRotationSpeed = gravityRotationSpeed; // Counter-clockwise (positive)
            } else if (gravityRotationSlider === 0.5) {
                gravityRotationSpeed = 0; // No rotation at center
            } else {
                gravityRotationSpeed = -gravityRotationSpeed; // Clockwise (negative)
            }
            
            return 'rotation-slider';
        }
        
        // Check if clicking within circle (15% larger selection radius for easier interaction)
        const dx = canvasX - centerX;
        const dy = canvasY - centerY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const selectionRadius = radius * 1.15; // 15% larger than base radius
        
        if (dist <= selectionRadius) {
            // Snap to center if close
            const snapRadius = 10;
            if (dist < snapRadius) {
                physProps.gravity = new Vector2(0, 0);
                doGravityDown = false;
                doGravityUp = false;
                doGravityLeft = false;
                doGravityRight = false;
                return 'gravity';
            }
            
            // Snap to cardinal directions
            const angle = Math.atan2(dy, dx);
            const snapAngle = Math.PI / 16; // Snap within ~11 degrees
            let snappedAngle = angle;
            
            // Check for cardinal snaps (right=0, down=/2, left=, up=-/2)
            const cardinals = [0, Math.PI/2, Math.PI, -Math.PI/2];
            for (const cardinal of cardinals) {
                if (Math.abs(angle - cardinal) < snapAngle || 
                    Math.abs(angle - cardinal + Math.PI*2) < snapAngle ||
                    Math.abs(angle - cardinal - Math.PI*2) < snapAngle) {
                    snappedAngle = cardinal;
                    break;
                }
            }
            
            // Calculate gravity from position (joystick-style: click direction = gravity direction)
            const maxGravity = 1.0;
            const magnitude = (dist / radius) * maxGravity;
            const gx = Math.cos(snappedAngle) * magnitude;
            const gy = -Math.sin(snappedAngle) * magnitude;
            
            physProps.gravity = new Vector2(gx, gy);
            
            // Update gravity direction flags based on dominant direction
            const absGx = Math.abs(gx);
            const absGy = Math.abs(gy);
            if (absGy > absGx) {
                // Vertical gravity dominates
                doGravityDown = gy > 0;
                doGravityUp = gy < 0;
                doGravityLeft = false;
                doGravityRight = false;
            } else if (absGx > absGy) {
                // Horizontal gravity dominates
                doGravityLeft = gx > 0;
                doGravityRight = gx < 0;
                doGravityDown = false;
                doGravityUp = false;
            } else {
                // Equal or no gravity
                doGravityDown = false;
                doGravityUp = false;
                doGravityLeft = false;
                doGravityRight = false;
            }
            
            return 'gravity';
        }
        
        // If clicked within menu bounds but outside circle, allow dragging
        return 'drag';
    }
    
    function drawParticlesMenu() {
        if (particlesMenuOpacity <= 0) return;
        
        const ctx = c;
        const w = particlesMenuWidth;
        const h = particlesMenuHeight;
        const centerX = particlesMenuCenterX;
        const centerY = particlesMenuCenterY;
        const sliderSpacing = 35;  // Match physics menu spacing
        
        // Save context state and apply global alpha
        ctx.save();
        ctx.globalAlpha = particlesMenuOpacity;
        
        // Draw menu background, border, and close button
        drawMenuBackground(ctx, centerX, centerY, w, h, {
            bottomOffset: 0
        });
        
        // Draw title
        ctx.fillStyle = 'hsl(0, 0%, 70%)';
        ctx.font = 'bold 20px verdana, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Particles', centerX, centerY - h/2 + 12);
        
        // Starting Y position for first slider
        let currentY = centerY - h/2 + 50;  // Match physics menu
        
        // Slider dimensions - adjusted to leave space for readouts
        const sliderStartX = centerX - w/2 + 20;
        const sliderWidth = w - 80;  // Shorter to leave space for readouts
        const sliderHeight = 20;
        
        // SLIDER 1: Particle Quantity (square root from 1 to 100)
        // Draw gradient bar
        for (let i = 0; i <= sliderWidth; i++) {
            const brightness = 30 + (i / sliderWidth) * 40;
            ctx.fillStyle = `hsl(30, 70%, ${brightness}%)`;
            ctx.fillRect(sliderStartX + i, currentY - sliderHeight/2, 1, sliderHeight);
        }
        
        // Draw border
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1;
        ctx.strokeRect(sliderStartX, currentY - sliderHeight/2, sliderWidth, sliderHeight);
        
        // Draw marker
        const quantityPercent = (particlesMenuQuantity - 1) / 99;
        const quantityHandleX = sliderStartX + quantityPercent * sliderWidth;
        ctx.fillStyle = 'white';
        ctx.fillRect(quantityHandleX - 2, currentY - sliderHeight/2 - 3, 4, sliderHeight + 6);
        ctx.strokeStyle = 'black';
        ctx.strokeRect(quantityHandleX - 2, currentY - sliderHeight/2 - 3, 4, sliderHeight + 6);
        
        // Draw label inside slider (after gradient so it's on top)
        ctx.fillStyle = 'black';
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Quantity', sliderStartX + sliderWidth/2, currentY);
        
        // Draw value display to the right
        const actualCount = particlesMenuQuantity * particlesMenuQuantity;
        ctx.fillStyle = 'hsl(0, 0%, 80%)';
        ctx.textAlign = 'right';
        ctx.fillText(actualCount.toString(), centerX + w/2 - 15, currentY);
        
        currentY += sliderSpacing;
        
        // SLIDER 2: Small Radius
        // Draw gradient bar
        for (let i = 0; i <= sliderWidth; i++) {
            const brightness = 30 + (i / sliderWidth) * 40;
            ctx.fillStyle = `hsl(170, 70%, ${brightness}%)`;
            ctx.fillRect(sliderStartX + i, currentY - sliderHeight/2, 1, sliderHeight);
        }
        
        // Draw border
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1;
        ctx.strokeRect(sliderStartX, currentY - sliderHeight/2, sliderWidth, sliderHeight);
        
        // Draw marker (range 0-50)
        const smallRadiusPercent = particlesMenuSmallRadius / 50;
        const smallRadiusHandleX = sliderStartX + smallRadiusPercent * sliderWidth;
        ctx.fillStyle = 'white';
        ctx.fillRect(smallRadiusHandleX - 2, currentY - sliderHeight/2 - 3, 4, sliderHeight + 6);
        ctx.strokeStyle = 'black';
        ctx.strokeRect(smallRadiusHandleX - 2, currentY - sliderHeight/2 - 3, 4, sliderHeight + 6);
        
        // Draw label inside slider (after gradient so it's on top)
        ctx.fillStyle = 'black';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = 'bold 14px sans-serif';
        ctx.fillText('Smallest Radius', sliderStartX + sliderWidth/2, currentY);
        
        // Draw value display to the right
        ctx.fillStyle = 'hsl(0, 0%, 80%)';
        ctx.textAlign = 'right';
        ctx.fillText(particlesMenuSmallRadius.toString(), centerX + w/2 - 15, currentY);
        
        currentY += sliderSpacing;
        
        // SLIDER 3: Large Radius
        // Draw gradient bar
        for (let i = 0; i <= sliderWidth; i++) {
            const brightness = 30 + (i / sliderWidth) * 40;
            ctx.fillStyle = `hsl(180, 70%, ${brightness}%)`;
            ctx.fillRect(sliderStartX + i, currentY - sliderHeight/2, 1, sliderHeight);
        }
        
        // Draw border
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1;
        ctx.strokeRect(sliderStartX, currentY - sliderHeight/2, sliderWidth, sliderHeight);
        
        // Draw marker (range 1-50)
        const largeRadiusPercent = (particlesMenuLargeRadius - 1) / 49;
        const largeRadiusHandleX = sliderStartX + largeRadiusPercent * sliderWidth;
        ctx.fillStyle = 'white';
        ctx.fillRect(largeRadiusHandleX - 2, currentY - sliderHeight/2 - 3, 4, sliderHeight + 6);
        ctx.strokeStyle = 'black';
        ctx.strokeRect(largeRadiusHandleX - 2, currentY - sliderHeight/2 - 3, 4, sliderHeight + 6);
        
        // Draw label inside slider (after gradient so it's on top)
        ctx.fillStyle = 'black';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Largest Radius', sliderStartX + sliderWidth/2, currentY);
        
        // Draw value display to the right
        ctx.fillStyle = 'hsl(0, 0%, 80%)';
        ctx.textAlign = 'right';
        ctx.fillText(particlesMenuLargeRadius.toString(), centerX + w/2 - 15, currentY);
        
        currentY += sliderSpacing + 10;
        
        // RENDER TYPE DROPDOWN
        ctx.textAlign = 'left';
        ctx.fillText('Style', sliderStartX, currentY - 12);
        
        const dropdownHeight = 24;
        const dropdownWidth = w - 40;  // Equal 20px spacing on both sides
        const renderTypes = [
            { value: 'drawSpheres', label: 'spheres' },
            { value: 'drawDiscs', label: 'discs' },
            { value: 'drawCircles', label: 'circles' },
            { value: 'drawRings', label: 'rings' },
            { value: 'drawGummies', label: 'gummies (beta)' }
        ];
        
        // Find currently selected type
        const selectedType = renderTypes.find(t => t.value === particlesMenuRenderType) || renderTypes[1];
        
        if (particlesMenuRenderTypeExpanded) {
            // Draw all options when expanded
            renderTypes.forEach((type, index) => {
                const optionY = currentY + index * dropdownHeight;
                const isSelected = particlesMenuRenderType === type.value;
                
                // Draw option background
                if (isSelected) {
                    ctx.fillStyle = 'hsl(180, 70%, 35%)';
                } else {
                    ctx.fillStyle = 'hsl(0, 0%, 20%)';
                }
                ctx.fillRect(sliderStartX, optionY, dropdownWidth, dropdownHeight - 2);
                
                // Draw option border
                ctx.strokeStyle = isSelected ? 'hsl(180, 70%, 55%)' : 'hsl(0, 0%, 40%)';
                ctx.lineWidth = isSelected ? 2 : 1;
                ctx.strokeRect(sliderStartX, optionY, dropdownWidth, dropdownHeight - 2);
                
                // Draw option text
                ctx.fillStyle = isSelected ? 'hsl(0, 0%, 95%)' : 'hsl(0, 0%, 70%)';
                ctx.font = isSelected ? 'bold 16px sans-serif' : '16px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(type.label, sliderStartX + 8, optionY + dropdownHeight/2 - 1);
            });
        } else {
            // Draw only selected option when collapsed
            ctx.fillStyle = 'hsl(0, 0%, 20%)';
            ctx.fillRect(sliderStartX, currentY, dropdownWidth, dropdownHeight - 2);
            
            ctx.strokeStyle = 'hsl(0, 0%, 60%)';
            ctx.lineWidth = 1;
            ctx.strokeRect(sliderStartX, currentY, dropdownWidth, dropdownHeight - 2);
            
            ctx.fillStyle = 'hsl(0, 0%, 90%)';
            ctx.font = '16px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(selectedType.label, sliderStartX + 8, currentY + dropdownHeight/2 - 1);
            
            // Draw dropdown arrow
            ctx.fillStyle = 'hsl(0, 0%, 70%)';
            const arrowX = sliderStartX + dropdownWidth - 15;
            const arrowY = currentY + dropdownHeight/2;
            ctx.beginPath();
            ctx.moveTo(arrowX - 4, arrowY - 2);
            ctx.lineTo(arrowX, arrowY + 2);
            ctx.lineTo(arrowX + 4, arrowY - 2);
            ctx.fill();
        }
        
        ctx.restore();
    }
    
    function particlesMenuHitTest(mouseX, mouseY) {
        const w = particlesMenuWidth;
        const h = particlesMenuHeight;
        const centerX = particlesMenuCenterX;
        const centerY = particlesMenuCenterY;
        const borderPadding = 8;
        
        const menuLeft = centerX - w/2 - borderPadding;
        const menuRight = centerX + w/2 + borderPadding;
        const menuTop = centerY - h/2 - 8;
        const menuBottom = centerY + h/2 + 8;
        
        // Calculate dropdown position (same as in draw function)
        const sliderStartX = centerX - w/2 + 20;  // Match new coordinates
        const sliderHeight = 20;
        const sliderSpacing = 35;  // Match new spacing
        let dropdownY = centerY - h/2 + 50;
        dropdownY += sliderSpacing; // After slider 1
        dropdownY += sliderSpacing; // After slider 2
        dropdownY += sliderSpacing + 10; // After slider 3, position at dropdown
        
        const dropdownHeight = 24;
        const dropdownWidth = w - 100;  // Adjust for new slider width
        const renderTypes = ['drawSpheres', 'drawDiscs', 'drawCircles', 'drawRings', 'drawGummies'];
        
        // If dropdown is expanded, check dropdown options FIRST (before menu bounds)
        // This allows clicking options that extend outside the menu
        if (particlesMenuRenderTypeExpanded) {
            for (let i = 0; i < renderTypes.length; i++) {
                const optionY = dropdownY + i * dropdownHeight;
                if (mouseX >= sliderStartX && mouseX <= sliderStartX + dropdownWidth &&
                    mouseY >= optionY && mouseY <= optionY + dropdownHeight - 2) {
                    return 'renderType_' + i;
                }
            }
        }
        
        // Check if inside menu bounds - skip when already dragging
        if (!particlesMenuDragging) {
            if (mouseX < menuLeft || mouseX > menuRight || mouseY < menuTop || mouseY > menuBottom) {
                return null;
            }
        }
        
        // Check close button
        const closeButtonX = centerX - w/2 - borderPadding + 20;
        const closeButtonY = centerY - h/2 - 8 + 20;
        const closeButtonRadius = 12;
        const distToClose = Math.sqrt((mouseX - closeButtonX)**2 + (mouseY - closeButtonY)**2);
        if (distToClose <= closeButtonRadius) {
            return 'close';
        }
        
        // Check sliders (reuse sliderStartX already defined above)
        const sliderWidth = w - 80;  // Match new slider width
        let currentY = centerY - h/2 + 50;
        
        // Quantity slider - check centered like physics menu
        if (mouseX >= sliderStartX && mouseX <= sliderStartX + sliderWidth &&
            mouseY >= currentY - sliderHeight/2 && mouseY <= currentY + sliderHeight/2) {
            return 'quantity';
        }
        currentY += sliderSpacing;
        
        // Small radius slider
        if (mouseX >= sliderStartX && mouseX <= sliderStartX + sliderWidth &&
            mouseY >= currentY - sliderHeight/2 && mouseY <= currentY + sliderHeight/2) {
            return 'smallRadius';
        }
        currentY += sliderSpacing;
        
        // Large radius slider
        if (mouseX >= sliderStartX && mouseX <= sliderStartX + sliderWidth &&
            mouseY >= currentY - sliderHeight/2 && mouseY <= currentY + sliderHeight/2) {
            return 'largeRadius';
        }
        currentY += sliderSpacing + 10;
        
        // Check render type dropdown (collapsed state only - expanded already checked above)
        if (!particlesMenuRenderTypeExpanded) {
            // Check just the collapsed dropdown header
            if (mouseX >= sliderStartX && mouseX <= sliderStartX + dropdownWidth &&
                mouseY >= currentY && mouseY <= currentY + dropdownHeight - 2) {
                return 'renderTypeToggle';
            }
        }
        
        // If clicked within menu bounds but not on any control, allow dragging
        return 'drag';
    }
    
    function updateGravityMenuPosition() {
        // Position to the right of physics menu with spacing
        const spacing = 30; // Gap between menus
        
        // Get physics menu right edge
        const physicsMenuRight = physicsMenuCenterX + physicsMenuWidth / 2;
        const gravityMenuSize = gravityMenuRadius * 2 + 50;
        gravityMenuX = physicsMenuRight + spacing + gravityMenuSize / 2;
        
        // Adjust Y position to align tops with other menus
        // Gravity menu draws background at centerY - size/2 - 38
        // Other menus draw background at centerY - height/2 - 8
        // Fine-tuned to align tops perfectly
        gravityMenuY = canvas.height / 2 + 22;
    }
    
    function handleColorWheelInteraction(canvasX, canvasY) {
        if (!colorWheelVisible) return false;
        
        const size = colorWheelSize;
        const centerX = colorWheelCenterX;
        const centerY = colorWheelCenterY;
        const radius = colorWheelRadius;
        
        // Define control positions
        const barX = centerX + radius + 32;
        const barY = centerY - radius;
        const barWidth = 20;
        const barHeight = radius * 2;
        
        const velBarX = centerX - radius + 14;
        const velBarY = centerY + radius + 20;
        const velBarWidth = radius * 2;
        const velBarHeight = 20;
        
        const persBarX = centerX - radius + 14;
        const persBarY = centerY + radius + 57;
        const persBarWidth = radius * 2;
        const persBarHeight = 20;
        
        const wheelDrawX = centerX - radius - 2 + 12;
        const wheelDrawY = centerY - radius - 2;
        const actualWheelCenterX = wheelDrawX + radius + 2;
        const actualWheelCenterY = wheelDrawY + radius + 2;
        
        // If already dragging a specific control, update that control regardless of mouse position
        if (colorWheelDragging && colorWheelDraggingControl) {
            if (colorWheelDraggingControl === 'sensitivity') {
                const velPos = Math.max(0, Math.min(1, (canvasX - velBarX) / velBarWidth));
                colorWheelVelMap = Math.round(velPos * 500);
                physProps.velColorMap = colorWheelVelMap;
                return 'color';
            } else if (colorWheelDraggingControl === 'persistence') {
                const persPos = Math.max(0, Math.min(1, (canvasX - persBarX) / persBarWidth));
                colorWheelPersistence = Math.round(persPos * 30);
                persistence = colorWheelPersistence;
                return 'color';
            } else if (colorWheelDraggingControl === 'lightness') {
                const lightPos = Math.max(0, Math.min(1, (canvasY - barY) / barHeight));
                colorWheelLight = Math.round(100 - lightPos * 95 + 5);
                ballLightness = colorWheelLight;
                return 'color';
            } else if (colorWheelDraggingControl === 'wheel') {
                const dx = canvasX - actualWheelCenterX;
                const dy = canvasY - actualWheelCenterY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                let angle = Math.atan2(dy, dx) * 180 / Math.PI;
                if (angle < 0) angle += 360;
                
                colorWheelHue = Math.round(angle);
                colorWheelSat = Math.round(Math.min(100, (distance / radius) * 100));
                
                physProps.baseColor = colorWheelHue;
                ballSaturation = colorWheelSat;
                return 'color';
            }
        }
        
        // Check close button - only when not dragging
        if (!colorWheelDragging) {
            const closeButtonX = centerX - radius + 12;
            const closeButtonY = centerY - radius - 18;
            const closeButtonRadius = 12;
            const dxClose = canvasX - closeButtonX;
            const dyClose = canvasY - closeButtonY;
            const distClose = Math.sqrt(dxClose * dxClose + dyClose * dyClose);
            
            if (distClose <= closeButtonRadius) {
                colorWheelTargetOpacity = 0;
                colorWheelAnimating = true;
                return true;
            }
            
            // Check if within expanded color wheel area
            if (canvasX < centerX - radius - 20 || canvasX > centerX + radius + 55 ||
                canvasY < centerY - radius - 38 || canvasY > centerY + radius + 88) {
                return false;
            }
        }
        
        // Determine which control was clicked (for initial drag)
        if (canvasX >= velBarX - 5 && canvasX <= velBarX + velBarWidth + 5 &&
            canvasY >= velBarY - 5 && canvasY <= velBarY + velBarHeight + 5) {
            colorWheelDraggingControl = 'sensitivity';
            const velPos = Math.max(0, Math.min(1, (canvasX - velBarX) / velBarWidth));
            colorWheelVelMap = Math.round(velPos * 500);
            physProps.velColorMap = colorWheelVelMap;
            return 'color';
        } else if (canvasX >= persBarX - 5 && canvasX <= persBarX + persBarWidth + 5 &&
            canvasY >= persBarY - 5 && canvasY <= persBarY + persBarHeight + 5) {
            colorWheelDraggingControl = 'persistence';
            const persPos = Math.max(0, Math.min(1, (canvasX - persBarX) / persBarWidth));
            colorWheelPersistence = Math.round(persPos * 30);
            persistence = colorWheelPersistence;
            return 'color';
        } else if (canvasX >= barX - 5 && canvasX <= barX + barWidth + 5 &&
            canvasY >= barY && canvasY <= barY + barHeight) {
            colorWheelDraggingControl = 'lightness';
            const lightPos = Math.max(0, Math.min(1, (canvasY - barY) / barHeight));
            colorWheelLight = Math.round(100 - lightPos * 95 + 5);
            ballLightness = colorWheelLight;
            return 'color';
        } else {
            const dx = canvasX - actualWheelCenterX;
            const dy = canvasY - actualWheelCenterY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance <= radius) {
                colorWheelDraggingControl = 'wheel';
                let angle = Math.atan2(dy, dx) * 180 / Math.PI;
                if (angle < 0) angle += 360;
                
                colorWheelHue = Math.round(angle);
                colorWheelSat = Math.round((distance / radius) * 100);
                
                physProps.baseColor = colorWheelHue;
                ballSaturation = colorWheelSat;
                return 'color';
            }
        }
        
        // If clicked inside the border but not on wheel/slider/close, it's a drag area
        return 'drag';
    }
    
    function handlePhysicsMenuInteraction(canvasX, canvasY) {
        if (!physicsMenuVisible) return false;
        
        const w = physicsMenuWidth;
        const h = physicsMenuHeight;
        const centerX = physicsMenuCenterX;
        const centerY = physicsMenuCenterY;
        const checkboxPadding = 8;
        const sliderSpacing = 35;
        const sliderStartX = centerX - w/2 + 35;
        const sliderWidth = w - 50;
        const sliderHeight = 20;
        
        // If already dragging a specific slider, update it regardless of mouse position
        if (physicsMenuDragging && physicsMenuDraggingControl) {
            const percent = Math.max(0, Math.min(1, (canvasX - sliderStartX) / sliderWidth));
            
            if (physicsMenuDraggingControl === 'repulsionForce') {
                physicsMenuRepulsionForce = 1 + percent * (20 - 1);
                physProps.repulsionForce = physicsMenuRepulsionForce / 10;
                return 'slider';
            } else if (physicsMenuDraggingControl === 'repulsionDist') {
                physicsMenuRepulsionDist = percent * 10;
                physProps.repulsionDist = physicsMenuRepulsionDist;
                return 'slider';
            } else if (physicsMenuDraggingControl === 'ballRest') {
                physicsMenuBallRest = Math.round(percent * 100);
                physProps.ballRest = physicsMenuBallRest / 100;
                if (physicsMenuBallRest > 0) {
                    physicsMenuBounceOn = true;
                } else {
                    physicsMenuBounceOn = false;
                }
                return 'slider';
            } else if (physicsMenuDraggingControl === 'time') {
                physicsMenuTime = 500 + percent * (1000 - 500);
                physProps.dt = 1 / (Math.floor(Math.exp(((140 - 0.1 * physicsMenuTime) / 10))) + 6);
                return 'slider';
            } else if (physicsMenuDraggingControl === 'speed') {
                physicsMenuSpeed = 1 + percent * (50 - 1);
                physProps.maxSpeed = 0.1 * physicsMenuSpeed;
                return 'slider';
            } else if (physicsMenuDraggingControl === 'substeps') {
                const substepsSliderWidth = sliderWidth / 2;
                const substepsPercent = Math.max(0, Math.min(1, (canvasX - sliderStartX) / substepsSliderWidth));
                physicsMenuSubsteps = Math.round(1 + substepsPercent * 3);
                physicsMenuSubsteps = Math.max(1, Math.min(4, physicsMenuSubsteps));
                updateSubsteps(physicsMenuSubsteps);
                return 'slider';
            }
        }
        
        // Check if click is within physics menu bounds - skip if already dragging
        if (!physicsMenuDragging) {
            if (canvasX < centerX - w/2 || canvasX > centerX + w/2 ||
                canvasY < centerY - h/2 || canvasY > centerY + h/2) {
                return false;
            }
            
            // Check close button - only when not dragging
            const closeButtonX = centerX - w/2 + 15;
            const closeButtonY = centerY - h/2 + 15;
            const closeButtonRadius = 12;
            const closeDistX = canvasX - closeButtonX;
            const closeDistY = canvasY - closeButtonY;
            if (Math.sqrt(closeDistX * closeDistX + closeDistY * closeDistY) < closeButtonRadius) {
                physicsMenuTargetOpacity = 0;
                physicsMenuAnimating = true;
                return 'close';
            }
        }
        
        // Track Y position for each control
        let currentY = centerY - h/2 + 50;
        
        // 1. Repulsion Force slider and checkbox
        const repulsionCheckX = centerX - w/2 + checkboxPadding;
        const repulsionCheckSize = 14;
        
        // Check repulsion checkbox
        if (canvasX >= repulsionCheckX && canvasX <= repulsionCheckX + repulsionCheckSize &&
            canvasY >= currentY - repulsionCheckSize/2 && canvasY <= currentY + repulsionCheckSize/2) {
            physicsMenuRepulsionOn = !physicsMenuRepulsionOn;
            ballRepulsion = physicsMenuRepulsionOn;
            return 'checkbox';
        }
        
        // Check repulsion slider
        if (canvasX >= sliderStartX && canvasX <= sliderStartX + sliderWidth &&
            canvasY >= currentY - sliderHeight/2 && canvasY <= currentY + sliderHeight/2) {
            physicsMenuDraggingControl = 'repulsionForce';
            const percent = (canvasX - sliderStartX) / sliderWidth;
            physicsMenuRepulsionForce = 1 + percent * (20 - 1);
            physProps.repulsionForce = physicsMenuRepulsionForce / 10;
            return 'slider';
        }
        
        currentY += sliderSpacing;
        
        // 2. Repulsion Distance slider
        if (canvasX >= sliderStartX && canvasX <= sliderStartX + sliderWidth &&
            canvasY >= currentY - sliderHeight/2 && canvasY <= currentY + sliderHeight/2) {
            physicsMenuDraggingControl = 'repulsionDist';
            const percent = (canvasX - sliderStartX) / sliderWidth;
            physicsMenuRepulsionDist = percent * 10;
            physProps.repulsionDist = physicsMenuRepulsionDist;
            return 'slider';
        }
        
        currentY += sliderSpacing;
        
        // 3. Ball Rest (Restitution) slider and checkbox
        // Check bounce checkbox
        if (canvasX >= repulsionCheckX && canvasX <= repulsionCheckX + repulsionCheckSize &&
            canvasY >= currentY - repulsionCheckSize/2 && canvasY <= currentY + repulsionCheckSize/2) {
            physicsMenuBounceOn = !physicsMenuBounceOn;
            physicsMenuBallRest = physicsMenuBounceOn ? 85 : 0;
            physProps.ballRest = physicsMenuBallRest / 100;
            return 'checkbox';
        }
        
        // Check ball rest slider
        if (canvasX >= sliderStartX && canvasX <= sliderStartX + sliderWidth &&
            canvasY >= currentY - sliderHeight/2 && canvasY <= currentY + sliderHeight/2) {
            physicsMenuDraggingControl = 'ballRest';
            const percent = (canvasX - sliderStartX) / sliderWidth;
            physicsMenuBallRest = Math.round(percent * 100);
            physProps.ballRest = physicsMenuBallRest / 100;
            if (physicsMenuBallRest > 0) {
                physicsMenuBounceOn = true;
            } else {
                physicsMenuBounceOn = false;
            }
            return 'slider';
        }
        
        currentY += sliderSpacing;
        
        // 4. Time slider
        if (canvasX >= sliderStartX && canvasX <= sliderStartX + sliderWidth &&
            canvasY >= currentY - sliderHeight/2 && canvasY <= currentY + sliderHeight/2) {
            physicsMenuDraggingControl = 'time';
            const percent = (canvasX - sliderStartX) / sliderWidth;
            physicsMenuTime = 500 + percent * (1000 - 500);
            physProps.dt = 1 / (Math.floor(Math.exp(((140 - 0.1 * physicsMenuTime) / 10))) + 6);
            return 'slider';
        }
        
        currentY += sliderSpacing;
        
        // 5. Speed Limit slider
        if (canvasX >= sliderStartX && canvasX <= sliderStartX + sliderWidth &&
            canvasY >= currentY - sliderHeight/2 && canvasY <= currentY + sliderHeight/2) {
            physicsMenuDraggingControl = 'speed';
            const percent = (canvasX - sliderStartX) / sliderWidth;
            physicsMenuSpeed = 1 + percent * (50 - 1);
            physProps.maxSpeed = 0.1 * physicsMenuSpeed;
            return 'slider';
        }
        
        currentY += sliderSpacing;
        
        // 6. Substeps slider (half width, 4 detents)
        const substepsSliderWidth = sliderWidth / 2;
        if (canvasX >= sliderStartX && canvasX <= sliderStartX + substepsSliderWidth &&
            canvasY >= currentY - sliderHeight/2 && canvasY <= currentY + sliderHeight/2) {
            physicsMenuDraggingControl = 'substeps';
            const percent = (canvasX - sliderStartX) / substepsSliderWidth;
            // Snap to 4 detents: 1, 2, 3, 4
            physicsMenuSubsteps = Math.round(1 + percent * 3);
            physicsMenuSubsteps = Math.max(1, Math.min(4, physicsMenuSubsteps));
            updateSubsteps(physicsMenuSubsteps);
            return 'slider';
        }
        
        // FPS toggle button
        const fpsButtonX = sliderStartX + substepsSliderWidth + 40;
        const fpsButtonY = currentY;
        const fpsButtonWidth = 50;
        const fpsButtonHeight = 28;
        
        if (canvasX >= fpsButtonX && canvasX <= fpsButtonX + fpsButtonWidth &&
            canvasY >= fpsButtonY - fpsButtonHeight/2 && canvasY <= fpsButtonY + fpsButtonHeight/2) {
            physicsMenuFpsOn = !physicsMenuFpsOn;
            toggleFPS();
            return 'button';
        }
        
        // If clicked inside the border but not on slider/checkbox/close, it's a drag area
        return 'drag';
    }
    
    function handleParticlesMenuInteraction(canvasX, canvasY) {
        if (!particlesMenuVisible) return false;
        
        const sliderStartX = particlesMenuCenterX - particlesMenuWidth/2 + 20;
        const sliderWidth = particlesMenuWidth - 80;
        
        // If already dragging a specific slider, update it regardless of mouse position
        if (particlesMenuDragging && particlesMenuDraggingControl) {
            const percent = Math.max(0, Math.min(1, (canvasX - sliderStartX) / sliderWidth));
            
            if (particlesMenuDraggingControl === 'quantity') {
                particlesMenuQuantity = Math.round(1 + percent * 99);
                adjustParticleCount(particlesMenuQuantity * particlesMenuQuantity);
                return 'slider';
            } else if (particlesMenuDraggingControl === 'smallRadius') {
                const newSmallRadius = Math.round(percent * 50);
                particlesMenuSmallRadius = Math.min(newSmallRadius, particlesMenuLargeRadius - 1);
                rescaleBalls();
                return 'slider';
            } else if (particlesMenuDraggingControl === 'largeRadius') {
                particlesMenuLargeRadius = Math.round(1 + percent * 49);
                if (particlesMenuSmallRadius >= particlesMenuLargeRadius) {
                    particlesMenuSmallRadius = Math.max(0, particlesMenuLargeRadius - 1);
                }
                rescaleBalls();
                return 'slider';
            }
        }
        
        const hitTest = particlesMenuHitTest(canvasX, canvasY);
        if (!hitTest) return false;
        
        // Handle close button
        if (hitTest === 'close') {
            particlesMenuTargetOpacity = 0;
            particlesMenuAnimating = true;
            return 'close';
        }
        
        // Handle sliders - set which control is being dragged
        if (hitTest === 'quantity') {
            particlesMenuDraggingControl = 'quantity';
            const percent = Math.max(0, Math.min(1, (canvasX - sliderStartX) / sliderWidth));
            particlesMenuQuantity = Math.round(1 + percent * 99);
            adjustParticleCount(particlesMenuQuantity * particlesMenuQuantity);
            return 'slider';
        }
        
        if (hitTest === 'smallRadius') {
            particlesMenuDraggingControl = 'smallRadius';
            const percent = Math.max(0, Math.min(1, (canvasX - sliderStartX) / sliderWidth));
            const newSmallRadius = Math.round(percent * 50);
            // Ensure small radius stays below large radius
            particlesMenuSmallRadius = Math.min(newSmallRadius, particlesMenuLargeRadius - 1);
            rescaleBalls();
            return 'slider';
        }
        
        if (hitTest === 'largeRadius') {
            particlesMenuDraggingControl = 'largeRadius';
            const percent = Math.max(0, Math.min(1, (canvasX - sliderStartX) / sliderWidth));
            particlesMenuLargeRadius = Math.round(1 + percent * 49);
            // Ensure small is less than large
            if (particlesMenuSmallRadius >= particlesMenuLargeRadius) {
                particlesMenuSmallRadius = Math.max(0, particlesMenuLargeRadius - 1);
            }
            rescaleBalls();
            return 'slider';
        }
        
        // Handle render type dropdown toggle
        if (hitTest === 'renderTypeToggle') {
            particlesMenuRenderTypeExpanded = !particlesMenuRenderTypeExpanded;
            return 'dropdown';
        }
        
        // Handle render type selection
        if (hitTest.startsWith('renderType_')) {
            const index = parseInt(hitTest.split('_')[1]);
            const renderTypes = ['drawSpheres', 'drawDiscs', 'drawCircles', 'drawRings', 'drawGummies'];
            particlesMenuRenderType = renderTypes[index];
            setRenderType(particlesMenuRenderType);
            particlesMenuRenderTypeExpanded = false; // Collapse dropdown after selection
            return 'renderType';
        }
        
        return hitTest; // 'drag'
    }
    
    // Event listeners for HTML elements removed - now handled by main menu in canvas
    
    // Mouse move handler for color wheel dragging
    function colorWheelMouseMove(e) {
        const bounds = canvas.getBoundingClientRect();
        const mX = e.clientX - bounds.left - canvas.clientLeft;
        const mY = e.clientY - bounds.top - canvas.clientTop;
        handleColorWheelInteraction(mX, mY);
    }
    
    // Mouse move handler for color wheel position dragging
    function colorWheelPositionMove(e) {
        const bounds = canvas.getBoundingClientRect();
        const mX = e.clientX - bounds.left - canvas.clientLeft;
        const mY = e.clientY - bounds.top - canvas.clientTop;
        colorWheelCenterX = mX - colorWheelDragOffsetX;
        colorWheelCenterY = mY - colorWheelDragOffsetY;
    }
    
    // Mouse move handler for physics menu dragging
    function physicsMenuMouseMove(e) {
        const bounds = canvas.getBoundingClientRect();
        const mX = e.clientX - bounds.left - canvas.clientLeft;
        const mY = e.clientY - bounds.top - canvas.clientTop;
        handlePhysicsMenuInteraction(mX, mY);
    }
    
    // Mouse move handler for physics menu position dragging
    function physicsMenuPositionMove(e) {
        const bounds = canvas.getBoundingClientRect();
        const mX = e.clientX - bounds.left - canvas.clientLeft;
        const mY = e.clientY - bounds.top - canvas.clientTop;
        physicsMenuCenterX = mX - physicsMenuDragOffsetX;
        physicsMenuCenterY = mY - physicsMenuDragOffsetY;
    }
    
    // Mouse move handler for particles menu dragging
    function particlesMenuMouseMove(e) {
        const bounds = canvas.getBoundingClientRect();
        const mX = e.clientX - bounds.left - canvas.clientLeft;
        const mY = e.clientY - bounds.top - canvas.clientTop;
        handleParticlesMenuInteraction(mX, mY);
    }
    
    // Mouse move handler for particles menu position dragging
    function particlesMenuPositionMove(e) {
        const bounds = canvas.getBoundingClientRect();
        const mX = e.clientX - bounds.left - canvas.clientLeft;
        const mY = e.clientY - bounds.top - canvas.clientTop;
        particlesMenuCenterX = mX - particlesMenuDragOffsetX;
        particlesMenuCenterY = mY - particlesMenuDragOffsetY;
    }
    
    // Mouse move handler for walls menu dragging
    function wallsMenuMouseMove(e) {
        const bounds = canvas.getBoundingClientRect();
        const mX = e.clientX - bounds.left - canvas.clientLeft;
        const mY = e.clientY - bounds.top - canvas.clientTop;
        handleWallsMenuInteraction(mX, mY);
    }
    
    // Mouse move handler for walls menu position dragging
    function wallsMenuPositionMove(e) {
        const bounds = canvas.getBoundingClientRect();
        const mX = e.clientX - bounds.left - canvas.clientLeft;
        const mY = e.clientY - bounds.top - canvas.clientTop;
        wallsMenuCenterX = mX - wallsMenuDragOffsetX;
        wallsMenuCenterY = mY - wallsMenuDragOffsetY;
    }
    
    // Touch handlers for particles menu
    function touchParticlesMenuMove(e) {
        if (e.touches.length === 1) {
            const bounds = canvas.getBoundingClientRect();
            const mX = e.touches[0].clientX - bounds.left - canvas.clientLeft;
            const mY = e.touches[0].clientY - bounds.top - canvas.clientTop;
            handleParticlesMenuInteraction(mX, mY);
        }
    }
    
    function touchParticlesMenuPositionMove(e) {
        if (e.touches.length === 1) {
            const bounds = canvas.getBoundingClientRect();
            const mX = e.touches[0].clientX - bounds.left - canvas.clientLeft;
            const mY = e.touches[0].clientY - bounds.top - canvas.clientTop;
            particlesMenuCenterX = mX - particlesMenuDragOffsetX;
            particlesMenuCenterY = mY - particlesMenuDragOffsetY;
        }
    }
    
    // Touch handlers for walls menu
    function touchWallsMenuMove(e) {
        if (e.touches.length === 1) {
            const bounds = canvas.getBoundingClientRect();
            const mX = e.touches[0].clientX - bounds.left - canvas.clientLeft;
            const mY = e.touches[0].clientY - bounds.top - canvas.clientTop;
            handleWallsMenuInteraction(mX, mY);
        }
    }
    
    function touchWallsMenuPositionMove(e) {
        if (e.touches.length === 1) {
            const bounds = canvas.getBoundingClientRect();
            const mX = e.touches[0].clientX - bounds.left - canvas.clientLeft;
            const mY = e.touches[0].clientY - bounds.top - canvas.clientTop;
            wallsMenuCenterX = mX - wallsMenuDragOffsetX;
            wallsMenuCenterY = mY - wallsMenuDragOffsetY;
        }
    }
    
    // Mouse move handler for gravity menu dragging
    function gravityMenuMouseMove(e) {
        const bounds = canvas.getBoundingClientRect();
        const mX = e.clientX - bounds.left - canvas.clientLeft;
        const mY = e.clientY - bounds.top - canvas.clientTop;
        handleGravityMenuInteraction(mX, mY);
    }
    
    // Mouse move handler for gravity menu position dragging
    function gravityMenuPositionMove(e) {
        const bounds = canvas.getBoundingClientRect();
        const mX = e.clientX - bounds.left - canvas.clientLeft;
        const mY = e.clientY - bounds.top - canvas.clientTop;
        gravityMenuX = mX - gravityMenuDragOffsetX;
        gravityMenuY = mY - gravityMenuDragOffsetY;
    }
    
    // Touch handlers for gravity menu
    function touchGravityMenuMove(e) {
        if (e.touches.length === 1) {
            const bounds = canvas.getBoundingClientRect();
            const mX = e.touches[0].clientX - bounds.left - canvas.clientLeft;
            const mY = e.touches[0].clientY - bounds.top - canvas.clientTop;
            handleGravityMenuInteraction(mX, mY);
        }
    }
    
    function touchGravityMenuPositionMove(e) {
        if (e.touches.length === 1) {
            const bounds = canvas.getBoundingClientRect();
            const mX = e.touches[0].clientX - bounds.left - canvas.clientLeft;
            const mY = e.touches[0].clientY - bounds.top - canvas.clientTop;
            gravityMenuX = mX - gravityMenuDragOffsetX;
            gravityMenuY = mY - gravityMenuDragOffsetY;
        }
    }
    
    // Mouse move handler for respawn menu position dragging
    function respawnMenuPositionMove(e) {
        const bounds = canvas.getBoundingClientRect();
        const mX = e.clientX - bounds.left - canvas.clientLeft;
        const mY = e.clientY - bounds.top - canvas.clientTop;
        respawnMenuCenterX = mX - respawnMenuDragOffsetX;
        respawnMenuCenterY = mY - respawnMenuDragOffsetY;
    }
    
    function touchRespawnMenuPositionMove(e) {
        if (e.touches.length === 1) {
            const bounds = canvas.getBoundingClientRect();
            const mX = e.touches[0].clientX - bounds.left - canvas.clientLeft;
            const mY = e.touches[0].clientY - bounds.top - canvas.clientTop;
            respawnMenuCenterX = mX - respawnMenuDragOffsetX;
            respawnMenuCenterY = mY - respawnMenuDragOffsetY;
        }
    }
    
    // Mouse move handler for toys menu position dragging
    function toysMenuPositionMove(e) {
        const bounds = canvas.getBoundingClientRect();
        const mX = e.clientX - bounds.left - canvas.clientLeft;
        const mY = e.clientY - bounds.top - canvas.clientTop;
        toysMenuCenterX = mX - toysMenuDragOffsetX;
        toysMenuCenterY = mY - toysMenuDragOffsetY;
    }
    
    function touchToysMenuPositionMove(e) {
        if (e.touches.length === 1) {
            const bounds = canvas.getBoundingClientRect();
            const mX = e.touches[0].clientX - bounds.left - canvas.clientLeft;
            const mY = e.touches[0].clientY - bounds.top - canvas.clientTop;
            toysMenuCenterX = mX - toysMenuDragOffsetX;
            toysMenuCenterY = mY - toysMenuDragOffsetY;
        }
    }
    
    // Note: Cluster and array layout controls moved to respawn menu
    // Note: showBumperEntry is now handled by the toys menu
    // Note: All toy controls are now handled by the toys menu system
    // Toy event handlers have been moved to the toys menu interaction handler
    
    // Flying puck button handler - moved to toys menu
    // Note: All toy event handlers moved to toys menu system
    
    // Note: Toy initialization moved to toys menu system
    // All toy elements are now handled through the toys menu
    
    // Heart button handler - moved to toys menu
    // Cycle puck button handler - moved to toys menu 
    // Orbit button handler - moved to toys menu
    // Yin-Yang button handler - moved to toys menu
    
    // Three-state logic for orbit functionality (variables needed by toys menu)
    let orbitState = 0; // 0 = off, 1 = normal, -1 = reverse
    
    // Three-state logic for yin-yang functionality (variables needed by toys menu)
    let yinYangState = 0; // 0 = off, 1 = normal, -1 = reverse
    
    // Three-state logic for worm functionality (variables needed by toys menu)
    let wormState = 0; // 0 = off, 1 = spheres, 2 = curves
    
    // Event listeners for removed HTML elements are now handled by main menu in canvas
    
    // Worm variables (needed for worm functionality in toys menu)
    var wormRenderMode = 'spheres'; // default
    var wormOutlinePoints = { top: [], bottom: [], headCenter: null, headRadius: 0 }; // Store outline for collision
           
    function setRenderType(renderType) {
       if (renderType === 'drawSpheres') {
            doSpheres = true;
            doDiscs = false;
            doCircles = false;
            doRings = false;
            colorWheelSat = 80;
            ballSaturation = 80;
            colorWheelLight = 55;
            ballLightness = 45;
            physProps.repulsionDist = 4;
            if (wasGummi == true) {
                particlesMenuQuantity = 64;
                particlesMenuLargeRadius = 15;
                particlesMenuSmallRadius = 3;
                wasGummi = false;
                makeBalls();
            }
       } else if (renderType === 'drawDiscs') {
            doDiscs = true;
            doSpheres = false;
            doCircles = false;
            doRings = false;
            colorWheelSat = 80;
            ballSaturation = 80;
            colorWheelLight = 40;
            ballLightness = 40;
            physProps.repulsionDist = 4;
            if (wasGummi == true) {
                particlesMenuQuantity = 64;
                particlesMenuLargeRadius = 15;
                particlesMenuSmallRadius = 3;
                wasGummi = false;
                makeBalls();
            }
       } else if (renderType === 'drawCircles') {
            doCircles = true;
            doDiscs = false;
            doSpheres = false;
            doRings = false;
            colorWheelSat = 50;
            ballSaturation = 50;
            colorWheelLight = 45;
            ballLightness = 50;
            physProps.repulsionDist = 4;
            if (wasGummi == true) {
                particlesMenuQuantity = 64;
                particlesMenuLargeRadius = 15;
                particlesMenuSmallRadius = 3;
                physicsMenuRepulsionForce = 20;
                physProps.repulsionForce = 2.0;
                wasGummi = false;
                makeBalls();
            }
        } else if (renderType === 'drawRings') {
            doRings = true;
            doGummi = false;
            doCircles = false;
            doDiscs = false;
            doSpheres = false;
            colorWheelSat = 100;
            ballSaturation = 100;
            colorWheelLight = 70;
            ballLightness = 70;
            physProps.repulsionDist = 4;
            if (wasGummi == true) {
                particlesMenuQuantity = 64;
                particlesMenuLargeRadius = 15;
                particlesMenuSmallRadius = 3;
                physicsMenuRepulsionForce = 20;
                physProps.repulsionForce = 2.0;
                wasGummi = false;
                makeBalls();
            }
       } else if (renderType === 'drawGummies') {
            doGummi = true;
            doRings = false;
            wasGummi = true;
            doDiscs = false;
            doSpheres = false;
            doCircles = false;
            colorWheelSat = 100;
            ballSaturation = 100;
            colorWheelLight = 70;
            ballLightness = 70;
            physProps.repulsionDist = 1.5;
            particlesMenuQuantity = 15;
            particlesMenuLargeRadius = 80;
            particlesMenuSmallRadius = 20;
            physicsMenuRepulsionForce = 10;
            physProps.repulsionForce = 1.0;
            makeBalls();
        }
    };

    // FPS toggle logic removed - now handled in physics menu button
    window.addEventListener('DOMContentLoaded', function() {
        // FPS counter initialization moved to physics menu handling
    });
    //  end get world properties from sliders ----------

    //  MOUSE STUFF AND TOUCH STUFF  -------------------------------------------------------------------
    
    let cursorX = simWidth / 2;
    let cursorY = 0;
    let newX = 0, newY = 0, startX = 0, startY = 0;
    let dX = 0, dY = 0; // Mouse offset for dragging
    let isBlowerAngleMode = false; // Track if user is adjusting blower angle vs moving it
    let blowerActive = true; // Track if blower is on (affecting particles) or off
    let isPuck0ResizeMode = false; // Track if user is resizing flying puck (Puck[2]) via grip
    let isPuck1ResizeMode = false; // Track if user is resizing orbit puck (Puck[3]) via grip
    let isPuck2ResizeMode = false; // Track if user is resizing heartbeat (Puck[0]) via grip
    let isPuck3ResizeMode = false; // Track if user is resizing cycle (Puck[1]) via grip
    let initialPuckRadius = 0; // Store initial radius when resize starts
    let initialMouseDist = 0; // Store initial mouse distance from puck center
    let isBumperScaleMode = false; // Track if user is scaling bumpers
    let bumperScaleStartX = 0; // Store initial X position for scaling
    let initialBumperRadius = 0; // Store initial bumper radius when scaling starts
    const BUMPER_SCALE_DEAD_ZONE = 20; // pixels of horizontal movement before scaling starts
    
    // Long-press detection for bumpers
    let longPressTimer = null;
    let longPressTriggeredOnBumper = false;
    let longPressStartPos = null;
    const LONG_PRESS_DURATION = 500; // milliseconds
    const LONG_PRESS_MOVE_THRESHOLD = 10; // pixels
    
    canvas.addEventListener('mousedown', mouseDownHandler);
    canvas.addEventListener('mouseup', mouseUp);
    canvas.addEventListener('contextmenu', handleContextMenu);
    canvas.addEventListener('touchstart', touchStartHandler, {passive: false});
    canvas.addEventListener('touchend', touchEndHandler, {passive: false});
    canvas.addEventListener('touchcancel', touchEndHandler, {passive: false});
    
    // Double-click anywhere on the canvas to restart the simulation without reloading the page
    /*canvas.addEventListener('dblclick', function(e) {
        // Only prevent restart if user is actively dragging for shower width adjustment
        if (isDoubleTapDrag) return;
        
        // Clear and rebuild the particle set (preserves UI state)
        if (typeof forcedWipeRestart === 'function') {
            forcedWipeRestart();
        } else if (typeof makeBalls === 'function') {
            makeBalls();
        }
        // If tracing is enabled, reselect the tracer so the trail restarts correctly
        if (typeof selectTracerBall === 'function' && typeof doTracer !== 'undefined') {
            if (doTracer && (doSmallTracer || doMediumTracer || doBigTracer)) {
                selectTracerBall();
            }
        }
    });*/
    
    function mouseDownHandler(ev) {
        const e = ev || window.event;
        
        // If another object is being interacted with, ignore this mousedown
        if (globalInteractionLock) {
            return;
        }
        
        // Calculate mouse position in canvas coordinates
        bounds = canvas.getBoundingClientRect();
        mX = e.clientX - bounds.left - canvas.clientLeft;
        mY = e.clientY - bounds.top - canvas.clientTop;
        
        // Check ellipsis button first (always visible)
        const ellipsisX = ellipsisMargin + ellipsisSize / 2;
        const ellipsisY = ellipsisMargin + ellipsisSize / 2;
        const distToEllipsis = Math.sqrt((mX - ellipsisX) ** 2 + (mY - ellipsisY) ** 2);
        
        if (distToEllipsis <= ellipsisSize / 2) {
            toggleMainMenu();
            return;
        }
        
        // Check main menu items if visible
        if (mainMenuVisible || mainMenuX > -calculateMainMenuWidth()) {
            const menuWidth = calculateMainMenuWidth();
            const itemWidth = 90;
            const itemSpacing = 10;
            const sidePadding = 20;
            const barY = mainMenuPadding;
            const menuHeight = mainMenuHeight;
            
            // Check if clicking within main menu bar
            if (mX >= mainMenuX && mX <= mainMenuX + menuWidth &&
                mY >= barY && mY <= barY + menuHeight) {
                
                // Determine which item was clicked
                let currentX = mainMenuX + sidePadding;
                
                for (const item of mainMenuItems) {
                    if (mX >= currentX && mX <= currentX + itemWidth) {
                        // Toggle the item
                        if (item.isPause) {
                            pause();
                        } else if (item.variable) {
                            // Toggle menu visibility
                            const currentValue = eval(item.variable);
                            const menuCheckboxId = item.id + 'MenuToggle';
                            
                            if (item.id === 'particles') {
                                particlesMenuVisible = !currentValue;
                                if (particlesMenuVisible) {
                                    if (typeof Balls !== 'undefined' && Array.isArray(Balls)) {
                                        particlesMenuQuantity = Math.round(Math.sqrt(Balls.length));
                                    }
                                    
                                    // Use stored position if manually moved, otherwise use default
                                    if (!particlesMenuManuallyMoved) {
                                        particlesMenuCenterX = defaultMenuPositions.particles.x * canvas.width;
                                        particlesMenuCenterY = defaultMenuPositions.particles.y * canvas.height;
                                        
                                        // Check if menu would overlap main menu bar
                                        const menuTopY = particlesMenuCenterY - particlesMenuHeight / 2;
                                        const mainMenuBottomY = mainMenuPadding + mainMenuHeight;
                                        
                                        if (menuTopY < mainMenuBottomY) {
                                            // Move below main menu with random gap
                                            const randomGap = 10 + Math.random() * 15; // 10-25px
                                            particlesMenuCenterY = mainMenuBottomY + randomGap + particlesMenuHeight / 2;
                                        }
                                    }
                                    
                                    particlesMenuTargetOpacity = 1;
                                    particlesMenuAnimating = true;
                                    bringMenuToFront('particlesMenu');
                                } else {
                                    particlesMenuTargetOpacity = 0;
                                    particlesMenuAnimating = true;
                                }
                            } else if (item.id === 'physics') {
                                physicsMenuVisible = !currentValue;
                                if (physicsMenuVisible) {
                                    // Use stored position if manually moved, otherwise use default
                                    if (!physicsMenuManuallyMoved) {
                                        physicsMenuCenterX = defaultMenuPositions.physics.x * canvas.width;
                                        physicsMenuCenterY = defaultMenuPositions.physics.y * canvas.height;
                                        
                                        // Check if menu would overlap main menu bar
                                        const menuTopY = physicsMenuCenterY - physicsMenuHeight / 2;
                                        const mainMenuBottomY = mainMenuPadding + mainMenuHeight;
                                        
                                        if (menuTopY < mainMenuBottomY) {
                                            // Move below main menu with random gap
                                            const randomGap = 10 + Math.random() * 15; // 10-25px
                                            physicsMenuCenterY = mainMenuBottomY + randomGap + physicsMenuHeight / 2;
                                        }
                                    }
                                    
                                    physicsMenuTargetOpacity = 1;
                                    physicsMenuAnimating = true;
                                    bringMenuToFront('physicsMenu');
                                    physicsMenuRepulsionForce = (physProps.repulsionForce || 2.0) * 10;
                                    physicsMenuRepulsionOn = ballRepulsion;
                                    physicsMenuBallRest = Math.round((physProps.ballRest || 0) * 100);
                                    physicsMenuBounceOn = (physProps.ballRest > 0);
                                    const substepsFromDt = Math.round((1 / physProps.dt) / 60);
                                    const expValue = substepsFromDt - 6;
                                    physicsMenuTime = expValue > 0 ? (140 - 10 * Math.log(expValue)) / 0.1 : 1000;
                                    physicsMenuSpeed = (physProps.maxSpeed || 2.0) / 0.1;
                                    physicsMenuSubsteps = physProps.substeps || 1;
                                } else {
                                    physicsMenuTargetOpacity = 0;
                                    physicsMenuAnimating = true;
                                }
                            } else if (item.id === 'gravity') {
                                gravityMenuVisible = !currentValue;
                                if (gravityMenuVisible) {
                                    // Use stored position if manually moved, otherwise use default
                                    if (!gravityMenuManuallyMoved) {
                                        gravityMenuX = defaultMenuPositions.gravity.x * canvas.width;
                                        gravityMenuY = defaultMenuPositions.gravity.y * canvas.height;
                                        
                                        // Check if menu would overlap main menu bar
                                        const gravityMenuSize = gravityMenuRadius * 2 + 50;
                                        const menuTopY = gravityMenuY - gravityMenuSize / 2;
                                        const mainMenuBottomY = mainMenuPadding + mainMenuHeight;
                                        
                                        if (menuTopY < mainMenuBottomY) {
                                            // Move below main menu with random gap
                                            const randomGap = 10 + Math.random() * 15; // 10-25px
                                            gravityMenuY = mainMenuBottomY + randomGap + gravityMenuSize / 2;
                                        }
                                    }
                                    
                                    gravityMenuTargetOpacity = 1;
                                    gravityMenuAnimating = true;
                                    bringMenuToFront('gravityMenu');
                                } else {
                                    gravityMenuTargetOpacity = 0;
                                    gravityMenuAnimating = true;
                                }
                            } else if (item.id === 'walls') {
                                wallsMenuVisible = !currentValue;
                                if (wallsMenuVisible) {
                                    // Use stored position if manually moved, otherwise use default
                                    if (!wallsMenuManuallyMoved) {
                                        wallsMenuCenterX = defaultMenuPositions.walls.x * canvas.width;
                                        wallsMenuCenterY = defaultMenuPositions.walls.y * canvas.height;
                                        
                                        // Check if menu would overlap main menu bar
                                        const menuTopY = wallsMenuCenterY - wallsMenuHeight / 2;
                                        const mainMenuBottomY = mainMenuPadding + mainMenuHeight;
                                        
                                        if (menuTopY < mainMenuBottomY) {
                                            // Move below main menu with random gap
                                            const randomGap = 10 + Math.random() * 15; // 10-25px
                                            wallsMenuCenterY = mainMenuBottomY + randomGap + wallsMenuHeight / 2;
                                        }
                                    }
                                    
                                    wallsMenuTargetOpacity = 1;
                                    wallsMenuAnimating = true;
                                    bringMenuToFront('wallsMenu');
                                } else {
                                    wallsMenuTargetOpacity = 0;
                                    wallsMenuAnimating = true;
                                }
                            } else if (item.id === 'respawn') {
                                respawnMenuVisible = !currentValue;
                                if (respawnMenuVisible) {
                                    // Use stored position if manually moved, otherwise use default
                                    if (!respawnMenuManuallyMoved) {
                                        respawnMenuCenterX = defaultMenuPositions.respawn.x * canvas.width;
                                        respawnMenuCenterY = defaultMenuPositions.respawn.y * canvas.height;
                                        
                                        // Check if menu would overlap main menu bar
                                        const menuTopY = respawnMenuCenterY - respawnMenuHeight / 2;
                                        const mainMenuBottomY = mainMenuPadding + mainMenuHeight;
                                        
                                        if (menuTopY < mainMenuBottomY) {
                                            // Move below main menu with random gap
                                            const randomGap = 10 + Math.random() * 15; // 10-25px
                                            respawnMenuCenterY = mainMenuBottomY + randomGap + respawnMenuHeight / 2;
                                        }
                                    }
                                    
                                    respawnMenuTargetOpacity = 1;
                                    respawnMenuAnimating = true;
                                    bringMenuToFront('respawnMenu');
                                } else {
                                    respawnMenuTargetOpacity = 0;
                                    respawnMenuAnimating = true;
                                }
                            } else if (item.id === 'toys') {
                                toysMenuVisible = !currentValue;
                                if (toysMenuVisible) {
                                    // Use stored position if manually moved, otherwise use default
                                    if (!toysMenuManuallyMoved) {
                                        toysMenuCenterX = defaultMenuPositions.toys.x * canvas.width;
                                        toysMenuCenterY = defaultMenuPositions.toys.y * canvas.height;
                                        
                                        // Check if menu would overlap main menu bar
                                        const menuTopY = toysMenuCenterY - toysMenuHeight / 2;
                                        const mainMenuBottomY = mainMenuPadding + mainMenuHeight;
                                        
                                        if (menuTopY < mainMenuBottomY) {
                                            // Move below main menu with random gap
                                            const randomGap = 10 + Math.random() * 15; // 10-25px
                                            toysMenuCenterY = mainMenuBottomY + randomGap + toysMenuHeight / 2;
                                        }
                                    }
                                    
                                    toysMenuTargetOpacity = 1;
                                    toysMenuAnimating = true;
                                    bringMenuToFront('toysMenu');
                                } else {
                                    toysMenuTargetOpacity = 0;
                                    toysMenuAnimating = true;
                                }
                            } else if (item.id === 'color') {
                                colorWheelVisible = !currentValue;
                                if (colorWheelVisible) {
                                    // Use stored position if manually moved, otherwise use default
                                    if (!colorWheelManuallyMoved) {
                                        colorWheelCenterX = defaultMenuPositions.colorWheel.x * canvas.width;
                                        colorWheelCenterY = defaultMenuPositions.colorWheel.y * canvas.height;
                                        
                                        // Check if menu would overlap main menu bar
                                        const menuTopY = colorWheelCenterY - colorWheelSize / 2;
                                        const mainMenuBottomY = mainMenuPadding + mainMenuHeight;
                                        
                                        if (menuTopY < mainMenuBottomY) {
                                            // Move below main menu with random gap
                                            const randomGap = 10 + Math.random() * 15; // 10-25px
                                            colorWheelCenterY = mainMenuBottomY + randomGap + colorWheelSize / 2;
                                        }
                                    }
                                    
                                    colorWheelTargetOpacity = 1;
                                    colorWheelAnimating = true;
                                    bringMenuToFront('colorWheel');
                                    colorWheelPersistence = persistence;
                                    colorWheelVelMap = physProps.velColorMap;
                                } else {
                                    colorWheelTargetOpacity = 0;
                                    colorWheelAnimating = true;
                                }
                            }
                        }
                        return;
                    }
                    currentX += itemWidth + itemSpacing;
                }
                
                // Clicked on main menu bar but not on any item - do nothing special
                return;
            }
        }
        
        // Check menus in reverse z-order (top to bottom) so topmost menu gets priority
        for (let i = menuDrawOrder.length - 1; i >= 0; i--) {
            const menuName = menuDrawOrder[i];
            
            if (menuName === 'colorWheel' && colorWheelVisible) {
                const handled = handleColorWheelInteraction(mX, mY);
                if (handled === 'color') {
                    globalInteractionLock = true;
                    bringMenuToFront('colorWheel');
                    colorWheelDragging = true;
                    document.addEventListener('mousemove', colorWheelMouseMove);
                    document.addEventListener('touchmove', touchColorWheelMove, {passive: false});
                    return;
                } else if (handled === 'drag') {
                    globalInteractionLock = true;
                    bringMenuToFront('colorWheel');
                    colorWheelPositionDragging = true;
                    colorWheelDragOffsetX = mX - colorWheelCenterX;
                    colorWheelDragOffsetY = mY - colorWheelCenterY;
                    document.addEventListener('mousemove', colorWheelPositionMove);
                    document.addEventListener('touchmove', touchColorWheelPositionMove, {passive: false});
                    return;
                }
            } else if (menuName === 'physicsMenu' && physicsMenuVisible) {
                const handled = handlePhysicsMenuInteraction(mX, mY);
                if (handled === 'slider' || handled === 'checkbox') {
                    globalInteractionLock = true;
                    bringMenuToFront('physicsMenu');
                    physicsMenuDragging = true;
                    document.addEventListener('mousemove', physicsMenuMouseMove);
                    document.addEventListener('touchmove', touchPhysicsMenuMove, {passive: false});
                    return;
                } else if (handled === 'button') {
                    globalInteractionLock = true;
                    bringMenuToFront('physicsMenu');
                    return;
                } else if (handled === 'drag') {
                    globalInteractionLock = true;
                    bringMenuToFront('physicsMenu');
                    physicsMenuPositionDragging = true;
                    physicsMenuDragOffsetX = mX - physicsMenuCenterX;
                    physicsMenuDragOffsetY = mY - physicsMenuCenterY;
                    document.addEventListener('mousemove', physicsMenuPositionMove);
                    document.addEventListener('touchmove', touchPhysicsMenuPositionMove, {passive: false});
                    return;
                }
            } else if (menuName === 'wallsMenu' && wallsMenuVisible) {
                const handled = handleWallsMenuInteraction(mX, mY);
                if (handled === 'slider' || handled === 'checkbox') {
                    globalInteractionLock = true;
                    bringMenuToFront('wallsMenu');
                    wallsMenuDragging = true;
                    document.addEventListener('mousemove', wallsMenuMouseMove);
                    document.addEventListener('touchmove', touchWallsMenuMove, {passive: false});
                    return;
                } else if (handled === 'close') {
                    globalInteractionLock = true;
                    bringMenuToFront('wallsMenu');
                    return;
                } else if (handled === 'drag') {
                    globalInteractionLock = true;
                    bringMenuToFront('wallsMenu');
                    wallsMenuPositionDragging = true;
                    wallsMenuDragOffsetX = mX - wallsMenuCenterX;
                    wallsMenuDragOffsetY = mY - wallsMenuCenterY;
                    wallsMenuManuallyMoved = true;
                    document.addEventListener('mousemove', wallsMenuPositionMove);
                    document.addEventListener('touchmove', touchWallsMenuPositionMove, {passive: false});
                    return;
                }
            } else if (menuName === 'respawnMenu' && respawnMenuVisible) {
                const handled = handleRespawnMenuInteraction(mX, mY);
                if (handled === 'checkbox' || handled === 'radio' || handled === 'dropdown') {
                    globalInteractionLock = true;
                    bringMenuToFront('respawnMenu');
                    return;
                } else if (handled === 'drag') {
                    globalInteractionLock = true;
                    bringMenuToFront('respawnMenu');
                    respawnMenuPositionDragging = true;
                    respawnMenuDragOffsetX = mX - respawnMenuCenterX;
                    respawnMenuDragOffsetY = mY - respawnMenuCenterY;
                    respawnMenuManuallyMoved = true;
                    document.addEventListener('mousemove', respawnMenuPositionMove);
                    document.addEventListener('touchmove', touchRespawnMenuPositionMove, {passive: false});
                    return;
                }
            } else if (menuName === 'toysMenu' && toysMenuVisible) {
                const handled = handleToysMenuInteraction(mX, mY);
                if (handled === 'toy' || handled === 'close') {
                    globalInteractionLock = true;
                    bringMenuToFront('toysMenu');
                    return;
                } else if (handled === 'drag') {
                    globalInteractionLock = true;
                    bringMenuToFront('toysMenu');
                    toysMenuPositionDragging = true;
                    toysMenuDragOffsetX = mX - toysMenuCenterX;
                    toysMenuDragOffsetY = mY - toysMenuCenterY;
                    toysMenuManuallyMoved = true;
                    document.addEventListener('mousemove', toysMenuPositionMove);
                    document.addEventListener('touchmove', touchToysMenuPositionMove, {passive: false});
                    return;
                }
            } else if (menuName === 'particlesMenu' && particlesMenuVisible) {
                const handled = handleParticlesMenuInteraction(mX, mY);
                if (handled === 'slider' || handled === 'renderType') {
                    globalInteractionLock = true;
                    bringMenuToFront('particlesMenu');
                    particlesMenuDragging = true;
                    document.addEventListener('mousemove', particlesMenuMouseMove);
                    document.addEventListener('touchmove', touchParticlesMenuMove, {passive: false});
                    return;
                } else if (handled === 'drag') {
                    globalInteractionLock = true;
                    bringMenuToFront('particlesMenu');
                    particlesMenuPositionDragging = true;
                    particlesMenuDragOffsetX = mX - particlesMenuCenterX;
                    particlesMenuDragOffsetY = mY - particlesMenuCenterY;
                    document.addEventListener('mousemove', particlesMenuPositionMove);
                    document.addEventListener('touchmove', touchParticlesMenuPositionMove, {passive: false});
                    return;
                }
            } else if (menuName === 'gravityMenu' && gravityMenuVisible) {
                const handled = handleGravityMenuInteraction(mX, mY);
                if (handled === 'gravity' || handled === 'rotation-slider') {
                    globalInteractionLock = true;
                    bringMenuToFront('gravityMenu');
                    gravityMenuDragging = true;
                    document.addEventListener('mousemove', gravityMenuMouseMove);
                    document.addEventListener('touchmove', touchGravityMenuMove, {passive: false});
                    return;
                } else if (handled === 'drag') {
                    globalInteractionLock = true;
                    bringMenuToFront('gravityMenu');
                    gravityMenuPositionDragging = true;
                    gravityMenuDragOffsetX = mX - gravityMenuX;
                    gravityMenuDragOffsetY = mY - gravityMenuY;
                    document.addEventListener('mousemove', gravityMenuPositionMove);
                    document.addEventListener('touchmove', touchGravityMenuPositionMove, {passive: false});
                    return;
                }
            }
        }
        
        // Clean up any existing listeners first to prevent duplicates
        document.removeEventListener('mousemove', mouseHungryPuckMove);
        document.removeEventListener('mousemove', mouseHungryPuck2Move);
        document.removeEventListener('mousemove', mouseBlowerMove);
        document.removeEventListener('mousemove', mousePuck0Move);
        document.removeEventListener('mousemove', mousePuck1Move);
        document.removeEventListener('mousemove', mousePuck2Move);
        document.removeEventListener('mousemove', mousePuck3Move);
        document.removeEventListener('mousemove', mousePuck0Resize);
        document.removeEventListener('mousemove', mousePuck1Resize);
        document.removeEventListener('mousemove', mousePuck2Resize);
        document.removeEventListener('mousemove', mousePuck3Resize);
        document.removeEventListener('mousemove', mouseDynamicPuckMove);
        document.removeEventListener('mousemove', mouseDynamicPuckResize);
        document.removeEventListener('mousemove', mouseMisterMisterMove);
        document.removeEventListener('mousemove', mouseBumperMove);
        document.removeEventListener('mousemove', setNewDir);
        document.removeEventListener('mousemove', doubleTapDragMove);
        document.removeEventListener('mousemove', misterSpeedDragMove);
        
        blower = Blower[0];
        hungryPuck = Hungrypuck[0];
        hungryPuck2 = Hungrypuck[1];
        misterMister = MisterMister[0];
        
        // Find special pucks by their properties - directly assign
        puck3 = Puck.find(p => p.heartBeat); // heartBeat puck
        puck4 = Puck.find(p => p.cycle); // cycle puck
        puck1 = Puck.find(p => !p.heartBeat && !p.cycle && !p.flying && !p.orbit && !p.yinyang); // first normal puck
        puck2 = puck1; // for compatibility

        bounds = canvas.getBoundingClientRect();
		mX = e.clientX - bounds.left - canvas.clientLeft;
        mY = e.clientY - bounds.top - canvas.clientTop;

		cursorX = mX / cScale;
        cursorY = (canvas.height - mY) / cScale;
        mousePos = new Vector2(cursorX, cursorY);

        startX = mX;
        startY = mY;

        firstCornerX = mX;
        firstCornerY = mY;
        
        // Long-press detection for bumpers
        longPressTriggeredOnBumper = false;
        longPressStartPos = { x: e.clientX, y: e.clientY };
        
        // Check if clicking on a bumper
        if (showBumpers && Bumpers.length > 0) {
            for (let i = 0; i < Bumpers.length; i++) {
                const bumper = Bumpers[i];
                const dx = cursorX - bumper.pos.x;
                const dy = cursorY - bumper.pos.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist <= bumper.radius) {
                    // Check if shift key is pressed for scaling mode
                    if (e.shiftKey) {
                        isBumperScaleMode = true;
                        bumperScaleStartX = e.clientX;
                        initialBumperRadius = bumperRadius;
                        document.addEventListener('mousemove', mouseBumperScale);
                        return; // Exit early, don't start long-press timer
                    }
                    
                    // Start long-press timer
                    longPressTimer = setTimeout(() => {
                        // If only one row remains, turn off bumpers instead of deleting
                        if (bumperRows <= 1) {
                            const bumperToy = toysMenuItems.find(item => item.id === 'showBumperEntry');
                            if (bumperToy) bumperToy.checked = false;
                            showBumpers = false;
                            return;
                        }
                        
                        longPressTriggeredOnBumper = true;
                        // Remove entire row of bumpers
                        const bumperY = bumper.pos.y;
                        const tolerance = 0.001;
                        const bumpersToRemove = [];
                        
                        for (let j = 0; j < Bumpers.length; j++) {
                            if (Math.abs(Bumpers[j].pos.y - bumperY) < tolerance) {
                                bumpersToRemove.push(j);
                            }
                        }
                        
                        // Remove in reverse order to maintain indices
                        for (let j = bumpersToRemove.length - 1; j >= 0; j--) {
                            Bumpers.splice(bumpersToRemove[j], 1);
                        }
                        
                        bumperRows--;
                    }, LONG_PRESS_DURATION);
                    
                    // Add mousemove listener to cancel long-press if mouse moves too much
                    document.addEventListener('mousemove', cancelLongPressOnMove);
                    break;
                }
            }
        }
        
        // ESTABLISH OBJECT DISTANCES TO MOUSE POSITION  ------------------------
        dirBlower = new Vector2();
		dirBlower.subtractVectors(mousePos, blower.pos);
		dBlower = dirBlower.length();
        
        dirHungryPuck = new Vector2();
		dirHungryPuck.subtractVectors(mousePos, hungryPuck.pos);
		dHungryPuck = dirHungryPuck.length();

        dirHungryPuck2 = new Vector2();
		dirHungryPuck2.subtractVectors(mousePos, hungryPuck2.pos);
		dHungryPuck2 = dirHungryPuck2.length();

        dirMisterMister = new Vector2();
		dirMisterMister.subtractVectors(mousePos, misterMister.pos);
		dMisterMister = dirMisterMister.length();

        dirPuck1 = new Vector2();
        if (puck1) {
            dirPuck1.subtractVectors(mousePos, puck1.pos);
            dPuck1 = dirPuck1.length();
        } else {
            dPuck1 = Infinity;
        }

        dirPuck2 = new Vector2();
        if (puck2) {
            dirPuck2.subtractVectors(mousePos, puck2.pos);
            dPuck2 = dirPuck2.length();
        } else {
            dPuck2 = Infinity;
        }

        // Check distance to grip indicators and buttons for all pucks dynamically
        let dPuck2Grip = Infinity;  // heartbeat puck
        let dPuck3Grip = Infinity;  // cycle puck
        
        // Calculate distances for heartbeat puck
        const heartbeatPuck = Puck.find(p => p.heartBeat);
        if (heartbeatPuck && heartbeatPuck.gripPos) {
            const dirPuck2Grip = new Vector2();
            dirPuck2Grip.subtractVectors(mousePos, heartbeatPuck.gripPos);
            dPuck2Grip = dirPuck2Grip.length();
        }
        // Calculate distances for cycle puck
        const cyclePuck = Puck.find(p => p.cycle);
        if (cyclePuck && cyclePuck.gripPos) {
            const dirPuck3Grip = new Vector2();
            dirPuck3Grip.subtractVectors(mousePos, cyclePuck.gripPos);
            dPuck3Grip = dirPuck3Grip.length();
        }

        dirPuck3 = new Vector2();
        if (puck3) {
            dirPuck3.subtractVectors(mousePos, puck3.pos);
            dPuck3 = dirPuck3.length();
        } else {
            dPuck3 = Infinity;
        }

        dirPuck4 = new Vector2();
        if (puck4) {
            dirPuck4.subtractVectors(mousePos, puck4.pos);
            dPuck4 = dirPuck4.length();
        } else {
            dPuck4 = Infinity;
        }

        if (showBumpers == true) {
            // Calculate bumper array bounds if bumpers exist
            var bumperArrayBottom = -Infinity;
            var bumperArrayTop = Infinity;
            if (Bumpers.length > 0) {
                var lowestBumper = Bumpers[0];
                var highestBumper = Bumpers[Bumpers.length - 1];
                bumperArrayBottom = lowestBumper.pos.y - lowestBumper.radius;
                bumperArrayTop = highestBumper.pos.y + highestBumper.radius;
            }
        }
        
    // CHOOSE FOREGROUND OBJECTS UNDER CURSOR TO MOVE  --------------------- 
        if (dMisterMister < misterMister.radius) {
            dX = startX / cScale - misterMister.pos.x;
            dY = (simHeight - startY / cScale) - misterMister.pos.y;
            document.addEventListener('mousemove', mouseMisterMisterMove);
            document.addEventListener('touchmove', touchMisterMisterMove, {passive: false});
        } else {
        if (dHungryPuck2 < hungryPuck2.radius) {
            dX = startX / cScale - hungryPuck2.pos.x;
            dY = (simHeight - startY / cScale) - hungryPuck2.pos.y;
            document.addEventListener('mousemove', mouseHungryPuck2Move);
            document.addEventListener('touchmove', touchHungryPuck2Move, {passive: false});
        } else {
		if (dHungryPuck < hungryPuck.radius) {
            dX = startX / cScale - hungryPuck.pos.x;
            dY = (simHeight - startY / cScale) - hungryPuck.pos.y;
            document.addEventListener('mousemove', mouseHungryPuckMove);
            document.addEventListener('touchmove', touchHungryPuckMove, {passive: false});
        } else {
        if (puck3 && dPuck2Grip < 0.08) {
            // Clicking on puck3's (heartbeat) resize grip
            isPuck2ResizeMode = true;
            initialPuckRadius = puck3.radius;
            initialMouseDist = dPuck3;
            document.addEventListener('mousemove', mousePuck2Resize);
        } else if (puck3 && dPuck3 < puck3.radius) {
            dX = startX / cScale - puck3.pos.x;
            dY = (simHeight - startY / cScale) - puck3.pos.y;
            mouseDown = true;
            document.addEventListener('mousemove', mousePuck2Move);
            document.addEventListener('touchmove', touchPuck2Move, {passive: false});
        } else {
        if (puck4 && dPuck3Grip < 0.08) {
            // Clicking on puck4's (cycle) resize grip
            isPuck3ResizeMode = true;
            initialPuckRadius = puck4.radius;
            initialMouseDist = dPuck4;
            document.addEventListener('mousemove', mousePuck3Resize);
        } else if (puck4 && dPuck4 < puck4.radius) {
            dX = startX / cScale - puck4.pos.x;
            dY = (simHeight - startY / cScale) - puck4.pos.y;
            mouseDown = true;
            document.addEventListener('mousemove', mousePuck3Move);
            document.addEventListener('touchmove', touchPuck3Move, {passive: false});
        } else {
        // Check all normal pucks dynamically for button and grip clicks
        // Find the closest match across all normal pucks
        let normalPuckHandled = false;
        let closestPlusIndex = -1, closestPlusDist = Infinity;
        let closestMinusIndex = -1, closestMinusDist = Infinity;
        let closestGripIndex = -1, closestGripDist = Infinity;
        let closestBodyIndex = -1, closestBodyDist = Infinity;
        
        for (let i = 0; i < Puck.length; i++) {
            const puck = Puck[i];
            if (!puck || puck.heartBeat || puck.cycle || puck.flying || puck.orbit || puck.yinyang) {
                continue; // Skip special pucks
            }
            
            // Calculate distances for this normal puck
            if (puck.plusPos) {
                const dirPlus = new Vector2();
                dirPlus.subtractVectors(mousePos, puck.plusPos);
                const dPlus = dirPlus.length();
                if (dPlus < closestPlusDist) {
                    closestPlusDist = dPlus;
                    closestPlusIndex = i;
                }
            }
            if (puck.minusPos) {
                const dirMinus = new Vector2();
                dirMinus.subtractVectors(mousePos, puck.minusPos);
                const dMinus = dirMinus.length();
                if (dMinus < closestMinusDist) {
                    closestMinusDist = dMinus;
                    closestMinusIndex = i;
                }
            }
            if (puck.gripPos) {
                const dirGrip = new Vector2();
                dirGrip.subtractVectors(mousePos, puck.gripPos);
                const dGrip = dirGrip.length();
                if (dGrip < closestGripDist) {
                    closestGripDist = dGrip;
                    closestGripIndex = i;
                }
            }
            const dirBody = new Vector2();
            dirBody.subtractVectors(mousePos, puck.pos);
            const dBody = dirBody.length();
            if (dBody < puck.radius && dBody < closestBodyDist) {
                closestBodyDist = dBody;
                closestBodyIndex = i;
            }
        }
        
        // Check arrow button distance
        let closestArrowDist = Infinity;
        let closestArrowIndex = -1;
        for (let i = 0; i < Puck.length; i++) {
            const puck = Puck[i];
            if (!puck.heartBeat && !puck.cycle && !puck.flying && !puck.orbit && !puck.yinyang && puck.arrowPos) {
                const dx = mousePos.x - puck.arrowPos.x;
                const dy = mousePos.y - puck.arrowPos.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < closestArrowDist) {
                    closestArrowDist = dist;
                    closestArrowIndex = i;
                }
            }
        }
        
        // Check off button distance
        let closestOffDist = Infinity;
        let closestOffIndex = -1;
        for (let i = 0; i < Puck.length; i++) {
            const puck = Puck[i];
            if (!puck.heartBeat && !puck.cycle && !puck.flying && !puck.orbit && !puck.yinyang && puck.offPos) {
                const dx = mousePos.x - puck.offPos.x;
                const dy = mousePos.y - puck.offPos.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < closestOffDist) {
                    closestOffDist = dist;
                    closestOffIndex = i;
                }
            }
        }
        
        // Now check which action to take based on closest match
        // Use scaled detection radius for buttons (0.12 * puck radius for better precision on small pucks)
        const plusButtonRadius = closestPlusIndex >= 0 ? 0.12 * Puck[closestPlusIndex].radius : Infinity;
        const minusButtonRadius = closestMinusIndex >= 0 ? 0.12 * Puck[closestMinusIndex].radius : Infinity;
        const offButtonRadius = closestOffIndex >= 0 ? 0.12 * Puck[closestOffIndex].radius : Infinity;
        const arrowButtonRadius = closestArrowIndex >= 0 ? 0.15 * Puck[closestArrowIndex].radius : Infinity;
        const gripRadius = closestGripIndex >= 0 ? 0.12 * Puck[closestGripIndex].radius : Infinity;
        
        if (closestPlusDist < plusButtonRadius) {
            duplicateNormalPuck(closestPlusIndex);
            normalPuckHandled = true;
        } else if (closestMinusDist < minusButtonRadius) {
            deleteNormalPuck(closestMinusIndex);
            normalPuckHandled = true;
        } else if (closestOffDist < offButtonRadius) {
            // Turn off all normal pucks and update the toys menu puck button
            const button = document.getElementById('showPuckButton');
            if (button) {
                button.checked = false;
                button.className = 'checkbox-puck';
                button.title = 'Pucks';
            }
            // Also update the toysMenuItems state so the icon is dimmed
            const puckToy = toysMenuItems.find(item => item && item.id === 'showPuckButton');
            if (puckToy) puckToy.checked = false;
            doOscillatePucks = false;
            showPucks = false;
            // Hide all normal pucks
            for (var p = 0; p < Puck.length; p++) {
                if (!Puck[p].heartBeat && !Puck[p].cycle && !Puck[p].flying && !Puck[p].orbit && !Puck[p].yinyang) {
                    Puck[p].radius = 0;
                    Puck[p].puckArriving = false;
                }
            }
            normalPuckHandled = true;
        } else if (closestArrowDist < arrowButtonRadius) {
            // Toggle oscillation mode
            doOscillatePucks = !doOscillatePucks;
            
            if (doOscillatePucks) {
                // Starting oscillation - ensure pucks are visible
                for (var p = 0; p < Puck.length; p++) {
                    if (!Puck[p].heartBeat && !Puck[p].cycle && !Puck[p].flying && !Puck[p].orbit && !Puck[p].yinyang) {
                        if (!Puck[p].OGradius || Puck[p].OGradius <= 0) {
                            Puck[p].OGradius = 0.3;
                        }
                    }
                }
            } else {
                // Stopping oscillation - reset properties
                for (let i = 0; i < Puck.length; i++) {
                    const puck = Puck[i];
                    if (!puck.heartBeat && !puck.cycle && !puck.flying && !puck.orbit && !puck.yinyang) {
                        puck.oscInit = false;
                        puck.oscOriginX = undefined;
                        puck.oscAmplitude = undefined;
                        puck.oscCenterX = undefined;
                        puck.oscStartTime = undefined;
                        puck.oscPhaseOffset = undefined;
                    }
                }
            }
            normalPuckHandled = true;
        } else if (closestGripDist < gripRadius) {
            activeResizePuckIndex = closestGripIndex;
            initialPuckRadius = Puck[closestGripIndex].radius;
            const dirBody = new Vector2();
            dirBody.subtractVectors(mousePos, Puck[closestGripIndex].pos);
            initialMouseDist = dirBody.length();
            document.addEventListener('mousemove', mouseDynamicPuckResize);
            normalPuckHandled = true;
        } else if (closestBodyIndex >= 0) {
            const puck = Puck[closestBodyIndex];
            
            // If clicking on an oscillating puck, stop oscillation
            if (doOscillatePucks) {
                doOscillatePucks = false;
                
                // Reset oscillation properties
                for (let i = 0; i < Puck.length; i++) {
                    const p = Puck[i];
                    if (!p.heartBeat && !p.cycle && !p.flying && !p.orbit && !p.yinyang) {
                        p.oscInit = false;
                        p.oscOriginX = undefined;
                        p.oscAmplitude = undefined;
                        p.oscCenterX = undefined;
                        p.oscStartTime = undefined;
                        p.oscPhaseOffset = undefined;
                    }
                }
                normalPuckHandled = true;
            } else {
                // Normal drag behavior when not oscillating
                dX = startX / cScale - puck.pos.x;
                dY = (simHeight - startY / cScale) - puck.pos.y;
                mouseDown = true;
                activeDragPuckIndex = closestBodyIndex;
                document.addEventListener('mousemove', mouseDynamicPuckMove);
                document.addEventListener('touchmove', touchDynamicPuckMove, {passive: false});
                normalPuckHandled = true;
            }
        }
        if (!normalPuckHandled) {
            if (dBlower < 2.0 * blower.radius) {
                // Check if clicking on blower yellow suspend button (only in state 1)
                if (blowerState === 1) {
                    const suspendButtonX = blower.pos.x + Math.cos(Math.PI + blower.blowerAngle) * 1.0 * blower.radius;
                    const suspendButtonY = blower.pos.y + Math.sin(Math.PI + blower.blowerAngle) * 1.0 * blower.radius;
                    const dSuspendButton = Math.sqrt(
                        Math.pow(mousePos.x - suspendButtonX, 2) + 
                        Math.pow(mousePos.y - suspendButtonY, 2)
                    );
                    if (dSuspendButton < 0.15 * blower.radius) {
                        // Toggle blower active state
                        blowerActive = !blowerActive;
                        e.preventDefault();
                        return; // Don't proceed with other blower interactions
                    }
                    const offButtonX = blower.pos.x + Math.cos(Math.PI + blower.blowerAngle) * 1.35 * blower.radius;
                    const offButtonY = blower.pos.y + Math.sin(Math.PI + blower.blowerAngle) * 1.35 * blower.radius;
                    const dOffButton = Math.sqrt(
                        Math.pow(mousePos.x - offButtonX, 2) + 
                        Math.pow(mousePos.y - offButtonY, 2)
                    );
                    if (dOffButton < 0.15 * blower.radius) {
                            // Turn blower completely off and hide it
                            blower.active = false;
                            if (typeof blowerState !== 'undefined') blowerState = 0;
                            // Update the toys menu blower icon
                            var blowerButton = document.getElementById('showBlowerButton');
                            if (blowerButton) {
                               blowerButton.checked = false;
                               blowerButton.className = 'checkbox-blower';
                               blowerButton.title = 'Blower';
                               blowerButton.setAttribute('data-state', 0);
                            }
                            var blowerToy = toysMenuItems && toysMenuItems.find(item => item && item.id === 'showBlowerButton');
                            if (blowerToy) blowerToy.checked = false;
                            e.preventDefault();
                            return; // Don't proceed with other blower interactions
                    }
                }
                
                // Check if click is in outer half of radius (angle mode) or inner half (move mode)
                if (dBlower > 0.5 * blower.radius) {
                    // Outer: adjust angle mode
                    isBlowerAngleMode = true;
                } else {
                    // Inner: move mode
                    isBlowerAngleMode = false;
                    dX = startX / cScale - blower.pos.x;
                    dY = (simHeight - startY / cScale) - blower.pos.y;
                }
                document.addEventListener('mousemove', mouseBlowerMove);
                document.addEventListener('touchmove', touchBlowerMove, {passive: false});
            } else if (showBumpers == true && Bumpers.length > 0 && mousePos.y < bumperArrayTop && mousePos.y > bumperArrayBottom) {
                // Check if shift key is pressed for scaling mode
                if (e.shiftKey) {
                    isBumperScaleMode = true;
                    bumperScaleStartX = e.clientX;
                    initialBumperRadius = bumperRadius;
                    document.addEventListener('mousemove', mouseBumperScale);
                } else {
                    dY = (simHeight - startY / cScale) - (bumperArrayTop + bumperArrayBottom) / 2;
                    // Store initial positions of all bumpers for relative movement
                    initialBumperPositions = [];
                    for (var i = 0; i < Bumpers.length; i++) {
                        initialBumperPositions[i] = Bumpers[i].pos.y;
                    }
                    document.addEventListener('mousemove', mouseBumperMove);
                    document.addEventListener('touchmove', touchBumperMove, {passive: false});
                }
            } else {
                // Nothing else selected: handle shower, fountain, or spray direction
                if (doShower) {
                    // Single click in shower mode: set shower position and start drag for width control
                    if (doGravityDown || doGravityUp || (!doGravityDown && !doGravityUp && !doGravityLeft && !doGravityRight)) {
                        // Gravity is up/down or none (default down): set X position
                        customShowerPos = cursorX;
                    } else if (doGravityLeft || doGravityRight) {
                        // Gravity is left/right: set Y position  
                        customShowerPos = cursorY;
                    }
                    
                    // Start drag mode for shower width control
                    isDoubleTapDrag = true;
                    dragStartX = cursorX;
                    dragStartY = cursorY;
                    initialDumpSqueeze = dumpSqueeze;
                    document.addEventListener('mousemove', doubleTapDragMove);
                    document.addEventListener('touchmove', doubleTapDragMoveTouch, {passive: false});
                } else if (doFountain) {
                    // Fountain mode: update spray direction immediately and start drag for misterSpeed control
                    setNewDir(e);
                    mouseDown = true;
                    isMisterSpeedDrag = true;
                    misterDragStartX = cursorX;
                    initialMisterSpeed = misterSpeed;
                    document.addEventListener('mousemove', misterSpeedDragMove);
                    document.addEventListener('touchmove', misterSpeedDragMoveTouch, {passive: false});
                } else {
                    // Not in shower mode: update spray direction immediately and start tracking drag
                    setNewDir(e);
                    mouseDown = true;
                    document.addEventListener('mousemove', setNewDir, false);
                    document.addEventListener('touchmove', setNewDir, {passive: false});
                }
                    const now = performance.now(); // Fix: define the missing 'now' variable
                    lastTapTime = now;
                    lastTapX = cursorX;
                    lastTapY = cursorY;
            }
        }
        }}}}}}

    function setNewDir(e) {
        const ev = e || window.event;
        if (!ev) return;
        const rect = canvas.getBoundingClientRect();
        const clientX = ev.clientX;
        const clientY = ev.clientY;
        if (typeof clientX !== 'number' || typeof clientY !== 'number') return;

        // Convert to simulation coordinates
        const mx = (clientX - rect.left - canvas.clientLeft) / cScale;
        const my = (canvas.height - (clientY - rect.top - canvas.clientTop)) / cScale;

        const misterMister = MisterMister[0];
        // Center of particle spawn region (use center, not random). Ignore ball.radius for direction.
        // spawnX center: mr.pos.x - 0.35R + 0.5*(0.9R) = mr.pos.x + 0.10R
        const originX = misterMister.pos.x + 0.10 * misterMister.radius;
        // spawnY center differs by mode:
        //  worm:    mr.pos.y - 0.30R  (from -0.3R - 0.35R + 0.5*0.7R)
        //  default: mr.pos.y - 0.70R  (from -0.65R - 0.35R + 0.5*0.6R)
        const originYOffset = (typeof mrMode === 'string' && mrMode === 'worm') ? 0.30 : 0.70;
        const originY = misterMister.pos.y - originYOffset * misterMister.radius;
        // Angle from spawn-region center to cursor
        misterMister.respawnDir = Math.atan2(my - originY, mx - originX);
        // Set yeet proportional to distance from fountain origin to cursor (clamped)
        const dx = mx - originX;
        const dy = my - originY;
        let dist = Math.sqrt(dx*dx + dy*dy);
        // Clamp and scale: min 0.1, max 2.0 (adjust as needed for feel)
        dist = Math.max(0.1, Math.min(2.0, dist));
        yeet = dist * 40; // 40 is a scaling factor for feel; adjust as needed
    }

    function doubleTapDragMove(event) {
        if (!isDoubleTapDrag) return;
        
        const bounds = canvas.getBoundingClientRect();
        const mX = event.clientX - bounds.left - canvas.clientLeft;
        const mY = event.clientY - bounds.top - canvas.clientTop;
        const cursorX = mX / cScale;
        const cursorY = (canvas.height - mY) / cScale;
        
        // Calculate drag delta based on gravity direction (2x sensitivity)
        let dragDistance;
        if (doGravityDown || doGravityUp || (!doGravityDown && !doGravityUp && !doGravityLeft && !doGravityRight)) {
            // Horizontal drag for vertical gravity
            dragDistance = (cursorX - dragStartX) / (simWidth * 0.5);
        } else {
            // Vertical drag for horizontal gravity  
            dragDistance = (cursorY - dragStartY) / (simHeight * 0.5);
        }
        
        // Update dumpSqueeze based on drag (right/up = increase, left/down = decrease)
        dumpSqueeze = initialDumpSqueeze + dragDistance;
        dumpSqueeze = Math.max(0.1, Math.min(1.0, dumpSqueeze)); // Clamp to 0.1-1.0 range
    }

    function doubleTapDragMoveTouch(event) {
        if (!isDoubleTapDrag || event.touches.length === 0) return;
        event.preventDefault();
        
        const touch = event.touches[0];
        const bounds = canvas.getBoundingClientRect();
        const mX = touch.clientX - bounds.left - canvas.clientLeft;
        const mY = touch.clientY - bounds.top - canvas.clientTop;
        const cursorX = mX / cScale;
        const cursorY = (canvas.height - mY) / cScale;
        
        // Calculate drag delta based on gravity direction (2x sensitivity)
        let dragDistance;
        if (doGravityDown || doGravityUp || (!doGravityDown && !doGravityUp && !doGravityLeft && !doGravityRight)) {
            // Horizontal drag for vertical gravity
            dragDistance = (cursorX - dragStartX) / (simWidth * 0.5);
        } else {
            // Vertical drag for horizontal gravity
            dragDistance = (cursorY - dragStartY) / (simHeight * 0.5);
        }
        
        // Update dumpSqueeze based on drag (right/up = increase, left/down = decrease)
        dumpSqueeze = initialDumpSqueeze + dragDistance;
        dumpSqueeze = Math.max(0.1, Math.min(1.0, dumpSqueeze)); // Clamp to 0.1-1.0 range
    }

    function misterSpeedDragMove(event) {
        if (!isMisterSpeedDrag) return;
        
        const bounds = canvas.getBoundingClientRect();
        const mX = event.clientX - bounds.left - canvas.clientLeft;
        const cursorX = mX / cScale;
        
        // Calculate drag delta (horizontal only, scaled to canvas width)
        const dragDistance = (cursorX - misterDragStartX) / (simWidth * 0.5);
        
        // Update misterSpeed based on drag (right = increase, left = decrease)
        // Range: 0.1 to 2.0, sensitivity adjusted for smooth control
        misterSpeed = initialMisterSpeed + dragDistance * 1.0; // 1.0 = sensitivity factor
        misterSpeed = Math.max(0.1, Math.min(2.0, misterSpeed)); // Clamp to 0.1-2.0 range
    }

    function misterSpeedDragMoveTouch(event) {
        if (!isMisterSpeedDrag || event.touches.length === 0) return;
        event.preventDefault();
        
        const touch = event.touches[0];
        const bounds = canvas.getBoundingClientRect();
        const mX = touch.clientX - bounds.left - canvas.clientLeft;
        const cursorX = mX / cScale;
        
        // Calculate drag delta (horizontal only, scaled to canvas width)
        const dragDistance = (cursorX - misterDragStartX) / (simWidth * 0.5);
        
        // Update misterSpeed based on drag (right = increase, left = decrease)
        // Range: 0.1 to 2.0, sensitivity adjusted for smooth control
        misterSpeed = initialMisterSpeed + dragDistance * 1.0; // 1.0 = sensitivity factor
        misterSpeed = Math.max(0.1, Math.min(2.0, misterSpeed)); // Clamp to 0.1-2.0 range
    }

    function cancelLongPressOnMove(event) {
        if (!longPressStartPos) return;
        
        const dx = event.clientX - longPressStartPos.x;
        const dy = event.clientY - longPressStartPos.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > LONG_PRESS_MOVE_THRESHOLD) {
            if (longPressTimer) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
            }
            document.removeEventListener('mousemove', cancelLongPressOnMove);
        }
    }

    function mouseBumperMove(event) {
        const rect = canvas.getBoundingClientRect();
        newY = event.clientY - rect.top;   
        var currentMouseY = (simHeight - newY / cScale);
        var targetCenterY = currentMouseY - dY;
        var initialCenterY = (initialBumperPositions[0] + initialBumperPositions[initialBumperPositions.length - 1]) / 2;
        var offsetY = targetCenterY - initialCenterY;
        
        for (var t = 0; t < Bumpers.length; t++) {
            bumper = Bumpers[t];
            bumper.pos.y = initialBumperPositions[t] + offsetY;
        }
    }
    
    function mouseBumperScale(event) {
        const deltaX = event.clientX - bumperScaleStartX;
        
        // Apply dead zone
        if (Math.abs(deltaX) < BUMPER_SCALE_DEAD_ZONE) {
            return; // Within dead zone, don't scale yet
        }
        
        // Calculate new radius based on horizontal movement
        // Sensitivity: every 100 pixels = 0.02 change in radius
        const effectiveDelta = deltaX > 0 ? deltaX - BUMPER_SCALE_DEAD_ZONE : deltaX + BUMPER_SCALE_DEAD_ZONE;
        const scaleFactor = effectiveDelta / 100 * 0.02;
        const newRadius = initialBumperRadius + scaleFactor;
        const clampedRadius = Math.max(0.020, Math.min(0.100, newRadius));
        
        updateBumperRadius(clampedRadius);
    }
    function mouseBlowerMove(event) {
        const rect = canvas.getBoundingClientRect();
        blower = Blower[0];
        newX = event.clientX - rect.left;
        newY = event.clientY - rect.top;   
        startX = event.clientX - rect.left;
        startY = event.clientY - rect.top;
        
        if (isBlowerAngleMode) {
            // Angle mode: calculate angle from blower center to mouse position
            var mouseWorldX = (newX / cScale) - (canvas.width / cScale / 2 - simWidth / 2);
            var mouseWorldY = (simHeight - newY / cScale) - (canvas.height / cScale / 2 - simHeight / 2);
            var deltaX = mouseWorldX - blower.pos.x;
            var deltaY = mouseWorldY - blower.pos.y;
            blower.blowerAngle = Math.atan2(deltaY, deltaX);
        } else {
            // Move mode: move the blower with the mouse
            blower.pos.x = (newX / cScale) - dX;
            blower.pos.y = (simHeight - newY / cScale) - dY;
        }
    }
    function mouseHungryPuckMove(event) {
        const rect = canvas.getBoundingClientRect();
        hungryPuck = Hungrypuck[0];
        newX = event.clientX - rect.left;
        newY = event.clientY - rect.top;   
        startX = event.clientX - rect.left;
        startY = event.clientY - rect.top;
        hungryPuck.pos.x = (newX / cScale) - dX;
        hungryPuck.pos.y = (simHeight - newY / cScale) - dY;
    }
    function mouseHungryPuck2Move(event) {
        const rect = canvas.getBoundingClientRect();
        hungryPuck2 = Hungrypuck[1];
        newX = event.clientX - rect.left;
        newY = event.clientY - rect.top;   
        startX = event.clientX - rect.left;
        startY = event.clientY - rect.top;
        hungryPuck2.pos.x = (newX / cScale) - dX;
        hungryPuck2.pos.y = (simHeight - newY / cScale) - dY;
    }
    function mouseMisterMisterMove(event) {
        const rect = canvas.getBoundingClientRect();
        misterMister = MisterMister[0];
        newX = event.clientX - rect.left;
        newY = event.clientY - rect.top;   
        startX = event.clientX - rect.left;
        startY = event.clientY - rect.top;
        misterMister.pos.x = (newX / cScale) - dX;
        misterMister.pos.y = (simHeight - newY / cScale) - dY;
    }
    function mousePuckMove(p) {
        return function(event) {
            const rect = canvas.getBoundingClientRect();
            puck = Puck[p];
            newX = event.clientX - rect.left;
            newY = event.clientY - rect.top;   
            startX = event.clientX - rect.left;
            startY = event.clientY - rect.top;
            puck.puckMoved = true;
            puck.moving = true;
            
            // Store previous position for velocity calculation
            puck.prevPos.set(puck.pos);
            
            // Update position
            puck.pos.x = (newX / cScale) - dX;
            puck.pos.y = (simHeight - newY / cScale) - dY;
            
            // Calculate velocity based on position change
            puck.vel.subtractVectors(puck.pos, puck.prevPos);
            // Scale velocity by frame rate approximation (assuming 60fps)
            puck.vel.scale(60);
        };
    }
    
    // Variables to track which puck is being interacted with
    var activeDragPuckIndex = -1;
    var activeResizePuckIndex = -1;
    
    // Dynamic move function for any normal puck
    function mouseDynamicPuckMove(event) {
        if (activeDragPuckIndex < 0 || activeDragPuckIndex >= Puck.length) return;
        const puck = Puck[activeDragPuckIndex];
        if (!puck) return;
        
        const rect = canvas.getBoundingClientRect();
        newX = event.clientX - rect.left;
        newY = event.clientY - rect.top;
        startX = event.clientX - rect.left;
        startY = event.clientY - rect.top;
        puck.puckMoved = true;
        puck.moving = true;
        
        // Store previous position for velocity calculation
        puck.prevPos.set(puck.pos);
        
        // Update position
        puck.pos.x = (newX / cScale) - dX;
        puck.pos.y = (simHeight - newY / cScale) - dY;
        
        // Calculate velocity based on position change
        puck.vel.subtractVectors(puck.pos, puck.prevPos);
        // Scale velocity by frame rate approximation (assuming 60fps)
        puck.vel.scale(60);
    }
    
    function touchDynamicPuckMove(event) {
        if (activeDragPuckIndex < 0 || activeDragPuckIndex >= Puck.length) return;
        const puck = Puck[activeDragPuckIndex];
        if (!puck || event.touches.length === 0) return;
        
        event.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const touch = event.touches[0];
        newX = touch.clientX - rect.left;
        newY = touch.clientY - rect.top;
        startX = touch.clientX - rect.left;
        startY = touch.clientY - rect.top;
        puck.puckMoved = true;
        puck.moving = true;
        
        puck.prevPos.set(puck.pos);
        puck.pos.x = (newX / cScale) - dX;
        puck.pos.y = (simHeight - newY / cScale) - dY;
        puck.vel.subtractVectors(puck.pos, puck.prevPos);
        puck.vel.scale(60);
    }
    
    // Dynamic resize function for any normal puck
    function mouseDynamicPuckResize(event) {
        if (activeResizePuckIndex < 0 || activeResizePuckIndex >= Puck.length) return;
        const puck = Puck[activeResizePuckIndex];
        if (!puck) return;
        
        const rect = canvas.getBoundingClientRect();
        const mouseX = (event.clientX - rect.left) / cScale;
        const mouseY = simHeight - (event.clientY - rect.top) / cScale;
        const mousePos = new Vector2(mouseX, mouseY);
        const dirFromCenter = new Vector2();
        dirFromCenter.subtractVectors(mousePos, puck.pos);
        const currentMouseDist = dirFromCenter.length();
        const radiusChange = currentMouseDist - initialMouseDist;
        puck.radius = Math.max(0.1, Math.min(2.0, initialPuckRadius + radiusChange));
        puck.OGradius = puck.radius;
    }
    
    // Create the specific puck move functions for special pucks
    // mousePuck2Move is for heartbeat (now at Puck[0])
    // mousePuck3Move is for cycle (now at Puck[1])
    var mousePuck2Move = mousePuckMove(0); // heartbeat puck
    var mousePuck3Move = mousePuckMove(1); // cycle puck
    var mousePuck0Move = mousePuckMove(2); // flying puck (legacy variable name)
    var mousePuck1Move = mousePuckMove(3); // orbit puck (legacy variable name)
    
    // Functions to duplicate and delete normal pucks
    function duplicateNormalPuck(puckIndex) {
        const originalPuck = Puck[puckIndex];
        if (!originalPuck || originalPuck.heartBeat || originalPuck.cycle || originalPuck.flying || originalPuck.orbit || originalPuck.yinyang) {
            return; // Only duplicate normal pucks
        }
        
        // Find a position that doesn't exactly match an existing puck
        const distance = 2.5 * originalPuck.radius;
        let angle = 0; // Start to the right (0 degrees)
        
        // Check if spawning to the right would go beyond canvas edge
        const testX = originalPuck.pos.x + distance;
        const rightEdge = simWidth;
        const maxAllowedX = rightEdge - 0.75 * originalPuck.radius;
        
        // If too close to edge, adjust initial angle
        if (testX > maxAllowedX) {
            angle = 0.25 * Math.PI; // 22.5 degrees counter-clockwise (/8 radians)
        }
        
        let attempts = 0;
        let newX, newY;
        let foundUniquePosition = false;
        
        while (attempts < 8 && !foundUniquePosition) { // Try up to 8 positions
            newX = originalPuck.pos.x + distance * Math.cos(angle);
            newY = originalPuck.pos.y + distance * Math.sin(angle);
            
            // Check if this exact position is occupied by an existing puck with same radius
            let positionOccupied = false;
            for (let i = 0; i < Puck.length; i++) {
                const existingPuck = Puck[i];
                const dx = Math.abs(newX - existingPuck.pos.x);
                const dy = Math.abs(newY - existingPuck.pos.y);
                
                // Consider position occupied if very close (within 0.01) and same radius
                if (dx < 0.01 && dy < 0.01 && Math.abs(existingPuck.radius - originalPuck.radius) < 0.01) {
                    positionOccupied = true;
                    break;
                }
            }
            
            if (!positionOccupied) {
                foundUniquePosition = true;
            } else {
                // Rotate 50 degrees counter-clockwise
                angle += 50 * Math.PI / 180; // 50 degrees in radians
                attempts++;
            }
        }
        
        // Create new puck at the found position
        const newPuck = new PUCK(
            originalPuck.radius,
            new Vector2(newX, newY),
            originalPuck.color,
            false
        );
        newPuck.OGradius = originalPuck.OGradius;
        Puck.push(newPuck);
    }
    
    function deleteNormalPuck(puckIndex) {
        // Count normal pucks
        let normalPuckCount = 0;
        for (let i = 0; i < Puck.length; i++) {
            const puck = Puck[i];
            if (!puck.heartBeat && !puck.cycle && !puck.flying && !puck.orbit && !puck.yinyang) {
                normalPuckCount++;
            }
        }
        
        // Don't delete if only one normal puck remains
        if (normalPuckCount <= 1) {
            return;
        }
        
        const puck = Puck[puckIndex];
        if (!puck || puck.heartBeat || puck.cycle || puck.flying || puck.orbit || puck.yinyang) {
            return; // Only delete normal pucks
        }
        
        Puck.splice(puckIndex, 1);
    }
    
    // Resize functions for puck0 and puck1
    function mousePuck0Resize(event) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = (event.clientX - rect.left) / cScale;
        const mouseY = simHeight - (event.clientY - rect.top) / cScale;
        const mousePos = new Vector2(mouseX, mouseY);
        const dirFromCenter = new Vector2();
        dirFromCenter.subtractVectors(mousePos, puck1.pos);
        const currentMouseDist = dirFromCenter.length();
        const radiusChange = currentMouseDist - initialMouseDist;
        puck1.radius = Math.max(0.1, Math.min(2.0, initialPuckRadius + radiusChange));
        puck1.OGradius = puck1.radius;
    }
    
    function mousePuck1Resize(event) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = (event.clientX - rect.left) / cScale;
        const mouseY = simHeight - (event.clientY - rect.top) / cScale;
        const mousePos = new Vector2(mouseX, mouseY);
        const dirFromCenter = new Vector2();
        dirFromCenter.subtractVectors(mousePos, puck2.pos);
        const currentMouseDist = dirFromCenter.length();
        const radiusChange = currentMouseDist - initialMouseDist;
        puck2.radius = Math.max(0.1, Math.min(2.0, initialPuckRadius + radiusChange));
        puck2.OGradius = puck2.radius;
    }
    
    function mousePuck2Resize(event) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = (event.clientX - rect.left) / cScale;
        const mouseY = simHeight - (event.clientY - rect.top) / cScale;
        const mousePos = new Vector2(mouseX, mouseY);
        const dirFromCenter = new Vector2();
        dirFromCenter.subtractVectors(mousePos, puck3.pos);
        const currentMouseDist = dirFromCenter.length();
        const radiusChange = currentMouseDist - initialMouseDist;
        puck3.radius = Math.max(0.1, Math.min(2.0, initialPuckRadius + radiusChange));
        puck3.OGradius = puck3.radius;
    }
    
    function mousePuck3Resize(event) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = (event.clientX - rect.left) / cScale;
        const mouseY = simHeight - (event.clientY - rect.top) / cScale;
        const mousePos = new Vector2(mouseX, mouseY);
        const dirFromCenter = new Vector2();
        dirFromCenter.subtractVectors(mousePos, puck4.pos);
        const currentMouseDist = dirFromCenter.length();
        const radiusChange = currentMouseDist - initialMouseDist;
        puck4.radius = Math.max(0.1, Math.min(2.0, initialPuckRadius + radiusChange));
        puck4.OGradius = puck4.radius;
    }
    
    function mouseUp() {
        // Release global interaction lock
        globalInteractionLock = false;
        
        // Clear long-press timer and remove move listener
        if (longPressTimer) {
            clearTimeout(longPressTimer);
            longPressTimer = null;
        }
        document.removeEventListener('mousemove', cancelLongPressOnMove);
        
        // Clear color wheel dragging
        colorWheelDragging = false;
        colorWheelDraggingControl = null;
        if (colorWheelPositionDragging) {
            colorWheelManuallyMoved = true;
        }
        colorWheelPositionDragging = false;
        document.removeEventListener('mousemove', colorWheelMouseMove);
        document.removeEventListener('touchmove', touchColorWheelMove);
        document.removeEventListener('mousemove', colorWheelPositionMove);
        document.removeEventListener('touchmove', touchColorWheelPositionMove);
        
        // Clear physics menu dragging
        physicsMenuDragging = false;
        physicsMenuDraggingControl = null;
        if (physicsMenuPositionDragging) {
            physicsMenuManuallyMoved = true;
        }
        physicsMenuPositionDragging = false;
        document.removeEventListener('mousemove', physicsMenuMouseMove);
        document.removeEventListener('touchmove', touchPhysicsMenuMove);
        document.removeEventListener('mousemove', physicsMenuPositionMove);
        document.removeEventListener('touchmove', touchPhysicsMenuPositionMove);
        
        // Clear particles menu dragging
        particlesMenuDragging = false;
        particlesMenuDraggingControl = null;
        if (particlesMenuPositionDragging) {
            particlesMenuManuallyMoved = true;
        }
        particlesMenuPositionDragging = false;
        document.removeEventListener('mousemove', particlesMenuMouseMove);
        document.removeEventListener('touchmove', touchParticlesMenuMove);
        document.removeEventListener('mousemove', particlesMenuPositionMove);
        document.removeEventListener('touchmove', touchParticlesMenuPositionMove);
        
        // Clear walls menu dragging
        wallsMenuDragging = false;
        wallsMenuDraggingControl = null;
        if (wallsMenuPositionDragging) {
            wallsMenuManuallyMoved = true;
        }
        wallsMenuPositionDragging = false;
        document.removeEventListener('mousemove', wallsMenuMouseMove);
        document.removeEventListener('touchmove', touchWallsMenuMove);
        document.removeEventListener('mousemove', wallsMenuPositionMove);
        document.removeEventListener('touchmove', touchWallsMenuPositionMove);
        
        // Clear respawn menu dragging
        respawnMenuDragging = false;
        if (respawnMenuPositionDragging) {
            respawnMenuManuallyMoved = true;
        }
        respawnMenuPositionDragging = false;
        document.removeEventListener('mousemove', respawnMenuPositionMove);
        document.removeEventListener('touchmove', touchRespawnMenuPositionMove);
        
        // Clear toys menu dragging
        toysMenuDragging = false;
        if (toysMenuPositionDragging) {
            toysMenuManuallyMoved = true;
        }
        toysMenuPositionDragging = false;
        document.removeEventListener('mousemove', toysMenuPositionMove);
        document.removeEventListener('touchmove', touchToysMenuPositionMove);
        
        // Clear gravity menu dragging
        gravityMenuDragging = false;
        gravityMenuDraggingControl = null;
        if (gravityMenuPositionDragging) {
            gravityMenuManuallyMoved = true;
        }
        gravityMenuPositionDragging = false;
        gravityRotationSliderDragging = false; // Reset rotation slider dragging
        document.removeEventListener('mousemove', gravityMenuMouseMove);
        document.removeEventListener('touchmove', touchGravityMenuMove);
        document.removeEventListener('mousemove', gravityMenuPositionMove);
        document.removeEventListener('touchmove', touchGravityMenuPositionMove);
        
        // Clear resize mode flags
        isPuck0ResizeMode = false;
        isPuck1ResizeMode = false;
        isPuck2ResizeMode = false;
        isPuck3ResizeMode = false;
        
        // Clear dynamic puck interaction indices
        activeDragPuckIndex = -1;
        activeResizePuckIndex = -1;
        mouseDown = false;
        isBlowerAngleMode = false;
        isBumperScaleMode = false;
        
        document.removeEventListener('mousemove', mouseHungryPuckMove);
        document.removeEventListener('mousemove', mouseHungryPuck2Move);
        document.removeEventListener('mousemove', mouseBlowerMove);
        document.removeEventListener('mousemove', mousePuck0Move);
        document.removeEventListener('mousemove', mousePuck1Move);
        document.removeEventListener('mousemove', mousePuck2Move);
        document.removeEventListener('mousemove', mousePuck3Move);
        document.removeEventListener('mousemove', mousePuck0Resize);
        document.removeEventListener('mousemove', mousePuck1Resize);
        document.removeEventListener('mousemove', mousePuck2Resize);
        document.removeEventListener('mousemove', mousePuck3Resize);
        document.removeEventListener('mousemove', mouseDynamicPuckMove);
        document.removeEventListener('mousemove', mouseDynamicPuckResize);
        document.removeEventListener('mousemove', mouseMisterMisterMove);
        document.removeEventListener('mousemove', mouseBumperMove);
        document.removeEventListener('mousemove', mouseBumperScale);
        document.removeEventListener('mousemove', setNewDir);
        document.removeEventListener('mousemove', doubleTapDragMove);
        
        // Also remove touch move listeners
        document.removeEventListener('touchmove', touchHungryPuckMove);
        document.removeEventListener('touchmove', touchHungryPuck2Move);
        document.removeEventListener('touchmove', touchBlowerMove);
        document.removeEventListener('touchmove', touchPuck0Move);
        document.removeEventListener('touchmove', touchPuck1Move);
        document.removeEventListener('touchmove', touchPuck2Move);
        document.removeEventListener('touchmove', touchPuck3Move);
        document.removeEventListener('touchmove', touchDynamicPuckMove);
        document.removeEventListener('touchmove', touchMisterMisterMove);
        document.removeEventListener('touchmove', touchBumperMove);
        document.removeEventListener('touchmove', doubleTapDragMoveTouch);
        document.removeEventListener('touchmove', misterSpeedDragMoveTouch);
        
        // Stop shower width drag mode
        isDoubleTapDrag = false;
        
        // Stop misterSpeed drag mode
        isMisterSpeedDrag = false;
        
        mouseDown = false;
        mouseUpTime = Date.now();
        const nowPerf = performance.now();
        for (var p = 0; p < Puck.length; p++) {
            if (Puck[p].puckMoved == true) {
                Puck[p].puckFadingIn = true;
                Puck[p].puckMoved = false;
                // If this is the heartBeat heart puck, reset heartbeat phase and delay 1s before resuming pulses
                if (Puck[p].heartBeat === true) {
                    Puck[p].hbResumeAt = nowPerf + heartResumeDelayMs; // delay after release
                    Puck[p].hbState = 'pause';
                    Puck[p].hbTimeInState = 0.0;
                    Puck[p].hbLastTime = nowPerf; // avoid dt spike
                    Puck[p].radius = Puck[p].OGradius; // ensure base size during pause
                }
                // If this is the cycle puck, pause cycling for 3s after release and restart at cycle beginning
                if (Puck[p].cycle === true) {
                    Puck[p].cycResumeAt = nowPerf + 5000; // 5 second delay
                    Puck[p].cycState = 'grow';
                    Puck[p].cycTimeInState = 0.0;
                    Puck[p].cycLastTime = nowPerf; // avoid dt spike
                    Puck[p].radius = Puck[p].OGradius; // hold at base size during pause
                }
            }
            Puck[p].moving = false;
        }
    }

    function handleContextMenu(event) {
        event.preventDefault(); // Prevent default context menu
        
        // Get mouse position
        const rect = canvas.getBoundingClientRect();
        const mouseX = (event.clientX - rect.left) / cScale;
        const mouseY = simHeight - (event.clientY - rect.top) / cScale;
        
        // Check if right-clicking on Blower
        if (blowerState >= 1 && Blower && Blower.length > 0) {
            const blower = Blower[0];
            const dx = mouseX - blower.pos.x;
            const dy = mouseY - blower.pos.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist <= blower.radius) {
                // Cycle through blower states: 1 -> 2 -> 3 -> 1
                if (blowerState === 1) {
                    blowerState = 2;
                } else if (blowerState === 2) {
                    blowerState = 3;
                } else {
                    blowerState = 1;
                }
                document.getElementById('showBlowerButton').setAttribute('data-state', blowerState);
                return;
            }
        }
        
        // Check if right-clicking on Mr. Mister (fountain spawner)
        if (doFountain && MisterMister && MisterMister.length > 0) {
            const mrMr = MisterMister[0];
            const dx = mouseX - mrMr.pos.x;
            const dy = mouseY - mrMr.pos.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist <= mrMr.radius) {
                // Cycle through fountain rotation modes: 1(normal) -> 2(sweep) -> 3(cw) -> 4(ccw) -> 1
                fountainState = (fountainState % 4) + 1;
                
                if (fountainState === 1) {
                    fountainSpinMode = null; // Normal mode
                } else if (fountainState === 2) {
                    fountainSpinMode = 'sweep';
                } else if (fountainState === 3) {
                    fountainSpinMode = 'cw';
                } else if (fountainState === 4) {
                    fountainSpinMode = 'ccw';
                }
                return;
            }
        }
        
        if (!showBumpers || Bumpers.length === 0) return;
        
        // Check if right-clicking on a bumper
        let clickedOnBumper = false;
        for (let i = 0; i < Bumpers.length; i++) {
            const bumper = Bumpers[i];
            const dx = mouseX - bumper.pos.x;
            const dy = mouseY - bumper.pos.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist <= bumper.radius) {
                // Remove this bumper
                Bumpers.splice(i, 1);
                clickedOnBumper = true;
                break; // Only remove one bumper per click
            }
        }
        
        // If didn't click on a bumper, check if clicked in bumper array area to add row
        if (!clickedOnBumper && Bumpers.length > 0) {
            // Calculate bumper array bounds
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (let i = 0; i < Bumpers.length; i++) {
                const b = Bumpers[i];
                minX = Math.min(minX, b.pos.x - b.radius);
                maxX = Math.max(maxX, b.pos.x + b.radius);
                minY = Math.min(minY, b.pos.y - b.radius);
                maxY = Math.max(maxY, b.pos.y + b.radius);
            }
            
            // Check if click is within bumper array horizontal bounds
            if (mouseX >= minX && mouseX <= maxX && mouseY >= minY && mouseY <= maxY) {
                // Special case: if only one row, always add to top
                if (bumperRows === 1) {
                    addBumperRow(true);
                } else {
                    // Determine if clicked in top or bottom half
                    const midY = (minY + maxY) / 2;
                    
                    if (mouseY > midY) {
                        // Clicked in bottom half - add row to bottom
                        addBumperRow(false);
                    } else {
                        // Clicked in top half - add row to top
                        addBumperRow(true);
                    }
                }
            }
        }
    }

    let touchDown = false;
    
    function touchStartHandler(event) {
        event.preventDefault(); // Prevent scrolling and other default touch behaviors
        
        // Use the first touch point
        var touch = event.touches[0];
        if (!touch) return;
        
        // Create a synthetic event object that mimics the mouse event structure
        var syntheticEvent = {
            clientX: touch.clientX,
            clientY: touch.clientY
        };
        
        // Store the original event object temporarily
        var originalEvent = window.event;
        window.event = syntheticEvent;
        
        // Call the existing mouse down handler
        mouseDownHandler();
        
        // Restore the original event
        window.event = originalEvent;
        
        touchDown = true;
    }
    
    function touchEndHandler(event) {
        event.preventDefault();
        
        if (touchDown) {
            // Remove touch move listeners
            document.removeEventListener('touchmove', touchBlowerMove);
            document.removeEventListener('touchmove', touchHungryPuckMove);
            document.removeEventListener('touchmove', touchHungryPuck2Move);
            document.removeEventListener('touchmove', touchPuck0Move);
            document.removeEventListener('touchmove', touchPuck1Move);
            document.removeEventListener('touchmove', touchPuck2Move);
            document.removeEventListener('touchmove', touchMisterMisterMove);
            document.removeEventListener('touchmove', touchBumperMove);
            
            // Call the existing mouse up handler
            mouseUp();
            
            touchDown = false;
        }
    }
    
    // Touch move functions that mirror the mouse move functions
    function touchBumperMove(event) {
        event.preventDefault();
        var touch = event.touches[0];
        if (!touch) return;
        
        var originalEvent = window.event;
        window.event = { clientY: touch.clientY };
        mouseBumperMove();
        window.event = originalEvent;
    }
    
    function touchColorWheelMove(event) {
        event.preventDefault();
        var touch = event.touches[0];
        if (!touch) return;
        
        const bounds = canvas.getBoundingClientRect();
        const mX = touch.clientX - bounds.left - canvas.clientLeft;
        const mY = touch.clientY - bounds.top - canvas.clientTop;
        handleColorWheelInteraction(mX, mY);
    }
    
    function touchColorWheelPositionMove(event) {
        event.preventDefault();
        var touch = event.touches[0];
        if (!touch) return;
        
        const bounds = canvas.getBoundingClientRect();
        const mX = touch.clientX - bounds.left - canvas.clientLeft;
        const mY = touch.clientY - bounds.top - canvas.clientTop;
        colorWheelCenterX = mX - colorWheelDragOffsetX;
        colorWheelCenterY = mY - colorWheelDragOffsetY;
    }
    
    function touchPhysicsMenuMove(event) {
        event.preventDefault();
        var touch = event.touches[0];
        if (!touch) return;
        
        const bounds = canvas.getBoundingClientRect();
        const mX = touch.clientX - bounds.left - canvas.clientLeft;
        const mY = touch.clientY - bounds.top - canvas.clientTop;
        handlePhysicsMenuInteraction(mX, mY);
    }
    
    function touchPhysicsMenuPositionMove(event) {
        event.preventDefault();
        var touch = event.touches[0];
        if (!touch) return;
        
        const bounds = canvas.getBoundingClientRect();
        const mX = touch.clientX - bounds.left - canvas.clientLeft;
        const mY = touch.clientY - bounds.top - canvas.clientTop;
        physicsMenuCenterX = mX - physicsMenuDragOffsetX;
        physicsMenuCenterY = mY - physicsMenuDragOffsetY;
    }

    function touchBlowerMove(event) {
        event.preventDefault();
        var touch = event.touches[0];
        if (!touch) return;
        
        var originalEvent = window.event;
        window.event = { clientX: touch.clientX, clientY: touch.clientY };
        mouseBlowerMove();
        window.event = originalEvent;
    }
    
    function touchHungryPuckMove(event) {
        event.preventDefault();
        var touch = event.touches[0];
        if (!touch) return;
        
        var originalEvent = window.event;
        window.event = { clientX: touch.clientX, clientY: touch.clientY };
        mouseHungryPuckMove();
        window.event = originalEvent;
    }
    
    function touchHungryPuck2Move(event) {
        event.preventDefault();
        var touch = event.touches[0];
        if (!touch) return;
        
        var originalEvent = window.event;
        window.event = { clientX: touch.clientX, clientY: touch.clientY };
        mouseHungryPuck2Move();
        window.event = originalEvent;
    }
    
    function touchMisterMisterMove(event) {
        event.preventDefault();
        var touch = event.touches[0];
        if (!touch) return;
        
        var originalEvent = window.event;
        window.event = { clientX: touch.clientX, clientY: touch.clientY };
        mouseMisterMisterMove();
        window.event = originalEvent;
    }
    
    function touchPuckMove(p) {
        return function(event) {
            event.preventDefault();
            var touch = event.touches[0];
            if (!touch) return;
            
            var originalEvent = window.event;
            window.event = { clientX: touch.clientX, clientY: touch.clientY };
            
            puck = Puck[p];
            newX = window.event.clientX;
            newY = window.event.clientY;   
            startX = window.event.clientX;
            startY = window.event.clientY;
            puck.puckMoved = true;
            puck.moving = true;
            
            // Store previous position for velocity calculation
            puck.prevPos.set(puck.pos);
            
            // Update position
            puck.pos.x = (newX / cScale) - dX;
            puck.pos.y = (simHeight - newY / cScale) - dY;
            
            // Calculate velocity based on position change
            puck.vel.subtractVectors(puck.pos, puck.prevPos);
            // Scale velocity by frame rate approximation (assuming 60fps)
            puck.vel.scale(60);
            
            window.event = originalEvent;
        };
    }
    
    // Create the specific touch puck move functions
    // touchPuck2Move is for heartbeat (now at Puck[0])
    // touchPuck3Move is for cycle (now at Puck[1])
    var touchPuck2Move = touchPuckMove(0); // heartbeat puck
    var touchPuck3Move = touchPuckMove(1); // cycle puck
    var touchPuck0Move = touchPuckMove(2); // flying puck (legacy variable name)
    var touchPuck1Move = touchPuckMove(3); // orbit puck (legacy variable name)
    

    //  end mouse and touch stuff
    
	//  BASIC FUNCTIONS -----------------------------------------------------------------------
	
    class Vector2 {
		constructor(x = 0.0, y = 0.0) {
			this.x = x; 
			this.y = y;
		}
		set(v) {
			this.x = v.x; 
            this.y = v.y;
		}
		clone() {
			return new Vector2(this.x, this.y);
		}
		add(v, s=1) {
			this.x += v.x * s;
			this.y += v.y * s;
			return this;
		}
		addVectors(a, b) {
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			return this;
		}
		subtract(v, s = 1.0) {
			this.x -= v.x * s;
			this.y -= v.y * s;
			return this;
		}
		subtractVectors(a, b) {
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			return this;			
		}
		length() {
			return Math.sqrt(this.x * this.x + this.y * this.y);
		}
		scale(s) {
			this.x *= s;
			this.y *= s;
		}
		dot(v) {
			return this.x * v.x + this.y * v.y;
		}
        perp() {
			return new Vector2(-this.y, this.x);
		}
	}

    function closestPointOnSegment(p, a, b) 
	{
		var ab = new Vector2();
		ab.subtractVectors(b, a);
		var t = ab.dot(ab);
		if (t == 0.0)
			return a.clone();
		t = Math.max(0.0, Math.min(1.0, (p.dot(ab) - a.dot(ab)) / t));
		var closest = a.clone();
		return closest.add(ab, t);
	}
    function rads(theta) {
        return theta * Math.PI/180;
    }
    function cX(pos) {
        return pos.x * cScale;
    }
	function cY(pos) {
        return canvas.height - pos.y * cScale;
    }
    
    function wipeRestart() {
        c.fillStyle = 'hsl(0, 0%, 0%)';
        c.fillRect(0, 0, canvas.width, canvas.height);
        makeBalls()
    }
    function forcedWipeRestart() {
        c.fillStyle = 'hsl(0, 0%, 0%)';
        c.fillRect(0, 0, canvas.width, canvas.height);
        makeBalls()
    }
    function pause() {
        // Toggle paused state
        physProps.paused = !physProps.paused;
        // Update the pause button checkbox to reflect the state (in case called programmatically)
        //var pauseCheckbox = document.querySelector('.checkbox-pause');
        if (pauseCheckbox) {
            pauseCheckbox.checked = physProps.paused;
        }
    }
    function loadPreset(idx) {
        const key = PRESET_KEYS[idx];
        let val = null;
        // Try localStorage first
        try {
            val = localStorage.getItem(key);
        } catch (e) {
            val = null;
        }
        // Fallback to cookies if not found
        if (!val) {
            const cookies = document.cookie.split(';');
            for (const c of cookies) {
                const trimmed = c.trim();
                if (trimmed.startsWith(key + '=')) {
                    val = trimmed.substring(key.length + 1);
                    try {
                        val = decodeURIComponent(val);
                    } catch (e) {}
                    break;
                }
            }
        }
        let state = null;
        if (val) {
            try {
                state = JSON.parse(val);
            } catch (e) { alert('Failed to load preset: ' + e); return; }
        } else if (DEFAULT_PRESETS && DEFAULT_PRESETS[idx]) {
            state = DEFAULT_PRESETS[idx];
        }
        if (state) {
            setControlState(state);
        } else {
            alert('No preset saved in this slot and no default available.');
        }
    }
    
    
    // Continuous implode functionality
    let implodeInterval = null;
    let imploderHoldTimer = null;
    let stinkerHoldTimer = null;
    let heartSpawnTimer = null;
    
    function startContinuousImplode() {
        // Start continuous implode effect
        if (implodeInterval) clearInterval(implodeInterval);
        implodeInterval = setInterval(() => {
            try { magnetize(); } catch(e) {}
        }, 16); // ~60fps for smooth continuous effect
    }

    function stopContinuousImplode() {
        // Stop continuous implode effect
        if (implodeInterval) {
            clearInterval(implodeInterval);
            implodeInterval = null;
        }
    }

        // Button-based event listeners removed; Magnet is now only activated via canvas interaction.

	function pauseAndStep() {
        //let input = document.querySelectorAll('.checkbox-pause');
        for (i = 0; i < input.length; i++) {
            input[i].checked = true;
        }
		physProps.paused = false;
		simulate();
		physProps.paused = true
	}

    function drawCircle(x, y, radius) {
        c.beginPath();			
		c.arc(x, y, radius, 0.0, 2.0 * Math.PI) 
		c.closePath();
	}

    function drawEllipse(x, y, radiusX, radiusY) {
        c.beginPath();			
		c.ellipse(x * cScale, y * cScale, radiusX * cScale, radiusY * cScale, 0, 0, 2 * Math.PI) 
		c.closePath();
	}

    function drawArrow(posX, posY, angle, radius) {
        // 0 degreees is up, angles rotate counterclockwise
        var arrow = {
            radius: radius,
            // 1 bottom right
            a1cos: Math.cos(rads(281.86) + angle),
            a1sin: Math.sin(rads(281.86) + angle),
            r1: 0.5109,
            // 2 right inside corner
            a2cos: Math.cos(rads(43.6) + angle),
            a2sin: Math.sin(rads(43.6) + angle),
            r2: 0.1450,
            // 3 right tip
            a3cos: Math.cos(rads(16.86) + angle),
            a3sin: Math.sin(rads(16.86) + angle),
            r3: 0.3448,
            // 4 top
            a4cos: Math.cos(rads(90) + angle),
            a4sin: Math.sin(rads(90) + angle),
            r4: 0.5,
            // 5 left tip
            a5cos: Math.cos(rads(163.14) + angle),
            a5sin: Math.sin(rads(163.14) + angle),
            r5: 0.3448,
            // 6 left inside corner
            a6cos: Math.cos(rads(136.4) + angle),
            a6sin: Math.sin(rads(136.4) + angle),
            r6: 0.1450,
            // 7 bottom left
            a7cos: Math.cos(rads(258.14) + angle),
            a7sin: Math.sin(rads(258.14) + angle),
            r7: 0.5109,
            // 8 bottom center
            a8cos: Math.cos(rads(270) + angle),
            a8sin: Math.sin(rads(270) + angle),
            r8: 0.5
        }

        c.beginPath();
        c.moveTo((posX + arrow.radius * arrow.r1 * arrow.a1cos) * cScale,
            (posY - arrow.radius * arrow.r1 * arrow.a1sin) * cScale);
        c.lineTo((posX + arrow.radius * arrow.r2 * arrow.a2cos) * cScale,
            (posY - arrow.radius * arrow.r2 * arrow.a2sin) * cScale);
        c.lineTo((posX + arrow.radius * arrow.r3 * arrow.a3cos) * cScale,
            (posY - arrow.radius * arrow.r3 * arrow.a3sin) * cScale);
        c.lineTo((posX + arrow.radius * arrow.r4 * arrow.a4cos) * cScale,
            (posY - arrow.radius * arrow.r4 * arrow.a4sin) * cScale);
        c.lineTo((posX + arrow.radius * arrow.r5 * arrow.a5cos) * cScale,
            (posY - arrow.radius * arrow.r5 * arrow.a5sin) * cScale);
        c.lineTo((posX + arrow.radius * arrow.r6 * arrow.a6cos) * cScale,
            (posY - arrow.radius * arrow.r6 * arrow.a6sin) * cScale);
        c.lineTo((posX + arrow.radius * arrow.r7 * arrow.a7cos) * cScale,
            (posY - arrow.radius * arrow.r7 * arrow.a7sin) * cScale);
        c.lineTo((posX + arrow.radius * arrow.r8 * arrow.a8cos) * cScale,
            (posY - arrow.radius * arrow.r8 * arrow.a8sin) * cScale);
        c.closePath();
    }

    // COLLISIONS AND BOUNDARIES =============================================================

    //  HANDLE WORM SEGMENT HITS --------------------------------------------------------
    // Point to line segment distance and closest point
    function pointToSegmentDistance(point, segStart, segEnd) {
        var dx = segEnd.x - segStart.x;
        var dy = segEnd.y - segStart.y;
        var lengthSquared = dx * dx + dy * dy;
        
        if (lengthSquared === 0) {
            // Segment is a point
            var distX = point.x - segStart.x;
            var distY = point.y - segStart.y;
            return {
                distance: Math.sqrt(distX * distX + distY * distY),
                closestPoint: { x: segStart.x, y: segStart.y }
            };
        }
        
        // Calculate projection parameter t (0 to 1 along segment)
        var t = ((point.x - segStart.x) * dx + (point.y - segStart.y) * dy) / lengthSquared;
        t = Math.max(0, Math.min(1, t));
        
        var closestX = segStart.x + t * dx;
        var closestY = segStart.y + t * dy;
        var distX = point.x - closestX;
        var distY = point.y - closestY;
        
        return {
            distance: Math.sqrt(distX * distX + distY * distY),
            closestPoint: { x: closestX, y: closestY }
        };
    }
    
    function handleWormSegmentHits(ball, wormSegment, segmentRadius, segmentVelocity) {
        var dir = new Vector2();
        dir.subtractVectors(ball.pos, wormSegment);
        var d = dir.length();
        if (d == 0.0 || d >= ball.radius + segmentRadius)
            return;

        dir.scale(1.0 / d);
        var overlap = ball.radius + segmentRadius - d;
        var corr = overlap + 0.01; // Increased buffer to prevent tunneling
        ball.pos.add(dir, corr);

        var relativeVel = new Vector2();
        relativeVel.subtractVectors(ball.vel, segmentVelocity);
        var velAlongNormal = relativeVel.dot(dir);
        var massScale = 10000000;
        var segmentMass = massScale * segmentRadius * segmentRadius;
        // Only apply velocity impulse if objects are approaching each other
        if (velAlongNormal <= 0) {
            var e = WormProps.wormRestitution; // Use worm's own restitution
            // Calculate impulse scalar
            var j = -(1 + e) * velAlongNormal;
            j /= (1 / ball.mass) + (1 / segmentMass);
            var impulse = new Vector2();
            impulse.set(dir);
            impulse.scale(j);
            
            ball.vel.add(impulse, 1 / ball.mass);
            
            // Additional damping to prevent tunneling (always reflect, then apply restitution)
            var v = ball.vel.dot(dir);
            if (v < 0) { // Still moving into worm
                ball.vel.add(dir, -v * (1 + WormProps.wormRestitution));
            }
        }
    }
    
    function handleWormOutlineCollision(ball, worm) {
        // Check collision with head circle first
        if (wormOutlinePoints.headCenter) {
            var headDx = ball.pos.x - wormOutlinePoints.headCenter.x;
            var headDy = ball.pos.y - wormOutlinePoints.headCenter.y;
            var headDist = Math.sqrt(headDx * headDx + headDy * headDy);
            
            if (headDist < ball.radius + wormOutlinePoints.headRadius) {
                // Collision with head circle
                var dir = new Vector2(headDx, headDy);
                if (headDist > 0) dir.scale(1.0 / headDist);
                else dir.set(new Vector2(1, 0));
                
                var overlap = ball.radius + wormOutlinePoints.headRadius - headDist;
                ball.pos.add(dir, overlap + 0.01); // Increased buffer to prevent tunneling
                
                // Apply velocity change with worm's restitution
                var segmentVel = worm.vel[1] || new Vector2(0, 0);
                var relativeVel = new Vector2();
                relativeVel.subtractVectors(ball.vel, segmentVel);
                var velAlongNormal = relativeVel.dot(dir);
                
                if (velAlongNormal < 0) {
                    // Always reflect velocity to prevent tunneling, then apply restitution as damping
                    var v = ball.vel.dot(dir);
                    ball.vel.add(dir, -v * (1 + WormProps.wormRestitution));
                }
                return;
            }
        }
        
        // Check collision with outline edges
        var minDist = Infinity;
        var collisionNormal = null;
        var collisionPoint = null;
        
        // Check top edge
        for (var i = 0; i < wormOutlinePoints.top.length - 1; i++) {
            var result = pointToSegmentDistance(ball.pos, wormOutlinePoints.top[i], wormOutlinePoints.top[i + 1]);
            if (result.distance < minDist) {
                minDist = result.distance;
                collisionPoint = result.closestPoint;
                collisionNormal = new Vector2(ball.pos.x - collisionPoint.x, ball.pos.y - collisionPoint.y);
            }
        }
        
        // Check bottom edge
        for (var i = 0; i < wormOutlinePoints.bottom.length - 1; i++) {
            var result = pointToSegmentDistance(ball.pos, wormOutlinePoints.bottom[i], wormOutlinePoints.bottom[i + 1]);
            if (result.distance < minDist) {
                minDist = result.distance;
                collisionPoint = result.closestPoint;
                collisionNormal = new Vector2(ball.pos.x - collisionPoint.x, ball.pos.y - collisionPoint.y);
            }
        }
        
        // Apply collision response if within ball radius
        if (minDist < ball.radius && collisionNormal) {
            var normalLength = collisionNormal.length();
            if (normalLength > 0) {
                collisionNormal.scale(1.0 / normalLength);
                var overlap = ball.radius - minDist;
                ball.pos.add(collisionNormal, overlap + 0.01); // Increased buffer to prevent tunneling
                
                // Always reflect velocity to prevent tunneling, then apply restitution as damping
                var v = ball.vel.dot(collisionNormal);
                if (v < 0) { // Still moving into worm
                    ball.vel.add(collisionNormal, -v * (1 + WormProps.wormRestitution));
                }
            }
        }
    }

    //  HANDLE BALL TO BALL HITS --------------------------------------------------------------------
	function handleBallHits(ball1, ball2) {
		var dir = new Vector2();
		dir.subtractVectors(ball2.pos, ball1.pos);
		var d = dir.length();
		if (d == 0.0 || d >= ball1.radius + ball2.radius)
			return;

		dir.scale(1.0 / d);
		var corr = (ball1.radius + ball2.radius - d) / 2.0 + 0.001; // Small buffer to prevent immediate re-collision
		var v1 = ball1.vel.dot(dir);
		var v2 = ball2.vel.dot(dir);
		var m1 = ball1.mass;
		var m2 = ball2.mass;
        if (physProps.ballRest == 0) {
            var newV1 = (m1 * v1 + m2 * v2) / (m1 + m2);
		    var newV2 = (m1 * v1 + m2 * v2) / (m1 + m2);
        } else {
            var newV1 = (m1 * v1 + m2 * v2 - m2 * (v1 - v2) * physProps.ballRest) / (m1 + m2);
		    var newV2 = (m1 * v1 + m2 * v2 - m1 * (v2 - v1) * physProps.ballRest) / (m1 + m2);
        }
		
        ball1.pos.add(dir, -corr);
		ball2.pos.add(dir, corr);
		ball1.vel.add(dir, newV1 - v1);
		ball2.vel.add(dir, newV2 - v2);
	}

    //  HANDLE BALL TO BALL COMPRESSION --------------------------------------------------------------------
	function handleBallRepulsion(ball1, ball2) {
		var dir = new Vector2();
		dir.subtractVectors(ball2.pos, ball1.pos);
		var d = dir.length();
		var repulsionThreshold = physProps.repulsionDist * (ball1.radius + ball2.radius);
		if (d == 0.0 || d >= repulsionThreshold)
			return;
		dir.scale(1.0 / d);
        var compression = Math.abs(repulsionThreshold - d);
        var force = (physProps.repulsionForce * compression) / physProps.substeps;
		var totalMass = ball1.mass + ball2.mass;
		var force1 = force * (ball2.mass / totalMass);
		var force2 = force * (ball1.mass / totalMass);
		
		ball1.vel.add(dir, -force1);
		ball2.vel.add(dir, force2);
	}

    //  HANDLE BUMPER HITS ------------------------------------------------------------------- 
	function handleBumperHits(ball, bumper) {
        var dir = new Vector2();
		dir.subtractVectors(ball.pos, bumper.pos);
		var d = dir.length();
		if (d == 0.0 || d >= ball.radius + bumper.radius)
			return;

		dir.scale(1.0 / d);
		var corr = (ball.radius + bumper.radius - d);
		var v = ball.vel.dot(dir);
        ball.pos.add(dir, corr);
        ball.vel.add(dir, v * -2.0 * physProps.bumperRest);

	}
    
    //  HANDLE PUCK TO BALL HITS  -------------------------------------------------------------------- 
	function handlePuckHits(ball, puck) {
        var dir = new Vector2();
		dir.subtractVectors(ball.pos, puck.pos);
		var d = dir.length();
		if (d == 0.0 || d >= ball.radius + puck.radius)
			return;

		dir.scale(1.0 / d);
		var overlap = ball.radius + puck.radius - d;
		
		// For puck collisions, push the ball out completely to prevent clipping
		// Use a slightly larger separation to ensure clean separation
		var corr = overlap + 0.001; // Small buffer to prevent immediate re-collision
		ball.pos.add(dir, corr);

        // Effective surface velocity along the collision normal
        // Includes translational puck motion and radial surface motion from pulsing
        var u_n = 0.0;
        if (puck.moving == true) {
            u_n += puck.vel.dot(dir);
        }
        // Also apply velocity for oscillating pucks
        if (doOscillatePucks && !puck.heartBeat && !puck.cycle && !puck.flying && !puck.orbit && !puck.yinyang && puck.vel) {
            u_n += puck.vel.dot(dir);
        }
        // Also apply velocity for flying puck
        if (puck.flying === true && (doFlyingPuck || doFlyingPuck2) && puck.vel) {
            u_n += puck.vel.dot(dir);
        }
        // Also apply velocity for orbit puck
        if (puck.orbit === true && showOrbit && puck.vel) {
            u_n += puck.vel.dot(dir);
        }
        if (puck.heartBeat === true && Math.abs(puck.radiusRate) > 1e-6) {
            u_n += puck.radiusRate; // outward positive along dir
        }

        // Ball normal velocity component
        var v_n = ball.vel.dot(dir);

        // If the ball is approaching the moving surface (in surface frame), reflect with restitution
        if (v_n < u_n) {
            var e = physProps.puckRest;
            // Set new normal component: v'_n = u_n - e * (v_n - u_n) = (1+e)u_n - e v_n
            var v_n_prime = (1 + e) * u_n - e * v_n;
            var delta = v_n_prime - v_n; // change to apply along normal
            ball.vel.add(dir, delta);
        }
	}

    //  HANDLE CORNER HITS  --------------------------------------------------------------------
    function handleCornerHits(ball1, corner) {
        // Find arc center based on corner position and type
        let arcCenterX, arcCenterY;
        if (corner.corner === 'northwest') {
            arcCenterX = corner.pos.x + corner.radius; 
            arcCenterY = corner.pos.y + corner.radius;
        } else if (corner.corner === 'northeast') {
            arcCenterX = corner.pos.x - corner.radius; 
            arcCenterY = corner.pos.y + corner.radius;
        } else if (corner.corner === 'southwest') {
            arcCenterX = corner.pos.x + corner.radius; 
            arcCenterY = corner.pos.y - corner.radius;
        } else { // southeast
            arcCenterX = corner.pos.x - corner.radius; 
            arcCenterY = corner.pos.y - corner.radius;
        }
        
        const dx = ball1.pos.x - arcCenterX;
        const dy = ball1.pos.y - arcCenterY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Check if ball is colliding with the inside of the arc
        if (distance > corner.radius - 2 * ball1.radius) {
            // Surface normal points from arc center toward ball
            const normalX = dx / distance;
            const normalY = dy / distance;
            
            ball1.pos.x = arcCenterX + normalX * (corner.radius - 2 * ball1.radius);
            ball1.pos.y = arcCenterY + normalY * (corner.radius - 2 * ball1.radius);
            
            const dot = ball1.vel.x * normalX + ball1.vel.y * normalY;
            ball1.vel.x -= 2 * dot * normalX;
            ball1.vel.y -= 2 * dot * normalY;
        }
    }
    
    //  HANDLE SHOWER  -------------------------------------------------------------------- 
    function goShower(ball) {
        if (doGravityUp == true) {
            ball.pos.y = simHeight + ball.radius;
            if (customShowerPos !== null) {
                // Use custom position directly - center the spawn distribution at the cursor click
                ball.pos.x = customShowerPos + ((Math.random() - 0.5) * simWidth * dumpSqueeze);
            } else {
                // Use original formula with dumpShift
                ball.pos.x = dumpShift + ((Math.random() * simWidth * dumpSqueeze) + ((1.0 / (2 * dumpSqueeze)) - 0.5) * simWidth * dumpSqueeze);
            }
            ball.vel.x = 0;
            ball.vel.y = 0;
        } else if (doGravityLeft == true) {
            ball.pos.x = -ball.radius;
            if (customShowerPos !== null) {
                // Use custom position directly - center the spawn distribution at the cursor click
                ball.pos.y = customShowerPos + ((Math.random() - 0.5) * simHeight * dumpSqueeze);
            } else {
                // Use centered formula similar to up/down gravity but for Y axis
                ball.pos.y = (simHeight / 2) + ((Math.random() * simHeight * dumpSqueeze) + ((1.0 / (2 * dumpSqueeze)) - 0.5) * simHeight * dumpSqueeze);
            }
            ball.vel.x = 0;
            ball.vel.y = 0;
        } else if (doGravityRight == true) {
            ball.pos.x = simWidth + ball.radius;
            if (customShowerPos !== null) {
                // Use custom position directly - center the spawn distribution at the cursor click
                ball.pos.y = customShowerPos + ((Math.random() - 0.5) * simHeight * dumpSqueeze);
            } else {
                // Use centered formula similar to up/down gravity but for Y axis
                ball.pos.y = (simHeight / 2) + ((Math.random() * simHeight * dumpSqueeze) + ((1.0 / (2 * dumpSqueeze)) - 0.5) * simHeight * dumpSqueeze);
            }
            ball.vel.x = 0;
            ball.vel.y = 0;
        } else if (doGravityDown == true) {
            ball.pos.y = -ball.radius;
            if (customShowerPos !== null) {
                // Use custom position directly - center the spawn distribution at the cursor click
                ball.pos.x = customShowerPos + ((Math.random() - 0.5) * simWidth * dumpSqueeze);
            } else {
                // Use original formula with dumpShift
                ball.pos.x = dumpShift + ((Math.random() * simWidth * dumpSqueeze) + ((1.0 / (2 * dumpSqueeze)) - 0.5) * simWidth * dumpSqueeze);
            }
            ball.vel.x = 0;
            ball.vel.y = 0;
        } else {
            ball.pos.y = simHeight + ball.radius + 30 * Math.random() * ball.radius;
            if (customShowerPos !== null) {
                // Use custom position directly - center the spawn distribution at the cursor click
                ball.pos.x = customShowerPos + ((Math.random() - 0.5) * simWidth * dumpSqueeze);
            } else {
                // Use original formula with dumpShift
                ball.pos.x = dumpShift + ((Math.random() * simWidth * dumpSqueeze) + ((1.0 / (2 * dumpSqueeze)) - 0.5) * simWidth * dumpSqueeze);
            }
            ball.vel.x = 0;
            ball.vel.y = 0;
        }
    }
    
    //  HANDLE MR. MISTER go fountain --------------------------------------------------------------------
    function goFountain(ball) {
        if (mrMode == "typewriter" && goLeft == true) {
            return;
        }
        var mrMr = MisterMister[0];
        if (mrMode == "worm") {
            ball.immuneToWorm = true;
            ball.immunityFramesLeft = 10; 
            if (mrMr.pos.x < 0 || mrMr.pos.x > simWidth || 
                mrMr.pos.y < 0 || mrMr.pos.y > simHeight) {
                return;
            }
            var spawnX = mrMr.pos.x - (0.35 * mrMr.radius - ball.radius) + (Math.random() * (0.9 * mrMr.radius - 6 * ball.radius));
            var spawnY = mrMr.pos.y - 0.3 * mrMr.radius - (0.35 * mrMr.radius - ball.radius) + (Math.random() * (0.7 * mrMr.radius - 4 * ball.radius));
            ball.pos.x = Math.max(0, Math.min(simWidth, spawnX));
            ball.pos.y = Math.max(0, Math.min(simHeight, spawnY));
            var velX = 0.1 * yeet * Math.cos(mrMr.respawnDir + alpha);
            var velY = 0.1 * yeet * Math.sin(mrMr.respawnDir + alpha);
        } else {
            ball.growing = true;
            ball.radius = 0.003;
            var spawnX = mrMr.pos.x - (0.3 * mrMr.radius - ball.radius) + (Math.random() * (0.9 * mrMr.radius - 6 * ball.radius));
            var spawnY = mrMr.pos.y - 0.60 * mrMr.radius - (0.35 * mrMr.radius - ball.radius) + (Math.random() * (0.6 * mrMr.radius - 4 * ball.radius));
            ball.pos.x = Math.max(0, Math.min(simWidth, spawnX));
            ball.pos.y = Math.max(0, Math.min(simHeight, spawnY));
            if (sprinklerSpeed > 0 && (fountainSpinMode == "sweep" || fountainSpinMode == "cw" || fountainSpinMode == "ccw")) {
                var velX = 0.1 * yeet * Math.cos(mrMr.respawnDir + alpha);
                var velY = 0.1 * yeet * Math.sin(mrMr.respawnDir + alpha);
            } else {
                var velX = 0.1 * yeet * Math.cos(mrMr.respawnDir);
                var velY = 0.1 * yeet * Math.sin(mrMr.respawnDir);
            }
        }
        
        ball.vel.x = velX;
        ball.vel.y = velY;
    }

    //  BLOWER HITS  --------------------------------------------------------------------
	function handleBlowerHits(ball, blower) {
        if (!blowerActive) return; // Don't affect particles when inactive
        
        var dir = new Vector2();
		dir.subtractVectors(ball.pos, blower.pos);
		var d = dir.length();
		if (d == 0.0 || d > ball.radius + blower.radius)
			return;

		dir.scale(1.0 / d);

        // Check if particle is behind the blower (dot product < 0)
        // Blower direction vector
        var blowerDirX = Math.cos(blower.blowerAngle);
        var blowerDirY = Math.sin(blower.blowerAngle);
        
        // Dot product of blower direction and particle direction from blower center
        var dotProduct = dir.x * blowerDirX + dir.y * blowerDirY;
        
        // Only affect particles in the rear hemisphere (dotProduct < 0)
        if (dotProduct >= 0) {
            return; // Particle is in front or at the side, ignore it
        }

        var blowerOffsetX = Math.cos(blower.blowerAngle) * 0.35 * blower.radius;
        var blowerOffsetY = Math.sin(blower.blowerAngle) * 0.35 * blower.radius;
        var veloc = ball.vel.length();

        ball.pos.x += Math.cos(blower.blowerAngle) * 0.1 * blower.radius;
        ball.pos.y += Math.sin(blower.blowerAngle) * 0.1 * blower.radius;
        ball.vel.x += Math.cos(blower.blowerAngle) * blower.force;
        ball.vel.y += Math.sin(blower.blowerAngle) * blower.force;
    }

    //  HUNGRY PUCK HITS  --------------------------------------------------------------------
	function handleHungryPuckHits(ball, hungryPuck) {
        var dir = new Vector2();
		dir.subtractVectors(ball.pos, hungryPuck.pos);
		var d = dir.length();
		if (d == 0.0 || d > ball.radius + hungryPuck.radius)
			return;

		dir.scale(1.0 / d);
        // FOUNTAIN AND SWEEPER SETUP FOR HUNGRY PUCK--------------------------------------------------
        if (fountainSpinMode == 'cw' || fountainSpinMode == 'sweep') {
            alpha += sprinklerSpeed * -1.0 * physProps.dt;
            if (alpha > 2 * Math.PI || alpha < -2 * Math.PI) {
                alpha = 0
            }
        } else if (fountainSpinMode == 'ccw') {
            alpha += sprinklerSpeed * 1.0 * physProps.dt;
            if (alpha > 2 * Math.PI || alpha < -2 * Math.PI) {
                alpha = 0
            }
        }

        // HANDLE SHOWER AND FOUNTAIN FOR HUNGRY PUCK -------------------------------------------------------------  
        if (doOneShot == false) {
            if (doShower == true) {
                goShower(ball); 
            }
            
            if (doFountain == true) {
                goFountain(ball);
            }
        }
    }

    //  HANDLE BOUNDARIES = FLOOR, WALLS, CEILING -------------------------------------------------------
	function handleOutOfBounds(ball, worldSize) {
        // FOUNTAIN AND SWEEPER SETUP ----------------------------------------------------
        if (fountainSpinMode == 'cw') {
            sweepAngle = 2 * Math.PI;
            alpha += sprinklerSpeed * -1.0 * physProps.dt;
            if (alpha > 2 * Math.PI || alpha < -2 * Math.PI) {
                alpha = 0;
            }
        } else if (fountainSpinMode == 'ccw') {
            sweepAngle = 2 * Math.PI;
            alpha += sprinklerSpeed * 1.0 * physProps.dt;
            if (alpha > 2 * Math.PI || alpha < -2 * Math.PI) {
                alpha = 0;
            }
        } else {
            sweepAngle = 0.35 * Math.PI;
            alpha += sprinklerSpeed * sweepDir * physProps.dt;
            if (alpha > (sweepAngle * 1.01) || alpha < (-sweepAngle * 1.01)) { // small chance of stalling
                alpha = 0
            }
            if (alpha > sweepAngle || alpha < -sweepAngle) {
                sweepDir *= -1;
            }
        }

        // HANDLE WALL HITS ------------------------------------------------------------  
        if (doCeiling == true) {
            if (ball.pos.y > worldSize.y - 2 * ball.radius) {
                ball.pos.y = worldSize.y - 2 * ball.radius;
                ball.vel.y = -ball.vel.y * physProps.ceilingRest * 0.97;
		    }
        }
        if (doFloor == true) {
            if (ball.pos.y < 2 * ball.radius) {
		        ball.pos.y = 2 * ball.radius;
		        ball.vel.y = -ball.vel.y * physProps.floorRest * 0.97;
		        }
        }
        if (doLeftWall == true) {
            if (cornerRad <= 100) {
                if (ball.pos.x < ball.radius) {
                    ball.pos.x = ball.radius;
                    ball.vel.x = -ball.vel.x * physProps.wallRest;
                }
            } else {
                NWCorner = Corners[0];
                if (ball.pos.x < NWCorner.pos.x + ball.radius) {
                    ball.pos.x = NWCorner.pos.x + ball.radius
                    ball.vel.x = -ball.vel.x * physProps.wallRest;
                }
            }
        }
        if (doRightWall == true) {
            if (cornerRad <= 100) {
                if (ball.pos.x > worldSize.x - ball.radius) {
                    ball.pos.x = worldSize.x - ball.radius;
                    ball.vel.x = -ball.vel.x * physProps.wallRest;
                }    
            } else {
                NECorner = Corners[1];
                if (ball.pos.x > NECorner.pos.x - ball.radius) {
                    ball.pos.x = NECorner.pos.x - ball.radius;
                    ball.vel.x = -ball.vel.x * physProps.wallRest;
                }  
            }
        }

        // HANDLE BOUNDS FOR SHOWER AND FOUNTAIN -------------------------------------------------------------  
        if (doOneShot == false) {
            if (doShower == true) {
                if (ball.pos.y < -2.0 * ball.radius || 
                    ball.pos.y > simHeight + 2.0 * ball.radius ||
                    ball.pos.x < -2.0 * ball.radius || 
                    ball.pos.x > simWidth + 2.0 * ball.radius) {
                    goShower(ball);
                }
            } 
            var hP = MisterMister[0];
            var dir = hP.respawnDir;
            var velX = 0.1 *yeet * Math.cos(dir + alpha);
            var velY = 0.1 * yeet * Math.sin(dir + alpha);
            if (doFountain == true) {
                if (ball.pos.y < -2.0 * ball.radius || 
                    ball.pos.y > simHeight + 2.0 * ball.radius ||
                    ball.pos.x < -2.0 * ball.radius || 
                    ball.pos.x > simWidth + 2.0 * ball.radius) {
                    // Additional check for worm mode: only respawn if Mr. Mister is within bounds
                    if (mrMode == "worm") {
                        if (hP.pos.x >= 0 && hP.pos.x <= simWidth && 
                            hP.pos.y >= 0 && hP.pos.y <= simHeight) {
                            goFountain(ball);
                        }
                        // If Mr. Mister is outside bounds in worm mode, don't respawn the particle
                    } else {
                        // Normal respawn behavior for other modes
                        goFountain(ball);
                    }
                }
            }
        }
	}

    // HANDLE MR. MISTER BOUNDS ------------------------------------------------------------  
    function handleMrMrBounds(hungryPuck, worldSize) {
        mrMr = MisterMister[0];
            if (mrMr.pos.y > worldSize.y - mrMr.radius) {
                mrMr.pos.y = worldSize.y - mrMr.radius;
                mrMr.vel.y = -mrMr.vel.y;
            }
            if (mrMr.pos.y < mrMr.radius) {
                mrMr.pos.y = mrMr.radius;
                mrMr.vel.y = -mrMr.vel.y;
            }
            if (mrMr.pos.x < mrMr.radius) {
                mrMr.pos.x = mrMr.radius;
                mrMr.vel.x = -mrMr.vel.x;
            }
            if (mrMr.pos.x > worldSize.x - mrMr.radius) {
                mrMr.pos.x = worldSize.x - mrMr.radius;
                mrMr.vel.x = -mrMr.vel.x;
            }
    }

    //  RESET FLYING PUCK --------------------------------------------------------
    function resetFlyingPuck() {
            const flyingPuck = Puck.find(p => p.flying);
            if (!flyingPuck) return;
            
            // choose flyingpuck point outside bounds
            var randNo = Math.random();
            var sideChooser = Math.floor(4 * Math.random());
            if (sideChooser == 0) { // left
                flyingPuck.pos.x = -1.0 * flyingPuck.OGradius;
                flyingPuck.pos.y = randNo * simHeight;
            } else if (sideChooser == 1) { // right
                flyingPuck.pos.x = simWidth + flyingPuck.OGradius;
                flyingPuck.pos.y = randNo * simHeight; 
            } else if (sideChooser == 2) { // top
                flyingPuck.pos.x = randNo * simWidth;
                flyingPuck.pos.y = -1.0 * flyingPuck.OGradius; 
            } else { // bottom
                flyingPuck.pos.x = randNo * simWidth;
                flyingPuck.pos.y = simHeight + flyingPuck.OGradius; 
            }       

            // choose some random point near the center of the canvas, say within 20% of the center
            var angle = 2 * Math.PI * Math.random();
            var radius = 0.5 * Math.min(simWidth, simHeight) * Math.random();
            var centerX = 0.5 * simWidth + radius * Math.cos(angle);
            var centerY = 0.5 * simHeight + radius * Math.sin(angle);
            
            // use these two points to define a velocity vector
            var dir = new Vector2(centerX, centerY);
            dir.subtractVectors(dir, flyingPuck.pos);

            // scale the velocity vector to a reasonable speed
            var speed = 3.0; // tune this value as needed
            var length = dir.length();
            if (length > 0) {
                dir.scale(speed / length);
            }
            flyingPuck.vel = dir;  
        }

    function startFPSCounter() {
        const fpsElement = document.getElementById('fpsCounter');
        if (fpsElement) {
            fpsElement.classList.add('visible');
            // Set proper initial content to ensure correct width calculation
            fpsElement.textContent = '60 fps';
            // Force reflow to ensure element dimensions are calculated
            fpsElement.offsetHeight;
            // Position after element has proper content and dimensions
            requestAnimationFrame(() => {
                positionFpsCounter();
            });
        }
    }
    
    function stopFPSCounter() {
        const fpsElement = document.getElementById('fpsCounter');
        if (fpsElement) {
            fpsElement.classList.remove('visible');
        }
    }
    
    function toggleFPS() {
        if (physicsMenuFpsOn) {
            startFPSCounter();
        } else {
            stopFPSCounter();
        }
    }


    //  WORLD PROPERTIES INIT DEFINITIONS ----------------------------------------------
    var physProps = {
		gravity : new Vector2(0, 0),
		substeps: 1,
		dt : 1 / (60 * 1), // update on change
		worldSize : new Vector2(simWidth, simHeight),

        maxSpeed: 0,
		ballRest : 0,
        bumperRest : 0.95,
        floorRest : 1.0,
        wallRest : 1.0,
        ceilingRest : 1.0,
        puckRest: 0.95,
        persistence: 0,
        paused : false,
        repulsionForce: 2,
        repulsionDist: 0,
        velColorMap: 0,
        baseColor: 0,
	}

    // Initialize color wheel values now that physProps exists
    physProps.baseColor = colorWheelHue;
    ballSaturation = colorWheelSat;
    ballLightness = colorWheelLight;
    // Initialize physics menu repulsion distance
    physProps.repulsionDist = physicsMenuRepulsionDist;    // WORMPROPS  ----------------------------------------------
    var WormProps = {
        gravity : new Vector2(0, 0),
        dt : 1 / 60,
        wormSubSteps : 1,
        paused : true,
        phase: 0.0,
        wormRestitution: 0.0, // Worm's own coefficient of restitution (independent of ball settings)
    
        wiggleActive: false,
        wiggleFrame: 0,
        wigglePerFrameVelY: 0.0,
        wigglePerFrameVelX: 0.0,
        wigglePerFrameVel: 0.0,
        wiggleDir: 1,
        prevHeadVY: 0.0,
        wiggleToggle: 1, // alternates sign each cycle
        wiggleAdvancePerFrame: 0.0,
        startRadius: 0,
        endRadius: 0,
        numNodes: 0,
        advanceSpeed: null, // Will be set randomly on first makeWorm() call
        
        // Worm motion constants
        waveAmplitudeRatio: null,         // body wave amplitude as fraction of canvas height 0.07
        wavePhaseIncrement: null,         // how fast the wave travels along the body (temporal frequency)
        waveNodeLag: 0.7,                 // phase lag per node (spatial wave number)
        waveNudge: 0.65,                  // how strongly nodes are nudged toward the target wave each frame (0..1)
        thrustCoeff: 0.0018,              // how much lateral motion converts to forward thrust (tweakable)
        minJointAngle: Math.PI * 0.6,     // minimum allowed interior joint angle (radians). Lower -> more flexible.
        spawnGapMinSim: 0.1,              // min spawn gap in sim units used at setup
        spawnGapMinPixels: 50,            // min spawn gap in pixels used at wrap-time
        spawnGapWidthFactor: 0.1,         // alternative spawn gap as fraction of canvas width (in sim units)
        wiggleFrames: 6,                  // frames over which the wiggle is applied
        wiggleDistancePixels: 24,         // total vertical travel during wiggle (pixels)
        wiggleXPixels: 0,                 // total horizontal propulsion applied during wiggle (pixels)
        wiggleVyZeroThreshold: 0.005,     // threshold to treat vy as zero
        spawnInitialXSim: 0,              // e.g. -2.0 puts pivot 2 sim units left of x=0
        spawnInitialYSim: 0,              // will be set to 0.5 * simHeight in makeWorm()
        
        // Worm delay properties
        isHiding: false,
        hideStartTime: 0,
        hideDelay: 5000, 
    }
    
    // Function to update dt when steps change
    function updateSubsteps(newSubsteps) {
        physProps.substeps = newSubsteps;
        physProps.dt = 1 / (60 * physProps.substeps);
    }
    
	//  SETUP SCENE ======================================================
	function setupScene() {
        // Initialize main menu to off-screen position
        mainMenuX = -calculateMainMenuWidth();
        mainMenuTargetX = mainMenuX;
        mainMenuVisible = false;
        mainMenuAnimating = false;
        
        currentDate = new Date();
        mSecs = currentDate.getMilliseconds();
        dumpSqueeze2 = 0.2;
        alpha = 0;
        sweepDir = 1;
        dir = 0;
        huePos = 0;
        delta = 0;
        mrMrTimer = 0;
        mouseUpTime = 0;
        mouseDownTime = 0;
        
        firstFlight = true;  // for flying puck passes
        goLeft = false;
        spawnLeft = true;
        showEaters = false;
        mrMode = "";
        blowerState = 1; // 0=off, 1=visible but not simulating, 2=visible and simulating

        doCeiling = wallsMenuCeiling;
        doFloor = wallsMenuFloor;
        doLeftWall = wallsMenuLeftWall;
        doRightWall = wallsMenuRightWall;
        dumpShift = 0; // Default to center of screen (spawn formula will add 0.5*simWidth offset)
        customShowerPos = null; // Custom shower position set by mouse clicks
        dumpSqueeze = 0.4; // Default shower width (40%)
        
        // Get bumper and puck states from toys menu
        const bumperToy = toysMenuItems.find(item => item.id === 'showBumperEntry');
        showBumpers = bumperToy ? bumperToy.checked : false;
        
        const puckToy = toysMenuItems.find(item => item.id === 'showPuckButton');
        showPucks = puckToy ? puckToy.checked : true;
        
        // Initialize FPS counter state
        if (physicsMenuFpsOn) {
            startFPSCounter();
        } else {
            stopFPSCounter();
        }
        
        // Get toy states from toys menu
        const heartToy = toysMenuItems.find(item => item.id === 'showHeartButton');
        showHeart = heartToy ? heartToy.checked : false;
        
        blowerState = 1; // Initialize to state 1 (visible but not simulating)
        
        const cycleToy = toysMenuItems.find(item => item.id === 'showCyclePuckButton');
        showCycle = cycleToy ? cycleToy.checked : false;
        
        const orbitToy = toysMenuItems.find(item => item.id === 'orbitButton');
        showOrbit = orbitToy ? orbitToy.checked : false;
        
        const yinYangToy = toysMenuItems.find(item => item.id === 'yinYangButton');
        showYinYang = yinYangToy ? yinYangToy.checked : false;
        
        doShower = (respawnMenuSpawnType === 'shower');
        doFountain = (respawnMenuSpawnType === 'fountain');
        showEaters = respawnMenuHungryPuck;
        mrMode = respawnMenuMisterMode;
        
        const flyingToy = toysMenuItems.find(item => item.id === 'flyingPuckButton');
        const flyingPuckState = flyingToy ? (flyingToy.checked ? 1 : 0) : 0;
        doFlyingPuck = (flyingPuckState === 1);
        doFlyingPuck2 = (flyingPuckState === 2);

        // Physics menu controls ball rest
        physProps.ballRest = physicsMenuBallRest / 100;

        // Read oscillation state from toys menu
        const showPuckToy = toysMenuItems.find(item => item.id === 'showPuckButton');
        const puckState = showPuckToy ? (showPuckToy.checked ? 1 : 0) : 0;
        doOscillatePucks = (puckState === 2);
        
        const smallTracerToy = toysMenuItems.find(item => item.id === 'smallTracerButton');
        doSmallTracer = smallTracerToy ? smallTracerToy.checked : false;
        
        const mediumTracerToy = toysMenuItems.find(item => item.id === 'mediumTracerButton');
        doMediumTracer = mediumTracerToy ? mediumTracerToy.checked : false;
        
        const bigTracerToy = toysMenuItems.find(item => item.id === 'bigTracerButton');
        doBigTracer = bigTracerToy ? bigTracerToy.checked : false;
        if (doSmallTracer == true || doMediumTracer == true || doBigTracer == true) {
            doTracer = true;
        } else {
            doTracer = false;
        }

        
        
        // Shower width control state tracking
        isDoubleTapDrag = false;
        dragStartX = 0;
        dragStartY = 0;
        initialDumpSqueeze = 0.4;
        
        // Mr. Mister speed control state tracking
        isMisterSpeedDrag = false;
        misterDragStartX = 0;
        initialMisterSpeed = 1.0;
        
        ballRepulsion = physicsMenuRepulsionOn;
        misterSpeed = 1.0; // Default speed (range: 0.1 to 2.0)
        ballSaturation = 0;
        ballLightness = colorWheelLight;
        persistence = colorWheelPersistence;
        cornerRad = wallsMenuCornerRadius || 100;

        doSpheres = false;
        doDiscs = true;
        doCircles = false;
        doGummi = false;
        wasGummi = false;

        doOneShot = respawnMenuOneShot;
        yeet = 40; // Default value; will be set by mouse in fountain mode
        doGravityDown = false;
        doGravityUp = false;
        doGravityLeft = false;
        doGravityRight = false;
        
        // Read worm state from toys menu
        const wormToy = toysMenuItems.find(item => item.id === 'wormButton');
        // Use the global wormState variable instead of deriving from checked status
        doWorm = wormState > 0;
        wormRenderMode = wormState === 2 ? 'curves' : 'spheres';

        physProps.baseColor = colorWheelHue;
        physProps.velColorMap = colorWheelVelMap;
        physProps.maxSpeed = 0.1 * physicsMenuSpeed;

        var wormValue = Math.floor(10 + 5 * Math.random());
        WormProps.startRadius = Math.max(Math.min(0.01 * wormValue, 0.3), 0.2);
        WormProps.endRadius = 0.04,
        WormProps.numNodes = wormValue,

        fountainSpinMode = "";
        sprinklerSpeed = 0.0001 * 15;
        respawnDir = 0;

       

        // Direction state for orbit and yin-yang (1 = normal, -1 = reverse)
        orbitDirection = 1;
        yinYangDirection = 1;

        makePucks();
        
        // Initialize flying puck if enabled
        const flyingPuck = Puck.find(p => p.flying);
        if (doFlyingPuck && flyingPuck) {
            resetFlyingPuck();
            flyingPuck.radius = flyingPuck.OGradius;
            flyingPuck.flyingIsHiding = false;
            flyingPuck.flyingHideStartTime = 0;
        } else if (doFlyingPuck2 && flyingPuck) {
            flyingPuck.pos.x = -1.0 * flyingPuck.OGradius;
            flyingPuck.vel.x = 3.0;
            flyingPuck.vel.y = 0;
            flyingPuck.radius = flyingPuck.OGradius;
            flyingPuck.flyingIsHiding = false;
            flyingPuck.flyingHideStartTime = 0;
        }
        
        makeBlower(
            0.2, 
            new Vector2(
                0.7 * simWidth, 
                0.4 * simHeight));
        makeHungryPucks();
        makeMisterMister();

        setRenderType(particlesMenuRenderType);
        
        // Initialize menu positions in the desired order (left to right): particles, physics, gravity, respawn, color
        updateParticlesMenuPosition();
        updatePhysicsMenuPosition(); 
        updateGravityMenuPosition();
        updateRespawnMenuPosition();
        updateColorWheelPosition();
        
        // Apply any custom default menu positions (overrides automatic positioning)
        applyDefaultMenuPositions();
        
        if (firstRun == true) {
            makeBalls();
            makeCorners()
            makeBumpers();
            makeWorm();
            firstRun = false;
        }
    }

    // Splode timing (ms): delay between each ball's impulse
    const SPL0DE_DELAY_MS = 1; // tune this to control pacing
    // Apply outward impulse to all balls with a small staggered delay per index
    function delayedSplode() {
        const cx = 0.5 * simWidth;
        const cy = 0.5 * simHeight;
        // Base impulse magnitude (scaled like before)
        const baseSpeed = 50 * physProps.dt;
        // Schedule each ball's impulse with an increasing timeout
        for (let i = Balls.length - 1; i >= 0; i--) {
            const b = Balls[i];
            const delay = (Balls.length - 1 - i) * SPL0DE_DELAY_MS;
            setTimeout(() => {
                // Guard in case balls array was rebuilt
                if (!b || !b.pos || !b.vel) return;
                const d = new Vector2();
                d.subtractVectors(b.pos, new Vector2(cx, cy));
                const angle = Math.atan2(d.y, d.x);
                b.vel.x += baseSpeed * Math.cos(angle);
                b.vel.y += baseSpeed * Math.sin(angle);
            }, delay);
        }
    }

    function instantSplode() {
        const baseSpeed = 50 * physProps.dt;
        for (let i = Balls.length - 1; i >= 0; i--) {
            var ball = Balls[i];
            var d = new Vector2();
            d.subtractVectors(ball.pos, new Vector2(0.5 * simWidth, 0.5 * simHeight));
            const angle = Math.atan2(d.y, d.x);
            ball.vel.x += baseSpeed * Math.cos(angle);
            ball.vel.y += baseSpeed * Math.sin(angle);
        }
    }

    

	//  BALL CONSTRUCTOR  -----------------------------------------------------------------------
	class BALL {
		constructor(radius, mass, pos, vel, saturation, whiteBall, tracerBall, smallBallRadius, bigBallRadius) {
			this.radius = radius;
            this.OGradius = radius; // Store original radius for reference
			this.mass = mass;
			this.pos = pos.clone();
			this.vel = vel.clone();
            this.color = 0;
            this.saturation = saturation;
            this.whiteBall = whiteBall;
            this.immuneToWorm = false;
            this.immunityFramesLeft = 0; 
            this.tracerBall = tracerBall;
            // Store normalized position (0-1) in size range for rescaling
            // When smallBallRadius is 0, all balls are bigBallRadius (normalized = 1)
            if (smallBallRadius == 0) {
                this.radiusNormalized = 1.0;
            } else if (bigBallRadius > smallBallRadius) {
                this.radiusNormalized = (radius - smallBallRadius) / (bigBallRadius - smallBallRadius);
            } else {
                this.radiusNormalized = 0.5; // default to middle if same size
            }
            // Smoothed heading for image-based rendering (gummi)
            this.headingAngle = 0;          // radians, screen-space orientation
            this.headingInitialized = false; // initialize on first valid velocity
            this.artificialMovement = false; // Flag to track when ball is being repositioned artificially
            if (tracerBall == true) {
                if (doSmallTracer == true) {
                    this.radius = smallBallRadius;
                } else 
                if (doBigTracer == true) {
                    this.radius = bigBallRadius;
                } else 
                if (doMediumTracer == true) {
                    this.radius = 0.5 * (smallBallRadius + bigBallRadius);
                }  
                this.trail = new Float32Array(1500); // Increased size to accommodate flags
                this.trailFirst = 0;
                this.trailLast = 0;
                this.tracer = true;
                this.speedHue = 0;
                this.speedHueRatio = 1;
                this.growing = false;
            }
		}
        get top() {
            return this.pos.y + this.radius;
        }
        get bottom() {
            return this.pos.y - this.radius;
        }
        get left() {
            return this.pos.x - this.radius;
        }
        get right() {
            return this.pos.x + this.radius;
        }
        updateTrace() {
            // Check if ball is outside simulation boundaries
            var isOutsideBounds = (this.pos.x < 0 || this.pos.x > simWidth || 
                                 this.pos.y < 0 || this.pos.y > simHeight);
            
            if (isOutsideBounds) {
                this.artificialMovement = true; // Mark as outside/artificial movement
                return; // Don't record trace when outside
            }
            
            // Ball is back inside bounds - resume normal tracing (don't reset trace)
            var wasArtificial = this.artificialMovement;
            if (this.artificialMovement) {
                this.artificialMovement = false; // Resume normal tracing
            }
            
            // Record normal trace point (x, y, discontinuity_flag)
            this.trail[this.trailLast] = this.pos.x;
            this.trail[this.trailLast + 1] = this.pos.y;
            this.trail[this.trailLast + 2] = wasArtificial ? 1.0 : 0.0; // Flag discontinuity
            this.trailLast = (this.trailLast + 3) % this.trail.length;
            if (this.trailLast == this.trailFirst)
                this.trailFirst = (this.trailFirst + 3) % this.trail.length;
        }
        resetTrace() {
            this.trailFirst = 0;
            this.trailLast = 0;
        }
        simulate() {
            if (this.growing == true) {
                this.radius += 0.00025;
                if (this.radius >= this.OGradius) {
                    this.radius = this.OGradius;
                    this.growing = false;
                }
            }
            //this.radius = 0.005;
            this.vel.add(physProps.gravity, physProps.dt);
            var speed = (this.vel.length() * 60 * physProps.dt);
            if (speed > (physProps.maxSpeed / physProps.substeps)) {
                this.vel.x *= (physProps.maxSpeed / physProps.substeps) / speed;
                this.vel.y *= (physProps.maxSpeed / physProps.substeps) / speed;
            }
            this.pos.add(this.vel, physProps.dt)
            this.speedHue = physProps.baseColor + speed * physProps.velColorMap * physProps.substeps;
            
            if (this.speedHue > physProps.baseColor + 330) {
                this.speedHue = physProps.baseColor + 330;
            }
            this.speedHueRatio = Math.min(0.8 + 0.2 * speed);
        }
        drawTrace() {
            c.lineCap = 'round';
            c.lineWidth = Math.max(0.005, this.radius) * cScale;
            if (this.trailLast != this.trailFirst) {
                var i = this.trailFirst;
                var segmentCount = 0;
                var totalSegments = 0;
                
                // First, count total segments
                var tempI = this.trailFirst;
                while (tempI != this.trailLast) {
                    totalSegments++;
                    tempI = (tempI + 3) % this.trail.length;
                }
                
                // Draw each segment with fading
                i = this.trailFirst;
                var prevX = this.trail[i] * cScale;
                var prevY = canvas.height - this.trail[i + 1] * cScale;
                i = (i + 3) % this.trail.length;
                
                while (i != this.trailLast) {
                    var currentX = this.trail[i] * cScale;
                    var currentY = canvas.height - this.trail[i + 1] * cScale;
                    var isDiscontinuity = this.trail[i + 2] > 0.5; // Check discontinuity flag
                    
                    // Skip drawing if this point represents a discontinuity (post-teleportation)
                    if (!isDiscontinuity) {
                        // Calculate fade: older segments are more transparent
                        var fadeRatio = segmentCount / totalSegments;
                        var alpha = 1.0 - fadeRatio; // Start opaque, fade to transparent
                        
                        c.strokeStyle = `hsl(200, 60%, 70%, ${1 - alpha})`;
                        c.beginPath();
                        c.moveTo(prevX, prevY);
                        c.lineTo(currentX, currentY);
                        c.stroke();
                    }
                    // If isDiscontinuity is true, skip drawing this segment (creates gap)
                    
                    prevX = currentX;
                    prevY = currentY;
                    segmentCount++;
                    i = (i + 3) % this.trail.length;
                }
            }
        }
        draw() {
            if (doDiscs == true) {
                drawCircle(cX(this.pos), cY(this.pos), 0.95 * this.radius * cScale);    
                if (this.whiteBall == true || this.tracerBall == true) {
                    // reg color
                    c.fillStyle = `hsl(0, 0%, ${ballLightness + 20}%)`;
                    // hi color
                    c.strokeStyle = `hsl(0, 0%, ${ballLightness + 50}%)`;
                    c.lineWidth = 0.2 * this.radius * cScale;
                } else {
                    // reg color   
                    c.fillStyle = `hsl(${this.speedHue}, ${ballSaturation * this.saturation}%, ${this.speedHueRatio * ballLightness}%)`;
                    // hi color
                    c.strokeStyle = `hsl(${this.speedHue}, ${ballSaturation * this.saturation}%, ${this.speedHueRatio * ballLightness + 25}%)`;
                    c.lineWidth = 0.2 * this.radius * cScale;
                }
                c.fill();
                c.stroke();
            } else if (doSpheres == true) {
                const shineOffsetX = cScale * this.radius * 0.3; // old masterShineShiftX;
                const shineOffsetY = cScale * this.radius * 0.4; // old masterShineShiftY;
                const shineVector = Math.sqrt(shineOffsetX * shineOffsetX + shineOffsetY * shineOffsetY);
                const shineRadius = 0.5 * cScale * this.radius + shineVector;
                const shading = c.createRadialGradient(
                    cX(this.pos) - shineOffsetX, 
                    cY(this.pos) - shineOffsetY, 
                    shineRadius, 
                    cX(this.pos) - shineOffsetX, 
                    cY(this.pos) - shineOffsetY, 
                    0);
                shading.addColorStop(0, `hsl(${this.speedHue}, ${ballSaturation * this.saturation}%, ${this.speedHueRatio * ballLightness - 15}%)`);
                shading.addColorStop(1, `hsl(${this.speedHue}, ${ballSaturation * this.saturation}%, ${this.speedHueRatio * ballLightness + 25}%)`);
                drawCircle(cX(this.pos), cY(this.pos), 0.95 *this.radius * cScale);
                c.fillStyle = shading;
                c.fill()
            } else if (doCircles == true) {
                drawCircle(cX(this.pos), cY(this.pos), 0.90 *this.radius * cScale);    
                c.fillStyle = `hsl(${this.speedHue}, ${ballSaturation * this.saturation}%, ${this.speedHueRatio * ballLightness}%)`;
                c.fill();
            } else if (doRings == true) {
                drawCircle(cX(this.pos), cY(this.pos), 0.80 *this.radius * cScale);    
                c.strokeStyle = `hsl(${this.speedHue}, ${ballSaturation * this.saturation}%, ${this.speedHueRatio * ballLightness}%)`;
                c.lineWidth = 0.3 * this.radius * cScale;
                c.stroke();
            } else if (doGummi == true) {
                const x = cX(this.pos);
                const y = cY(this.pos);
                const rpx = this.radius * cScale;
                if (gummiReady && gummiImage && gummiImage.complete && gummiImage.width > 0 && gummiImage.height > 0) {
                    // Compute and smooth screen-space rotation angle from velocity (y down)
                    const speed = this.vel.length();
                    if (speed > 1e-6) {
                        const target = Math.atan2(-this.vel.y, this.vel.x);
                        if (!this.headingInitialized) {
                            this.headingAngle = target;
                            this.headingInitialized = true;
                        } else {
                            // Smooth with exponential filter using dt-based alpha
                            const TWO_PI = Math.PI * 2;
                            let diff = target - this.headingAngle;
                            // Wrap to [-PI, PI]
                            diff = ((diff + Math.PI) % TWO_PI + TWO_PI) % TWO_PI - Math.PI;
                            const tau = gummiHeadingTau; // seconds time constant (tunable)
                            const alpha = 1 - Math.exp(-physProps.dt / Math.max(1e-6, tau));
                            this.headingAngle += alpha * diff;
                        }
                    }
                    const angle = (this.headingAngle || 0) + gummiHeadingOffset;
                    // Preserve aspect ratio: scale so the largest image dimension fits the diameter
                    const iw = gummiImage.width;
                    const ih = gummiImage.height;
                    const s = (2 * rpx) / Math.max(iw, ih);
                    const dw = iw * s;
                    const dh = ih * s;
                    // Slightly inset the clipping radius to avoid visual edge cropping
                    const clipR = Math.max(0, rpx - 0.5);
                    c.save();
                    c.translate(x, y);
                    c.rotate(angle);
                    // Circular clip centered at the ball
                    c.beginPath();
                    c.arc(0, 0, clipR, 0, 2 * Math.PI);
                    c.closePath();
                    c.clip();
                    // Center the image on the ball after rotation
                    c.drawImage(gummiImage, -dw / 2, -dh / 2, dw, dh);
                    // Tint the grayscale image to match ball color behavior
                    const prevOp = c.globalCompositeOperation;
                    c.globalCompositeOperation = 'multiply';
                    c.fillStyle = `hsl(${this.speedHue}, ${ballSaturation * this.saturation}%, ${this.speedHueRatio * ballLightness}%)`;
                    // Cover the clipped circle area for consistent tinting
                    c.fillRect(-clipR, -clipR, 2 * clipR, 2 * clipR);
                    c.globalCompositeOperation = prevOp;
                    c.restore();
                } else {
                    // Fallback: draw a simple disc until the image is loaded
                    drawCircle(x, y, rpx);
                    c.fillStyle = `hsl(${this.speedHue}, ${ballSaturation * this.saturation}%, ${this.speedHueRatio * ballLightness}%)`;;
                    c.fill();
                }
            }
        }
	}

    //  MAKE BALLS -------------------------------------------
    //  SQUARE ARRAY 
    // Adjust particle count live without restarting simulation
    function adjustParticleCount(targetCount) {
        if (!Array.isArray(Balls)) Balls = [];
        
        var currentCount = Balls.length;
        var smallBallRadius = 0.001 * particlesMenuSmallRadius;
        var bigBallRadius = 0.001 * particlesMenuLargeRadius;
        
        if (targetCount > currentCount) {
            // Add new balls
            var ballsToAdd = targetCount - currentCount;
            for (var i = 0; i < ballsToAdd; i++) {
                // Random size
                var radius;
                if (smallBallRadius == 0) {
                    radius = bigBallRadius;
                } else {
                    radius = smallBallRadius + Math.random() * (bigBallRadius - smallBallRadius);
                }
                
                // Random position in simulation area
                var pos = new Vector2(
                    Math.random() * simWidth,
                    Math.random() * simHeight
                );
                
                // Small random velocity
                var vel = new Vector2(
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1
                );
                
                var mass = 2 * Math.PI * radius * radius;
                var saturation = 0.5 + 0.5 * Math.random();
                var whiteBall = (Math.random() * 100 < 5);
                var tracerBall = false;
                
                Balls.push(new BALL(radius, mass, pos, vel, saturation, whiteBall, tracerBall, smallBallRadius, bigBallRadius));
            }
        } else if (targetCount < currentCount) {
            // Remove balls from the end
            Balls.length = targetCount;
        }
    }

    // Rescale existing balls based on new size inputs without recreating them
    function rescaleBalls() {
        if (!Array.isArray(Balls) || Balls.length === 0) return;
        
        var newSmallRadius = 0.001 * particlesMenuSmallRadius;
        var newBigRadius = 0.001 * particlesMenuLargeRadius;
        
        // Rescale each ball using its stored normalized position in the size range
        for (var i = 0; i < Balls.length; i++) {
            var ball = Balls[i];
            
            // Use stored normalized position (0-1) to map to new size range
            var normalizedPosition = ball.radiusNormalized !== undefined ? ball.radiusNormalized : 0.5;
            
            // When smallRadius is 0, all balls should be bigRadius
            var newRadius;
            if (newSmallRadius == 0) {
                newRadius = newBigRadius;
            } else {
                // Calculate new radius: smallRadius + (normalized * range)
                newRadius = newSmallRadius + normalizedPosition * (newBigRadius - newSmallRadius);
            }
            ball.radius = newRadius;
            ball.mass = 2 * Math.PI * newRadius * newRadius;
        }
    }

    function makeBalls() {
        Balls = [];
        var smallBallRadius = 0.001 * particlesMenuSmallRadius;
        var bigBallRadius = 0.001 * particlesMenuLargeRadius;
        var maxBallRadius = Math.max(smallBallRadius, bigBallRadius);
        var getNumBalls = particlesMenuQuantity * particlesMenuQuantity;
        var ballJitter = 0.20;
        var brakes = 0;
        // Use global dumpSqueeze value (set by double-tap-and-drag or default)
        // var dumpSqueeze is now handled globally
        var dumpSqueeze2 = 0.2;
        // Use global dumpShift value (set by mouse clicks or default center)
        // var dumpShift is now handled globally
        var velX = 0;
        var velY = 0;
        // On program start or any reset that calls makeBalls(), delay the heart puck 4x
        // the standard resume delay so the first visible beat begins cleanly after a brief intro pause.
        if (typeof Puck !== 'undefined' && Array.isArray(Puck) && Puck.length > 0) {
            const nowPerf = performance.now();
            for (var i = 0; i < Puck.length; i++) {
                var heartPuck = Puck[i];
                if (heartPuck && heartPuck.heartBeat === true) {
                    heartPuck.hbResumeAt = nowPerf + 4 * heartResumeDelayMs;
                    heartPuck.hbState = 'pause';
                    heartPuck.hbTimeInState = 0.0;
                    heartPuck.hbLastTime = nowPerf;
                    heartPuck.radius = heartPuck.OGradius;
                    break;
                }
            }
        }
        if (respawnMenuLayoutType === 'array') {  
            var numCols = Math.floor(Math.sqrt(getNumBalls));
            var numRows = Math.floor(Math.sqrt(getNumBalls));
            var countDifference = getNumBalls - (numCols * numRows);
            var addedRows = Math.ceil(countDifference / numCols);
            var boxWidth = (numCols * 2.0 * maxBallRadius);
            var boxHeight = ((numRows + addedRows) * 2.0 * maxBallRadius);
            var horizBias = 0.5 * (simWidth - boxWidth);
            var vertBias = 0.5 * (simHeight - boxHeight);
            var middleRow = Math.floor((numRows + addedRows) / 2);
            var middleCol = Math.floor(numCols / 2);
            for (var j = 0; j < (numRows + addedRows); j++) {
                for (var i = 0; i < numCols; i++) {
                    if (smallBallRadius == 0) {
                        var radius = bigBallRadius;
                    } else {
                        var radius = smallBallRadius + Math.random() * (bigBallRadius - smallBallRadius);
                    }          
                    var mass = 2 * Math.PI * radius * radius; 
                    var vel = new Vector2((-0.5 + 1.0 * Math.random()) * brakes, (-0.5 + 1.0 * Math.random()) * brakes);
                    var boxedPosX = (i + 1) * (boxWidth / (numCols +1)) + (Math.random() * radius * ballJitter) + horizBias;
                    var boxedPosY = (j + 1) * (boxHeight / (numRows + 1)) + vertBias;
                    var pos = new Vector2(boxedPosX, boxedPosY);
                    var saturation = 0.5 + 0.5 * Math.random();
                    if (Math.random() * 100 < 5) {
                            var whiteBall = true;
                        } else {
                            var whiteBall = false;
                        }
                    var tracerBall = (j == middleRow && i == middleCol);
                    if (Balls.length < getNumBalls) {
                        Balls.push(new BALL(radius, mass, pos, vel, saturation, whiteBall, tracerBall, smallBallRadius, bigBallRadius));
                    }
                }
            }
        }
        //  ROUND CLUSTER - SINGLE TIGHT SPIRAL
        if (respawnMenuLayoutType === 'cluster') {
            var centerX = 0.5 * simWidth;
            var centerY = 0.5 * simHeight;
            var ballDiameter = bigBallRadius * 2;
            var angle = 0;
            var spiralRadius = 0;
            
            for (var q = 0; q < getNumBalls; q++) {
                // Determine ball radius first
                if (smallBallRadius == 0) {
                    var radius = bigBallRadius;
                } else {
                    var radius = smallBallRadius + Math.random() * (bigBallRadius - smallBallRadius);
                }
                
                // Place first ball at center
                if (q == 0) {
                    var circleXpos = centerX;
                    var circleYpos = centerY;
                } else {
                    // Calculate position on spiral
                    var circleXpos = centerX + Math.cos(angle) * spiralRadius;
                    var circleYpos = centerY + Math.sin(angle) * spiralRadius;
                    
                    // Calculate next position based on ball diameter
                    // Angular step ensures balls are spaced by their diameter along the arc
                    var arcLength = ballDiameter * 1.05; // Small gap between balls
                    var angleStep = arcLength / Math.max(spiralRadius, ballDiameter);
                    angle += angleStep;
                    
                    // Increase radius slowly: one ball diameter per full rotation (2)
                    spiralRadius += (ballDiameter * angleStep) / (2 * Math.PI);
                }
                
                var mass = 2 * Math.PI * radius * radius; 
                var pos = new Vector2(circleXpos, circleYpos);   
                
                // Give balls slight outward velocity based on their position
                var outwardAngle = Math.atan2(circleYpos - centerY, circleXpos - centerX);
                var vel = new Vector2(Math.cos(outwardAngle) * brakes, Math.sin(outwardAngle) * brakes);
                
                if (Math.random() * 100 < 5) {
                    var whiteBall = true;
                } else {
                    var whiteBall = false;
                }
                if (q == 0) {
                    var tracerBall = true;
                } else {
                    var tracerBall = false;
                }   
                var saturation = 0.5 + 0.5 * Math.random();

                Balls.push(new BALL(radius, mass, pos, vel, saturation, whiteBall, tracerBall, smallBallRadius, bigBallRadius));
            }   
        }
    }

    // Dynamically reassign the tracer ball without respawning all balls
    function selectTracerBall() {
        if (!Array.isArray(Balls) || Balls.length === 0) return;

        // Determine target radius based on mode
        const sR = 0.001 * particlesMenuSmallRadius;
        const bR = 0.001 * particlesMenuLargeRadius;
        let targetR = 0.5 * (sR + bR); // default medium
        if (doSmallTracer === true) targetR = sR;
        else if (doBigTracer === true) targetR = bR;

        // Clear any current tracer flags and remember previous tracer to stop tracing
        let prevTracer = null;
        for (let i = 0; i < Balls.length; i++) {
            if (Balls[i].tracerBall === true) {
                prevTracer = Balls[i];
            }
            Balls[i].tracerBall = false;
            Balls[i].tracer = false;
            // restore color behavior; whiteBall remains whatever it was
        }

        // Choose the ball whose radius is closest to targetR
        let bestIdx = 0;
        let bestDiff = Number.POSITIVE_INFINITY;
        for (let i = 0; i < Balls.length; i++) {
            const diff = Math.abs(Balls[i].radius - targetR);
            if (diff < bestDiff) { bestDiff = diff; bestIdx = i; }
        }

        // Assign new tracer flags and ensure it has a trail buffer
        const tracer = Balls[bestIdx];
        tracer.tracerBall = true;
        tracer.tracer = true;
        tracer.whiteBall = true; // ensure white visual for the tracer
        if (!tracer.trail || tracer.trail.length === 0) {
            tracer.trail = new Float32Array(1500);
        }
        tracer.resetTrace();
    }

    //  CORNER CONSTRUCTOR  ---------------------------------------------------------------------
    class CORNER {
		constructor(pos, corner) {
			this.pos = pos.clone();
            this.corner = corner;
            this.radius = 0.01 * cornerRad * 0.5 * simHeight;
            if (screenVertical == true) {
                this.radius = 0.01 * cornerRad * 0.5 * simWidth;
            } else {
                this.radius = 0.01 * cornerRad * 0.5 * simHeight;
            }
        }
        get left() {
            return this.pos.x - this.radius;
        }
        get right() {
            return this.pos.x + this.radius;
        }
        draw() {
            // Use canvas gradient that matches page background for seamless edges
            if (!cornerFillGradient) { updateCornerFillGradient(); }
            c.fillStyle = cornerFillGradient; 
            var budge = 0;
            if (this.corner == 'northwest') {
                c.beginPath();
                c.moveTo(0, 0);
                c.lineTo(this.radius * cScale, 0);
                c.arc((this.pos.x + this.radius - budge) * cScale, (this.pos.y + this.radius - budge) * cScale, this.radius * cScale, 1.5 * Math.PI, Math.PI, true);
                c.lineTo(0, this.radius * cScale);
                c.closePath();
                c.fill();
            }
            if (this.corner == 'southwest') {
                c.beginPath();
                c.moveTo(0, simHeight * cScale);
                c.lineTo(0, (simHeight - this.radius) * cScale);
                c.arc((this.pos.x + this.radius - budge) * cScale, (this.pos.y - this.radius + budge) * cScale, this.radius * cScale, Math.PI, 0.5 * Math.PI, true);
                c.lineTo(this.radius * cScale, simHeight * cScale);
                c.closePath();
                c.fill();
            }
            if (this.corner == 'southeast') {
                c.beginPath();
                c.moveTo(simWidth * cScale, simHeight * cScale);
                c.lineTo((simWidth - this.radius) * cScale, simHeight * cScale);
                c.arc((this.pos.x - this.radius + budge) * cScale, (this.pos.y - this.radius + budge) * cScale, this.radius * cScale, 0.5 * Math.PI, 0, true);
                c.lineTo(simWidth * cScale, (simHeight - this.radius) * cScale);
                c.closePath();
                c.fill();
            }   
            if (this.corner == 'northeast') {
                c.beginPath();
                c.moveTo(simWidth * cScale, 0);
                c.lineTo(simWidth * cScale, this.radius * cScale);
                c.arc((this.pos.x - this.radius + budge) * cScale, (this.pos.y + this.radius - budge) * cScale, this.radius * cScale, 0, 1.5 * Math.PI, true);
                c.lineTo((simWidth - this.radius) * cScale, 0);
                c.closePath();
                c.fill();
            }
            
            // Draw the arc outlines
            c.strokeStyle = 'hsl(0, 0%, 25%)';
            c.lineWidth = 0.008 * cScale;
            c.lineCap = 'butt';
            var budge = 0.003;
            if (this.corner == 'northwest') {
                c.beginPath();
                c.arc((this.pos.x + this.radius + budge) * cScale, (this.pos.y + this.radius + budge) * cScale, this.radius * cScale, Math.PI, 1.5 * Math.PI, false);
            }
            if (this.corner == 'southwest') {
                c.beginPath();
                c.arc((this.pos.x + this.radius + budge) * cScale, (this.pos.y - this.radius - budge) * cScale, this.radius * cScale, 0.5 * Math.PI, 1.0 * Math.PI, false);
            }
            if (this.corner == 'southeast') {
                c.beginPath();
                c.arc((this.pos.x - this.radius - budge) * cScale, (this.pos.y - this.radius - budge) * cScale, this.radius * cScale, 2 * Math.PI, 0.5 * Math.PI, false);
            }   
            if (this.corner == 'northeast') {
                c.beginPath();
                c.arc((this.pos.x - this.radius - budge) * cScale, (this.pos.y + this.radius + budge) * cScale, this.radius * cScale, 1.5 * Math.PI, 2 * Math.PI, false);
            }
            c.stroke();
            //c.lineWidth = 0.009 * cScale;
            // top edge (ceiling)
            if (doCeiling == true) {
                c.beginPath();
                // Connect to actual corner positions when corners exist
                var leftCorner = Corners.find(c => c.corner === 'northwest');
                var rightCorner = Corners.find(c => c.corner === 'northeast');
                var leftX = (doLeftWall && this.radius > 0) ? (leftCorner.pos.x + this.radius + budge) * cScale : budge * cScale;
                var rightX = (doRightWall && this.radius > 0) ? (rightCorner.pos.x - this.radius - budge) * cScale : (simWidth - budge) * cScale;
                c.moveTo(leftX, budge * cScale);
                c.lineTo(rightX, budge * cScale);
                c.closePath();
                c.stroke();
            }
            // bottom edge (floor)
            if (doFloor == true) {
                c.beginPath();
                // Connect to actual corner positions when corners exist
                var leftCorner = Corners.find(c => c.corner === 'southwest');
                var rightCorner = Corners.find(c => c.corner === 'southeast');
                var leftX = (doLeftWall && this.radius > 0) ? (leftCorner.pos.x + this.radius + budge) * cScale : budge * cScale;
                var rightX = (doRightWall && this.radius > 0) ? (rightCorner.pos.x - this.radius - budge) * cScale : (simWidth - budge) * cScale;
                c.moveTo(leftX, (simHeight - budge) * cScale);
                c.lineTo(rightX, (simHeight - budge) * cScale);
                c.closePath();
                c.stroke();
            }
            
            // When corners move inward, we normally skip side outlines in horizontal mode,
            // but if either ceiling or floor is disabled, keep drawing the side outlines.
            if (cornerRad >= 100 && screenVertical == false && doCeiling && doFloor) {  
                return;
            }
            // left edge
            budge = 0.0;
            c.lineWidth = 0.016 * cScale;
            if (doLeftWall == true) {
                c.beginPath();
                // When corner radius > 0, connect to corner arcs; when corner radius = 0 or adjacent wall disabled, extend to edge
                var topY = (!doCeiling && cornerRad > 100) ? 0 : ((doCeiling && this.radius > 0) ? (this.radius + budge) * cScale : budge * cScale);
                var bottomY = (!doFloor && cornerRad > 100) ? (simHeight * cScale) : ((doFloor && this.radius > 0) ? (simHeight - this.radius - budge) * cScale : (simHeight - budge) * cScale);
                var leftWallX;
                if (cornerRad > 100 && (!doCeiling || !doFloor)) {
                    var leftCorner = (Corners && Corners.find(c => c.corner === 'northwest')) || (Corners && Corners.find(c => c.corner === 'southwest'));
                    if (leftCorner && typeof leftCorner.pos?.x === 'number') {
                        // Align with the vertical boundary defined by the corner center X
                        leftWallX = (leftCorner.pos.x + budge) * cScale;
                    } else {
                        leftWallX = budge * cScale; // fallback
                    }
                } else {
                    leftWallX = budge * cScale;
                }
                c.moveTo(leftWallX, topY);
                c.lineTo(leftWallX, bottomY);
                c.closePath();
                c.stroke();

                // Fill outside area to the left when corridor is constricted and a horizontal boundary is open
                if (cornerRad > 100 && (!doCeiling || !doFloor)) {
                    var prevFill = c.fillStyle;
                    // Match corner fill gradient
                    if (!cornerFillGradient) { updateCornerFillGradient(); }
                    c.fillStyle = cornerFillGradient;
                    c.beginPath();
                    c.rect(0, topY, Math.max(0, leftWallX), Math.max(0, bottomY - topY));
                    c.fill();
                    c.fillStyle = prevFill;
                }
            }  
            // right edge
            if (doRightWall == true) {
                c.beginPath();
                // When corner radius > 0, connect to corner arcs; when corner radius = 0 or adjacent wall disabled, extend to edge
                var topY = (!doCeiling && cornerRad > 100) ? 0 : ((doCeiling && this.radius > 0) ? (this.radius + budge) * cScale : budge * cScale);
                var bottomY = (!doFloor && cornerRad > 100) ? (simHeight * cScale) : ((doFloor && this.radius > 0) ? (simHeight - this.radius - budge) * cScale : (simHeight - budge) * cScale);
                var rightWallX;
                if (cornerRad > 100 && (!doCeiling || !doFloor)) {
                    var rightCorner = (Corners && Corners.find(c => c.corner === 'northeast')) || (Corners && Corners.find(c => c.corner === 'southeast'));
                    if (rightCorner && typeof rightCorner.pos?.x === 'number') {
                        // Align with the vertical boundary defined by the corner center X
                        rightWallX = (rightCorner.pos.x) * cScale;
                    } else {
                        rightWallX = (simWidth - budge) * cScale; // fallback
                    }
                } else {
                    rightWallX = (simWidth - budge) * cScale;
                }
                c.moveTo(rightWallX, topY);
                c.lineTo(rightWallX, bottomY);
                c.closePath();
                c.stroke();

                // Fill outside area to the right when corridor is constricted and a horizontal boundary is open
                if (cornerRad > 100 && (!doCeiling || !doFloor)) {
                    var prevFill2 = c.fillStyle;
                    // Match corner fill gradient
                    if (!cornerFillGradient) { updateCornerFillGradient(); }
                    c.fillStyle = cornerFillGradient;
                    c.beginPath();
                    var rx = Math.min(rightWallX, simWidth * cScale);
                    c.rect(rx, topY, Math.max(0, simWidth * cScale - rx), Math.max(0, bottomY - topY));
                    c.fill();
                    c.fillStyle = prevFill2;
                }
            }
        }
    }

    class WORM {
        constructor(masses, lengths, angles, radii) {
            this.masses = [0.0];
            this.lengths = [0.0];
            this.radii = [0.0];
            this.pos = [{x:0.0, y:0.0}];
            this.prevPos = [{x:0.0, y:0.0}];
            this.vel = [{x:0.0, y:0.0}];
            this.theta = [0.0];
            this.omega = [0.0];
            this.waver = 0.0;

            var x = 0.0, y = 0.0;
            for (var i = 0; i < masses.length; i++) {
                var mi = masses[i];
                var li = lengths[i];
                var ai = angles[i];
                var ri = radii[i];
                this.masses.push(mi);
                this.lengths.push(li);
                this.radii.push(ri);
                this.theta.push(ai);
                this.omega.push(0.0);

                x = 0;
                y += li * Math.cos(ai);
                this.pos.push({ x:x, y:y});
                this.prevPos.push({ x:x, y:y});
                this.vel.push({x:0, y:0});
            }
        }
        simulate(dt) {
            var p = this;
            for (var i = 1; i < p.masses.length; i++) {
                p.prevPos[i].x = p.pos[i].x;
                p.prevPos[i].y = p.pos[i].y;
                p.pos[i].x += p.vel[i].x * dt;
                p.pos[i].y += p.vel[i].y * dt;
            }
            for (var i = 1; i < p.masses.length; i++) {
                var dx = p.pos[i].x - p.pos[i-1].x;
                var dy = p.pos[i].y - p.pos[i-1].y;
                var d = Math.sqrt(dx * dx + dy * dy);
                if (d > 1e-9) {
                    var w0 = p.masses[i - 1] > 0.0 ? 1.0 / p.masses[i - 1] : 0.0;
                    var w1 = p.masses[i] > 0.0 ? 1.0 / p.masses[i] : 0.0;
                    var corr = (p.lengths[i] - d) / d / (w0 + w1);
                    p.pos[i - 1].x -= w0 * corr * dx; 
                    p.pos[i - 1].y -= w0 * corr * dy; 
                    p.pos[i].x += w1 * corr * dx; 
                    p.pos[i].y += w1 * corr * dy; 
                }
            }
                // --- Joint angle limits: iterate interior joints and prevent acute folding
                for (var i = 1; i < p.pos.length - 1; i++) {
                    var A = p.pos[i-1];
                    var B = p.pos[i];
                    var C = p.pos[i+1];
                    // vectors from joint B
                    var vBAx = A.x - B.x, vBAy = A.y - B.y;
                    var vBCx = C.x - B.x, vBCy = C.y - B.y;
                    var lenBA = Math.sqrt(vBAx*vBAx + vBAy*vBAy);
                    var lenBC = Math.sqrt(vBCx*vBCx + vBCy*vBCy);
                    if (lenBA < 1e-9 || lenBC < 1e-9) continue;
                    // compute angle between vBA and vBC (0..PI)
                    var dot = (vBAx * vBCx + vBAy * vBCy) / (lenBA * lenBC);
                    dot = Math.max(-1, Math.min(1, dot));
                    var angle = Math.acos(dot);
                    if (angle < WormProps.minJointAngle) {
                        // need to increase angle to minJointAngle by rotating vBC around B
                        var targetAngle = WormProps.minJointAngle;
                        var delta = targetAngle - angle; // positive
                        // determine rotation direction using cross product (z-component)
                        var cross = vBAx * vBCy - vBAy * vBCx;
                        var sign = (cross >= 0) ? 1 : -1;
                        // compute current angle of vBC
                        var cur = Math.atan2(vBCy, vBCx);
                        // rotate by sign * delta
                        var newAngle = cur + sign * delta;
                        // place C at new location preserving segment length lenBC (should be p.lengths[i+1])
                        var newCx = B.x + Math.cos(newAngle) * lenBC;
                        var newCy = B.y + Math.sin(newAngle) * lenBC;
                        // apply small smoothing: lerp between old and new to avoid jitter
                        var smooth = 0.9; // keep most of the correction
                        p.pos[i+1].x = newCx * smooth + C.x * (1 - smooth);
                        p.pos[i+1].y = newCy * smooth + C.y * (1 - smooth);
                        // update prevPos to avoid large velocity spikes
                        p.prevPos[i+1].x = p.pos[i+1].x - (p.pos[i+1].x - p.prevPos[i+1].x) * 0.5;
                        p.prevPos[i+1].y = p.pos[i+1].y - (p.pos[i+1].y - p.prevPos[i+1].y) * 0.5;
                    }
                }
            for (var i = 1; i < p.masses.length; i++) {
                p.vel[i].x = 0.99 * (p.pos[i].x - p.prevPos[i].x) / dt;
                p.vel[i].y = 0.99 * (p.pos[i].y - p.prevPos[i].y) / dt;

            }
        }
        draw() {
            var p = this;
            
            if (wormRenderMode === 'curves') {
                // CURVED OUTLINE RENDERING using bezier curves
                this.drawCurved();
            } else {
                // SPHERE RENDERING (original)
                this.drawSpheres();
            }
        }
        
        drawSpheres() {
            var p = this;
            //  CIRCLES  ----------
            for (var i = 1; i < p.pos.length; i++) {
                var ri = (i < p.radii.length && typeof p.radii[i] === 'number') ? p.radii[i] : 0.02;
                var r = ri;
                c.beginPath();
                c.arc(
                    cX(p.pos[i]), cY(p.pos[i]), cScale * r, 0.0, 2 * Math.PI);
                c.closePath();
                var sphereGradient = c.createRadialGradient(
                        (cX(p.pos[i]) - (0.2 * r * cScale)), 
                        (cY(p.pos[i]) - (0.4 * r * cScale)), 
                        0, 
                        (cX(p.pos[i]) - (0.2 * r * cScale)), 
                        (cY(p.pos[i]) - (0.4 * r * cScale)), 
                        1.2 * r * cScale
                    );
                var highlight = 'hsl(30, 80%, 80%)';
                var midtone = 'hsl(30, 80%, 60%)';
                var shadow = 'hsl(30, 80%, 10%)';
                sphereGradient.addColorStop(0.0, highlight);
                sphereGradient.addColorStop(0.15, midtone);
                sphereGradient.addColorStop(1.0, shadow);
                c.fillStyle = sphereGradient;
                c.fill();
                //c.lineWidth = .02 * cScale;  
                //c.strokeStyle = "blue";       
                //c.fillStyle = "darkblue";
                //c.fill();
                //c.stroke();
            }
            // pivot (pos[0]) is intentionally not drawn so the first visible
            // circle (pos[1]) is the head of the chain.
        }
        
        drawCurved() {
            var p = this;
            if (p.pos.length < 3) return; // Need at least 3 points for curves
            
            // Build smooth outline using perpendicular offsets at each node
            var topPoints = [];
            var bottomPoints = [];
            
            // Clear global outline storage
            wormOutlinePoints.top = [];
            wormOutlinePoints.bottom = [];
            
            for (var i = 1; i < p.pos.length; i++) {
                var ri = (i < p.radii.length && typeof p.radii[i] === 'number') ? p.radii[i] : 0.02;
                
                // Calculate tangent direction (average of segments before and after)
                var tangent = new Vector2(0, 0);
                if (i > 1 && i < p.pos.length - 1) {
                    // Interior point: average of two adjacent segments
                    var prev = new Vector2().subtractVectors(p.pos[i], p.pos[i-1]);
                    var next = new Vector2().subtractVectors(p.pos[i+1], p.pos[i]);
                    tangent.addVectors(prev, next);
                    tangent.scale(0.5);
                } else if (i === 1) {
                    // First point: use forward direction
                    tangent.subtractVectors(p.pos[i+1], p.pos[i]);
                } else {
                    // Last point: use backward direction
                    tangent.subtractVectors(p.pos[i], p.pos[i-1]);
                }
                
                // Normalize tangent
                var len = tangent.length();
                if (len > 0.0001) {
                    tangent.scale(1.0 / len);
                }
                
                // Perpendicular vector (rotated 90 degrees)
                var perp = tangent.perp();
                
                // Offset points above and below centerline
                var topPt = new Vector2(
                    p.pos[i].x + perp.x * ri,
                    p.pos[i].y + perp.y * ri
                );
                var bottomPt = new Vector2(
                    p.pos[i].x - perp.x * ri,
                    p.pos[i].y - perp.y * ri
                );
                
                topPoints.push(topPt);
                bottomPoints.push(bottomPt);
                
                // Store in global collision data
                wormOutlinePoints.top.push(topPt);
                wormOutlinePoints.bottom.push(bottomPt);
            }
            
            // Store head info for collision
            var firstCenter = p.pos[1];
            var firstRadius = (p.radii.length > 1 ? p.radii[1] : 0.02);
            wormOutlinePoints.headCenter = firstCenter;
            wormOutlinePoints.headRadius = firstRadius;
            
            // Draw filled outline using bezier curves
            c.beginPath();
            
            // Start at head (first visible node)
            c.moveTo(cX(topPoints[0]), cY(topPoints[0]));
            
            // Draw top edge with smooth cubic bezier curves
            for (var i = 0; i < topPoints.length - 1; i++) {
                var p0 = topPoints[i];
                var p1 = topPoints[i + 1];
                
                // Calculate control points for smooth cubic bezier
                // Place control points 1/3 and 2/3 along the segment for smoother curves
                var cp1X = cX(p0) + (cX(p1) - cX(p0)) * 0.33;
                var cp1Y = cY(p0) + (cY(p1) - cY(p0)) * 0.33;
                var cp2X = cX(p0) + (cX(p1) - cX(p0)) * 0.67;
                var cp2Y = cY(p0) + (cY(p1) - cY(p0)) * 0.67;
                
                c.bezierCurveTo(cp1X, cp1Y, cp2X, cp2Y, cX(p1), cY(p1));
            }
            
            // Draw tail cap (semicircle)
            var lastTop = topPoints[topPoints.length - 1];
            var lastBottom = bottomPoints[bottomPoints.length - 1];
            var lastCenter = p.pos[p.pos.length - 1];
            var lastRadius = (p.radii.length > 0 ? p.radii[p.radii.length - 1] : 0.02) * cScale;
            c.arc(cX(lastCenter), cY(lastCenter), lastRadius, 
                  Math.atan2(cY(lastCenter) - cY(lastTop), cX(lastCenter) - cX(lastTop)),
                  Math.atan2(cY(lastCenter) - cY(lastBottom), cX(lastCenter) - cX(lastBottom)));
            
            // Draw bottom edge back to start (reversed)
            for (var i = bottomPoints.length - 1; i > 0; i--) {
                var p0 = bottomPoints[i];
                var p1 = bottomPoints[i - 1];
                
                // Calculate control points for smooth cubic bezier
                var cp1X = cX(p0) + (cX(p1) - cX(p0)) * 0.33;
                var cp1Y = cY(p0) + (cY(p1) - cY(p0)) * 0.33;
                var cp2X = cX(p0) + (cX(p1) - cX(p0)) * 0.67;
                var cp2Y = cY(p0) + (cY(p1) - cY(p0)) * 0.67;
                
                c.bezierCurveTo(cp1X, cp1Y, cp2X, cp2Y, cX(p1), cY(p1));
            }
            
            // Draw head cap (semicircle)
            var firstTop = topPoints[0];
            var firstBottom = bottomPoints[0];
            var firstCenter = p.pos[1]; // First visible node
            var firstRadius = (p.radii.length > 1 ? p.radii[1] : 0.02) * cScale;
            c.arc(cX(firstCenter), cY(firstCenter), firstRadius,
                  Math.atan2(cY(firstCenter) - cY(firstBottom), cX(firstCenter) - cX(firstBottom)),
                  Math.atan2(cY(firstCenter) - cY(firstTop), cX(firstCenter) - cX(firstTop)));
            
            c.closePath();
            
            // Fill with gradient - calculate body gradient from tail to head for smooth transition
            var bodyGradientStart = p.pos[p.pos.length - 1]; // tail
            var bodyGradientEnd = p.pos[1]; // head
            var gradient = c.createLinearGradient(
                cX(bodyGradientStart), cY(bodyGradientStart),
                cX(bodyGradientEnd), cY(bodyGradientEnd)
            );
            gradient.addColorStop(0, 'hsl(30, 80%, 20%)');  // dark at tail
            gradient.addColorStop(0.5, 'hsl(30, 80%, 50%)'); // mid tone
            gradient.addColorStop(1, 'hsl(30, 80%, 70%)');   // light at head
            c.fillStyle = gradient;
            c.fill();
            
            // Draw full circle for the head (lead segment) using same body gradient
            c.beginPath();
            c.arc(cX(firstCenter), cY(firstCenter), firstRadius, 0, 2 * Math.PI);
            c.closePath();
            
            // Use the same gradient as the body for continuous appearance
            c.fillStyle = gradient;
            c.fill();
        }
    }

    function simulateWorm() {
        var sdt = WormProps.dt / WormProps.wormSubSteps;

        for (var step = 0; step < WormProps.wormSubSteps; step++) {
            WormProps.SpaceWorm.simulate(sdt, WormProps.gravity);
        }

        // Wiggle trigger: when head vertical velocity crosses zero (top/bottom of stroke)
        var p = WormProps.SpaceWorm;
        if (!WormProps.wiggleActive && p && p.vel && p.vel.length > 1) {
            var headVY = p.vel[1].y;
            // detect zero crossing (sign change) with a small threshold to avoid noise
            if (Math.abs(headVY) < WormProps.wiggleVyZeroThreshold && Math.abs(WormProps.prevHeadVY) >= WormProps.wiggleVyZeroThreshold) {
                // alternate wiggle direction each cycle for visual variation
                WormProps.wiggleToggle *= -1;
                var dir = WormProps.wiggleToggle; // -1 or +1
                WormProps.wiggleDir = dir;
                // vertical per-frame impulse in sim units
                var totalSimY = (WormProps.wiggleDistancePixels / cScale) * dir;
                WormProps.wigglePerFrameVel = (totalSimY / (WormProps.wiggleFrames * WormProps.dt));
                // horizontal propulsion per-frame (sim units)
                var totalSimX = (WormProps.wiggleXPixels / cScale) * dir;
                WormProps.wigglePerFrameVelX = (totalSimX / (WormProps.wiggleFrames * WormProps.dt));
                // small pivot advance per frame to push the worm forward during wiggle
                var totalAdvanceSim = (WormProps.wiggleXPixels * 0.5 / cScale) * dir; // proportional to X pixels
                WormProps.wiggleAdvancePerFrame = totalAdvanceSim / WormProps.wiggleFrames;
                WormProps.wiggleActive = true;
                WormProps.wiggleFrame = 0;
            }
            WormProps.prevHeadVY = headVY;
        }
        if (WormProps.wiggleActive) {
            var p = WormProps.SpaceWorm;
            if (p && p.pos.length > 1) {
                // apply per-frame vertical impulse to head (pos[1])
                p.pos[1].y += WormProps.wigglePerFrameVel * WormProps.dt;
                // apply small horizontal impulse to head
                p.pos[1].x += WormProps.wigglePerFrameVelX * WormProps.dt;
                // nudge prevPos to create a velocity impulse for the solver
                p.prevPos[1].y = p.pos[1].y - WormProps.wigglePerFrameVel * WormProps.dt * 0.5;
                p.prevPos[1].x = p.pos[1].x - WormProps.wigglePerFrameVelX * WormProps.dt * 0.5;
                // also advance the pivot a little to visualize propulsion
                p.pos[0].x += WormProps.wiggleAdvancePerFrame;
                p.prevPos[0].x += WormProps.wiggleAdvancePerFrame * 0.5;
            }
            WormProps.wiggleFrame++;
            if (WormProps.wiggleFrame >= WormProps.wiggleFrames) {
                WormProps.wiggleActive = false;
                WormProps.wiggleAdvancePerFrame = 0.0;
            }
        }

        // Run movement/wrap logic once per frame (per dT) instead of every substep.
        if (doWorm && WormProps.SpaceWorm && !WormProps.isHiding) {
            var p = WormProps.SpaceWorm;
            // regular horizontal advance of the pivot (scaled to dT)
            // apply once per substep, so divide by substeps to keep speed constant per frame
            p.pos[0].x += WormProps.advanceSpeed / physProps.substeps;
            // traveling-wave body undulation (fish-like propulsion)
            // advance the global wave phase
            WormProps.phase += WormProps.wavePhaseIncrement / physProps.substeps;
            // compute amplitude in sim units
            var ampPixels = canvas.height * WormProps.waveAmplitudeRatio;
            var ampSim = ampPixels / cScale;
            // For each node, compute a target lateral position from a traveling sinusoid
            for (var i = 1; i < p.pos.length; i++) {
                // spatial phase lag increases toward the tail
                var nodePhase = WormProps.phase - (i * WormProps.waveNodeLag);
                var targetY = WormProps.spawnInitialYSim + ampSim * Math.sin(nodePhase);
                // nudge current node toward the target wave position (smooth steering)
                var deltaY = (targetY - p.pos[i].y) * WormProps.waveNudge;
                p.pos[i].y += deltaY;
                // update prevPos slightly so the solver sees an effective lateral velocity impulse
                p.prevPos[i].y += deltaY * 0.5;
                // compute lateral velocity (sim units / dt)
                var lateralV = (p.pos[i].y - p.prevPos[i].y) / WormProps.dt;
                // convert a portion of lateral motion into forward thrust
                // larger nodes (near the head) produce slightly less per-node thrust
                var sizeFactor = (i < p.radii.length ? p.radii[i] : 0.02);
                var thrust = -Math.sign(lateralV) * Math.abs(lateralV) * WormProps.thrustCoeff * (sizeFactor * 50);
                // apply small forward displacement to simulate reaction against fluid
                p.pos[i].x += thrust;
                p.prevPos[i].x += thrust * 0.5;
            }
            // keep pivot vertically anchored to the spawn baseline so the whole body follows
            p.pos[0].y = WormProps.spawnInitialYSim + ampSim * Math.sin(WormProps.phase - (0 * WormProps.waveNodeLag));
        }
        
        // Handle worm wrap-around and delay logic
        if (doWorm && WormProps.SpaceWorm) {
            var p = WormProps.SpaceWorm;
            // If the entire chain has passed the right edge, start hiding delay
            // or check if delay has elapsed to reappear on left side
            var minX = Infinity, maxX = -Infinity;
            for (var i = 0; i < p.pos.length; i++) {
                if (p.pos[i].x < minX) minX = p.pos[i].x;
                if (p.pos[i].x > maxX) maxX = p.pos[i].x;
            }
            var canvasRightSim = canvas.width / cScale;
            var lastIdx = p.pos.length - 1;
            var lastRadius = (lastIdx < p.radii.length) ? p.radii[lastIdx] : 0.02;
            var lastLeftEdge = p.pos[lastIdx].x - lastRadius;
            if (lastLeftEdge > canvasRightSim && !WormProps.isHiding) {
                WormProps.isHiding = true;
                WormProps.hideStartTime = Date.now();
            } else if (WormProps.isHiding) {
                var currentTime = Date.now();
                if (currentTime - WormProps.hideStartTime >= WormProps.hideDelay) {
                    // Delay has elapsed - recycle worm
                    WormProps.isHiding = false;
                    WormProps.advanceSpeed = (0.015 + 0.02 * Math.random()) / physProps.substeps;
                    WormProps.wavePhaseIncrement = WormProps.advanceSpeed * 3.0;
                    WormProps.waveAmplitudeRatio = Math.max(0.05, WormProps.advanceSpeed * 3.5);
                    var spawnGapSim = Math.max(WormProps.spawnGapMinPixels / cScale, WormProps.spawnGapWidthFactor * canvas.width / cScale, WormProps.spawnGapMinSim);
                    var shiftSim = - (maxX + spawnGapSim);
                    for (var i = 0; i < p.pos.length; i++) {
                        p.pos[i].x += shiftSim;
                        p.prevPos[i].x += shiftSim;
                    }
                }
            }
        }
    }

    //  MAKE WORM  ---------------------------------
    function makeWorm() {
        //  WORM CONSTANTS -----------
        steps = 100;
        // Set initial Y position based on current simHeight
        WormProps.spawnInitialYSim = 0.5 * simHeight;
        
        // Tunable constants (edit these to change motion/spawn behavior)
        // Set random advance speed and store it in WormProps for consistency
        if (!WormProps.advanceSpeed) {
            WormProps.advanceSpeed = (0.015 + 0.02 * Math.random()) / WormProps.wormSubSteps;
        }
        // Set wavePhaseIncrement proportional to advanceSpeed
        // (tune the multiplier as needed for desired effect)
        WormProps.wavePhaseIncrement = WormProps.advanceSpeed * 3.0;
        WormProps.waveAmplitudeRatio = Math.max(0.05, WormProps.advanceSpeed * 3.5);
        // All motion constants are now stored in WormProps with camelCase naming
        // Fish-style traveling wave (body undulation) parameters
        //leadRradius = 0.15;
        //minRradius = 0.05;
        //numNodes = 20;
        leadRradius = WormProps.startRadius;
        minRradius = WormProps.endRadius;
        numNodes = WormProps.numNodes;

        var angles = [];
        var lengths = [];
        var masses = [];
        var radii = [];
        if (numNodes == 1) {
            radii.push(leadRradius);
        } else {
            // progression from leadRradius to minRradius
            var ratio = Math.pow(minRradius / leadRradius, 1.0 / (numNodes - 1));
            for (var i = 0; i < numNodes; i++)
                radii.push(leadRradius * Math.pow(ratio, i));
        }
        //  Lengths are chosen so neighboring circles touch (center distance = r_prev + r_curr).
        //  lengths: distance from pivot to first node, then between nodes so circles touch
        lengths = [];
        var pivotRadius = leadRradius; // make pivot radius match lead so the first length fits
        for (var i = 0; i < numNodes; i++) {
            if (i == 0)
                lengths.push(1.03 * (pivotRadius + radii[0])); // extra space from pivot to head
            else
                lengths.push(1.03 * (radii[i - 1] + radii[i]));
        }
        //  set mass
        var massScale = 10000000;
        for (var i = 0; i < radii.length; i++) {
            masses.push(Math.max(0.0001, radii[i] * radii[i] * massScale));
        }

        WormProps.SpaceWorm = new WORM(masses, lengths, angles, radii);
        
        // Initialize worm delay state - don't hide at startup
        WormProps.isHiding = false;
        WormProps.hideStartTime = 0;
        
        // spawn the  chain
        (function(){
            var p = WormProps.SpaceWorm;
            if (!p) return;
            // compute total span from pivot to last node in sim units
            var totalSpan = 0.0;
            for (var i = 1; i < p.lengths.length; i++) {
                totalSpan += p.lengths[i];
            }
            // spawnGapSim: how far left of x=0 the rightmost node should be
            var spawnGapSim = Math.max(
                WormProps.spawnGapMinSim, 
                WormProps.spawnGapWidthFactor * canvas.width / cScale, 
                WormProps.spawnGapMinPixels / cScale
            );
            // startX is where the pivot (pos[0]) will be placed  use the
            // explicit spawnInitialXSim constant (no fallback).
            p.pos[0].x = WormProps.spawnInitialXSim;
            // use explicit spawnInitialYSim for vertical placement
            p.pos[0].y = WormProps.spawnInitialYSim;
            p.prevPos[0].x = p.pos[0].x;
            p.prevPos[0].y = p.pos[0].y;
            for (var i = 1; i < p.pos.length; i++) {
                // place each subsequent node to the LEFT of the previous one
                p.pos[i].x = p.pos[i-1].x - p.lengths[i];
                p.pos[i].y = WormProps.spawnInitialYSim;
                p.prevPos[i].x = p.pos[i].x;
                p.prevPos[i].y = p.pos[i].y;
            }
        })();
    }

    //  DEFINE CORNERS  ---------------------------------------------------------------------
    function makeCorners() {
        if (typeof CORNER === 'undefined') {
            // CORNER class not yet defined, skip for now
            return;
        }
        Corners = [];
        Corners.push(new CORNER(new Vector2(0, 0), 'northwest'));
        Corners.push(new CORNER(new Vector2(simWidth, 0), 'northeast'));
        Corners.push(new CORNER(new Vector2(0, simHeight), 'southwest'));
        Corners.push(new CORNER(new Vector2(simWidth, simHeight), 'southeast'));
        updateCornerGeometry();
    }

    // Update corner radii and positions to match walls menu
    function updateCornerGeometry() {
        if (typeof Corners === 'undefined' || !Corners) {
            return; // Skip if Corners array not initialized yet
        }
        var cornerRad = (wallsMenuCornerRadius !== undefined) ? wallsMenuCornerRadius : 100;
        if (cornerRad < 100) {
            // Stage 1: Adjust radius only (0-100)
            for (var c = 0; c < Corners.length; c++) {
                var corner = Corners[c];
                if (screenVertical == true) {
                    corner.radius = 0.01 * cornerRad * 0.5 * simWidth;
                } else {
                    corner.radius = 0.01 * cornerRad * 0.5 * simHeight;
                }
                // Reset corners to edges
                if (corner.corner == 'northwest' || corner.corner == 'southwest') {
                    corner.pos.x = 0;
                } else if (corner.corner == 'northeast' || corner.corner == 'southeast') {
                    corner.pos.x = simWidth;
                }
                // Reset Y positions too
                if (corner.corner == 'northwest' || corner.corner == 'northeast') {
                    corner.pos.y = 0;
                } else if (corner.corner == 'southwest' || corner.corner == 'southeast') {
                    corner.pos.y = simHeight;
                }
            }
        } else {
            // Stage 2: Maximum radius, but move corners inward horizontally only (100-150)
            for (var c = 0; c < Corners.length; c++) {
                var corner = Corners[c];
                // Set radius to maximum (touching state)
                if (screenVertical == true) {
                    corner.radius = 0.5 * simWidth;
                } else {
                    corner.radius = 0.5 * simHeight;
                }
                
                // Calculate lateral movement based on slider position (100-150)
                var cornerSeparation = simWidth - 2 * corner.radius;
                var cornerClosureRatio = (cornerRad - 100) / 50; // Corrected for 0-50 range in Stage 2
                var maximumShift = 0.5 * simWidth - corner.radius;
                var shiftAmount = Math.min(maximumShift, cornerSeparation * cornerClosureRatio);
                
                // Move corners horizontally inward only
                if (cornerClosureRatio > 0) {
                    if (corner.corner == 'northwest' || corner.corner == 'southwest') {
                        corner.pos.x = shiftAmount;
                    } else if (corner.corner == 'northeast' || corner.corner == 'southeast') {
                        corner.pos.x = simWidth - shiftAmount;
                    }
                } else {
                    // Reset to edges if no closure
                    if (corner.corner == 'northwest' || corner.corner == 'southwest') {
                        corner.pos.x = 0;
                    } else if (corner.corner == 'northeast' || corner.corner == 'southeast') {
                        corner.pos.x = simWidth;
                    }
                }
                
                // Keep Y positions at edges (no vertical movement)
                if (corner.corner == 'northwest' || corner.corner == 'northeast') {
                    corner.pos.y = 0;
                } else if (corner.corner == 'southwest' || corner.corner == 'southeast') {
                    corner.pos.y = simHeight;
                }
            }
        }
    }

    //  DEFINE BUMPERS --------------------------------------------------------------
    function makeBumpers() {
        Bumpers = [];
        // bumperRows and bumperRadius are now global variables set by mouse wheel
        const gapMultiplier = 1.1;
        const smallBumperRatio = 0.75;
        const vertBumperPadding = 0.30;
        var smallBallRadius = 0.001 * particlesMenuSmallRadius;
        var bigBallRadius = 0.001 * particlesMenuLargeRadius;
        var maxBallRadius = Math.max(smallBallRadius, bigBallRadius);
        var bumperSpacing = (2 * maxBallRadius) * gapMultiplier;
        var combinedSpacing = (2 * bumperRadius) + bumperSpacing;
        var verticalBPD = vertBumperPadding * combinedSpacing;
        var combinedVerticalSpacing = (2 * bumperRadius) + bumperSpacing + verticalBPD;
        var paddingCorrectionShift = -0.5 * ((bumperRows - 1) * verticalBPD);
        if (Math.trunc(simWidth / combinedSpacing) % 2 == 0) {
            bumperCols = Math.trunc(simWidth / combinedSpacing); 
        } else {
            bumperCols = Math.trunc(simWidth / combinedSpacing) + 1; 
        }
        var bumperBarLengthX = ((bumperCols - 1.0) * bumperSpacing) + ((2.0 * (bumperCols -1.0)) * bumperRadius);
        var bumperBarLengthY = ((bumperRows - 1.0) * bumperSpacing) + ((2.0 * (bumperRows -1.0)) * bumperRadius);
        var centeringOffsetX = (simWidth / 2.0) - (bumperBarLengthX / 2.0);
        var centeringOffsetY = (simHeight / 2.0) - (bumperBarLengthY / 2.0) + (-0.3 * simHeight + paddingCorrectionShift);
        var bottomMargin = ((simHeight - bumperBarLengthY) / 2) + 2 * bumperRadius;
        var topMargin = ((simHeight - bumperBarLengthY) / 2) + bumperBarLengthY + 2 * bumperRadius; 
            centeringOffsetY - combinedVerticalSpacing/2;
        var numBumpers = 0;
        for (p = -1; p < bumperCols; p++) {
            for (q = 0; q < bumperRows; q++) {
                if (q % 2 == 0) {
                    Bumpers.push(new BUMPER(bumperRadius, new Vector2((p * combinedSpacing) + (combinedSpacing / 2.0) + centeringOffsetX, (q * combinedVerticalSpacing) + centeringOffsetY)));        
                    numBumpers += 1;
                } else if (p > -1) {
                    Bumpers.push(new BUMPER(bumperRadius * smallBumperRatio, new Vector2((p * combinedSpacing) + centeringOffsetX, (q * combinedVerticalSpacing) + centeringOffsetY)));    
                    numBumpers += 1;
                }
            }
        }
    }

    // Update bumper radius without rebuilding array
    function updateBumperRadius(newRadius) {
        if (Bumpers.length === 0) return;
        
        const oldRadius = bumperRadius;
        bumperRadius = newRadius;
        const smallBumperRatio = 0.75;
        const gapMultiplier = 1.1;
        const vertBumperPadding = 0.30;
        
        var smallBallRadius = 0.001 * particlesMenuSmallRadius;
        var bigBallRadius = 0.001 * particlesMenuLargeRadius;
        var maxBallRadius = Math.max(smallBallRadius, bigBallRadius);
        var bumperSpacing = (2 * maxBallRadius) * gapMultiplier;
        var combinedSpacing = (2 * bumperRadius) + bumperSpacing;
        var verticalBPD = vertBumperPadding * combinedSpacing;
        var combinedVerticalSpacing = (2 * bumperRadius) + bumperSpacing + verticalBPD;
        
        // Calculate old spacing values
        var oldCombinedSpacing = (2 * oldRadius) + bumperSpacing;
        var oldVerticalBPD = vertBumperPadding * oldCombinedSpacing;
        var oldCombinedVerticalSpacing = (2 * oldRadius) + bumperSpacing + oldVerticalBPD;
        
        // Find the center of the current bumper array
        let minY = Infinity, maxY = -Infinity;
        let minX = Infinity, maxX = -Infinity;
        for (let i = 0; i < Bumpers.length; i++) {
            minY = Math.min(minY, Bumpers[i].OGpos.y);
            maxY = Math.max(maxY, Bumpers[i].OGpos.y);
            minX = Math.min(minX, Bumpers[i].OGpos.x);
            maxX = Math.max(maxX, Bumpers[i].OGpos.x);
        }
        const centerY = (minY + maxY) / 2;
        const centerX = (minX + maxX) / 2;
        
        // Update each bumper's radius and position based on new spacing
        for (let i = Bumpers.length - 1; i >= 0; i--) {
            const bumper = Bumpers[i];
            const isSmallBumper = bumper.radius < oldRadius * 0.9;
            
            // Update radius
            bumper.radius = isSmallBumper ? bumperRadius * smallBumperRatio : bumperRadius;
            
            // Calculate displacement from center in grid units
            const offsetY = bumper.OGpos.y - centerY;
            const offsetX = bumper.OGpos.x - centerX;
            
            // Scale the offset based on new spacing
            const scaleY = oldCombinedVerticalSpacing > 0 ? combinedVerticalSpacing / oldCombinedVerticalSpacing : 1;
            const scaleX = oldCombinedSpacing > 0 ? combinedSpacing / oldCombinedSpacing : 1;
            
            const newOffsetY = offsetY * scaleY;
            const newOffsetX = offsetX * scaleX;
            
            // Calculate current position offset from OGpos
            const currentOffsetX = bumper.pos.x - bumper.OGpos.x;
            const currentOffsetY = bumper.pos.y - bumper.OGpos.y;
            
            // Update OGpos
            bumper.OGpos.y = centerY + newOffsetY;
            bumper.OGpos.x = centerX + newOffsetX;
            
            // Update current pos to maintain relative offset
            bumper.pos.y = bumper.OGpos.y + currentOffsetY;
            bumper.pos.x = bumper.OGpos.x + currentOffsetX;
            
            // Check if bumper is now off-screen and remove it
            if (bumper.pos.x - bumper.radius < -bumper.radius * 2 || 
                bumper.pos.x + bumper.radius > simWidth + bumper.radius * 2 ||
                bumper.pos.y - bumper.radius < -bumper.radius * 2 || 
                bumper.pos.y + bumper.radius > simHeight + bumper.radius * 2) {
                Bumpers.splice(i, 1);
            }
        }
        
        // When scaling down, check if we need to add bumpers at the edges
        if (newRadius < oldRadius) {
            addMissingBumpers();
        }
    }
    
    // Add bumpers that should exist based on current grid but are missing
    function addMissingBumpers() {
        if (Bumpers.length === 0) return;
        
        const gapMultiplier = 1.1;
        const smallBumperRatio = 0.75;
        const vertBumperPadding = 0.30;
        var smallBallRadius = 0.001 * particlesMenuSmallRadius;
        var bigBallRadius = 0.001 * particlesMenuLargeRadius;
        var maxBallRadius = Math.max(smallBallRadius, bigBallRadius);
        var bumperSpacing = (2 * maxBallRadius) * gapMultiplier;
        var combinedSpacing = (2 * bumperRadius) + bumperSpacing;
        var verticalBPD = vertBumperPadding * combinedSpacing;
        var combinedVerticalSpacing = (2 * bumperRadius) + bumperSpacing + verticalBPD;
        
        if (Math.trunc(simWidth / combinedSpacing) % 2 == 0) {
            bumperCols = Math.trunc(simWidth / combinedSpacing); 
        } else {
            bumperCols = Math.trunc(simWidth / combinedSpacing) + 1; 
        }
        
        var bumperBarLengthX = ((bumperCols - 1.0) * bumperSpacing) + ((2.0 * (bumperCols -1.0)) * bumperRadius);
        var centeringOffsetX = (simWidth / 2.0) - (bumperBarLengthX / 2.0);
        
        // Find unique Y positions (rows) in existing bumpers
        let rowYPositions = [];
        for (let i = 0; i < Bumpers.length; i++) {
            const y = Bumpers[i].OGpos.y;
            if (!rowYPositions.find(ry => Math.abs(ry - y) < 0.001)) {
                rowYPositions.push(y);
            }
        }
        rowYPositions.sort((a, b) => a - b);
        
        // For each row, determine pattern and add missing bumpers
        for (let rowIdx = 0; rowIdx < rowYPositions.length; rowIdx++) {
            const rowY = rowYPositions[rowIdx];
            
            // Get existing bumpers in this row
            const rowBumpers = Bumpers.filter(b => Math.abs(b.OGpos.y - rowY) < 0.001);
            if (rowBumpers.length === 0) continue;
            
            // Determine if this is a large or small bumper row
            const isLargeRow = rowBumpers[0].radius > bumperRadius * 0.85;
            
            // Generate expected X positions for this row
            let expectedPositions = [];
            if (isLargeRow) {
                // Large bumpers: p from -1 to bumperCols-1
                for (let p = -1; p < bumperCols; p++) {
                    expectedPositions.push((p * combinedSpacing) + (combinedSpacing / 2.0) + centeringOffsetX);
                }
            } else {
                // Small bumpers: p from 0 to bumperCols-1
                for (let p = 0; p < bumperCols; p++) {
                    expectedPositions.push((p * combinedSpacing) + centeringOffsetX);
                }
            }
            
            // Check which positions are missing
            for (let expectedX of expectedPositions) {
                const exists = rowBumpers.find(b => Math.abs(b.OGpos.x - expectedX) < combinedSpacing * 0.1);
                if (!exists) {
                    // Add missing bumper
                    const radius = isLargeRow ? bumperRadius : bumperRadius * smallBumperRatio;
                    Bumpers.push(new BUMPER(radius, new Vector2(expectedX, rowY)));
                }
            }
        }
    }

    // Add a new row of bumpers at the top or bottom
    function addBumperRow(addToTop) {
        if (Bumpers.length === 0) return;
        
        const smallBumperRatio = 0.75;
        const vertBumperPadding = 0.30;
        var smallBallRadius = 0.001 * particlesMenuSmallRadius;
        var bigBallRadius = 0.001 * particlesMenuLargeRadius;
        var maxBallRadius = Math.max(smallBallRadius, bigBallRadius);
        const gapMultiplier = 1.1;
        var bumperSpacing = (2 * maxBallRadius) * gapMultiplier;
        var combinedSpacing = (2 * bumperRadius) + bumperSpacing;
        var verticalBPD = vertBumperPadding * combinedSpacing;
        var combinedVerticalSpacing = (2 * bumperRadius) + bumperSpacing + verticalBPD;
        
        // Find current min/max Y positions and the bumpers on the edge rows
        let minY = Infinity, maxY = -Infinity;
        let topRowBumpers = [];
        let bottomRowBumpers = [];
        
        for (let i = 0; i < Bumpers.length; i++) {
            if (Bumpers[i].pos.y < minY) {
                minY = Bumpers[i].pos.y;
                topRowBumpers = [Bumpers[i]];
            } else if (Math.abs(Bumpers[i].pos.y - minY) < 0.001) {
                topRowBumpers.push(Bumpers[i]);
            }
            
            if (Bumpers[i].pos.y > maxY) {
                maxY = Bumpers[i].pos.y;
                bottomRowBumpers = [Bumpers[i]];
            } else if (Math.abs(Bumpers[i].pos.y - maxY) < 0.001) {
                bottomRowBumpers.push(Bumpers[i]);
            }
        }
        
        // Sort the reference row bumpers by X position to get their X positions
        let referenceRowBumpers;
        let newRowY;
        let useSmallPattern;
        
        if (addToTop) {
            newRowY = minY - combinedVerticalSpacing;
            
            // Check if it fits
            if (newRowY - bumperRadius < 0) return;
            
            // Determine pattern based on the current top row
            const topRowIsLarge = topRowBumpers.length > 0 && topRowBumpers[0].radius > bumperRadius * 0.85;
            useSmallPattern = topRowIsLarge;
            
            // Reference row is top row
            referenceRowBumpers = topRowBumpers.slice().sort((a, b) => a.pos.x - b.pos.x);
        } else {
            newRowY = maxY + combinedVerticalSpacing;
            
            // Check if it fits
            if (newRowY + bumperRadius > simHeight) return;
            
            // Determine pattern based on the current bottom row
            const bottomRowIsLarge = bottomRowBumpers.length > 0 && bottomRowBumpers[0].radius > bumperRadius * 0.85;
            useSmallPattern = bottomRowIsLarge;
            
            // Reference row is bottom row
            referenceRowBumpers = bottomRowBumpers.slice().sort((a, b) => a.pos.x - b.pos.x);
        }
        
        // Add the new bumpers using X positions derived from the reference row
        let newBumpers = [];
        
        if (useSmallPattern) {
            // Small bumpers pattern (odd rows): offset by half spacing from large bumper positions
            // Calculate the offset between large and small patterns
            const offsetX = combinedSpacing / 2.0;
            
            for (let i = 0; i < referenceRowBumpers.length; i++) {
                const refX = referenceRowBumpers[i].pos.x;
                // Small bumpers are offset by half spacing
                const newX = refX - offsetX;
                
                // Safety check: ensure bumper is within bounds
                if (newX - bumperRadius * smallBumperRatio >= 0 && 
                    newX + bumperRadius * smallBumperRatio <= simWidth) {
                    newBumpers.push(new BUMPER(bumperRadius * smallBumperRatio, new Vector2(newX, newRowY)));
                }
            }
        } else {
            // Large bumpers pattern (even rows): offset by half spacing from small bumper positions
            const offsetX = combinedSpacing / 2.0;
            
            // Add one bumper before the first reference bumper
            if (referenceRowBumpers.length > 0) {
                const firstRefX = referenceRowBumpers[0].pos.x;
                const newX = firstRefX - offsetX;
                
                // Safety check: ensure bumper is within bounds
                if (newX - bumperRadius >= 0 && newX + bumperRadius <= simWidth) {
                    newBumpers.push(new BUMPER(bumperRadius, new Vector2(newX, newRowY)));
                }
            }
            
            // Add bumpers between existing positions
            for (let i = 0; i < referenceRowBumpers.length; i++) {
                const refX = referenceRowBumpers[i].pos.x;
                const newX = refX + offsetX;
                
                // Safety check: ensure bumper is within bounds
                if (newX - bumperRadius >= 0 && newX + bumperRadius <= simWidth) {
                    newBumpers.push(new BUMPER(bumperRadius, new Vector2(newX, newRowY)));
                }
            }
        }
        
        // Only add if we created at least some bumpers
        if (newBumpers.length === 0) {
            return;
        }
        
        // Add to array
        if (addToTop) {
            Bumpers = newBumpers.concat(Bumpers);
        } else {
            Bumpers = Bumpers.concat(newBumpers);
        }
        
        bumperRows++;
    }


    //  BUMPER CONSTRUCTOR  ---------------------------------------------------------------------
	class BUMPER {
		constructor(radius, pos) {
			this.radius = radius;
			this.pos = pos.clone();
            this.OGpos = pos.clone();
		}
        get left() {
            return this.pos.x - this.radius;
        }
        get right() {
            return this.pos.x + this.radius;
        }
        draw() {
            drawCircle(cX(this.pos), cY(this.pos), this.radius * cScale);
            c.fillStyle = `hsla(0, 0%, 10%)`;
            c.fill();
            drawCircle(cX(this.pos), cY(this.pos), this.radius * cScale);
            c.lineWidth = 0.003 * cScale;
            c.strokeStyle = `hsl(0, 0%, 70%)`;
            c.stroke();
        }
	}

    //  PUCK CONSTRUCTOR -----------------------------------------------------------------------
    class PUCK {
		constructor(radius, pos, color, heartBeat) {
			this.radius = 0; // Start at zero radius
            this.OGradius = radius;
			this.pos = pos.clone();
            this.vel = new Vector2(0, 0);
            this.prevPos = pos.clone();
            this.color = color;
            this.heartBeat = heartBeat;
            this.cycle = false; // custom cyclic radius behavior (Puck[1])
            this.flying = false;
            this.orbit = false; // elliptical orbit behavior (Puck[3])
            this.yinyang = false; // yin-yang orbit behavior (Puck[4])
            this.mass = 0.001 * radius;
            this.puckFadingIn = false;
            this.moving = false;
            this.puckArriving = true; // Start with arriving animation
            this.radiusRate = 0.0; // dR/dt for pulsing surface velocity

            // Flying puck delay properties
            this.flyingIsHiding = false;
            this.flyingHideStartTime = 0;
            this.flyingHideDelay = 2000; // 2 seconds in milliseconds

            // Heartbeat properties for heartBeat puck (Puck[0])
            if (heartBeat == true) {
                this.heartBpm = 40;
                this.heartPeriod = 60.0 / this.heartBpm; // seconds per beat
                // Durations within a single beat (must sum <= heartPeriod)
                // Fast rise, slower fall for each pulse, brief gap between pulses, then long pause
                this.hbDur = {
                    p1Rise: 0.02,
                    p1Fall: 0.20,
                    between: 0.01,
                    p2Rise: 0.1,
                    p2Fall: 0.20
                };
                this.hbPause = Math.max(0, this.heartPeriod - (this.hbDur.p1Rise + this.hbDur.p1Fall + this.hbDur.between + this.hbDur.p2Rise + this.hbDur.p2Fall));
                // State machine
                this.hbState = 'p1Rise';
                this.hbTimeInState = 0.0;
                this.hbLastTime = performance.now();
                // Post-drag resume control (ms timestamp from performance.now(); 0 = inactive)
                this.hbResumeAt = 0;
                // Visual scaling
                this.hbAmp = 0.5;      // max +% radius at first peak
                // Between-pulses baseline: fraction between base (1.0) and first peak (1.0 + hbAmp)
                // 0.0 => base radius, 1.0 => first peak radius
                this.hbBetweenFrac = 0.85; // barely shrink between pulses
            }
		}
        initCycle() {
            // Initialize the cycle puck state machine (called after setting this.cycle=true)
            this.cycPeriod = 8.0; // total seconds
            this.cycDur = { grow: 0.3, shrink: 5.6, recover: 0.0 }; // slow shrink back to base
            this.cycState = 'grow';
            this.cycTimeInState = 0.0;
            this.cycLastTime = performance.now();
            this.cycMax = 3.5;   
            this.cycMin = 1.0;   // shrink back to base (1.0x)
            // Delay cycling at startup for 6 seconds
            this.cycResumeAt = this.cycLastTime + 6000; // ms timestamp
        }
        simulate() {
            // OSCILLATION for normal pucks ---------------------------------
            if (doOscillatePucks == true && !this.heartBeat && !this.cycle && !this.flying && !this.orbit && !this.yinyang) {
                // If puck is still arriving (growing from 0), let that animation complete first
                if (this.puckArriving && this.radius < this.OGradius) {
                    // Let the puckArriving animation run (same as default behavior)
                    if (this.radius >= this.OGradius) {
                        this.radius = this.OGradius;
                        this.puckArriving = false;
                    } else {
                        this.radius += this.OGradius * 0.1; // Appropriate growth rate for smooth animation
                    }
                    return; // Don't start oscillation until puck is fully visible
                }
                
                // Don't oscillate if the puck is being moved by mouse/touch
                if (this.moving) {
                    // Reset oscillation when user starts dragging
                    this.oscInit = false;
                    this.oscOriginX = undefined;
                    this.oscAmplitude = undefined;
                    this.oscCenterX = undefined;
                    this.oscStartTime = undefined;
                    this.oscPhaseOffset = undefined;
                    return;
                }
                
                // sinusoidal left-right oscillation ----------
                // log initial positions ---------
                if (!this.oscInit) {
                    this.oscInit = true;
                    this.oscOriginX = this.pos.x;
                    // Calculate amplitude: distance from starting position to center vertical axis
                    const centerX = simWidth / 2;
                    this.oscAmplitude = Math.abs(this.pos.x - centerX);
                    // Each puck oscillates around the center vertical axis
                    this.oscCenterX = centerX;
                    this.oscStartTime = performance.now(); // Store start time for phase calculation
                    
                    // Calculate initial phase so puck starts from current position (no jump)
                    const currentOffset = this.pos.x - centerX;
                    // If amplitude is 0, set a small default to avoid division by zero
                    const safeAmplitude = this.oscAmplitude > 0 ? this.oscAmplitude : 1;
                    const normalizedPosition = currentOffset / safeAmplitude; // -1 to 1
                    // Clamp to valid sine range
                    const clampedPosition = Math.max(-1, Math.min(1, normalizedPosition));
                    
                    // Each puck gets its own phase based solely on its current position
                    this.oscPhaseOffset = Math.asin(clampedPosition);
                }
                // parameters --------------------
                this.cycLastTime = this.cycLastTime || performance.now();
                const now = performance.now();
                const dt = (now - this.cycLastTime) / 1000.0;
                this.cycLastTime = now;
                const oscFreq = 0.5; // cycles per second (same for both pucks)
                
                // Store previous position for velocity calculation
                const prevX = this.pos.x;
                
                // update position ---------------
                // Oscillate around the center vertical axis with amplitude based on starting position
                // Apply phase offset to desynchronize the pucks
                const phase = 2 * Math.PI * oscFreq * ((now - this.oscStartTime) / 1000.0) + this.oscPhaseOffset;
                const deltaX = this.oscAmplitude * Math.sin(phase);
                const newX = this.oscCenterX + deltaX;
                this.pos.x = newX;
                
                // Calculate and set velocity based on position change
                if (dt > 0) {
                    const velocityX = (newX - prevX) / dt;
                    // Initialize velocity if it doesn't exist
                    if (!this.vel) {
                        this.vel = new Vector2(0, 0);
                    }
                    this.vel.x = velocityX;
                    this.vel.y = 0; // No vertical movement in oscillation
                }
                
                return;
            }

            // HEART heartBeat -------------------------------------------------
            if (this.heartBeat) {
                // heartBeat puck heartbeat animation (time-based, independent of framerate)
            const now = performance.now();

            // If the puck is being dragged/moved, reset to base size and hold state timing (no pulses while moving)
            if (this.moving) {
                // No pulsing while being dragged; also clear surface speed
                this.radiusRate = 0.0;
                this.radius = this.OGradius;
                // Prevent dt from accumulating during drag
                this.hbLastTime = now;
                return;
            }

            // If a post-release delay is active, hold at base until resume time
            if (this.hbResumeAt && now < this.hbResumeAt) {
                this.radiusRate = 0.0;
                this.radius = this.OGradius;
                // Prevent dt accumulation while waiting
                this.hbLastTime = now;
                return;
            }
            // If we just reached resume time, restart beat at beginning after 1s delay
            if (this.hbResumeAt && now >= this.hbResumeAt) {
                this.hbResumeAt = 0;
                this.hbState = 'p1Rise';
                this.hbTimeInState = 0.0;
                this.hbLastTime = now;
            }

            const dt = Math.max(0, (now - this.hbLastTime) / 1000.0);
            this.hbLastTime = now;

            // Helper easing functions
            const easeOutCubic = (t)=> 1 - Math.pow(1 - t, 3); // quick start, slow end (fast rise)
            const easeInCubic  = (t)=> Math.pow(t, 3);         // slow start, quick end (slow fall perception)

            // Advance state machine
            let advance = (duration)=> {
                this.hbTimeInState += dt;
                if (this.hbTimeInState >= duration) {
                    this.hbTimeInState -= duration;
                    return true; // signal to move to next state
                }
                return false;
            };

            // Calculate current radius scale based on state
            const d = this.hbDur;
            const baselineBetween = 1.0 + this.hbBetweenFrac * this.hbAmp; // target level between pulses
            let scale = 1.0;
            switch (this.hbState) {
                case 'p1Rise': {
                    const t = Math.min(1, this.hbTimeInState / d.p1Rise);
                    scale = 1.0 + this.hbAmp * easeOutCubic(t);
                    if (advance(d.p1Rise)) { this.hbState = 'p1Fall'; }
                    break;
                }
                case 'p1Fall': {
                    const t = Math.min(1, this.hbTimeInState / d.p1Fall);
                    // Fall from first peak down to the configured between-baseline (avoid deep dip)
                    const start = 1.0 + this.hbAmp;
                    const end = baselineBetween;
                    scale = end + (start - end) * (1.0 - easeInCubic(t));
                    if (advance(d.p1Fall)) { this.hbState = 'between'; }
                    break;
                }
                case 'between': {
                    // Hold at a configurable level between base and the first peak
                    scale = baselineBetween;
                    if (advance(d.between)) { this.hbState = 'p2Rise'; }
                    break;
                }
                case 'p2Rise': {
                    const t = Math.min(1, this.hbTimeInState / d.p2Rise);
                    // Rise from the between-baseline up to the second peak (no initial drop)
                    const peak2 = 1.0 + this.hbAmp;
                    scale = baselineBetween + (peak2 - baselineBetween) * easeOutCubic(t);
                    if (advance(d.p2Rise)) { this.hbState = 'p2Fall'; }
                    break;
                }
                case 'p2Fall': {
                    const t = Math.min(1, this.hbTimeInState / d.p2Fall);
                    scale = 1.0 + this.hbAmp * (1.0 - easeInCubic(t));
                    if (advance(d.p2Fall)) { this.hbState = (this.hbPause > 0 ? 'pause' : 'p1Rise'); }
                    break;
                }
                case 'pause': default: {
                    scale = 1.0;
                    if (advance(this.hbPause)) { this.hbState = 'p1Rise'; }
                    break;
                }
            }

            // Compute surface radial speed from radius change
            const newRadius = this.OGradius * scale;
            const safeDt = Math.max(1e-6, dt);
            this.radiusRate = (newRadius - this.radius) / safeDt;
            this.radius = newRadius;
                return;
            }

            // CYCLE heartBeat (Puck[1]) -------------------------------------
            if (this.cycle) {
                const now = performance.now();
                if (this.moving) {
                    this.radiusRate = 0.0;
                    this.radius = this.OGradius;
                    this.cycLastTime = now;
                    return;
                }

                // Hold at base until resume time (startup or post-drag)
                if (this.cycResumeAt && now < this.cycResumeAt) {
                    this.radiusRate = 0.0;
                    this.radius = this.OGradius;
                    this.cycLastTime = now; // prevent dt accumulation
                    return;
                }
                if (this.cycResumeAt && now >= this.cycResumeAt) {
                    // Resume cycling from beginning after delay
                    this.cycResumeAt = 0;
                    this.cycState = 'grow';
                    this.cycTimeInState = 0.0;
                    this.cycLastTime = now;
                }

                const dt = Math.max(0, (now - this.cycLastTime) / 1000.0);
                this.cycLastTime = now;

                // Easing helpers
                const easeInQuad = (t)=> t*t;      // accelerating
                const easeOutQuad = (t)=> 1-(1-t)*(1-t); // decelerating

                // Advance within state
                const adv = (dur)=>{
                    this.cycTimeInState += dt;
                    if (this.cycTimeInState >= dur) {
                        this.cycTimeInState -= dur;
                        return true;
                    }
                    return false;
                };

                let scale = 1.0;
                switch (this.cycState) {
                    case 'grow': {
                        const t = Math.min(1, this.cycTimeInState / this.cycDur.grow);
                        // ease-in from 1.0 -> 3.5
                        scale = 1.0 + (this.cycMax - 1.0) * easeInQuad(t);
                        if (adv(this.cycDur.grow)) { this.cycState = 'shrink'; }
                        break;
                    }
                    case 'shrink': {
                        const t = Math.min(1, this.cycTimeInState / this.cycDur.shrink);
                        // slow linear shrink from 3.5 -> 1.0
                        scale = this.cycMax + (1.0 - this.cycMax) * t;
                        if (adv(this.cycDur.shrink)) { this.cycState = 'grow'; }
                        break;
                    }
                    case 'recover': default: {
                        // recover is now 0.0s, immediately transition to grow
                        this.cycState = 'grow';
                        scale = 1.0;
                        break;
                    }
                }

                const newRadius = this.OGradius * scale;
                const safeDt = Math.max(1e-6, dt);
                this.radiusRate = (newRadius - this.radius) / safeDt;
                this.radius = newRadius;
                return;
            }

            // SIMULATE FLYING PUCK  ---------------------
            if (this.flying == true) {
                // If puck is hiding (waiting to reappear), check if delay has elapsed
                if (this.flyingIsHiding) {
                    const currentTime = Date.now();
                    if (currentTime - this.flyingHideStartTime >= this.flyingHideDelay) {
                        // Delay has elapsed - reappear on the left or right side
                        this.flyingIsHiding = false;
                        if (firstFlight == true) {
                            this.pos.x = -this.radius;
                            var velo = 3.0;
                            firstFlight = false;
                        } else {
                            this.pos.x = simWidth + this.radius;
                            var velo = -3.0;
                            firstFlight = true;
                        }

                        if (doFlyingPuck == true) {
                            resetFlyingPuck();
                        } else 
                        if (doFlyingPuck2 == true) {
                            this.pos.y = 0.5 * simHeight;
                            this.vel.x = velo;
                            this.vel.y = 0;
                        }
                        this.radius = 0.7 * this.OGradius + 0.3 * Math.random() * this.OGradius;
                    } else {
                        // Still hiding, keep puck invisible
                        this.radius = 0;
                        return;
                    }
                }
                // update position  ----------
                this.pos.x += this.vel.x * physProps.dt;
                this.pos.y += this.vel.y * physProps.dt;
                
                // Check if puck has moved off the right side of the screen
                if (this.pos.x - this.radius > simWidth || this.pos.x + this.radius < 0 || this.pos.y - this.radius > simHeight || this.pos.y + this.radius < 0) {
                    // Start hiding delay instead of immediately reappearing
                    this.flyingIsHiding = true;
                    this.flyingHideStartTime = Date.now();
                    this.radius = 0; // Hide the puck
                    return;
                }
                
                const friction = 0.99999; 
                this.vel.x *= friction;
                this.vel.y *= friction;
                this.radius -= 0.1 * physProps.dt;
                if (this.radius <= 0.1 * this.OGradius) {
                    this.radius = 0.1 * this.OGradius; 
                }
                return;
            }

            // SIMULATE ELLIPTICAL ORBIT PUCK --------------------------------
            if (this.orbit == true) {
                // Don't orbit while being moved by user
                if (this.moving) {
                    return;
                }

                const now = performance.now();
                this.orbitLastTime = this.orbitLastTime || now;
                const dt = (now - this.orbitLastTime) / 1000.0;
                this.orbitLastTime = now;

                // Calculate orbit bounds based on actual simulation boundaries
                // At orbit extremes, puck center passes within one diameter of edge midpoint
                const puckDiameter = this.radius * 2;

                // Get actual simulation boundaries
                // Left/Right: Use corner positions (responsive to corner movement)
                const leftEdgeX = Corners[0].pos.x;    // NW corner x position
                const rightEdgeX = Corners[1].pos.x;   // NE corner x position
                // Top/Bottom: Use canvas boundaries
                const topEdgeY = simHeight;    // Top of canvas
                const bottomEdgeY = 0;         // Bottom of canvas

                // Edge midpoints based on actual boundaries
                const leftEdgeMidX = leftEdgeX;
                const leftEdgeMidY = simHeight / 2;
                const rightEdgeMidX = rightEdgeX;
                const rightEdgeMidY = simHeight / 2;
                const topEdgeMidX = (leftEdgeX + rightEdgeX) / 2;
                const topEdgeMidY = topEdgeY;
                const bottomEdgeMidX = (leftEdgeX + rightEdgeX) / 2;
                const bottomEdgeMidY = bottomEdgeY;

                // Calculate orbit bounds (puck center positions at extremes)
                const leftBound = leftEdgeMidX + puckDiameter;
                const rightBound = rightEdgeMidX - puckDiameter;
                const topBound = topEdgeMidY - puckDiameter;
                const bottomBound = bottomEdgeMidY + puckDiameter;

                // Calculate ellipse parameters
                const centerX = (leftBound + rightBound) / 2;
                const centerY = (topBound + bottomBound) / 2;
                const semiMajorA = (rightBound - leftBound) / 2;
                const semiMinorB = (topBound - bottomBound) / 2;

                // Use direction state for orbit and yin-yang

                let dir = 1;
                // For yin-yang mode, both pucks (the orbit and the yinyang) should reverse together
                if (showYinYang && (this.yinyang === true || (this.orbit === true && !this.yinyang))) {
                    dir = (typeof yinYangDirection !== 'undefined') ? yinYangDirection : 1;
                } else if (this.orbit === true) {
                    dir = (typeof orbitDirection !== 'undefined') ? orbitDirection : 1;
                }

                // Update orbit angle (clockwise or counterclockwise)
                this.orbitAngle = (this.orbitAngle || 0) - this.orbitSpeed * dt * dir;

                // Store previous position for velocity calculation
                const prevX = this.pos.x;
                const prevY = this.pos.y;

                // Calculate position on ellipse
                this.pos.x = centerX + semiMajorA * Math.cos(this.orbitAngle);
                this.pos.y = centerY + semiMinorB * Math.sin(this.orbitAngle);

                // Calculate velocity based on position change
                if (dt > 0) {
                    this.vel.x = (this.pos.x - prevX) / dt;
                    this.vel.y = (this.pos.y - prevY) / dt;
                }

                return;
            }

            // DEFAULT: Non-heartBeat arrival growth behavior -----------------
            if (this.puckArriving && !this.heartBeat && !this.cycle && !this.flying && !this.orbit) {
                if (this.radius >= this.OGradius) {
                    this.radius = this.OGradius;
                    this.puckArriving = false;
                } else {
                    this.radius += this.OGradius * 0.1; // Appropriate growth rate for smooth animation
                }
            }
            return;
        }
        draw() {
            //  DRAW PUCKS  --------------------------------------
            if (this.puckFadingIn == true) {
                var fadeInTimer = 400; 
                var timeSinceMouseUp = Date.now() - mouseUpTime;
                var alphaPercent = timeSinceMouseUp / fadeInTimer;
                if (timeSinceMouseUp >= fadeInTimer) {
                    this.puckFadingIn = false;
                }
            } else {
                var alphaPercent = 1;
            }

            // DRAW NORMAL PUCK  -----------
            if (this.moving == false && this.flying == false && this.orbit == false && this.yinyang == false) {  
                drawCircle(cX(this.pos), cY(this.pos), 0.985 * this.radius * cScale);
                const grd = c.createRadialGradient(
                    cX(this.pos), 
                    cY(this.pos), 
                    0, 
                    cX(this.pos), 
                    cY(this.pos), 
                    1.3 *this.radius * cScale);
                grd.addColorStop(1, `hsla(220, 70%, 30%, ${alphaPercent * 0.4})`);
                grd.addColorStop(0.5, `hsla(220, 60%, 5%, ${alphaPercent * 0.4})`);
                c.fillStyle = grd;
                c.fill();

                c.strokeStyle = `hsla(0, 0%, 60%, ${alphaPercent})`;
                c.setLineDash([]); // solid line
                c.lineWidth = 0.01 * cScale;
                c.stroke();  

                // Only draw resize grip and plus/minus buttons for normal pucks (not heartbeat or cycle)
                if (!this.heartBeat && !this.cycle) {
                    // Draw resize grip indicator (small green circle) at lower right
                    const gripCos = Math.cos(1.75 * Math.PI); // 315 degrees
                    const gripSin = Math.sin(1.75 * Math.PI);
                    const gripDist = this.radius - 0.3 * this.radius;
                    const gripDist2 = this.radius - 0.35 * this.radius;
                    this.gripPos = new Vector2(this.pos.x + gripDist * gripCos, this.pos.y + gripDist * gripSin);
                    this.gripPos2 = new Vector2(this.pos.x + gripDist2 * gripCos, this.pos.y + gripDist2 * gripSin);
                    
                    // Position buttons on opposite corner (around 135 degrees, upper left)
                    const buttonBaseAngle = 0.75 * Math.PI; // 135 degrees
                    
                    //  minus button
                    //const minusAngle = buttonBaseAngle + (25 * Math.PI / 180);
                    const minusAngle = 0.82 * Math.PI;
                    this.minusPos = new Vector2(this.pos.x + gripDist * Math.cos(minusAngle), this.pos.y + gripDist * Math.sin(minusAngle));
                    
                    //  plus button
                    const plusAngle = 0.68 * Math.PI;
                    this.plusPos = new Vector2(this.pos.x + gripDist * Math.cos(plusAngle), this.pos.y + gripDist * Math.sin(plusAngle));
                    
                    //  off button 
                    const offAngle = 1.18 * Math.PI;
                    this.offPos = new Vector2(this.pos.x + gripDist * Math.cos(offAngle), this.pos.y + gripDist * Math.sin(offAngle));

                    //  arrow button 
                    const arrowAngle = 0.25 * Math.PI;
                    this.arrowPos = new Vector2(this.pos.x + gripDist * Math.cos(arrowAngle), this.pos.y + gripDist * Math.sin(arrowAngle));
              
                    // Draw resize grip indicator
                    drawCircle(
                        this.arrowPos.x * cScale,
                        (simHeight - this.arrowPos.y) * cScale,
                        0.1 * this.radius * cScale);
                    c.fillStyle = 'blue';
                    c.fill();

                //  resize arrow buttons ----------
                //  arrow button 
                    const resizeAngle = 0.82 * Math.PI;
                    this.arrowPos = new Vector2(this.pos.x + gripDist * Math.cos(arrowAngle), this.pos.y + gripDist * Math.sin(arrowAngle));
              
                    // Draw resize grip indicator
                    drawCircle(
                        this.gripPos.x * cScale,
                        (simHeight - this.gripPos.y) * cScale,
                        0.1 * this.radius * cScale);
                    c.fillStyle = 'green';
                    //c.fill();
                    
                    // Draw arrow pointing out
                    drawArrow(
                            this.gripPos.x,
                            simHeight - this.gripPos.y,
                            1.25 * Math.PI,
                            0.2 * this.radius, 
                        )
                    c.fillStyle = 'green';
                    c.fill();

                    // Draw arrow pointing in
                    drawArrow(
                            this.gripPos2.x,
                            simHeight - this.gripPos2.y,
                            0.25 * Math.PI,
                            0.2 * this.radius, 
                        )
                    c.fill();

                  


                    // Draw plus button  ----------
                    drawCircle(
                        cX(this.plusPos), 
                        cY(this.plusPos), 
                        0.1 * this.radius * cScale);
                    c.fillStyle = 'hsl(320, 100%, 30%)'; 
                    c.fill();
                    
                    c.strokeStyle = 'black';
                    //c.stroke();
                    c.lineWidth = 0.02 * this.radius * cScale;
                    // Draw + symbol
                    c.beginPath();
                    c.moveTo(cX(this.plusPos) - 0.05 * this.radius * cScale, cY(this.plusPos));
                    c.lineTo(cX(this.plusPos) + 0.05 * this.radius * cScale, cY(this.plusPos));
                    c.moveTo(cX(this.plusPos), cY(this.plusPos) - 0.05 * this.radius * cScale);
                    c.lineTo(cX(this.plusPos), cY(this.plusPos) + 0.05 * this.radius * cScale);
                    c.stroke();
                    
                    // Draw minus button
                    // Count normal pucks to determine if this is the last one
                    const normalPuckCount = Puck.filter(p => !p.heartBeat && !p.cycle && !p.flying && !p.orbit).length;
                    const isLastNormalPuck = normalPuckCount === 1;
                    
                    drawCircle(
                        cX(this.minusPos), 
                        cY(this.minusPos), 
                        0.1 * this.radius * cScale);
                    c.fillStyle = isLastNormalPuck ? 'hsl(320, 100%, 15%)' : 'hsl(320, 100%, 30%)'; // Dim if last puck
                    c.fill();
                    
                    c.strokeStyle = isLastNormalPuck ? 'black' : 'black'; // Dim if last puck
                    c.lineWidth = 0.03 * this.radius * cScale;
                    // Draw - symbol
                    c.beginPath();
                    c.moveTo(cX(this.minusPos) - 0.05 * this.radius * cScale, cY(this.minusPos));
                    c.lineTo(cX(this.minusPos) + 0.05 * this.radius * cScale, cY(this.minusPos));
                    c.stroke();
                    
                    // Draw off button
                    drawCircle(
                        cX(this.offPos), 
                        cY(this.offPos), 
                        0.1 * this.radius * cScale);
                    c.fillStyle = 'rgba(139, 0, 0, 0.6)'; // Dim dark red
                    c.fill();
                    c.strokeStyle = 'black'; // Dim  X
                    c.lineWidth = 0.02 * this.radius * cScale;
                    // Draw X symbol
                    c.beginPath();
                    c.moveTo(cX(this.offPos) - 0.04 * this.radius * cScale, cY(this.offPos) - 0.04 * this.radius * cScale);
                    c.lineTo(cX(this.offPos) + 0.04 * this.radius * cScale, cY(this.offPos) + 0.04 * this.radius * cScale);
                    c.moveTo(cX(this.offPos) + 0.04 * this.radius * cScale, cY(this.offPos) - 0.04 * this.radius * cScale);
                    c.lineTo(cX(this.offPos) - 0.04 * this.radius * cScale, cY(this.offPos) + 0.04 * this.radius * cScale);
                    c.stroke();
                }

            // MOVING NORMAL PUCK ----------
            } else { 
                drawCircle(cX(this.pos), cY(this.pos), this.radius * cScale);
                const grd = c.createRadialGradient(
                    cX(this.pos), 
                    cY(this.pos), 
                    0, 
                    cX(this.pos), 
                    cY(this.pos), 
                    1.0 *this.radius * cScale);
                grd.addColorStop(0, `hsla(220, 70%, 15%, ${alphaPercent * 0.2})`);
                grd.addColorStop(1.0, `hsla(220, 70%, 8%, ${alphaPercent * 0.2})`);
                c.fillStyle = grd;
                c.fill();
            }

            // DRAW ORBIT OR YIN-YANG PUCK  ----------
            if (this.orbit == true || this.yinyang == true) {
                drawCircle(cX(this.pos), cY(this.pos), this.radius * cScale);
                const shineOffsetX = cScale * this.radius * 0.3; 
                const shineOffsetY = cScale * this.radius * 0.4; 
                const shineVector = Math.sqrt(shineOffsetX * shineOffsetX + shineOffsetY * shineOffsetY);
                const shineRadius = 0.8 * cScale * this.radius + shineVector;
                const shading = c.createRadialGradient(
                    cX(this.pos) - shineOffsetX, 
                    cY(this.pos) - shineOffsetY, 
                    0, 
                    cX(this.pos) - shineOffsetX, 
                    cY(this.pos) - shineOffsetY, 
                    shineRadius);
                if (this.yinyang) {
                    // draw black sphere with white highlight
                    var highlight = `hsl(0, 0%, 70%)`;
                    var midtone1 = `hsl(0, 0%, 20%)`;
                    var midtone2 = `hsl(0, 0%, 10%)`;
                    var shadow = `hsl(0, 0%, 0%)`;
                    shading.addColorStop(0.0, highlight);
                    shading.addColorStop(0.15, midtone1);
                    shading.addColorStop(0.5, midtone2);
                    shading.addColorStop(1.0, shadow);
                } else {
                    if (showYinYang == true) {
                        var highlight = `hsl(0, 0%, 90%)`;
                        var midtone = `hsl(0, 0%, 60%)`;
                        var shadow = `hsl(0, 0%, 10%)`;
                    } else {
                        var thisPassHue = 120;
                        var highlight = `hsl(${thisPassHue}, 80%, 70%)`;
                        var midtone = `hsl(${thisPassHue}, 80%, 50%)`;
                        var shadow = `hsl(${thisPassHue}, 50%, 10%)`;
                    }
                    shading.addColorStop(0.0, highlight);
                    shading.addColorStop(0.15, midtone);
                    shading.addColorStop(1.0, shadow);
                }
                c.fillStyle = shading;
                c.fill();
            }
            
            // DRAW HEARTBEAT PUCK  -----------
            if (this.heartBeat == true) {
                if (this.moving == false) {  // stationary heartbeat renderingb ----------
                    drawCircle(cX(this.pos), cY(this.pos), 0.985 * this.radius * cScale);
                    const grd = c.createRadialGradient(
                        cX(this.pos), 
                        cY(this.pos), 
                        0, 
                        cX(this.pos), 
                        cY(this.pos), 
                        1.3 *this.radius * cScale);
                    grd.addColorStop(1, `hsla(220, 70%, 30%, ${alphaPercent * 0.4})`);
                    grd.addColorStop(0.5, `hsla(220, 60%, 5%, ${alphaPercent * 0.4})`);
                    c.fillStyle = grd;
                    c.fill();
                    c.strokeStyle = `hsla(0, 0%, 60%, ${alphaPercent})`;
                    c.lineWidth = 0.01 * cScale;
                    c.stroke();

                    c.fillStyle = `hsla(338, 100%, 72%, ${alphaPercent})`;
                    c.textBaseline = 'middle';
                    c.textAlign = "center";
                    c.font = `${(0.40 * this.OGradius + 0.3 * this.radius) * cScale}px monospace`;
                    c.fillText("", this.pos.x * cScale, (simHeight - this.pos.y + 0.10 * this.OGradius) * cScale);
                } else {  // moving heartbeat rendering  ----------
                    drawCircle(cX(this.pos), cY(this.pos), this.radius * cScale);
                    const grd = c.createRadialGradient(
                        cX(this.pos), 
                        cY(this.pos), 
                        0, 
                        cX(this.pos), 
                        cY(this.pos), 
                        1.0 *this.radius * cScale);
                    grd.addColorStop(0, `hsla(220, 70%, 15%, ${alphaPercent * 0.2})`);
                    grd.addColorStop(1.0, `hsla(220, 70%, 8%, ${alphaPercent * 0.2})`);
                    c.fillStyle = grd;
                    c.fill();

                    c.fillStyle = `hsla(338, 80%, 50%, ${alphaPercent - 0.9})`;
                    c.textBaseline = 'middle';
                    c.textAlign = "center";
                    c.font = `${(0.40 * this.OGradius + 0.3 * this.radius) * cScale}px monospace`;
                    c.fillText("", this.pos.x * cScale, (simHeight - this.pos.y + 0.10 * this.OGradius) * cScale);
                }
            } 

            // DRAW CYCLE PUCK ICON  ----------
            if (this.cycle === true) {
                const baseFontPx = (0.5 * this.OGradius) * cScale; // constant base size
                // Slow growth like heart: effective size ~ OGradius + 0.5 * radius
                const scaleFactor = Math.max(0.0001, (this.OGradius + 0.5 * this.radius) / (1.5 * this.OGradius));
                const cx = this.pos.x * cScale;
                const cy = (simHeight - this.pos.y) * cScale; // keep baseline anchored
                c.save();
                c.translate(Math.round(cx) + 0.5, Math.round(cy) + 0.5);
                c.scale(scaleFactor, scaleFactor);
                c.fillStyle = `hsla(190, 80%, 55%, ${alphaPercent})`;
                c.textBaseline = 'middle';
                c.textAlign = 'center';
                c.font = `${baseFontPx}px verdana`;
                c.fillText("\u26A0", 0, 0);
                c.restore();
            }

            //  DRAW FLYING PUCK  ----------
            if (this.flying == true) {
                const shineOffsetX = cScale * this.radius * 0.3; 
                const shineOffsetY = cScale * this.radius * 0.4; 
                const shineVector = Math.sqrt(shineOffsetX * shineOffsetX + shineOffsetY * shineOffsetY);
                const shineRadius = 0.7 * cScale * this.radius + shineVector;
                const shading = c.createRadialGradient(
                    cX(this.pos) - shineOffsetX, 
                    cY(this.pos) - shineOffsetY, 
                    0, 
                    cX(this.pos) - shineOffsetX, 
                    cY(this.pos) - shineOffsetY, 
                    shineRadius);
                var highlight = 'hsl(0, 80%, 70%)';
                var midtone = 'hsl(0, 80%, 50%)';
                var shadow = 'hsl(0, 50%, 10%)';
                shading.addColorStop(0.0, highlight);
                shading.addColorStop(0.15, midtone);
                shading.addColorStop(1.0, shadow);
                c.fillStyle = shading;
                c.fill();
            }
            
        }
        draw2() {
            // stationary normal puck overlay----------
            if (this.moving == false && this.flying == false) {
                const overlayRadius = 0.985 * this.radius;
                let isUnderCorner = false;
                
                // Check if puck is hidden by any corner mask
                if (Array.isArray(Corners) && Corners.length > 0) {
                    for (let i = 0; i < Corners.length; i++) {
                        const corner = Corners[i];
                        if (!corner || !corner.pos) continue;
                        
                        // Calculate corner arc center based on corner type
                        let arcCenterX, arcCenterY;
                        if (corner.corner === 'northwest') {
                            arcCenterX = corner.pos.x + corner.radius;
                            arcCenterY = corner.pos.y + corner.radius;
                        } else if (corner.corner === 'northeast') {
                            arcCenterX = corner.pos.x - corner.radius;
                            arcCenterY = corner.pos.y + corner.radius;
                        } else if (corner.corner === 'southwest') {
                            arcCenterX = corner.pos.x + corner.radius;
                            arcCenterY = corner.pos.y - corner.radius;
                        } else if (corner.corner === 'southeast') {
                            arcCenterX = corner.pos.x - corner.radius;
                            arcCenterY = corner.pos.y - corner.radius;
                        }
                        
                        const dx = this.pos.x - arcCenterX;
                        const dy = this.pos.y - arcCenterY;
                        const distToCornerCenter = Math.sqrt(dx * dx + dy * dy);
                        
                        // The corner HIDES anything where distance > corner.radius (outside the playable arc)
                        // Draw overlay if ANY part of the puck is in the hidden region
                        // That means: the farthest point of puck (distToCornerCenter + overlayRadius) > corner.radius
                        if (distToCornerCenter + overlayRadius > corner.radius) {
                            isUnderCorner = true;
                            break;
                        }
                    }
                }
                
                if (isUnderCorner) {
                    // Draw full dashed circle when hidden by corner
                    c.strokeStyle = `hsla(0, 0%, 100%, 20%)`;
                    c.lineWidth = 0.005 * cScale;
                    c.setLineDash([5, 12]);
                    c.beginPath();
                    c.arc(cX(this.pos), cY(this.pos), overlayRadius * cScale, 0, 2 * Math.PI);
                    c.stroke();
                    c.setLineDash([]);
                }
            }
        }
        get left() {
            return this.pos.x - this.radius;
        }
        get right() {
            return this.pos.x + this.radius;
        }
	}

    class HEART {
        constructor(pos, vel) {
            this.pos = pos.clone();
            this.vel = vel.clone();
            this.radius = 0.007 + Math.random() * 0.015;
            this.hue = 320;
            this.alpha = 0;
            this.birthday = Date.now();
            this.lifespan = 250 + Math.random() * 400; // 250-650ms 
        }
        simulate() {
            // Move based on velocity
            this.pos.x += this.vel.x * physProps.dt;
            this.pos.y += this.vel.y * physProps.dt;
            
            // Slow down over time
            this.vel.x *= 0.98;
            this.vel.y *= 0.98;
            
            // Get age ratio (0 at birth, 1 at end of lifespan)
            const age = Date.now() - this.birthday;
            const ageRatio = age / this.lifespan;
            
            // Fade in during first 20% of life, fade out during last 20%
            if (ageRatio < 0.2) {
                this.alpha = ageRatio / 0.2;
            } else if (ageRatio > 0.8) {
                this.alpha = (1 - ageRatio) / 0.2;
            } else {
                this.alpha = 1;
            }
            
            /*// Grow radius during first 30% of life
            const maxRadius = 0.03;
            if (ageRatio < 0.3) {
                this.radius = 0.02 + (maxRadius - 0.02) * (ageRatio / 0.5);
            }*/

            this.radius += 0.0007; // Slight growth over time
            
            // Remove if lifespan exceeded and fully faded
            if (age > this.lifespan && this.alpha <= 0) {
                const index = Hearts.indexOf(this);
                if (index > -1) {
                    Hearts.splice(index, 1);
                }
            }
        }
        draw() {
            drawHeart(this.pos.x, simHeight - this.pos.y, this.radius);
            c.fillStyle = `hsla(${this.hue}, 100%, 60%, ${this.alpha})`;
            c.fill();
        }
    }

    Hearts = [];
    function spawnHearts() {
        if (typeof Stinker === 'undefined' || Stinker.length === 0 || !Stinker[0].active) return;
        
        const stinker = Stinker[0];
        // Spawn slightly behind the stinker (random offset)
        const offsetX = 0.3 * stinker.radius * (-1 + 2 * Math.random());
        const offsetY = 0.3 * stinker.radius * (-1 + 2 * Math.random());
        const pos = new Vector2(stinker.pos.x + offsetX, stinker.pos.y + offsetY);
        
        // Random outward velocity
        const heartSpeed = 1;
        const rayAngle = Math.random() * 2 * Math.PI;
        const vel = new Vector2(heartSpeed * Math.cos(rayAngle), heartSpeed * Math.sin(rayAngle));
        
        Hearts.push(new HEART(pos, vel));
    }

    //  MAKE PEPE'S HEARTS  ----------------------------------------------
    function drawHeart(posX, posY, radius) {
        c.beginPath();
        c.moveTo(posX * cScale, (posY - 0.5 * radius) * cScale);
        for (var f = 0; f < Math.PI - 0.8; f += 0.1) {
                var drawX = posX + 0.08 * radius * 16 * Math.pow(Math.sin(f), 3);
                var drawY = posY - 0.08 * radius * (13 * Math.cos(f) - 5 * Math.cos(2 * f) - 2 * Math.cos(3 * f) - Math.cos(4 * f));   
                c.lineTo(drawX * cScale, drawY * cScale);
            }
            var f = Math.PI - 0.8;
            var drawX = posX + 0.08 * radius * 16 * Math.pow(Math.sin(f), 3);
            var drawY = posY - 0.08 * radius * (13 * Math.cos(f) - 5 * Math.cos(2 * f) - 2 * Math.cos(3 * f) - Math.cos(4 * f));   
            c.lineTo(drawX * cScale, drawY * cScale);
            c.lineTo(drawX * cScale, drawY * cScale);
        c.lineTo(posX * cScale, (posY + 1.15 * radius) * cScale);   
        for (var f = Math.PI + 0.8; f < 2 * Math.PI; f += 0.1) {
            var drawX = posX + 0.08 * radius * 16 * Math.pow(Math.sin(f), 3);
            var drawY = posY - 0.08 * radius * (13 * Math.cos(f) - 5 * Math.cos(2 * f) - 2 * Math.cos(3 * f) - Math.cos(4 * f));   
            c.lineTo(drawX * cScale, drawY * cScale);
            }
        c.closePath();
    }

    //  PEPE CONSTRUCTOR ----------------------------------------------------------------
    class STINKER {
        constructor(pos) {
            this.radius = 0.2;
            this.pos = pos.clone();
            this.force = 1;
        }
        draw() {
            const iconRadius = 60; 
            const centerX = this.pos.x * cScale;
            const centerY = (simHeight - this.pos.y) * cScale;

            // Draw pepe.png image
            if (pepeReady && pepeImage && pepeImage.complete && pepeImage.width > 0 && pepeImage.height > 0) {
                c.save();
                c.translate(centerX, centerY);
                
                const iw = pepeImage.width;
                const ih = pepeImage.height;
                const aspectRatio = iw / ih;
                const targetHeight = iconRadius * 2;
                const targetWidth = targetHeight * aspectRatio;
                
                c.drawImage(pepeImage, -targetWidth / 2, -targetHeight / 2, targetWidth, targetHeight);
                c.restore();
            }
        }
    }

    //  MAKE STINKER  --------------------------------------------------------------------------
    function makeStinker(pos) {
        Stinker = [];
        var obj = new STINKER(pos);
        obj.active = true;
        Stinker.push(obj);
        // Mouse/touch controls for moving Stinker
        var isStinkerDragging = false;
        var stinkerDragOffset = {x:0, y:0};

        canvas.addEventListener('mousedown', function(e) {
            if (globalInteractionLock) return; // Don't interact if something else is being used
            
            if (typeof Stinker !== 'undefined' && Stinker.length > 0) {
                if (!Stinker[0].active) return;
                
                var stinker = Stinker[0];
                
                // Check for drag - convert to sim coordinates
                var mouseX = e.offsetX / cScale;
                var mouseY = (simHeight - e.offsetY / cScale);
                var dx = mouseX - stinker.pos.x;
                var dy = mouseY - stinker.pos.y;
                const stinkerRadius = 60 / cScale; // 60 pixels in sim units
                const distFromCenter = Math.sqrt(dx*dx + dy*dy);
                const stinkerTiming = 110 - (Magnet[0].force * 10); // spawn hearts faster with stronger magnet
                if (distFromCenter < stinkerRadius) {
                    globalInteractionLock = true;
                    isStinkerDragging = true;
                    stinkerDragOffset.x = dx;
                    stinkerDragOffset.y = dy;
                    // Start stink on hold
                    stinkerHoldTimer = setInterval(stink, 50);
                    // Start spawning hearts at ~20 per second (50ms interval)
                    heartSpawnTimer = setInterval(spawnHearts, stinkerTiming);
                }
            }
        });
        canvas.addEventListener('mouseup', function(e) {
            if (stinkerHoldTimer) {
                clearInterval(stinkerHoldTimer);
                stinkerHoldTimer = null;
            }
            if (heartSpawnTimer) {
                clearInterval(heartSpawnTimer);
                heartSpawnTimer = null;
            }
            isStinkerDragging = false;
        });
        canvas.addEventListener('mouseleave', function(e) {
            if (stinkerHoldTimer) {
                clearInterval(stinkerHoldTimer);
                stinkerHoldTimer = null;
            }
            if (heartSpawnTimer) {
                clearInterval(heartSpawnTimer);
                heartSpawnTimer = null;
            }
            isStinkerDragging = false;
        });
        canvas.addEventListener('mousemove', function(e) {
            if (isStinkerDragging && typeof Stinker !== 'undefined' && Stinker.length > 0) {
                var mouseX = e.offsetX / cScale;
                var mouseY = (simHeight - e.offsetY / cScale);
                Stinker[0].pos.x = mouseX - stinkerDragOffset.x;
                Stinker[0].pos.y = mouseY - stinkerDragOffset.y;
            }
        });
        canvas.addEventListener('touchstart', function(e) {
        if (typeof Stinker !== 'undefined' && Stinker.length > 0 && Stinker[0].active) {
            var touch = e.touches[0];
            var rect = canvas.getBoundingClientRect();
            var mouseX = (touch.clientX - rect.left) / cScale;
            var mouseY = (simHeight - (touch.clientY - rect.top) / cScale);
            var dx = mouseX - Stinker[0].pos.x;
            var dy = mouseY - Stinker[0].pos.y;
            if (Math.sqrt(dx*dx + dy*dy) < Stinker[0].radius) {
                isStinkerDragging = true;
                stinkerDragOffset.x = dx;
                stinkerDragOffset.y = dy;
            }
        }
        }, { passive: true });
        canvas.addEventListener('touchmove', function(e) {
            if (isStinkerDragging && typeof Stinker !== 'undefined' && Stinker.length > 0) {
                var touch = e.touches[0];
                var rect = canvas.getBoundingClientRect();
                var mouseX = (touch.clientX - rect.left) / cScale;
                var mouseY = (simHeight - (touch.clientY - rect.top) / cScale);
                Stinker[0].pos.x = mouseX - stinkerDragOffset.x;
                Stinker[0].pos.y = mouseY - stinkerDragOffset.y;
            }
        }, { passive: true });
        canvas.addEventListener('touchend', function(e) {
            if (stinkerHoldTimer) {
                clearInterval(stinkerHoldTimer);
                stinkerHoldTimer = null;
            }
            if (heartSpawnTimer) {
                clearInterval(heartSpawnTimer);
                heartSpawnTimer = null;
            }
            isStinkerDragging = false;
        });
    }
    makeStinker(new Vector2(0.5 * simWidth, 0.07 * simHeight));


    //  MAGNET CONSTRUCTOR ----------------------------------------------------------------
    let poleGlowTicker = 0;
    class MAGNET {
        constructor(pos) {
            this.radius = 0.2;
            this.pos = pos.clone();
            this.force = 5;
        }
        draw() {
            const iconRadius = 30;
            const centerX = this.pos.x * cScale;
            const centerY = (simHeight - this.pos.y) * cScale;

            if (imploderHoldTimer != null) {
                poleGlowTicker += 0.05;
                if (poleGlowTicker > 2 * Math.PI) {
                    poleGlowTicker = 0;
                }  

                const poleGlowAlpha = 0.6 * Math.abs(Math.sin(poleGlowTicker));
                const glowRadius = 0.4 * iconRadius + poleGlowAlpha * 0.8 * iconRadius + (this.force / 5) * 0.4 * iconRadius;
                var poleGlow = c.createRadialGradient(
                    centerX - iconRadius, 
                    centerY - 1.2 * iconRadius, 
                    0, 
                    centerX - iconRadius, 
                    centerY - 1.2 * iconRadius, 
                    glowRadius);
                poleGlow.addColorStop(0, `hsla(270, 0%, 70%, ${poleGlowAlpha})`);
                poleGlow.addColorStop(1, `hsla(270, 0%, 50%, 0.0)`);
                c.fillStyle = poleGlow;
                drawCircle(centerX - iconRadius, centerY - 1.2 * iconRadius, glowRadius);
                c.fill();
                
                poleGlow = c.createRadialGradient(
                    centerX + iconRadius, 
                    centerY - 1.2 * iconRadius, 
                    0, 
                    centerX + iconRadius, 
                    centerY - 1.2 * iconRadius, 
                    glowRadius);
                poleGlow.addColorStop(0, `hsla(270, 0%, 70%, ${poleGlowAlpha})`);
                poleGlow.addColorStop(1, `hsla(270, 0%, 50%, 0.0)`);
                c.fillStyle = poleGlow;
                
                drawCircle(centerX + iconRadius, centerY - 1.2 * iconRadius, glowRadius);
                c.fill();
            };

            c.shadowBlur = 6;
            c.shadowColor = 'hsla(0, 0%, 0%, 1)';
            // black base for poles and arc
            c.lineWidth = 24;
            // Left pole
            c.beginPath();
            c.moveTo(centerX - iconRadius, centerY - 0.9 * iconRadius);
            c.lineTo(centerX - iconRadius, centerY);
            c.strokeStyle = 'hsla(0, 0%, 90%, 1.0)';
            c.stroke();
            // left pole tip
            c.beginPath();
            c.moveTo(centerX - iconRadius, centerY - 1.5 * iconRadius);
            c.lineTo(centerX - iconRadius, centerY - 0.9 * iconRadius);
            //c.stroke();
            // Right pole
            c.beginPath();
            c.moveTo(centerX + iconRadius, centerY - 0.9 * iconRadius);
            c.lineTo(centerX + iconRadius, centerY);
            c.stroke();
            // right pole tip
            c.beginPath();
            c.moveTo(centerX + iconRadius, centerY - 1.5 * iconRadius);
            c.lineTo(centerX + iconRadius, centerY - 0.9 * iconRadius);
            //c.stroke();
            // Arc connecting poles
            c.beginPath();
            c.arc(centerX, centerY, iconRadius, Math.PI, 0, true);
            c.stroke();
            c.shadowBlur = 0;

            // colored overlay for poles and arc
            c.lineWidth = 22;
            const grau = 'hsla(0, 0%, 50%, 1)';
            const lichtgrau = 'hsla(0, 0%, 80%, 1)';
            const rott = 'hsla(0, 85%, 40%, 1)';
            // Left pole
            c.beginPath();
            c.moveTo(centerX - iconRadius, centerY - 0.85 * iconRadius);
            c.lineTo(centerX - iconRadius, centerY + 0.1 * iconRadius);
            c.strokeStyle = rott;
            c.stroke();
            // left pole tip
            c.beginPath();
            c.moveTo(centerX - iconRadius, centerY - 1.5 * iconRadius);
            c.lineTo(centerX - iconRadius, centerY - 0.9 * iconRadius);
            if (imploderHoldTimer == null) {
                c.strokeStyle = grau;
            } else {
                c.strokeStyle = lichtgrau;
            }
            c.shadowBlur = 6;
            c.stroke();
            c.shadowBlur = 0;
            // Right pole
            c.beginPath();
            c.moveTo(centerX + iconRadius, centerY - 0.85 * iconRadius);
            c.lineTo(centerX + iconRadius, centerY + 0.1 * iconRadius);
            c.strokeStyle = rott;
            c.stroke();
            // right pole tip
            c.beginPath();
            c.moveTo(centerX + iconRadius, centerY - 1.5 * iconRadius);
            c.lineTo(centerX + iconRadius, centerY - 0.9 * iconRadius);
            if (imploderHoldTimer == null) {
                c.strokeStyle = grau;
            } else {
                c.strokeStyle = lichtgrau;
            }
            c.shadowBlur = 6;
            c.stroke();
            c.shadowBlur = 0;
            // Arc connecting poles
            c.beginPath();
            c.arc(centerX, centerY, iconRadius, Math.PI, 0, true);
            c.strokeStyle = rott;
            c.stroke();

            // + - force level indicators
            c.fillStyle = 'black';
            c.textBaseline = 'middle';
            c.textAlign = "center";
            c.font = `13px verdana`;
            // minus sign on left side
            c.fillText("-", centerX - iconRadius - 0.01 * iconRadius, centerY - 1.18 * iconRadius);
            // plus sign on right side
            c.fillText("+", centerX + iconRadius + 0.01 * iconRadius, centerY - 1.18 * iconRadius);

            // draw force level indicator dot gauge along the bottom U of the magnget
            const gaugeRadius = 3;
            const gaugeStartX = centerX - iconRadius + 0.2 * iconRadius;
            const gaugeEndX = centerX + iconRadius - 0.2 * iconRadius;
            const gaugeY = centerY + 0.2 * iconRadius;
            const gaugeSteps = 10;
            // draw gauge dots in an arc centered on the U-bend
            for (let i = 0; i < gaugeSteps; i++) {
                const t = i / (gaugeSteps - 1);
                const angle = Math.PI - t * Math.PI;
                const dotX = centerX + (iconRadius - 0.02 * iconRadius) * Math.cos(angle);
                const dotY = centerY + (iconRadius - 0.02 * iconRadius) * Math.sin(angle);
                drawCircle(dotX, dotY, gaugeRadius);
                if (i < this.force) {
                    if (this.force < 1) {
                        c.fillStyle = `hsl(0, 0%, ${this.force * 100}%)`;
                        //c.fillStyle = 'blue';
                    } else {
                        c.fillStyle = 'white';
                    }
                } else {
                    c.fillStyle = 'red';
                }
                c.fill();
            }
        }
    }

    //  MAKE MAGNET  --------------------------------------------------------------------------
    function makeImploder(radius, pos) {
        Magnet = [];
        var obj = new MAGNET(radius, pos);
        obj.active = true;
        Magnet.push(obj);
        // Mouse/touch controls for moving Magnet
        var isImploderDragging = false;
        var imploderDragOffset = {x:0, y:0};

        canvas.addEventListener('mousedown', function(e) {
            if (globalInteractionLock) return; // Don't interact if something else is being used
            
            if (typeof Magnet !== 'undefined' && Magnet.length > 0) {
                if (!Magnet[0].active) return;
                
                var magnet = Magnet[0];
                
                // Work in canvas pixel coordinates for the icon
                const canvasX = e.offsetX;
                const canvasY = e.offsetY;
                const centerX = magnet.pos.x * cScale;
                const centerY = (simHeight - magnet.pos.y) * cScale;
                
                const iconRadius = 30;
                const clickRadius = 20; // 20 pixel click area
                
                // Minus button (left gray pole)
                const minusCanvasX = centerX - iconRadius;
                const minusCanvasY = centerY - 1.2 * iconRadius;
                
                if (Math.abs(canvasX - minusCanvasX) < clickRadius && Math.abs(canvasY - minusCanvasY) < clickRadius) {
                    globalInteractionLock = true;
                    if (magnet.force <= 1) {
                        magnet.force = Math.max(0.1 , magnet.force - 0.1);
                        return;
                    };
                    magnet.force = Math.max(1, magnet.force - 1);
                    return;
                }
                
                // Plus button (right gray pole)
                const plusCanvasX = centerX + iconRadius;
                const plusCanvasY = centerY - 1.2 * iconRadius;
                
                if (Math.abs(canvasX - plusCanvasX) < clickRadius && Math.abs(canvasY - plusCanvasY) < clickRadius) {
                    globalInteractionLock = true;
                    if (magnet.force < 1) {
                        magnet.force = Math.min(1, magnet.force + 0.1);
                        return;
                    };
                    
                    magnet.force = Math.min(10, magnet.force + 1);
                    return;
                }
                
                // Check for drag - convert back to sim coordinates
                var mouseX = e.offsetX / cScale;
                var mouseY = (simHeight - e.offsetY / cScale);
                var dx = mouseX - magnet.pos.x;
                var dy = mouseY - magnet.pos.y;
                const magnetRadius = 60 / cScale; // 60 pixels in sim units
                const distFromCenter = Math.sqrt(dx*dx + dy*dy);
                
                if (distFromCenter < magnetRadius) {
                    globalInteractionLock = true;
                    isImploderDragging = true;
                    imploderDragOffset.x = dx;
                    imploderDragOffset.y = dy;
                    // Start magnetize on hold
                    imploderHoldTimer = setInterval(magnetize, 50);
                }
            }
        });
        canvas.addEventListener('mouseup', function(e) {
            if (imploderHoldTimer) {
                clearInterval(imploderHoldTimer);
                imploderHoldTimer = null;
            }
            isImploderDragging = false;
        });
        canvas.addEventListener('mouseleave', function(e) {
            if (imploderHoldTimer) {
                clearInterval(imploderHoldTimer);
                imploderHoldTimer = null;
            }
            isImploderDragging = false;
        });
        canvas.addEventListener('mousemove', function(e) {
            if (isImploderDragging && typeof Magnet !== 'undefined' && Magnet.length > 0) {
                var mouseX = e.offsetX / cScale;
                var mouseY = (simHeight - e.offsetY / cScale);
                Magnet[0].pos.x = mouseX - imploderDragOffset.x;
                Magnet[0].pos.y = mouseY - imploderDragOffset.y;
            }
        });
        canvas.addEventListener('mouseup', function(e) {
            isImploderDragging = false;
        });
        canvas.addEventListener('touchstart', function(e) {
        if (typeof Magnet !== 'undefined' && Magnet.length > 0 && Magnet[0].active) {
            var touch = e.touches[0];
            var rect = canvas.getBoundingClientRect();
            var mouseX = (touch.clientX - rect.left) / cScale;
            var mouseY = (simHeight - (touch.clientY - rect.top) / cScale);
            var dx = mouseX - Magnet[0].pos.x;
            var dy = mouseY - Magnet[0].pos.y;
            if (Math.sqrt(dx*dx + dy*dy) < Magnet[0].radius) {
                isImploderDragging = true;
                imploderDragOffset.x = dx;
                imploderDragOffset.y = dy;
            }
        }
        }, { passive: true });
        canvas.addEventListener('touchmove', function(e) {
            if (isImploderDragging && typeof Magnet !== 'undefined' && Magnet.length > 0) {
                var touch = e.touches[0];
                var rect = canvas.getBoundingClientRect();
                var mouseX = (touch.clientX - rect.left) / cScale;
                var mouseY = (simHeight - (touch.clientY - rect.top) / cScale);
                Magnet[0].pos.x = mouseX - imploderDragOffset.x;
                Magnet[0].pos.y = mouseY - imploderDragOffset.y;
            }
        }, { passive: true });
        canvas.addEventListener('touchend', function(e) {
            isImploderDragging = false;
        });
    }
    makeImploder(new Vector2(0.22 * simWidth, 0.35 * simHeight));

    //  HANDLE MAGNET ----------------------------------------------------------------
    let leftPole = true;
    function magnetize() {
        const implosionForce = Magnet[0] ? (Magnet[0].force) : 1;
        const baseSpeed = implosionForce * physProps.dt;
        // Use Magnet center if active, else canvas center
        let centerX, centerY;
        if (typeof Magnet !== 'undefined' && Magnet.length > 0 && Magnet[0].active) {
            if (leftPole == true) {
                centerX = Magnet[0].pos.x - 0.5 * Magnet[0].radius;
                leftPole = false;
            } else {
                centerX = Magnet[0].pos.x + 0.5 * Magnet[0].radius;
                leftPole = true;
            }
            centerY = Magnet[0].pos.y + 0.5 * Magnet[0].radius; 
        } else {
            centerX = 0.5 * simWidth;
            centerY = 0.5 * simHeight;
        }
        for (let i = Balls.length - 1; i >= 0; i--) {
            var ball = Balls[i];
            var d = new Vector2();
            d.subtractVectors(ball.pos, new Vector2(centerX, centerY));
        
            // Apply inward drawing force inversely proportional to distance
            var influenceDist = d.length();
            d.scale(1 / (influenceDist)); 
            ball.vel.x -= d.x * baseSpeed;
            ball.vel.y -= d.y * baseSpeed;
        }
    }

    //  HANDLE STINKER ----------------------------------------------------------------
    function stink() {
        const stinkForce = Magnet[0] ? (Magnet[0].force) : 1;
        const stinkSpeed = stinkForce * physProps.dt;
        // Use stinker center if active, else canvas center
        let centerX, centerY;
        if (typeof Stinker !== 'undefined' && Stinker.length > 0 && Stinker[0].active) {
            if (leftPole == true) {
                centerX = Stinker[0].pos.x - 0.5 * Stinker[0].radius;
                leftPole = false;
            } else {
                centerX = Stinker[0].pos.x + 0.5 * Stinker[0].radius;
                leftPole = true;
            }
            centerY = Stinker[0].pos.y + 0.5 * Stinker[0].radius; 
        } else {
            centerX = 0.5 * simWidth;
            centerY = 0.5 * simHeight;
        }
        for (let i = Balls.length - 1; i >= 0; i--) {
            var ball = Balls[i];
            var d = new Vector2();
            d.subtractVectors(ball.pos, new Vector2(centerX, centerY));
        
            // Apply inward drawing force inversely proportional to distance
            var influenceDist = d.length();
            d.scale(1 / (influenceDist)); 
            ball.vel.x += d.x * stinkSpeed;
            ball.vel.y += d.y * stinkSpeed;
        }
    }

    //  BLOWER CONSTRUCTOR ----------------------------------------------------------------
    class BLOWER {
        constructor(radius, pos) {
            this.radius = radius;
            this.OGradius = radius; // Remember original size
            this.pos = pos.clone();
            this.blowerAngle = 0.65 * Math.PI;
            this.force = 100;
		}
        get left() {
            return this.pos.x - this.radius;
        }
        get right() {
            return this.pos.x + this.radius;
        }
        simulate() {
            if (blowerState === 2) {
                this.blowerAngle += 0.2 * physProps.dt;
            } else if (blowerState === 3) {
                this.blowerAngle -= 0.2 * physProps.dt;
            }
        }
        draw() {
            // Draw arrow
            drawArrow(
                    this.pos.x, 
                    simHeight - this.pos.y, 
                    this.blowerAngle + 1.5 * Math.PI, 
                    3.2 * this.radius, 
                )
            c.lineWidth = 0.01 * cScale;
            c.strokeStyle = 'hsl(190, 85%, 60%)'
            
            c.fillStyle = 'hsla(0, 0%, 0%, 50%)';
            c.fill();
            c.stroke();

            // Draw green grip
            const gripX = (this.pos.x + Math.cos(this.blowerAngle) * this.radius) * cScale;
            const gripY = (simHeight - this.pos.y - Math.sin(this.blowerAngle) * this.radius) * cScale;
            drawCircle(
                gripX, 
                gripY, 
                0.12 * this.radius * cScale);
            c.fillStyle = 'green';
            c.fill();

            // Draw yellow off button (only when not in auto-rotate mode)
            if (blowerState === 1) {
                const offX = (this.pos.x + Math.cos(Math.PI + this.blowerAngle) * 1.0 * this.radius) * cScale;
                const offY = (simHeight - this.pos.y - Math.sin(Math.PI + this.blowerAngle) * 1.0 * this.radius) * cScale;
                const offX2 = (this.pos.x + Math.cos(Math.PI + this.blowerAngle) * 1.35 * this.radius) * cScale;
                const offY2 = (simHeight - this.pos.y - Math.sin(Math.PI + this.blowerAngle) * 1.35 * this.radius) * cScale;
                drawCircle(
                    offX, 
                    offY, 
                    0.1 * this.radius * cScale);
                // Dim button when blower is inactive
                if (blowerActive) {
                    //c.fillStyle = 'rgba(255, 165, 0, 0.3)';
                    c.fillStyle = 'hsl(40, 100%, 50%)';
                } else {
                    c.fillStyle = 'hsl(60, 30%, 30%)';
                }
                c.fill();
            
                // Draw off button
                drawCircle(
                    offX2, 
                    offY2, 
                    0.1 * this.radius * cScale);
                c.fillStyle = 'hsl(0, 90%, 40%)'; // Dim dark red
                c.fill();
            
            }

            // Draw image background circle
            drawCircle(
                this.pos.x * cScale, 
                (simHeight - this.pos.y) * cScale, 
                0.65 * this.radius * cScale);
            c.fillStyle = 'hsla(0, 0%, 0%, 70%)';
            c.fill();
                
            // Draw aeolus image 
            if (aeolusReady && aeolusImage && aeolusImage.complete && aeolusImage.width > 0 && aeolusImage.height > 0) {
                
                const x = this.pos.x  * cScale;
                const y = (simHeight - this.pos.y) * cScale;
                const rpx = 0.7 * this.radius * cScale; // Image size (50% of radius)
                
                // Calculate rotation angle (negative to reverse direction, add 180 to correct orientation)
                const angle = -this.blowerAngle;
                
                const iw = aeolusImage.width;
                const ih = aeolusImage.height;
                const s = (2 * rpx) / Math.max(iw, ih);
                const dw = iw * s;
                const dh = ih * s;
                
                c.save();
                c.translate(x, y);
                c.rotate(angle);
                
                // Draw the white image
                c.drawImage(aeolusImage, -dw / 2, -dh / 2, dw, dh);
                
                // Tint the image to bright yellow using multiply blend mode
                const prevOp = c.globalCompositeOperation;
                c.globalCompositeOperation = 'multiply';
                //c.fillStyle = 'hsl(0, 0%, 60%)'; // Bright blue matching the checked button
                //c.fillRect(-dw / 2, -dh / 2, dw, dh);
                c.globalCompositeOperation = prevOp;
                
                c.restore();
            }
        }
    }

    //  MAKE BLOWER  --------------------------------------------------------------------------
    function makeBlower(radius, pos) {
        Blower = [];
        Blower.push( new BLOWER(radius, pos) );
    }
       
        
    //  HUNGRY PUCK CONSTRUCTOR ----------------------------------------------------------------
    class HUNGRYPUCK {
		constructor(radius, pos, vel, color) {
			this.radius = radius;
			this.pos = pos.clone();
            this.vel = vel.clone();
            this.color = color;
		}
        get left() {
            return this.pos.x - this.radius;
        }
        get right() {
            return this.pos.x + this.radius;
        }
        draw1() {
            // body
            const grd = c.createRadialGradient(cX(this.pos), cY(this.pos), 1.2 * this.radius * cScale, 
            cX(this.pos), cY(this.pos), 1.6 * this.radius * cScale);
            grd.addColorStop(0.0, `hsla(0, 0%, 0%, 100%)`);
            grd.addColorStop(1.0, `hsla(0, 0%, 0%, 0%)`);
            c.fillStyle = grd;
            drawCircle(cX(this.pos), cY(this.pos), 1.6 * this.radius * cScale);
            c.fill();
            // eyes
            //c.strokeStyle = "hsl(120, 50%, 50%)";
            c.strokeStyle = "hsl(46, 100%, 65%)";
            c.lineWidth = 0.04 * this.radius * cScale;
            c.beginPath();
            c.moveTo(cX(this.pos) + 0.2 * this.radius * cScale, cY(this.pos) - 0.2 * this.radius * cScale);
            c.lineTo(cX(this.pos) + 0.5 * this.radius * cScale, cY(this.pos) - 0.3 * this.radius * cScale);
            c.stroke();
            c.beginPath();
            c.moveTo(cX(this.pos) - 0.2 * this.radius * cScale, cY(this.pos) - 0.2 * this.radius * cScale);
            c.lineTo(cX(this.pos) - 0.5 * this.radius * cScale, cY(this.pos) - 0.3 * this.radius * cScale);
            c.stroke();
            // mouth
            //c.strokeStyle = "hsl(90, 40%, 20%)";
            c.strokeStyle = "hsl(46, 90%, 20%)";
            c.lineWidth = 0.06 * this.radius * cScale;
            c.beginPath();
            c.arc(cX(this.pos), cY(this.pos), 0.9 * this.radius * cScale, 0, Math.PI) 
            c.stroke();
            // dimples
            //c.fillStyle = "hsl(90, 40%, 30%)";
            c.fillStyle = "hsl(46, 90%, 40%)";
            drawCircle(cX(this.pos) + 0.9 * this.radius * cScale, cY(this.pos), 0.05 * this.radius * cScale);
            c.fill();
            drawCircle(cX(this.pos) - 0.9 * this.radius * cScale, cY(this.pos), 0.05 * this.radius * cScale);
            c.fill();   
        }
        draw2() {
            // body
            const grd = c.createRadialGradient(cX(this.pos), cY(this.pos), 1.2 * this.radius * cScale, 
            cX(this.pos), cY(this.pos), 1.6 * this.radius * cScale);
            grd.addColorStop(0.0, `hsla(0, 0%, 0%, 100%)`);
            grd.addColorStop(1.0, `hsla(0, 0%, 0%, 0%)`);
            c.fillStyle = grd;
            drawCircle(cX(this.pos), cY(this.pos), 1.6 * this.radius * cScale);
            c.fill();
            // eyes
            //c.strokeStyle = "hsl(335, 70%, 60%)";
            c.strokeStyle = "hsl(46, 100%, 65%)";
            c.lineWidth = 0.04 * this.radius * cScale;
            c.beginPath();
            c.moveTo(cX(this.pos) + 0.25 * this.radius * cScale, cY(this.pos) - 0.2 * this.radius * cScale);
            c.lineTo(cX(this.pos) + 0.55 * this.radius * cScale, cY(this.pos) - 0.25 * this.radius * cScale);
            c.stroke();
            c.beginPath();
            c.moveTo(cX(this.pos) - 0.25 * this.radius * cScale, cY(this.pos) - 0.2 * this.radius * cScale);
            c.lineTo(cX(this.pos) - 0.55 * this.radius * cScale, cY(this.pos) - 0.25 * this.radius * cScale);
            c.stroke();
            // mouth
            c.strokeStyle = "hsl(46, 90%, 40%)";
            c.lineWidth = 0.05 * this.radius * cScale;
            c.beginPath();
            c.arc(cX(this.pos), cY(this.pos) + 0.4 * this.radius * cScale, 0.2 * this.radius * cScale, Math.PI, 0);
            c.stroke();
            // cheeks
            c.fillStyle = "hsl(320, 90%, 15%)";
            drawCircle(cX(this.pos) + 0.8 * this.radius * cScale, cY(this.pos) + 0.2 * this.radius * cScale, 0.2 * this.radius * cScale);
            c.fill();
            drawCircle(cX(this.pos) - 0.8 * this.radius * cScale, cY(this.pos) + 0.2 * this.radius * cScale, 0.2 * this.radius * cScale);
            c.fill();
        }
        draw3() {
            const overlayRadius = 1.1 * this.radius;
            let isUnderCorner = false;
            
            // Check if puck is hidden by any corner mask
            if (Array.isArray(Corners) && Corners.length > 0) {
                for (let i = 0; i < Corners.length; i++) {
                    const corner = Corners[i];
                    if (!corner || !corner.pos) continue;
                    
                    // Calculate corner arc center based on corner type
                    let arcCenterX, arcCenterY;
                    if (corner.corner === 'northwest') {
                        arcCenterX = corner.pos.x + corner.radius;
                        arcCenterY = corner.pos.y + corner.radius;
                    } else if (corner.corner === 'northeast') {
                        arcCenterX = corner.pos.x - corner.radius;
                        arcCenterY = corner.pos.y + corner.radius;
                    } else if (corner.corner === 'southwest') {
                        arcCenterX = corner.pos.x + corner.radius;
                        arcCenterY = corner.pos.y - corner.radius;
                    } else if (corner.corner === 'southeast') {
                        arcCenterX = corner.pos.x - corner.radius;
                        arcCenterY = corner.pos.y - corner.radius;
                    }
                    
                    const dx = this.pos.x - arcCenterX;
                    const dy = this.pos.y - arcCenterY;
                    const distToCornerCenter = Math.sqrt(dx * dx + dy * dy);
                    
                    // The corner HIDES anything where distance > corner.radius (outside the playable arc)
                    // Draw overlay if ANY part of the puck is in the hidden region
                    // That means: the farthest point of puck (distToCornerCenter + overlayRadius) > corner.radius
                    if (distToCornerCenter + overlayRadius > corner.radius) {
                        isUnderCorner = true;
                        break;
                    }
                }
            }
            
            if (isUnderCorner) {
                // Draw full dashed circle when hidden by corner
                c.strokeStyle = `hsla(0, 0%, 0%, 50%)`;
                c.lineWidth = 0.01 * cScale;
                c.setLineDash([5, 12]);
                c.beginPath();
                c.arc(cX(this.pos), cY(this.pos), overlayRadius * cScale, 0, 2 * Math.PI);
                c.stroke();
                c.setLineDash([]);
            }
        }
	}

    //  MR. MISTER CONSTRUCTOR ----------------------------------------------------------------
    class MISTERMISTER {
		constructor(pos, vel, color) {
			this.pos = pos.clone();
            this.vel = vel.clone();
            this.color = color;
            this.radius = 0.15;
            this.respawnDir = 0;
		}
        get left() {
            return this.pos.x - this.radius;
        }
        get right() {
            return this.pos.x + this.radius;
        }
        simulate() {
            if (mrMode == 'billiard') {
                this.pos.add(this.vel, physProps.dt)
            }
            if (mrMode == "typewriter") {
                if (goLeft == false) {
                    this.pos.x += this.vel.x * physProps.dt * misterSpeed;
                        if (this.pos.x > simWidth) {
                            goLeft = true;
                        }
                }
                if (goLeft == true) {
                    this.pos.x -= this.vel.x * 5 * physProps.dt * misterSpeed;
                        if (this.pos.x < 0) {
                            goLeft = false;
                        };
                }
            }
            if (mrMode == "printer") {
                if (goLeft == false) {
                    this.pos.x += this.vel.x * physProps.dt * misterSpeed;
                        if (this.pos.x > simWidth) {
                            goLeft = true;
                        }
                }
                if (goLeft == true) {
                    this.pos.x -= this.vel.x * physProps.dt * misterSpeed;
                        if (this.pos.x < 0) {
                            goLeft = false;
                        };
                }
            }
            if (mrMode == "scanner") {
                if (this.pos.x < 1.5 * this.radius + simWidth) {
                    this.pos.x += this.vel.x * physProps.dt * misterSpeed;
                }
                if (this.pos.x > 1.5 * this.radius + simWidth) {
                    this.pos.x = -1.5 * this.radius;
                }
            }
            if (mrMode == "circle") {
                delta += physProps.dt * misterSpeed;
                this.pos.x = 0.5 * simWidth + 0.2 * simWidth * Math.cos(delta);
                this.pos.y = 0.5 * simHeight + 0.2 * simWidth * Math.sin(delta);
            }
            if (mrMode == "oval") {
                delta += physProps.dt * misterSpeed;
                this.pos.x = 0.5 * simWidth + 0.3 * simWidth * Math.cos(delta);
                this.pos.y = 0.5 * simHeight + 0.3 * simHeight * Math.sin(delta);
            }
            if (mrMode == "bernoulli") {
                delta += physProps.dt * misterSpeed;
                var pathScale = 2 / (3 - Math.cos(2 * delta));
                this.pos.x = (0.5 * simWidth) + (0.4 * simWidth) * pathScale * Math.cos(delta);
                this.pos.y = (0.5 * simHeight) + (0.3 * simWidth) * pathScale * Math.sin(2 * delta) / 2;
            }
            if (mrMode == "worm") {
                if (WormProps.SpaceWorm && WormProps.SpaceWorm.pos.length > 1) {
                    this.pos.x = WormProps.SpaceWorm.pos[1].x;
                    this.pos.y = WormProps.SpaceWorm.pos[1].y;
                } else {
                    this.pos.x = 0.5 * simWidth;
                    this.pos.y = 0.5 * simHeight;
                }
            }
        }
        draw() {
            mrMrTimer += .05;
            var eyeLight = 30 + 70 * Math.abs(Math.sin(mrMrTimer));
            // body
            if (mrMode != 'worm') {
                const grd = c.createRadialGradient(cX(this.pos), cY(this.pos), 1.2 * 0.15 * cScale, 
                cX(this.pos), cY(this.pos), 1.6 * 0.15 * cScale);
                grd.addColorStop(0.0, `hsla(0, 0%, 0%, 100%)`);
                grd.addColorStop(1.0, `hsla(0, 0%, 0%, 0%)`);
                c.fillStyle = grd;
                c.strokeStyle = `hsl(200, 80%, ${eyeLight}%)`;
                drawCircle(cX(this.pos), cY(this.pos), 1.6 * 0.15 * cScale);
            } else {
                var sphereGradient = c.createRadialGradient(
                (cX(this.pos) - (this.radius * cScale)), 
                (cY(this.pos) - (0.4 * this.radius * cScale)), 
                0, 
                (cX(this.pos) - (0.2 * this.radius * cScale)), 
                (cY(this.pos) - (0.4 * this.radius * cScale)), 
                this.radius * cScale
                );
                var highlight = 'hsl(30, 80%, 80%)';
                var midtone = 'hsl(30, 80%, 60%)';
                var shadow = 'hsl(30, 80%, 10%)';
                sphereGradient.addColorStop(0.0, highlight);
                sphereGradient.addColorStop(0.15, midtone);
                sphereGradient.addColorStop(1.0, shadow);
                c.fillStyle = sphereGradient;
                c.strokeStyle = `hsl(200, 80%, ${eyeLight -40}%)`;
                drawCircle(cX(this.pos), cY(this.pos), 1.0 * 0.15 * cScale);
            }
            c.fill();
            // eyes  ----------
            c.lineWidth = 0.05 * 0.2 * cScale;
            c.beginPath();
            c.moveTo(cX(this.pos) + 0.35 * 0.15 * cScale, cY(this.pos) - 0.1 * 0.15 * cScale);
            c.lineTo(cX(this.pos) + 0.7 * 0.15 * cScale, cY(this.pos) - 0.1 * 0.15 * cScale);
            c.stroke();
            c.beginPath();
            c.moveTo(cX(this.pos) - 0.3 * 0.15 * cScale, cY(this.pos) - 0.1 * 0.15 * cScale);
            c.lineTo(cX(this.pos) - 0.65 * 0.15 * cScale, cY(this.pos) - 0.1 * 0.15 * cScale);
            c.stroke();
            // mouth  ----------
            if (mrMode == 'worm') {
                c.fillStyle = `black`;
                c.lineWidth = 0.05 * 0.2 * cScale;
                c.beginPath();
                c.ellipse(
                cX(this.pos), 
                cY(this.pos) + 0.45 * 0.15 * cScale, 
                0.45 * 0.15 * cScale, 
                0.35 * 0.15 * cScale, 
                0, 
                0, 
                2 * Math.PI, false);
                c.fillStyle = `black`;
            } else {
                c.fillStyle = `hsl(200, 80%, ${40 - eyeLight / 3}%)`;
                c.lineWidth = 0.05 * 0.2 * cScale;
                c.beginPath();
                c.ellipse(
                cX(this.pos), 
                cY(this.pos) + 0.7 * 0.15 * cScale, 
                0.45 * 0.15 * cScale, 
                0.35 * 0.15 * cScale, 
                0, 
                0, 
                2 * Math.PI, false);
            }
            
            c.fill();
            c.stroke();
        }
	}

    //  DEFINE PUCKS MAKE PUCKS -----------------------------------------------------------------         
    function makePucks() {
        Puck = [];
        puck1color = `hsla(70, 20%, 40%, 65%)`;
        puck2color = `hsla(160, 20%, 30%, 65%)`;
        //  HEARTBEAT PUCK (Puck[0])  ----------------------------------------------------------
        Puck.push (new PUCK(0.3, 
            new Vector2(0.65 * canvas.width / cScale, 
                0.1 * canvas.height / cScale), 
                puck2color, 
                true));
        //  CYCLE PUCK (Puck[1])  ---------------------------------------------------
        Puck.push (new PUCK(0.25,
            new Vector2(0.5 * simWidth, 
                0.9 * simHeight), 
                puck1color, 
                false));
            // mark last puck as cycle-type and init its state machine
            if (Puck.length > 1) {
                Puck[1].cycle = true;
                if (typeof Puck[1].initCycle === 'function') {
                    Puck[1].initCycle();
                }
            }
        //  FLYING PUCK (Puck[2])  ----------------------------------------------------------
        Puck.push (new PUCK(0.25, 
            new Vector2(
                0, 
                0.5 * simHeight), 
                puck2color, 
                false));
            // mark last puck as flying-type and init its state
            if (Puck.length > 2) {
                Puck[2].flying = true;
                Puck[2].vel.x = 3.0;
            }
        //  ELLIPTICAL ORBIT PUCK (Puck[3])  ------------------------------------------
        Puck.push (new PUCK(0.15,
            new Vector2(0.5 * simWidth, 
                0.5 * simHeight), 
                puck1color, 
                false));
            // mark last puck as orbit-type and init its state
            if (Puck.length > 3) {
                Puck[3].orbit = true;
                Puck[3].orbitAngle = 0; // Start at right side of ellipse
                Puck[3].orbitSpeed = 2.0; // radians per second
            }
        //  YIN-YANG ORBIT PUCK (Puck[4]) - Twin to elliptical orbit puck  ----------
        Puck.push (new PUCK(0.15,
            new Vector2(0.5 * simWidth, 
                0.5 * simHeight), 
                puck2color, 
                false));
            // mark last puck as yin-yang orbit type and init its state
            if (Puck.length > 4) {
                Puck[4].orbit = true;
                Puck[4].yinyang = true; // Mark as the yin-yang twin
                Puck[4].orbitAngle = Math.PI; // Start 180 degrees out of phase
                Puck[4].orbitSpeed = 2.0; // radians per second
            }
        // NORMAL PUCKS (Puck[5+]) - can be duplicated/deleted ----------------------------------------------------------
        Puck.push (new PUCK(
            0.3, 
            new Vector2(0.35 * simWidth, 
                0.2 * simHeight), 
                puck2color, 
                false));
        }
    
    //  DEFINE HUNGRY PUCKS ----------------------------------------------------------        
    function makeHungryPucks() {
        Hungrypuck = [];
        hungryPuckVel = new Vector2(0, 0);
        Hungrypuck.push (new HUNGRYPUCK(0.15, new Vector2(0.7 * simWidth, -0.1 * 0.15), hungryPuckVel, `hsl(0, 50%, 50%)`));
        Hungrypuck.push (new HUNGRYPUCK(0.15, new Vector2(0.3 * simWidth, -0.1 * 0.15), hungryPuckVel, `hsl(0, 50%, 50%)`));
    }
    
    // DEFINE MR. MISTER  ------------------------------------------------------------
    function makeMisterMister() {
        MisterMister = [];
        mrMrVel = new Vector2(1, 0);
        MisterMister.push (new MISTERMISTER(new Vector2(
            0.3 * simWidth, 
            0.85 * simHeight), 
            mrMrVel, 
            `hsl(0, 50%, 50%)`));
    }

    // END OF PUSH DEFINITIONS =======================================================

    //  SIMULATION --------------------------------------------------------------------------
	function simulate() {
        if (physProps.paused)
            return;	

        //  SIMULATE WORM ---------------------------------------------------------------------
        if (doWorm) {
            simulateWorm();
        }

        //  MR. & MRS. MISTER  ----------------------------------
        if (doFountain == true) {
            var mrMr = MisterMister[0];
            mrMr.simulate();
        }

        // SIMULATE ANIMATED PUCKS  ----------------------------------
        for (let p = 0; p < Puck.length; p++) {
            const puck = Puck[p];
            // heartBeat pucks have their own simulation conditions, normal pucks use puckArriving
            const shouldSim = ((doFlyingPuck == true || doFlyingPuck2 == true) && puck.flying == true) || 
                            (puck.heartBeat && showHeart) || 
                            (puck.cycle && showCycle) ||
                            (puck.orbit && showOrbit) ||
                            (puck.puckArriving && !puck.heartBeat && !puck.cycle && !puck.flying && !puck.orbit) ||
                            (doOscillatePucks && !puck.heartBeat && !puck.cycle && !puck.flying && !puck.orbit && !puck.yinyang);
            if (shouldSim) puck.simulate();
        }

        //  SIMUALTE BLOWER  ---------------------------------------------------------------     
        if (blowerState === 2 || blowerState === 3) {
            var blower = Blower[0];
            blower.simulate();
        }

        //  SIMULATE HEARTS  ---------------------------------------------------------------
        if (typeof Hearts !== 'undefined' && Hearts.length > 0) {
            for (let i = Hearts.length - 1; i >= 0; i--) {
                Hearts[i].simulate();
            }
        }

        //  BALLS ----------------------------------
        // Precompute bumper sweep structures once per frame
        let bumperCtx = null;
        if (showBumpers && Array.isArray(Bumpers) && Bumpers.length) {
            const lowest = Bumpers[0];
            const highest = Bumpers[Bumpers.length - 1];
            const arrayBottom = lowest.pos.y - lowest.radius;
            const arrayTop = highest.pos.y + highest.radius;
            const sortedBumpers = Bumpers.slice().sort((a,b)=>a.left-b.left);
            bumperCtx = { arrayBottom, arrayTop, sortedBumpers };
        }

        // Phase 1: integrate & per-ball updates (no ball-ball collisions yet)
        for (let i = 0; i < Balls.length; i++) {
            const ball = Balls[i];
            ball.simulate();
            if (doTracer && ball.tracerBall) ball.updateTrace();
            // Worm immunity countdown
            if (ball.immuneToWorm) {
                if (typeof ball.immunityFramesLeft === 'undefined') ball.immunityFramesLeft = 10;
                if (ball.immunityFramesLeft > 0) {
                    ball.immunityFramesLeft--;
                    if (ball.immunityFramesLeft <= 0) ball.immuneToWorm = false;
                }
            }
            // Hungry puck interaction (uses current position only; order independent)
            if (showEaters) {
                for (let h = 0; h < Hungrypuck.length; h++) {
                    const hp = Hungrypuck[h];
                    // Broad-phase: axis-aligned bounding box check for 3.0 radii
                    let broadRadius = 3.0 * (ball.radius + hp.radius);
                    if (
                        ball.pos.x + ball.radius >= hp.pos.x - broadRadius &&
                        ball.pos.x - ball.radius <= hp.pos.x + broadRadius &&
                        ball.pos.y + ball.radius >= hp.pos.y - broadRadius &&
                        ball.pos.y - ball.radius <= hp.pos.y + broadRadius
                    ) {
                        // Now do the expensive distance check
                        let dx = ball.pos.x - hp.pos.x;
                        let dy = ball.pos.y - hp.pos.y;
                        let dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist > 0 && dist < broadRadius) {
                            // Apply an inward force toward the hungry puck center
                            let strength = 0.025; // Tune this for effect
                            let fx = -strength * dx / dist;
                            let fy = -strength * dy / dist;
                            ball.vel.x += fx;
                            ball.vel.y += fy;
                        }
                        // Hard collision (recycle) if within sum of radii
                        if (dist > 0 && dist <= ball.radius + hp.radius) {
                            handleHungryPuckHits(ball, hp);
                        }
                    }
                }
            }

            //  HANDLE BLOWER HITS  ------------------
            if (blowerState >= 1 && blowerState <= 3) {
                for (let h = 0; h < Blower.length; h++) {
                    const blower = Blower[h];
                    // Broad-phase: axis-aligned bounding box check for 2.0 radii
                    let broadRadius = 3.0 * (ball.radius + blower.radius);
                    if (
                        ball.pos.x + ball.radius >= blower.pos.x - broadRadius &&
                        ball.pos.x - ball.radius <= blower.pos.x + broadRadius &&
                        ball.pos.y + ball.radius >= blower.pos.y - broadRadius &&
                        ball.pos.y - ball.radius <= blower.pos.y + broadRadius
                    ) {
                        // Fast check: only process particles behind the blower
                        let dx = ball.pos.x - blower.pos.x;
                        let dy = ball.pos.y - blower.pos.y;
                        let blowerDirX = Math.cos(blower.blowerAngle);
                        let blowerDirY = Math.sin(blower.blowerAngle);
                        let dotProduct = dx * blowerDirX + dy * blowerDirY;
                        
                        // Skip particles in front of the blower
                        if (dotProduct >= 0) continue;
                        
                        // Now do the expensive distance check
                        let dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist > 0 && dist < broadRadius) {
                            // Apply an inward force toward the blower center (only when active)
                            if (blowerActive) {
                                let strength = 0.02; // Tune this for effect
                                let fx = -strength * dx / dist;
                                let fy = -strength * dy / dist;
                                ball.vel.x += fx;
                                ball.vel.y += fy;
                            }
                        }
                        // Hard collision (recycle) if within sum of radii
                        if (dist > 0 && dist <= ball.radius + 0.5 *blower.radius) {
                            handleBlowerHits(ball, blower);
                        }
                    }
                }
            }
            
            // PUCK COLLISIONS -------------------
            for (let p = 0; p < Puck.length; p++) {
                const puck = Puck[p];
                if (puck.heartBeat && !showHeart) continue;
                if (puck.cycle && !showCycle) continue;
                if (puck.orbit && !showOrbit) continue;
                if (puck.flying && !doFlyingPuck && !doFlyingPuck2) continue;
                if (!puck.heartBeat && !puck.cycle && !puck.flying && !puck.orbit && !showPucks) continue;
                if (puck.right < ball.left) continue;
                if (Math.abs(ball.pos.y - puck.pos.y) <= ball.radius + puck.radius) handlePuckHits(ball, puck);
            }
            // Worm segment collisions - use outline in curves mode, circles in spheres mode
            if (!ball.immuneToWorm && doWorm && WormProps.SpaceWorm && WormProps.SpaceWorm.pos.length > 1) {
                const worm = WormProps.SpaceWorm;
                
                if (wormRenderMode === 'curves' && wormOutlinePoints.top.length > 0) {
                    // Outline-based collision for curves mode
                    handleWormOutlineCollision(ball, worm);
                } else {
                    // Circle-based collision for spheres mode (original)
                    let wormMinX = Infinity, wormMaxX = -Infinity, wormMinY = Infinity, wormMaxY = -Infinity;
                    for (let w = 0; w < worm.pos.length; w++) {
                        const sr = (w < worm.radii.length && typeof worm.radii[w] === 'number') ? worm.radii[w] : 0.02;
                        wormMinX = Math.min(wormMinX, worm.pos[w].x - sr);
                        wormMaxX = Math.max(wormMaxX, worm.pos[w].x + sr);
                        wormMinY = Math.min(wormMinY, worm.pos[w].y - sr);
                        wormMaxY = Math.max(wormMaxY, worm.pos[w].y + sr);
                    }
                    if (ball.pos.x + ball.radius >= wormMinX && ball.pos.x - ball.radius <= wormMaxX && ball.pos.y + ball.radius >= wormMinY && ball.pos.y - ball.radius <= wormMaxY) {
                        for (let w = 0; w < worm.pos.length; w++) {
                            const sr = (w < worm.radii.length && typeof worm.radii[w] === 'number') ? worm.radii[w] : 0.02;
                            const dx = ball.pos.x - worm.pos[w].x;
                            const dy = ball.pos.y - worm.pos[w].y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist <= ball.radius + sr) handleWormSegmentHits(ball, worm.pos[w], sr, worm.vel[w]);
                        }
                    }
                }
            }
            // Corner collisions
            for (let v = 0; v < Corners.length; v++) {
                const corner = Corners[v];
                let skip = false;
                if (corner.corner == 'northwest') skip = !doFloor || !doLeftWall;
                else if (corner.corner == 'northeast') skip = !doFloor || !doRightWall;
                else if (corner.corner == 'southwest') skip = !doCeiling || !doLeftWall;
                else skip = !doCeiling || !doRightWall;
                if (skip) continue;
                let check = false;
                if (corner.corner == 'northwest' || corner.corner == 'southwest') check = corner.right > ball.left && Math.abs(ball.pos.y - corner.pos.y) <= ball.radius + corner.radius;
                else check = corner.left < ball.left && Math.abs(ball.pos.y - corner.pos.y) <= ball.radius + corner.radius;
                if (check) handleCornerHits(ball, corner);
            }
            // Bounds
            if (mrMode == 'billiard') handleMrMrBounds(MisterMister[0], physProps.worldSize);
            handleOutOfBounds(ball, physProps.worldSize);
            // Bumpers (after position update; broad-phase by vertical slice)
            if (bumperCtx) {
                if (ball.bottom <= bumperCtx.arrayTop && ball.top >= bumperCtx.arrayBottom) {
                    for (let k = 0; k < bumperCtx.sortedBumpers.length; k++) {
                        const bumper = bumperCtx.sortedBumpers[k];
                        if (bumper.left > ball.right) break;
                        if (Math.abs(ball.pos.y - bumper.pos.y) <= ball.radius + bumper.radius) handleBumperHits(ball, bumper);
                    }
                }
            }
        }

        // Phase 2: ball-ball collisions (broad-phase)
        const useSpatial = Balls.length > 3600; // threshold; tweak as needed
        if (!useSpatial) {
            // Original sweep & prune with sort (but only once per frame, not per substep loop)
            const sorted = Balls.slice().sort((a,b)=>a.left-b.left);
            for (let i = 0; i < sorted.length; i++) {
                const a = sorted[i];
                for (let j = i+1; j < sorted.length; j++) {
                    const b = sorted[j];
                    if (ballRepulsion) {
                        // Early-out when beyond repulsion span on X
                        const span = physProps.repulsionDist * (a.radius + b.radius);
                        if ((b.left - a.right) > span) break;
                    } else {
                        if (b.left > a.right) break; // no more overlapping on x
                    }
                    // Radial tests to avoid axis-aligned artifacts (square patterns)
                    const dx = a.pos.x - b.pos.x;
                    const dy = a.pos.y - b.pos.y;
                    const dist2 = dx*dx + dy*dy;
                    const sumR = a.radius + b.radius;
                    const sumR2 = sumR * sumR;
                    if (ballRepulsion) {
                        const rep = physProps.repulsionDist * sumR;
                        if (dist2 < rep*rep) handleBallRepulsion(a,b);
                        if (dist2 <= sumR2) handleBallHits(a,b);
                    } else {
                        if (dist2 <= sumR2) handleBallHits(a,b);
                    }
                }
            }
        } else {
            // Uniform grid spatial hash
            let maxR = 0;
            for (let i=0;i<Balls.length;i++) if (Balls[i].radius>maxR) maxR = Balls[i].radius;
            const cellSize = Math.max( (ballRepulsion? physProps.repulsionDist:1) * (2*maxR), 2*maxR );
            const cols = Math.max(1, Math.floor(simWidth / cellSize) + 1);
            const rows = Math.max(1, Math.floor(simHeight / cellSize) + 1);
            const grid = new Array(cols * rows);
            for (let g=0; g<grid.length; g++) grid[g] = [];
            for (let i=0;i<Balls.length;i++) {
                const b = Balls[i];
                let cx = Math.floor(b.pos.x / cellSize);
                let cy = Math.floor(b.pos.y / cellSize);
                if (cx<0) cx=0; if (cx>=cols) cx=cols-1;
                if (cy<0) cy=0; if (cy>=rows) cy=rows-1;
                grid[cy*cols+cx].push(b);
            }
            for (let cy=0; cy<rows; cy++) {
                for (let cx=0; cx<cols; cx++) {
                    const cellIndex = cy*cols+cx;
                    const cellBalls = grid[cellIndex];
                    if (!cellBalls.length) continue;
                    // Same-cell pairs (unique)
                    for (let i=0;i<cellBalls.length;i++) {
                        for (let j=i+1;j<cellBalls.length;j++) {
                            const a = cellBalls[i], b = cellBalls[j];
                            const dx = a.pos.x - b.pos.x, dy = a.pos.y - b.pos.y;
                            const dist2 = dx*dx + dy*dy;
                            const sumR = a.radius + b.radius, sumR2 = sumR*sumR;
                            if (ballRepulsion) {
                                const rep = physProps.repulsionDist * sumR;
                                if (dist2 < rep*rep) handleBallRepulsion(a,b);
                                if (dist2 <= sumR2) handleBallHits(a,b);
                            } else {
                                if (dist2 <= sumR2) handleBallHits(a,b);
                            }
                        }
                    }
                    // Neighbor cells (unique offsets to avoid double-processing)
                    const neighborOffsets = [ [1,0], [1,1], [0,1], [-1,1] ];
                    for (const [dxCell, dyCell] of neighborOffsets) {
                        const nx = cx + dxCell, ny = cy + dyCell;
                        if (nx < 0 || ny < 0 || nx >= cols || ny >= rows) continue;
                        const neighborBalls = grid[ny*cols+nx];
                        if (!neighborBalls.length) continue;
                        for (let i=0;i<cellBalls.length;i++) {
                            for (let j=0;j<neighborBalls.length;j++) {
                                const a = cellBalls[i], b = neighborBalls[j];
                                const dx = a.pos.x - b.pos.x, dy = a.pos.y - b.pos.y;
                                const dist2 = dx*dx + dy*dy;
                                const sumR = a.radius + b.radius, sumR2 = sumR*sumR;
                                if (ballRepulsion) {
                                    const rep = physProps.repulsionDist * sumR;
                                    if (dist2 < rep*rep) handleBallRepulsion(a,b);
                                    if (dist2 <= sumR2) handleBallHits(a,b);
                                } else {
                                    if (dist2 <= sumR2) handleBallHits(a,b);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    //  DRAW EVERYTHING -----------------------------------------------------------------
	function drawEverything() {
        wipeOpacity = Math.pow(2.718, persistence / -10);
        c.fillStyle = `hsla(0, 0%, 0%, ${wipeOpacity})`;
        c.fillRect(0, 0, canvas.width, canvas.height);

        // Ensure the corner/mask gradient tracks the viewport each frame
        updateCornerFillGradient();

        // DRAW GRID -----------------------------------------------------------------
        /*
        if (persistence < 20) {
            var gridSpacing = .07;
            var horizGrids = simWidth / gridSpacing;
            var vertGrids = simHeight / gridSpacing;
            // Calculate center positions for heavy lines
            var centerX = simWidth * 0.5;
            var centerY = simHeight * 0.5;
            var centerGridX = Math.round(centerX / gridSpacing);
            var centerGridY = Math.round(centerY / gridSpacing);
            c.setLineDash([4, 4]);
            // Draw vertical lines
            for (var h = 1; h < horizGrids; h++) {
                // Make line heavy if it's at center or every 5th line from center
                var distanceFromCenter = Math.abs(h - centerGridX);
                if (distanceFromCenter % 5 == 0) {
                    c.lineWidth = 2;
                } else {
                    c.lineWidth = 1;
                }
                c.beginPath();
                c.moveTo(h * gridSpacing * cScale, 0);
                c.lineTo(h * gridSpacing * cScale, simHeight * cScale);
                c.strokeStyle = `hsl(0, 0%, 15%)`;
                c.stroke();
            }
            // Draw horizontal lines
            for (var v = 1; v < vertGrids; v++) {
                // Make line heavy if it's at center or every 5th line from center
                var distanceFromCenter = Math.abs(v - centerGridY);
                if (distanceFromCenter % 5 == 0) {
                    c.lineWidth = 2;
                } else {
                    c.lineWidth = 1
                }
                c.beginPath();
                c.moveTo(0, v * gridSpacing * cScale);
                c.lineTo(simWidth * cScale, v * gridSpacing * cScale);
                c.stroke();
            }
            c.setLineDash([0, 0]);
        }
        */
        //  DRAW WORM ---------------------------------------------------------------------
        if (doWorm == true && mrMode == "worm") {
             WormProps.SpaceWorm.draw()
        }
        // DRAW MR. MISTER --------------------------------------------------------------
        if (doFountain == true) {
            MrMr = MisterMister[0];
            MrMr.draw();
        }
        //  DRAW BALLS-------------------------------------------------------------------
        for (i = 0; i < Balls.length; i++) {
			ball = Balls[i];
            if (doTracer == true && ball.tracerBall == true) {
                ball.drawTrace(); 
            }
            ball.draw();
		}
        //  DRAW WORM ---------------------------------------------------------------------
        if (doWorm == true && mrMode != "worm") {
             WormProps.SpaceWorm.draw()
        }
        //  DRAW BUMPERS ----------------------------------------------------------------
        if (showBumpers == true) {
            for (k = 0; k < Bumpers.length; k++) {
            bumpers = Bumpers[k];   
            bumpers.draw();
            }
        }
        //  DRAW BLOWER  ---------------------------------------------------------------     
        if (blowerState >= 1 && blowerState <= 3) {
            var blower = Blower[0];
            blower.draw();
        }

        if (typeof Magnet !== 'undefined' && Magnet.length > 0 && Magnet[0].active) {
            Magnet[0].draw();
        }

        
        // Draw stinker ----------------------------------
        if (typeof Stinker !== 'undefined' && Stinker.length > 0 && Stinker[0].active) {
            Stinker[0].draw();
        }

        // Draw hearts ---------------------------------------------------------------
        if (typeof Hearts !== 'undefined' && Hearts.length > 0) {
            for (let i = 0; i < Hearts.length; i++) {
                Hearts[i].draw();
            }
        }
        
        //  DRAW HUNGRY PUCKS ---------------------------------------------------------------     
        if (showEaters == true) {
            // draw first hungry puck
            var hungryPuck = Hungrypuck[0];
            hungryPuck.draw1();
            
            // draw second hungry puck
            var hungryPuck = Hungrypuck[1];
            hungryPuck.draw2();
        }

        //  DRAW PUCKS ----------------------------------------------------------------         
        for (p=0; p < Puck.length; p++) { 
            var puck = Puck[p];
            // Respect toggles for each puck type
            if (puck.heartBeat === true && !showHeart) continue;
            if (puck.cycle === true && !showCycle) continue;
            if (puck.orbit === true && puck.yinyang !== true && !showOrbit && !showYinYang) continue;
            if (puck.orbit === true && puck.yinyang === true && !showYinYang) continue;
            if (puck.flying === true && !doFlyingPuck && !doFlyingPuck2) continue;
            // Only check showPucks for normal pucks (not heartBeat, cycle, flying, or orbit)
            if (!puck.heartBeat && !puck.cycle && !puck.flying && !puck.orbit && !showPucks) continue;
            puck.draw();
        }
        //  DRAW CORNERS  ---------------------------------------------------------------------
        for (var v = 0; v < Corners.length; v++) {
            corner = Corners[v];
            
            // Skip drawing corners on open sides based on boundary settings
            var shouldSkipCorner = false;
            if (corner.corner == 'northwest') {
                shouldSkipCorner = !doCeiling || !doLeftWall;
            } else if (corner.corner == 'northeast') {
                shouldSkipCorner = !doCeiling || !doRightWall;
            } else if (corner.corner == 'southwest') {
                shouldSkipCorner = !doFloor || !doLeftWall;
            } else if (corner.corner == 'southeast') {
                shouldSkipCorner = !doFloor || !doRightWall;
            }
            
            if (!shouldSkipCorner) {
                corner.draw();
            }
        } 
        if (!doCeiling && !doFloor) {
            var leftXSim = 0;
            var rightXSim = simWidth;
            if (cornerRad > 100 && Array.isArray(Corners) && Corners.length >= 2) {
                var nw = Corners[0]; 
                var ne = Corners[1]; 
                if (nw && typeof nw.pos?.x === 'number') leftXSim = nw.pos.x;
                if (ne && typeof ne.pos?.x === 'number') rightXSim = ne.pos.x;
            }
            // Fill masks beyond the left/right bounds using the same gradient as corners
            if (!cornerFillGradient) { updateCornerFillGradient(); }
            var prevFill = c.fillStyle;
            c.fillStyle = cornerFillGradient;
            var leftPX = Math.max(0, leftXSim * cScale);
            var rightPX = Math.min(simWidth * cScale, rightXSim * cScale);
            // Left mask: from canvas left to left bound
            if (doLeftWall == true && leftPX > 0) {
                c.beginPath();
                c.rect(0, 0, leftPX, simHeight * cScale);
                c.fill();
            }
            // Right mask: from right bound to canvas right
            if (doRightWall == true && rightPX < simWidth * cScale) {
                c.beginPath();
                c.rect(rightPX, 0, (simWidth * cScale - rightPX), simHeight * cScale);
                c.fill();
            }
            c.fillStyle = prevFill;
            c.strokeStyle = 'hsl(0, 0%, 25%)';
            c.lineWidth = 0.015 * cScale;
            c.lineCap = 'butt';
            // Left bound
            if (doLeftWall == true) {
                c.beginPath();
                c.moveTo(leftXSim * cScale, 0);
                c.lineTo(leftXSim * cScale, simHeight * cScale);
                c.stroke();
            }
            // Right bound
            if (doRightWall == true) {
                c.beginPath();
                c.moveTo(rightXSim * cScale, 0);
                c.lineTo(rightXSim * cScale, simHeight * cScale);
                c.stroke();
            }
        }
        if (!doLeftWall && !doRightWall) {
            var topYSim = 0;
            var bottomYSim = simHeight;
            if (cornerRad > 100 && Array.isArray(Corners) && Corners.length >= 2) {
                var nw = Corners[0]; 
                var sw = Corners[2]; 
                if (nw && typeof nw.pos?.y === 'number') topYSim = nw.pos.y;
                if (sw && typeof sw.pos?.y === 'number') bottomYSim = sw.pos.y;
            }
            // Fill masks beyond the top/bottom bounds using the same gradient as corners
            if (!cornerFillGradient) { updateCornerFillGradient(); }
            var prevFill = c.fillStyle;
            c.fillStyle = cornerFillGradient;
            var topPY = Math.max(0, topYSim * cScale);
            var bottomPY = Math.min(simHeight * cScale, bottomYSim * cScale);
            // Top mask: from canvas top to top bound
            if (doCeiling == true && topPY > 0) {
                c.beginPath();
                c.rect(0, 0, simWidth * cScale, topPY);
                c.fill();
            }
            // Bottom mask: from bottom bound to canvas bottom
            if (doFloor == true && bottomPY < simHeight * cScale) {
                c.beginPath();
                c.rect(0, bottomPY, simWidth * cScale, (simHeight * cScale - bottomPY));
                c.fill();
            }
            c.fillStyle = prevFill;
            c.strokeStyle = 'hsl(0, 0%, 25%)';
            c.lineWidth = 0.015 * cScale;
            c.lineCap = 'butt';
            // Top bound
            if (doCeiling == true) {
                c.beginPath();
                c.moveTo(0, topYSim * cScale);
                c.lineTo(simWidth * cScale, topYSim * cScale);
                c.stroke();
            }
            // Bottom bound
            if (doFloor == true) {
                c.beginPath();
                c.moveTo(0, bottomYSim * cScale);
                c.lineTo(simWidth * cScale, bottomYSim * cScale);
                c.stroke();
            }
        }
        /*
        //  DRAW PUCK OVERLAY ----------------------------------------------------------------         
        for (p=0; p < Puck.length; p++) { 
            var puck = Puck[p];
            // Respect toggles for each puck type
            if (puck.heartBeat === true && !showHeart) continue;
            if (puck.cycle === true && !showCycle) continue;
            if (puck.orbit === true && puck.yinyang !== true && !showOrbit && !showYinYang) continue;
            if (puck.orbit === true && puck.yinyang === true && !showYinYang) continue;
            if (puck.flying === true && !doFlyingPuck && !doFlyingPuck2) continue;
            // Only check showPucks for normal pucks (not heartBeat, cycle, flying, or orbit)
            if (puck.flying || puck.flying || puck.orbit || puck.yinyang) continue;
            puck.draw2();

            //  DRAW HUNGRY PUCKS ---------------------------------------------------------------     
            if (showEaters == true) {
                // draw first hungry puck
                var hungryPuck = Hungrypuck[0];
                hungryPuck.draw3();
                
                // draw second hungry puck
                var hungryPuck = Hungrypuck[1];
                hungryPuck.draw3();
            }
        }
        */
        
        // Draw menus in z-order (bottom to top)
        for (const menuName of menuDrawOrder) {
            switch(menuName) {
                case 'colorWheel':
                    animateColorWheelOpacity();
                    drawColorMenu();
                    break;
                case 'physicsMenu':
                    animatePhysicsMenuOpacity();
                    drawPhysicsMenu();
                    break;
                case 'wallsMenu':
                    animateWallsMenuOpacity();
                    drawWallsMenu();
                    break;
                case 'particlesMenu':
                    animateParticlesMenuOpacity();
                    drawParticlesMenu();
                    break;
                case 'gravityMenu':
                    animateGravityMenuOpacity();
                    drawGravityMenu();
                    break;
                case 'respawnMenu':
                    animateRespawnMenuOpacity();
                    drawRespawnMenu();
                    break;
                case 'toysMenu':
                    animateToysMenuOpacity();
                    drawToysMenu();
                    break;
            }
        }
        
        // Draw main menu (always on top) and ellipsis button
        updatePauseButtonBlink(physProps.dt);
        animateMainMenu();
        drawMainMenu();
        drawEllipsisButton();
    }

    //  FPS CALCULATION FUNCTION -------------------------------------------------------------
    function updateFPS() {
        // Only calculate FPS if the counter is visible
        const fpsElement = document.getElementById('fpsCounter');
        if (!fpsElement || !fpsElement.classList.contains('visible')) {
            return;
        }
        
        const currentTime = performance.now();
        const deltaTime = currentTime - fpsCounter.lastTime;
        
        // Add this frame time to our rolling window
        fpsCounter.frameTimes.push(deltaTime);
        
        // Keep only the last maxSamples frame times
        if (fpsCounter.frameTimes.length > fpsCounter.maxSamples) {
            fpsCounter.frameTimes.shift();
        }
        
        // Update the display only occasionally to prevent flickering
        fpsCounter.updateCounter++;
        if (fpsCounter.updateCounter >= fpsCounter.updateInterval) {
            fpsCounter.updateCounter = 0;
            
            // Calculate average frame time over the rolling window
            const avgFrameTime = fpsCounter.frameTimes.reduce((sum, time) => sum + time, 0) / fpsCounter.frameTimes.length;
            
            // Convert to FPS and round to nearest integer
            fpsCounter.displayFps = Math.round(1000 / avgFrameTime);
            
            // Update the display element
            const fpsElement = document.getElementById('fpsCounter');
            if (fpsElement) {
                fpsElement.textContent = `${fpsCounter.displayFps} fps`;
            }
        }
        
        fpsCounter.lastTime = currentTime;
    }

    //  POSITION FPS COUNTER FUNCTION --------------------------------------------------------
    function positionFpsCounter() {
        const canvas = document.getElementById('myCanvas');
        const fpsElement = document.getElementById('fpsCounter');
        if (canvas && fpsElement) {
            const canvasRect = canvas.getBoundingClientRect();
            // Ensure width is auto and no wrapping
            fpsElement.style.width = 'auto';
            fpsElement.style.whiteSpace = 'nowrap';
            // Position so right edge is 10px from canvas right
            const right = canvasRect.right + window.scrollX;
            const bottom = canvasRect.bottom + window.scrollY;
            fpsElement.style.left = (right - fpsElement.offsetWidth - 10) + 'px';
            fpsElement.style.top = (bottom - fpsElement.offsetHeight - 10) + 'px';
        }
    }

    //  MAIN SEQUENCE ----------------------------------------------------------------------------
	firstRun = true;
    initColorWheelOffscreenCanvas(); // Initialize offscreen canvas early
    setupScene();
    positionFpsCounter(); // Position FPS counter initially
    
    function update() {
        // Calculate FPS
        updateFPS();
        
        // Apply gravity rotation if slider is moved from center
        const gx = physProps.gravity.x;
        const gy = physProps.gravity.y;
        const gmag = Math.sqrt(gx * gx + gy * gy);
        
        if (gmag > 0.01 && gravityRotationSpeed !== 0) {
            // Rotate the gravity vector
            const currentAngle = Math.atan2(gy, gx);
            const newAngle = currentAngle + gravityRotationSpeed;
            
            physProps.gravity.x = Math.cos(newAngle) * gmag;
            physProps.gravity.y = Math.sin(newAngle) * gmag;
        }
        
        // Run multiple simulation substeps per frame
        for (let substep = 0; substep < physProps.substeps; substep++) {
            simulate();
        }
        drawEverything();
        requestAnimationFrame(update);
    }
    
    update();

</script> 
</body>
</html>