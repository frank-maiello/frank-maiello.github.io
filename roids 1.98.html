<!-- 
:: R0IDS :: copyright 2025 :: Frank Maiello :: maiello.frank@gmail.com ::

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. In no event shall the author or copyright holders be liable for any claim, damages, or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in, connection with the software or the use of other dealings in the Software.
-->

<!DOCTYPE html>
<html>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<head>
    <title>R0IDS 1.98</title>
    <style>
        body {font-family: verdana; 
            font-size: 14px;
            color: hsl(0, 0%, 89%);
            text-align: center;
            text-shadow: 3px 4px 10px hsl(0, 0%, 0%);
            margin-left: 0px;
            margin-right: 0px;
            padding-left: 5px;
            padding-right: 5px;

        }
        h1 {font-family: verdana; 
            font-size: 12px;
            color: hsl(0, 0%, 65%);
            text-align: center;
            text-shadow: 3px 4px 10px hsl(0, 0%, 0%);
            margin-left: 0px;
            margin-right: 0px;
            padding-left: 0px;
            padding-right: 0px;
            padding-top: 10px;
            display: inline;
        }
        h2 {font-family: verdana; 
            font-size: 0px;
            color: hsl(0, 0%, 65%);
            float: left;
            text-shadow: 3px 4px 10px hsl(0, 0%, 0%);
            margin-left: 0px;
            margin-right: 0px;
            padding-left: 0px;
            padding-right: 0px;
            display: inline;
        }
        .checkbox:hover {opacity: 1}
        .checkbox {-webkit-appearance: none;
            appearance: none;
            padding: 0px;
            border: 0px;
            vertical-align: middle;
            margin-top: 0px;
            margin-bottom: 0px;
            margin-left: 0px;
            margin-right: 5px;
            width: 15px;
            height: 15px;
            border-radius: 10px;
            background-color: hsl(0, 87%, 44%);
            opacity: 0.7;
            border: 2px solid hsl(0, 0%, 83%);
            cursor: pointer;
            box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
        .checkbox:checked {
            background-color: hsl(118, 100%, 33%);
        }
        .radio:hover {opacity: 1}
        .radio {-webkit-appearance: none;
            appearance: none;
            padding: 0px;
            border: 0px;
            vertical-align: middle;
            margin-top: 0px;
            margin-bottom: 0px;
            margin-left: 0px;
            margin-right: 5px;
            width: 15px;
            height: 15px;
            border-radius: 10px;
            background-color: hsl(200, 80%, 27%);
            opacity: 0.7;
            border: 2px solid hsl(0, 0%, 83%);
            cursor: pointer;
            box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
        .radio:checked {
            background-color: hsl(118, 100%, 33%);
        }
        .button:hover {opacity: 1}
        .button {
            appearance: none;
            padding: 0px;
            border: 0px;
            vertical-align: middle;
            margin-top: 0px;
            margin-bottom: 0px;
            margin-left: 0px;
            margin-right: 5px;
            width: 15px;
            height: 15px;
            border-radius: 10px;
            color: black;
            background-color: hsl(0, 80%, 47%);
            opacity: 0.7;
            cursor: pointer;
            box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
        
        .button1:hover {opacity: 1}
        .button1 {
            appearance: none;
            padding: 0px;
            border: 0px;
            vertical-align: middle;
            margin-top: 0px;
            margin-bottom: 0px;
            margin-left: 0px;
            margin-right: 5px;
            width: 15px;
            height: 15px;
            border-radius: 10px;
            color: black;
            background-color: hsl(30, 80%, 47%);
            opacity: 0.7;
            cursor: pointer;
            box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
        </style>
</head>

<body style="background: linear-gradient(to bottom, hsl(0, 0%, 8%) 0%, hsl(0, 0%, 15%) 50%); background-attachment: fixed; margin-left: 0px; margin-right: 0px">
    <div style="display:none;">
        <img id="andromeda" src="andromeda.png">
        <img id="earth" src="planet_disc.png">
    </div>
        <canvas id="myCanvas" style="border:1px solid hsl(0, 0%, 30%); margin-bottom: 3px; padding-left: 1px; padding-right: 1px; margin-left: 1px; margin-right: 1px">
    </canvas>

    <h2><input type="checkbox" title="Roid Fill ON/OFF" id="roidFill" class="checkbox" checked>
    <input type="checkbox" title="Artwork ON/OFF" id="artFill" class="checkbox" checked>
    <input type="checkbox" title="Not a Moon ON/OFF" id="moonFill" class="checkbox" checked>
    <input type="checkbox" title="Princess Mode ON/OFF" id="athena" class="checkbox" unchecked>
    <input type="checkbox" title="Untouchable ON/OFF" id="untouchable" class="checkbox" unchecked>
    <input type="radio" title="Auto Roids (default)" name="spawnType" id="auto" class="radio" checked>
    <input type="radio" title="Polkadot Roids" name="spawnType" id="polkadot" class="radio">
    <input type="radio" title="Globe Roids" name="spawnType" id="globe" class="radio">
    <input type="radio" title="Eyeball Roids" name="spawnType" id="eyeball" class="radio">
    <input type="radio" title="Tiny Bubbles" name="spawnType" id="suds" class="radio">
    <input type="button" value="-" title="Decrease Wave Level" id="waveMinusButton" class="button1">
    <input type="button" value="+" title="Increase Wave Level" id="wavePlusButton" class="button1">
    <input type="button" value="-" title="Decrease Torpedo Level" id="torpedoMinusButton" class="button">
    <input type="button" value="+" title="Increase Torpedo Level" id="torpedoPlusButton" class="button"></h2>
    <script>

    //  CANVAS SETUP AND SCALING  ------------------   
    function resizeCanvas() {
        canvas = document.getElementById("myCanvas");
        canvas.width = window.innerWidth - 15;
        canvas.height = window.innerHeight - 40;
        canvas.style.cursor = "pointer";
        c = canvas.getContext("2d");

        simMinWidth = 2;
        cScale = Math.min(canvas.width, canvas.height) / simMinWidth;
        simWidth = canvas.width / cScale;
        simHeight = canvas.height / cScale;

        offscreenFlashCanvas = document.createElement('canvas');
        offscreenFlashCanvas.width = 0.4 * cScale; 
        offscreenFlashCanvas.height = 0.4 * cScale; 
        flashC = offscreenFlashCanvas.getContext('2d');

        offscreenStarfieldCanvas = document.createElement('canvas');
        offscreenStarfieldCanvas.width = canvas.width; 
        offscreenStarfieldCanvas.height = canvas.height; 
        starfieldC = offscreenStarfieldCanvas.getContext('2d');

        offscreenNoMoonCanvas = document.createElement('canvas');
        offscreenNoMoonCanvas.width = canvas.width; 
        offscreenNoMoonCanvas.height = canvas.height; 
        noMoonC = offscreenNoMoonCanvas.getContext('2d');

        offscreenRoketCanvas = document.createElement('canvas');
    
        andromedaImage = document.getElementById('andromeda');
        earthImage = document.getElementById('earth');

        defineOffscreenRoket();
    }
    //  RESIZE CANVAS RIGHT AWAY  ---------
    resizeCanvas();
    //  RESIZE CANVAS AND CREATE NEW STARFIELD ON RESIZE  ---------
    window.addEventListener("resize", resizeCanvas);
    window.addEventListener("resize", makeStars);
    window.addEventListener("resize", defineOffscreenStarfield);

    //  PAGE BUTTONS  -------------------
    document.getElementById("torpedoMinusButton").addEventListener("click", function() {
        if (weaponLevel > 0) {
            weaponLevel -= 1;
            score += 20000 * (weaponLevel + 1);
            
        }
    });
    document.getElementById("torpedoPlusButton").addEventListener("click", function() {
        if (weaponLevel < maxWeaponLevel) {
            weaponLevel += 1;
            score -= 20000 * weaponLevel;;
        }
    });
    document.getElementById("waveMinusButton").addEventListener("click", function() {
        if (wave > 0) {
            if (wave > 1) {
                wave -= 1;
            }
            score -= 20000 * wave;
            if (score < 0) {
                score = 0;
            }
        }
    });
    document.getElementById("wavePlusButton").addEventListener("click", function() {
        spawnCycle += 1;
        if (spawnCycle > 8) {
            spawnCycle = 1;
        }
        wave += 1;
        score += 20000 * (wave - 1);
    });
    document.getElementById("untouchable").addEventListener("click", function() {
        untouchable = !untouchable;
    });

    //  KEYBOARD CONTROL  ---------------------
    document.addEventListener("keydown", keyDownHandler, false);
    document.addEventListener("keyup", keyUpHandler, false);
    //  KEY DOWN  ----------
    function keyDownHandler(u) {
        //  LEFT  ---------
        if (u.key == "a" || u.key == "A" || u.key == "ArrowLeft") {
            leftPressed = true;
        //  RIGHT  ---------
        } else if (u.key == "d" || u.key == "D" || u.key == "ArrowRight") {
            rightPressed = true;
        }  
        //  UP  ---------
        if (u.key == "ArrowUp" || u.key == "w" || u.key == "W") {
            thrustKey = true;
        }
        //  DOWN  ---------
        if (u.key == " " || u.key == 's' || u.key == 'S' || u.key == "ArrowDown") { 
            spawnTorpedoKey = true;
        //  SLOW DOWN  -------
        }if (u.key == "z" || u.key == "Z") {
            timeWarp = true;  
        }
        //  SHIELDS  -------
        if ((u.key == "x" || u.key == "X") && shieldLevel > 0) {
            shieldsUp = true;
            shieldKey = true;
        }
        //  START GAME  ---------
        if (gameIdle == true && (leftPressed || rightPressed || thrustKey || spawnTorpedoKey)) {
            gameIdle = false;
            gameOn = true;
            gameStarting = true;
            gameStartTime = Date.now();
            torpedosFired = 0;
            torpedosHit = 0;
        }
        //  RESTART GAME  -------
        if (gameOn != true && lives < 1 && (u.key == "R" || u.key == 'r')) {
            setupScene();
        }
        //  PAUSE  -------
        //if (u.key == "p" || u.key == "P") {
        //    userPause = !userPause;
        //}
        //  SPAWN ALIEN  -------
        //if (u.key == "q" || u.key == "Q") {
        //    spawnSoloAlien(new Vector2(0.5 * simWidth, 0.2 * simHeight));
        //}  
    }
    //  KEY UP  ----------
    function keyUpHandler(u) {
        //  LEFT  ---------
        if (u.key == "a" || u.key == "A" || u.key == "ArrowLeft") {
            leftPressed = false;
        //  RIGHT  ---------
        } else if (u.key == "d" || u.key == "D" || u.key == "ArrowRight") {
            rightPressed = false;
        } 
        //  UP  ---------
        if (u.key == "ArrowUp"  || u.key == "w" || u.key == "W") {
            thrustKey = false;
        }
        //  DOWN  ---------
        if (u.key == " " || u.key == 's' || u.key == 'S' || u.key == "ArrowDown") {
            spawnTorpedoKey = false;
        }
        //  SPEED BACK UP  -------
        if (u.key == "z" || u.key == "Z") {
            timeWarp = false;
        }
        //  SHIELDS  -------
        if (u.key == "x" || u.key == "X") {
            shieldsUp = false;
            shieldKey = false;
        }
    }

    //  SETUP SCENE ---------------------
    function setupScene() {
        //  INITIALIZE ARRAYS  ----------
        StarField = [];
        Roket = [];
        targetImage = [];
        Roids = [];
        SortedRoids = [];
        Torpedo = [];
        Exhaustlets = [];
        RetroLets = [];
        RoketDebris = [];
        RoidDebris = [];
        Pulse = [];
        CopyVel = [];
        Pusher = [];
        Scorer = [];
        Spawnlets = [];
        Enemy = [];
        Alien = [];
        EnemyDebris = [];
        MuzzleFlash = [];
        startReentryPos = [];
        WarpIn = [];
        Prize = [];
        Bomb = [];
        RingOfFire = [];
        Moon = [];
        PacMan = [];
        TrashTalk = [
            'BOOM!', 'KABOOM!', 'BOOYAH!', 'HAHAHA!!', 'HAH HAAAA!', 
            'PFFT...', 'TRY HARDERRRR', 'WINNER!', 'YOU LOSE!', 'A HIT!!', 
            'SO LAAAAME!!', 'YO MOMMA!', 'MERDE!!!', 'SEE YAAA!', 'BAM!', 
            'DE NADA!', 'PUHLEASE', 'LATER!', 'CIAO!', 'ADIOS!', 
            'TOO EASY', '$*@*&%#!!!', 'TSK TSK', 'DONE!', 'DUSTED!',
            'WHAM-O!', 'GOTCHA!', 'BUH-BYE!', 'BYE BYE!', 'WHY EVEN?',
            'WHY TRY?', 'YOU OK??', 'OK, LOSER', 'LOSER!', 'YOU LOSE',
            'I WIN!!', 'YUP!!!', 'NOPE!', 'DENIED!', 'NICE!!',
            'OUCH!!', 'THAT HURT?', 'KA-POW!!', '!!!!!!!', 'TOO BAD',
            'SO SAD', 'OH, YEAH!!', 'GET SOME!', 'POOF!', 'BOOF!',
            'EAT IT', 'HOSER', 'HEHEHE', 'BANG!!', 'BYEEEE!!',
            'TSCHUSS!', 'NEWB', 'AWWWWW', 'YAY ME!', 'GO ALIENS!',
            'YOU SUCK', 'SUCKER', 'SUCK IT', 'POP!!', 'BINGO!!',
            'GONE!!', 'TAKE THAT!', 'HAPPY?', 'GIVE UP', 'DENIED!',
            'I RULE!!', 'UM... NO', 'GOTTA GO!', 'SHAME...', 'YES!!!',
            'I H8 U', 'ET VOILA!', 'BONJOUR!', 'TAKE THAT!', 'OLE!!',
            'CHUMP', 'YA BLIND?', 'GO AWAY', 'WHOO HOO!', 'SWEET!',
            'SO HAPPY', 'BONGGGG', 'PEST', 'SHOO!',
            'SUCKS 2B U', 'SCHLECT', 'BAD SHOW', 'HAR HAR HAR', 'BOOSH!',
            'YOUR MOM', 'DAYAMN!', 'DAMN!', 'AW SHUCKS', 'SORRY!',
            'SORRY?', 'WAZZUUUP?!', 'YO!!!', 'TWAT', 'WANKER!!', 
            'JACKASS', 'ASS', 'WHASSUP?', 'THERE!', 'TASTY!',
            'TOSSER', 'KLUTZ', 'ALIENS RULE!', 'UFOs RULE!', 'CALL SETI!',
            'SHAKA LAKA!', 'PISS OFF!', 'SCAT!', 'BE GONE!', 'OUTTA HERE!',
            'SUCKA!!', 'DING!!', 'SMELL THAT?', "I'M BAAACK!", "S'UP??"
        ];
        SmackTalk = [ 
            'DAMN ITTT!!!', 'YO MOMMAAAA!!', 'MERDE!!', '$*@*&~%#^!!',  
            'OUCH!!', 'OH THAT HURT!', 'EAT ME!!', 'JERK!!', 
            'YOU SUCK!!', 'OH, NOOOO!!', 'SUCK IT!!', 'HAPPY NOW?', 'DIIIICK!!', 
            'I H8 YOU!', 'EXCUSE ME?!', 'NO FAIR!!', 'SHIIIIIT!!',
            'WHAAAAAAT?!', 'TWAAAAT!!', 'WANKERRR!', 'JACKAAAASS!!', 'ASSHOLE!!', 
            'NOOOOOO!', 'JERKOFF!', 'PISS OFF!!', 'BASTARDO!!',
            'DAMN IT!', 'REALLY?!', 'UH, OH...', 'DOHHHHH!', "I'LL BE BACK!!",
            "I'LL GET YOU!", 'AAAAAAAH!!', 'HELLLLLP!!', 'AGAIN??!!',
            'FAAAAAK!!', 'FARK YOU!!', 'FARKIN ASS!', 'DIIIICK!!', 
            'BACK SOON!', 'DAMN UUUUU!', 'HATED IT!', 'ZERO STARS!!',
            'OH JUST GREAT', 'MY PAAAANTS!!', 'ELIZABETH!!', 'SAVE ME!!',
            'SAY WHAT?!', "I'LL GET YOU!", 'AMATEUR!!', 'I H8 SPACE!', 
            'SPACE SUCKS!!', 'YOU SUUUCK!', 'THIS SUUUCKS!', 'ASSHOLE!!',
            'DINGUUUS!!', 'YOUR MOM!!', 'GO COWBOYS!!', 'GO METS!!',
            'NEXT TIME!!', 'WATCH UR 6!', "EGGMEN RULE!!", 'WHEEEEE!!!',
            'MY SHORTS!!', 'EFF YOU!!', 'THIS BLOWS!!', 'GET BENT!!',
            'WHAT A VIEW!!', 'DAMIIIITT!!', 'MY BALLLLS!!', 'OH... YOU',
            'IN SPACE, NOBO-', "NOW I'M MAD", "OH IT'S ON!", 'GET READY!!',
            'NEXT TIIIIME!!', 'LATER, DICK!!', "U WON'T LAST!", 'IMPOSSIBLE!!',
            "IT CAN'T BE", 'CUT IT OUT!!', 'PLEASE STOP!!', 'MOMMYYYYY!!',
            'MY SHIP!!!', 'YOU OWE ME!!', 'OWE U ONE!!', 'UR DONE!!', 'UR FIRED!!',
            'KNOCK KNOCK!!', 'BLASPHEMY!!', 'OH FFS...', 'OH FML...', 'WHAAAAAA!!',
            'TAX YA LATER!!', 'MY RIDE!!!', 'MY SPACESHIP!!', 'MY STUFF!!!',
            'MOTHERFUUU...', 'GOD DAMN IT!!', 'JESUUUUS!!', 'HATE YOU!!',
            'OY VEY!!', 'BORED YET?!', 'MY PROBE!!!', 'LOOK @ ME!!', "I'M ON PTO!",
            'BOORRREDDD!', 'U BORE ME!!', 'K, U GOT ME', 'K...', 'OKAY....',
            'AGAIN??!!!', 'MAAAAAAN!', 'CRACKHEAD!!', 'PISSUPAROPE!', 'EAT SOUP!!',
            'YEAH, GREAT...', 'NOT HAPPY!!!', 'CHEATER!!', 'FINE!!!!',
            'EAT OUT MORE!', 'TOUCH GRASS!!', 'THINK MINK!!', "EAT @ JOE'S",
            'FRRAAAAAANKK', "I'M PISSED!!", 'FUNNY, HUH?', "WE'LL SEE!!", 
            'AH, SHADDUP!', 'ENJOY IT!!', 'YOU BUSTA!!', 'NOT GOOD!!', 'GOOD ONE!!',
            'MY SAUCER!!!', 'YEOWWWWW!!!', 'MY KNOB!!!', "YOU'LL PAY!!", 'NOT COOL!!!',
            'MY GLASSES!!!', 'MY EYES!!!', 'WHY WHY WHY?', 'WHAT ME WORRY?', 'SCHEISSEEE!!!',
            'MALAKAAAA!!!', 'DOOFUUUUUS!!!', 'MY NOSE!!!', 'MY PHONE!!!', "I'M SORRY!!!",
            'YOU EVEN LIFT?!', 'LOOK AT ME!!', 'I QUIT!!', 'I RESIGN!!', "I'VE HAD IT!!",
            'KISS MY ASS!!', "I'M DONE!!", 'GET A HOBBY!!', 'READ A BOOK!!',
            'BUTTHEAD!!', 'SCHEISSKOPF!!', 'EAT ROIDS!!!', "I'M FLYIIING!!", 'GO EAGLES!!!',
            'GO BIRDS!!!', 'DALLAS SUCKS!!', 'JUST... GREAT', 'I SAID, BI...',
            'CALL 9-1-1!!', 'BEER ME!!!', 'I GIVE UP!!', 'WHAT GIVES?!', 'WHYYYYYY?!',
            "THAT'S NO MOON"
        ];

        //  INITIALIZE BOOLEANS  ----------
        gameOn = false;
        gameIdle = true;
        gameOver = false;
        gameBootTime = Date.now();
        userPause = false;
        gameStarting = false;
        pickFallingStar = 0;
        spawnTorpedoKey = false;
        bombsAway = false;
        rightPressed = false;
        leftPressed = false;
        upPressed = false;
        downPressed = false;
        thrustKey = false;
        tumbling = false;
        debrisMade = false;
        debrisPassOne = true
        spawning = false;
        firstSpawnPass = true; 
        secondSpawnPass = true;
        animateWave = false;
        dropOnce = true;
        sayByeBye = false; 
        firstPulse = true;
        poofPrize = false;
        wavingForward = true;
        timeWarp = false;
        shieldsUp = false;
        firstRetroPass = true;
        untouchable = false;

        //  INITIALIZE ALPHA VARIABLES  ----------
        lastSide = '';
        trash = '';
        spawnMode = '';
        
        //  INITIALIZE NUMERICAL VARIABLES  ----------
        lives = 3;
        dT = 1/60;
        startingRoidLimit = 6;
        wave = 0;
        weaponLevel = 0;
        maxWeaponLevel = 9;
        minWeaponLevel = 0;
        shieldLevel = 0;
        shieldKey = false;

        lastRoidSpawnTime = 0;
        bSide = 0;
        spawnCounter = 0; 
        interference = 0;
        score = 0;
        streak = 1;
        hitPct = 100;
        waveNoBday = 0;
        dimmer = 0;
        nSpawn = 1;
        spawnCycle = 0;
        programStartTime = Date.now();
        gameStartTime = 0;
        gameOverTime = 0;
        torpedosFired = 0;
        torpedosHit = 0;
        rainbowTorpedoIndex = 0;
        wagTorpedoIndex = 0;
        totalTravelX = 0;
        totalTravelY = 0;
        earthrise = 0;
        earthriseAdj = 2 * simHeight;
        earthSpinner = 0;
        imageCenterY = 0;

        col = 0;
        blinkyCycle = 0;
        eyeLiftL = 0;
        eyeLiftR = 0;
        eyeRoll = 0;
        lol = 0;
        lolX = 0;
        lolStart = 0;
        lolTime = 0;
        lolAdjY = 1;
        lolAdjX = 1;
        toothAdj = 0;
        knobLight = 90;
        leftArmAngle = Math.PI;
        rightArmAngle = 0;
        leftLegAngle = 0.8 * Math.PI;
        rightLegAngle = 0.2 * Math.PI;

        f = 0;
        knobOn = true;
        needNewCycleCounter = false;
        knobCounter = 0;
        knobOffCycles = 0;
        enemyShotBirthday = 0;
        bbl = 0;
        enemyCycling = true;
        nextWait = 0;
        prizeTimer = 0;
        poofStars = 1;
        poofPrizeDate = 0;
        textPulse = 0;
        bombDirShake = 0;
        bombBlastAngle = null;
        radarPulser = 0;

        c.shadowBlur = 0;

        rudolph = 0;
        rudolphIntensity = 0;
        disco = 0;
    
        cursorX = 0;
        cursorY = 0;
        lastMouseX = 0;
        lastMouseY = 0;
        
        //  TITLE SCREEN VARIABLES  ---------
        bob = 0;
        orbit = 0;
        titleLightness = 0;
        titleBallRadius = 0.25;
        titleBallX = 0.05 * simWidth;
        titleBallY = 0.05 * (-0.5 + Math.random());
        titleBallYIndex = 0.005 * (-0.5 + Math.random());
        titleBallHue = 360 * Math.random();
        titleBallSaturation = 20 + 60 * Math.random();
        titleBallLightness = 40 + 40 * Math.random();
        titleBallDir = 1;

        titleLightness2 = 0;
        titleBallRadius2 = 0.25;
        titleBallX2 = 0.95 * simWidth;
        titleBallY2 = 0.05 * (-0.5 + Math.random());
        titleBallYIndex2 = 0.005 * (-0.5 + Math.random());
        titleBallHue2 = 360 * Math.random();
        titleBallSaturation2 = 20 + 60 * Math.random();
        titleBallLightness2 = 40 + 40 * Math.random();
        titleBallDir2 = -1;

        titleLightness3 = 0;
        titleBallRadius3 = 0.25;
        titleBallX3 = 0.2 * simWidth + 0.6 * Math.random() * simWidth;
        titleBallY3 = 0.9 * simHeight;
        titleBallXIndex3 = 0.005 * (-0.5 + Math.random());
        titleBallHue3 = 360 * Math.random();
        titleBallSaturation3 = 20 + 60 * Math.random();
        titleBallLightness3 = 40 + 40 * Math.random();
        titleBallDir3 = -1;

        //  SPAWN INITIAL OBJECTS  ----------
        defineOffscreenRoket()
        spawnRoket();
        makeStars();
        defineOffscreenStarfield();
        defineOffscreenFlash();
        spawnMoon();
    }

    //  BASIC FUNCTIONS --------------------
    function drawCircle(posX, posY, radius) {
        c.beginPath();			
        c.arc(posX, posY, radius, 0, 2 * Math.PI) 
        c.closePath();
    }
    function offscreenDrawCircle(posX, posY, radius) {
        flashC.beginPath();			
        flashC.arc(posX, posY, radius, 0, 2 * Math.PI) 
        flashC.closePath();
    }
    function offscreenRoketDrawCircle(posX, posY, radius) {
        roketCtx.beginPath();			
        roketCtx.arc(posX, posY, radius, 0, 2 * Math.PI) 
        roketCtx.closePath();
    }
    function drawHorizEllipse(x, y, radius) {
        c.beginPath();			
        c.ellipse(x, y, radius, 0.35 * radius, 0, 0, 2 * Math.PI) 
        c.closePath();
    }
    function drawCustomEllipse(x, y, radius, scaleY) {
        c.beginPath();			
        c.ellipse(x, y, radius, scaleY * radius, 0, 0, 2 * Math.PI) 
        c.closePath();
    }
    function drawCustomEllipse2(x, y, radiusX, radiusY) {
        c.beginPath();			
        c.ellipse(x, y, radiusX, radiusY, 0, 0, 2 * Math.PI) 
        c.closePath();
    }
    function drawHorizEllipse2(x, y, radius) {
        c.beginPath();			
        c.ellipse(x, y, radius, 0.35 * Enemy[0].radius * cScale, 0, 0, 2 * Math.PI) 
        c.closePath();
    }
    function drawVertEllipse(x, y, radius) {
        c.beginPath();			
        c.ellipse(x, y, 0.7 * radius, radius, 0, 0, 2 * Math.PI) 
        c.closePath();
    }
    function rads(theta) {
        return theta * Math.PI/180;
    }
    function cX(pos) {
        return pos.x * cScale;
    }
	function cY(pos) {
        return pos.y * cScale;
    }
    function drawArrow(posX, posY, angle, radius) {
        var arrow = {
            radius: radius,
            // 1 bottom right
            a1cos: Math.cos(rads(281.86) + angle),
            a1sin: Math.sin(rads(281.86) + angle),
            r1: 0.5109,
            // 2 right inside corner
            a2cos: Math.cos(rads(43.6) + angle),
            a2sin: Math.sin(rads(43.6) + angle),
            r2: 0.1450,
            // 3 right tip
            a3cos: Math.cos(rads(16.86) + angle),
            a3sin: Math.sin(rads(16.86) + angle),
            r3: 0.3448,
            // 4 top
            a4cos: Math.cos(rads(90) + angle),
            a4sin: Math.sin(rads(90) + angle),
            r4: 0.5,
            // 5 left tip
            a5cos: Math.cos(rads(163.14) + angle),
            a5sin: Math.sin(rads(163.14) + angle),
            r5: 0.3448,
            // 6 left inside corner
            a6cos: Math.cos(rads(136.4) + angle),
            a6sin: Math.sin(rads(136.4) + angle),
            r6: 0.1450,
            // 7 bottom left
            a7cos: Math.cos(rads(258.14) + angle),
            a7sin: Math.sin(rads(258.14) + angle),
            r7: 0.5109,
            // 8 bottom center
            a8cos: Math.cos(rads(270) + angle),
            a8sin: Math.sin(rads(270) + angle),
            r8: 0.5
        }

        c.beginPath();
        c.moveTo((posX + arrow.radius * arrow.r1 * arrow.a1cos) * cScale,
            (posY - arrow.radius * arrow.r1 * arrow.a1sin) * cScale);
        c.lineTo((posX + arrow.radius * arrow.r2 * arrow.a2cos) * cScale,
            (posY - arrow.radius * arrow.r2 * arrow.a2sin) * cScale);
        c.lineTo((posX + arrow.radius * arrow.r3 * arrow.a3cos) * cScale,
            (posY - arrow.radius * arrow.r3 * arrow.a3sin) * cScale);
        c.lineTo((posX + arrow.radius * arrow.r4 * arrow.a4cos) * cScale,
            (posY - arrow.radius * arrow.r4 * arrow.a4sin) * cScale);
        c.lineTo((posX + arrow.radius * arrow.r5 * arrow.a5cos) * cScale,
            (posY - arrow.radius * arrow.r5 * arrow.a5sin) * cScale);
        c.lineTo((posX + arrow.radius * arrow.r6 * arrow.a6cos) * cScale,
            (posY - arrow.radius * arrow.r6 * arrow.a6sin) * cScale);
        c.lineTo((posX + arrow.radius * arrow.r7 * arrow.a7cos) * cScale,
            (posY - arrow.radius * arrow.r7 * arrow.a7sin) * cScale);
        c.lineTo((posX + arrow.radius * arrow.r8 * arrow.a8cos) * cScale,
            (posY - arrow.radius * arrow.r8 * arrow.a8sin) * cScale);
        c.closePath();
    }

    //  DRAW STAR  ------------------
    function drawStar(pos, radius, angle) {
        var drawX = pos.x * cScale;
        var drawY = pos.y * cScale;
        var starWedges = Math.PI / 5;
        var innerRadius = 0.3 * radius * cScale;
        var outerRadius = 0.6 * radius * cScale;
        c.beginPath();
        for (var v = 0; v < 10; v++) {
            let theta = angle + v * starWedges;
            let r = (v % 2 == 0) ? innerRadius : outerRadius;
            let x = drawX + r * Math.cos(theta);
            let y = drawY + r * Math.sin(theta);
            if (v == 0) {
                c.moveTo(x, y);
            } else {
                c.lineTo(x, y);
            }
        }
        c.closePath();
    }

    //  GET THE DANGLE FROM THE ANGLE ------------------
    function getDangle(enemyX, enemyY, roketX, roketY) {
        // top left ---------- sector #3
        if (roketX < enemyX && roketY > enemyY) {
            var dangle = Math.PI + (Math.atan(Math.abs(roketY - enemyY) / (roketX - enemyX)));
        } 
        // top right ---------- sector #2
        if (roketX < enemyX && roketY < enemyY) {
            var dangle = Math.PI - (Math.atan(Math.abs(roketY - enemyY) / (roketX - enemyX)));
        }
        // bottom left ---------- sector #4
        if (roketX > enemyX && roketY > enemyY) {
            var dangle = (Math.atan(Math.abs(roketY - enemyY) / (roketX - enemyX)));
        } 
        // bottom right ---------- sector #1
        if (roketX > enemyX && roketY < enemyY) {  
            var dangle = -(Math.atan(Math.abs(roketY - enemyY) / (roketX - enemyX)));
        }
        return dangle; 
    }

    // Quaternion helpers to avoid gimbal lock when integrating orientation
    function quatFromEuler(yaw, pitch, roll) {
        // yaw (Z), pitch (X), roll (Y) — same convention as earlier Euler usage
        const cy = Math.cos(yaw * 0.5);
        const sy = Math.sin(yaw * 0.5);
        const cp = Math.cos(pitch * 0.5);
        const sp = Math.sin(pitch * 0.5);
        const cr = Math.cos(roll * 0.5);
        const sr = Math.sin(roll * 0.5);
        // q = q_yaw * q_pitch * q_roll
        const w = cy * cp * cr + sy * sp * sr;
        const x = cy * sp * cr + sy * cp * sr;
        const y = cy * cp * sr - sy * sp * cr;
        const z = sy * cp * cr - cy * sp * sr;
        return { w: w, x: x, y: y, z: z };
    }

    function quatMultiply(a, b) {
        return {
            w: a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z,
            x: a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y,
            y: a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x,
            z: a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w
        };
    }

    function quatNormalize(q) {
        const len = Math.sqrt(q.w*q.w + q.x*q.x + q.y*q.y + q.z*q.z) || 1.0;
        q.w /= len; q.x /= len; q.y /= len; q.z /= len;
        return q;
    }

    function quatRotateVec(q, vx, vy, vz) {
        // Standard, stable quaternion-vector rotation using cross products:
        // t = 2 * cross(q.xyz, v)
        // v' = v + q.w * t + cross(q.xyz, t)
        const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
        // cross(q.xyz, v)
        const cx = qy * vz - qz * vy;
        const cy = qz * vx - qx * vz;
        const cz = qx * vy - qy * vx;
        const tx = 2 * cx;
        const ty = 2 * cy;
        const tz = 2 * cz;
        // cross(q.xyz, t)
        const c2x = qy * tz - qz * ty;
        const c2y = qz * tx - qx * tz;
        const c2z = qx * ty - qy * tx;
        return {
            x: vx + qw * tx + c2x,
            y: vy + qw * ty + c2y,
            z: vz + qw * tz + c2z
        };
    }

    //  Catmull-Rom Spline helper
    function catmullRomSpline(points, tension = 0.5, numSegments = 16) {
        let splinePoints = [];
        for (let i = 0; i < points.length - 1; i++) {
            let p0 = points[i === 0 ? i : i - 1];
            let p1 = points[i];
            let p2 = points[i + 1];
            let p3 = points[i + 2 < points.length ? i + 2 : i + 1];
            for (let t = 0; t < numSegments; t++) {
                let s = t / numSegments;
                let s2 = s * s;
                let s3 = s2 * s;
                let x = 0.5 * ((2 * p1.x) +
                    (-p0.x + p2.x) * s +
                    (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * s2 +
                    (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * s3);
                let y = 0.5 * ((2 * p1.y) +
                    (-p0.y + p2.y) * s +
                    (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * s2 +
                    (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * s3);
                splinePoints.push({ x, y });
            }
        }
        splinePoints.push(points[points.length - 1]);
        return splinePoints;
}

    function mouthEdgeY(x) {
        const dx = (x - mouthCenterX) / mouthRadiusX;
        if (Math.abs(dx) > 1) return mouthCenterY; // outside ellipse
        return mouthCenterY - Math.sqrt(1 - dx * dx) * mouthRadiusY;
    }

    function minImageDistance(ax, ay, bx, by, simWidth, simHeight) {
        let dx = ax - bx;
        let dy = ay - by;
        // Wrap distances to minimum image
        if (dx > simWidth / 2) dx -= simWidth;
        if (dx < -simWidth / 2) dx += simWidth;
        if (dy > simHeight / 2) dy -= simHeight;
        if (dy < -simHeight / 2) dy += simHeight;
        return { dx, dy, dist: Math.sqrt(dx*dx + dy*dy) };
    }

    //  DRAW POLKADOTS ON ROIDS  ------------------
    function drawPolkadots(cx, cy, radius, maxDots, dotRadiusFrac, roidHue, 
    roidSaturation, polkaPulseLightness, roidLightness, seed, randomNo, spinAngle = 0, flashPolkadots) {
        let dotHue;
        let flashAmount = 0;
        if (flashAmount > 0) {
            dotHue = 0;
        } else if (randomNo < 0.5) {
            dotHue = (roidHue + 90) % 360;
        } else {
            dotHue = (roidHue - 90) % 360;
        }

        if (typeof flashPolkadots === 'number') {
            flashAmount = Math.max(0, Math.min(1, flashPolkadots / 0.5));
        } else if (flashPolkadots === true) {
            flashAmount = 1;
        }
        
        const goldenAngle = Math.PI * (3 - Math.sqrt(5));
        const dotAngularRadius = Math.asin(dotRadiusFrac);

        function seededRand(seed) {
            let s = seed || 1;
            return function() {
                s = Math.imul(48271, s) & 0x7fffffff;
                return s / 0x7fffffff;
            };
        }

        let phase = ((seed || 1) % 10000) / 10000 * 2 * Math.PI;

        // Try from maxDots down to 1, return the first successful non-overlapping set
        for (let dotCount = maxDots; dotCount > 0; dotCount--) {
            let rand = seededRand(seed || 1); // re-seed for each attempt
            // Shuffle indices
            let indices = Array.from({length: dotCount}, (_, i) => i);
            for (let i = dotCount - 1; i > 0; i--) {
                let j = Math.floor(rand() * (i + 1));
                [indices[i], indices[j]] = [indices[j], indices[i]];
            }
            let placed = [];
            let success = true;
            for (let n = 0; n < dotCount; n++) {
                let i = indices[n];
                let y = 1 - (i + 0.5) / dotCount * 2;
                let rxy = Math.sqrt(1 - y * y);
                let theta = goldenAngle * i + phase;
                let x = Math.cos(theta) * rxy;
                let z = Math.sin(theta) * rxy;
                // Rotate (x, y) about z-axis by spinAngle (group rotation)
                let xRot = x * Math.cos(spinAngle) - y * Math.sin(spinAngle);
                let yRot = x * Math.sin(spinAngle) + y * Math.cos(spinAngle);
                x = xRot;
                y = yRot;
                // Strict overlap check
                let ok = true;
                for (let j = 0; j < placed.length; j++) {
                    let p = placed[j];
                    let dot = x * p.x + y * p.y + z * p.z;
                    let angDist = Math.acos(Math.max(-1, Math.min(1, dot)));
                    if (angDist < 2 * dotAngularRadius) {
                        ok = false;
                        break;
                    }
                }
                if (!ok) {
                    success = false;
                    break;
                }
                placed.push({x, y, z});
            }
            if (success) {
                // Draw all placed dots
                for (let k = 0; k < placed.length; k++) {
                    let {x, y, z} = placed[k];
                    let px = cx + x * radius;
                    let py = cy + y * radius;
                    // Tangent vectors for rim
                    let upx = 0, upy = 1, upz = 0;
                    if (Math.abs(y) > 0.99) { upx = 1; upy = 0; upz = 0; }
                    let t1x = upy * z - upz * y;
                    let t1y = upz * x - upx * z;
                    let t1z = upx * y - upy * x;
                    let t1len = Math.sqrt(t1x * t1x + t1y * t1y + t1z * t1z);
                    t1x /= t1len; t1y /= t1len; t1z /= t1len;
                    let t2x = y * t1z - z * t1y;
                    let t2y = z * t1x - x * t1z;
                    let t2z = x * t1y - y * t1x;
                    let t2len = Math.sqrt(t2x * t2x + t2y * t2y + t2z * t2z);
                    t2x /= t2len; t2y /= t2len; t2z /= t2len;

                    // Only draw dots whose centers are on the front hemisphere
                    if (z > 0) {
                        let rim3D = [];
                        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                        for (let j = 0; j < 32; j++) {  // 32 rimSteps
                            let psi = (2 * Math.PI * j) / 32;
                            let rimX = x * Math.cos(dotAngularRadius) + t1x * Math.sin(dotAngularRadius) * Math.cos(psi) + t2x * Math.sin(dotAngularRadius) * Math.sin(psi);
                            let rimY = y * Math.cos(dotAngularRadius) + t1y * Math.sin(dotAngularRadius) * Math.cos(psi) + t2y * Math.sin(dotAngularRadius) * Math.sin(psi);
                            let rimZ = z * Math.cos(dotAngularRadius) + t1z * Math.sin(dotAngularRadius) * Math.cos(psi) + t2z * Math.sin(dotAngularRadius) * Math.sin(psi);
                            // Normalize to sphere surface
                            let len = Math.sqrt(rimX * rimX + rimY * rimY + rimZ * rimZ);
                            rimX /= len; rimY /= len; rimZ /= len;
                            var pxr = cx + rimX * radius;
                            var pyr = cy + rimY * radius;
                            rim3D.push([pxr, pyr]);
                            if (pxr < minX) minX = pxr;
                            if (pxr > maxX) maxX = pxr;
                            if (pyr < minY) minY = pyr;
                            if (pyr > maxY) maxY = pyr;
                        }

                        // Improved filtering: Use PCA to measure major/minor axes of the rim ellipse
                        // Compute centroid
                        let sumX = 0, sumY = 0;
                        for (let j = 0; j < rim3D.length; j++) {
                            sumX += rim3D[j][0];
                            sumY += rim3D[j][1];
                        }
                        let meanX = sumX / rim3D.length;
                        let meanY = sumY / rim3D.length;
                        // Compute covariance matrix
                        let covXX = 0, covYY = 0, covXY = 0;
                        for (let j = 0; j < rim3D.length; j++) {
                            let dx = rim3D[j][0] - meanX;
                            let dy = rim3D[j][1] - meanY;
                            covXX += dx * dx;
                            covYY += dy * dy;
                            covXY += dx * dy;
                        }
                        covXX /= rim3D.length;
                        covYY /= rim3D.length;
                        covXY /= rim3D.length;
                        // Eigenvalues of 2x2 covariance matrix give squared axis lengths
                        let trace = covXX + covYY;
                        let det = covXX * covYY - covXY * covXY;
                        let lambda1 = trace / 2 + Math.sqrt((trace * trace) / 4 - det);
                        let lambda2 = trace / 2 - Math.sqrt((trace * trace) / 4 - det);
                        let majorAxis = 2 * Math.sqrt(Math.max(lambda1, lambda2));
                        let minorAxis = 2 * Math.sqrt(Math.min(lambda1, lambda2));
                        if (majorAxis === 0 || minorAxis / majorAxis < 0.2) {
                            continue; // Skip this dot
                        }

                        c.save();
                        c.beginPath();
                        c.moveTo(rim3D[0][0], rim3D[0][1]);
                        for (let j = 1; j < rim3D.length; j++) {
                            c.lineTo(rim3D[j][0], rim3D[j][1]);
                        }
                        c.closePath();
                        let distFromCenter = Math.sqrt((pxr - cx) ** 2 + (pyr - cy) ** 2);
                        let normDist = distFromCenter / radius;
                        if (roidFill.checked == true) {
                            let minWidth = 0.00001 * radius * cScale;
                            let maxWidth = 0.00004 * radius * cScale;
                            c.lineWidth = maxWidth - (maxWidth - minWidth) * normDist;
                            c.strokeStyle = `hsl(${roidHue}, 100%, ${roidLightness - 45}%, ${roidLightness - 20}%)`;
                            if (flashAmount > 0) {
                                let l = (1 - flashAmount) * (polkaPulseLightness - 20) + flashAmount * 100;
                                let a = (1 - flashAmount) * 0.7 + flashAmount * 1.0;
                                c.fillStyle = `hsla(${dotHue}, ${roidSaturation}%, ${l}%, ${a})`;
                                c.strokeStyle = `hsla(${dotHue}, ${roidSaturation}%, ${l}%, ${a})`;
                            } else {
                                c.fillStyle = `hsla(${dotHue}, ${roidSaturation + 10}%, ${polkaPulseLightness - 20}%, 70%)`;
                                c.strokeStyle = `hsl(${dotHue}, ${roidSaturation + 20}%, ${roidLightness - 20}%)`;
                            }
                            c.fill();
                        } else {
                            let minWidth = 0.00003 * radius * cScale;
                            let maxWidth = 0.0001 * radius * cScale;
                            c.lineWidth = maxWidth - (maxWidth - minWidth) * normDist;
                        }
                        c.stroke()
                        c.restore();
                    }
                }
                break; // Stop after the first successful (maximal) set
            }
        }
    }

    //  DRAW EYEBALL ROIDS  --------------------
    function drawEyeballRoid(px, py, radius, lookAngle, irisOffsetPx, hue, saturation, lightness, spinRotation, pupilScale = 0.45) {
        // cornea  ----------
        var sphereGradient = c.createRadialGradient(
            (px - (0.2 * radius)), 
            (py - (0.4 * radius)), 
            0, 
            (px - (0.2 * radius)), 
            (py - (0.4 * radius)), 
            1.5 * radius);
        /*var highlight = `hsl(0, 0%, 90%)`;
        var midtone = `hsl(0, 0%, 35%)`;
        var shadow = `hsl(0, 0%, 5%)`;*/
        var highlight = `hsl(${hue + 180}, ${saturation - 30}%, ${0.9 * lightness}%)`;
        var midtone = `hsl(${hue + 180}, ${saturation - 30}%, ${0.35 * lightness}%)`;
        var shadow = `hsl(${hue + 180}, ${saturation - 30}%, ${0.05 * lightness}%)`;
        sphereGradient.addColorStop(0.0, highlight);
        sphereGradient.addColorStop(0.5, midtone);
        sphereGradient.addColorStop(1.0, shadow);
        c.fillStyle = sphereGradient;
        c.beginPath();
        c.arc(px, py, radius, 0, Math.PI*2);
        c.closePath();
        c.fill();

        // iris: project a circular iris patch from the sphere surface and draw as an ellipse
        var io = Math.min(0.45 * radius + irisOffsetPx);
        var dx = Math.cos(lookAngle) * io;
        var dy = Math.sin(lookAngle) * io;
        // apply transient spin rotation (spinRotation rotates the iris/pupil around the eye center)
        var spin = spinRotation || 0;
        var sdx = Math.cos(spin) * dx - Math.sin(spin) * dy;
        var sdy = Math.sin(spin) * dx + Math.cos(spin) * dy;
        dx = sdx; dy = sdy;
        // clamp to sphere surface interior to avoid NaN z
        var dd2 = dx*dx + dy*dy;
        var max2 = (radius * 0.99) * (radius * 0.99);
        if (dd2 > max2) {
            var s = (radius * 0.99) / Math.sqrt(dd2);
            dx *= s; dy *= s; dd2 = dx*dx + dy*dy;
        }
        var z = Math.sqrt(Math.max(0, radius*radius - dd2));
        var scale = 0.95 * z / radius; // foreshortening factor (0..1)
        var ix = px + dx;
        var iy = py + dy;
        var irisR_base = radius * 0.5;

        // draw iris+pupil as ellipse using canvas transforms
        c.save();
        c.translate(ix, iy);
        // rotate so the ellipse major axis aligns with the look direction
        c.rotate(lookAngle + Math.PI/2);
        c.scale(1, scale);

        // create a local radial gradient centered on the iris (local coords)
        var irisGradient = c.createRadialGradient(0, 0, 0, 0, 0, irisR_base);
        irisGradient.addColorStop(0.0, `hsl(${hue}, 90%, 100%)`);
        irisGradient.addColorStop(0.6, `hsl(${hue}, 80%, 50%)`);
        irisGradient.addColorStop(1.0, `hsl(${hue}, 60%, 20%)`);

        // iris (filled with local gradient)  ----------
        c.fillStyle = irisGradient;
        c.beginPath();
        c.arc(0, 0, irisR_base, 0, Math.PI*2);
        c.closePath();
        c.fill();

        // thin outline  ----------
        c.strokeStyle = 'rgba(0,0,0,0.3)';
        c.lineWidth = 0.00005 * radius * cScale;
        c.stroke();

        // pupil  ----------
        var pScale = (typeof pupilScale === 'number') ? pupilScale : 0.45;
        c.fillStyle = '#000';
        c.beginPath();
        c.arc(0, 0, irisR_base * pScale, 0, Math.PI*2);
        c.closePath();
        c.fill();

        c.restore();

        //  ADD SHINE FOR IRIS  ----------
        var glossGradient = c.createRadialGradient(
            (px - (0.2 * radius)), 
            (py - (0.4 * radius)), 
            0, 
            (px - (0.2 * radius)), 
            (py - (0.4 * radius)), 
            1.5 * radius);
        var glossHighlight = `hsla(0, 0%, 100%, 40%)`;
        var glossMidtone = `hsla(0, 0%, 30%, 20%)`;
        var glossShadow = `hsla(0, 0%, 0%, 0%)`;
        glossGradient.addColorStop(0.0, glossHighlight);
        glossGradient.addColorStop(0.15, glossMidtone);
        glossGradient.addColorStop(1.0, glossShadow);
        c.fillStyle = glossGradient;
        c.beginPath();
        c.arc(px, py, radius, 0, Math.PI*2);
        c.closePath();
        c.fill();
    }

    //  DRAW GLOBE ROIDS  --------------------
    function drawGlobeRoid(cx, cy, radius, originalRadius, hue, saturation, lightness, spinAngle = 0, orientation = {w:1,x:0,y:0,z:0}, flashPolkadots) {
        // Parametric globe-style globe (latitude & longitude) with front-hemisphere clipping
        c.save();
        // line width scales with roid size (radius is in pixels already)
        c.lineWidth = 0.02 * radius;
        c.strokeStyle = `hsl(${hue}, ${Math.max(30, Math.round(saturation))}%, ${Math.max(20, Math.round(lightness))}%)`;
        c.lineCap = 'round';

        // Use orthographic projection with equal X/Y scale so circles remain circular
        const verticalSquash = 1.0;
        // Helper: project 3D point (x,y,z) to screen (no non-uniform squash)
        function project(x, y, z) {
            const sx = cx + x;
            const sy = cy - y; // invert Y to canvas coords
            return { x: sx, y: sy, z: z };
        }

        // rotate by yaw (around Z), pitch (around X), roll (around Y)
        const spin = spinAngle || 0;

        function rotatePoint(x, y, z) {
            return quatRotateVec(orientation, x, y, z);
        }

        // Latitudes: FAINT background curves  ----------
        // generate symmetric latitudes about the equator so spacing is equal to poles
        const latStep = 20; 
        const maxLat = 60;  
        const latDegrees = [0];
        for (let d = latStep; d <= maxLat; d += latStep) {
            latDegrees.push(d, -d);
        }
        c.save();
        c.lineWidth = 0.015 * radius;
        c.strokeStyle = `hsla(${hue}, ${Math.max(30, Math.round(saturation))}%, ${Math.max(20, Math.round(lightness - 20))}%, 0.6)`;
        for (let li = 0; li < latDegrees.length; li++) {
            const phi = latDegrees[li] * Math.PI / 180;
            const rLat = radius * Math.cos(phi);
            const z0 = radius * Math.sin(phi);
            const steps = 96;
            let any = false;
            c.beginPath();
            for (let s = 0; s <= steps; s++) {
                const theta = (s / steps) * 2 * Math.PI + spin;
                const x0 = rLat * Math.cos(theta);
                const y0 = rLat * Math.sin(theta);
                const rot = rotatePoint(x0, y0, z0);
                const p = project(rot.x, rot.y, rot.z);
                if (s === 0) c.moveTo(p.x, p.y); else c.lineTo(p.x, p.y);
                any = true;
            }
            if (any) c.stroke();
        }

        // Longitudes: FAINT background  ----------
        const numLongBg = 12;
        const phiStepsBg = 80;
        for (let k = 0; k < numLongBg; k++) {
            const lambda = (k / numLongBg) * 2 * Math.PI + spin;
            c.beginPath();
            for (let pi = 0; pi <= phiStepsBg; pi++) {
                const phi = (-0.5 + pi / phiStepsBg) * Math.PI;
                const x0 = radius * Math.cos(phi) * Math.cos(lambda);
                const y0 = radius * Math.cos(phi) * Math.sin(lambda);
                const z0 = radius * Math.sin(phi);
                const rot = rotatePoint(x0, y0, z0);
                const p = project(rot.x, rot.y, rot.z);
                if (pi === 0) c.moveTo(p.x, p.y); else c.lineTo(p.x, p.y);
            }
            c.stroke();
        }
        c.restore();

        //  SET FLASH SHADING  ----------
        // New behavior: when flashPolkadots is active (numeric remaining seconds),
        // the roid should ramp to red over 0.1s, then fade back to normal over 0.5s.
        let flashAmount = 0;
        
        // Determine remaining time (seconds). Caller sets polkadotFlashTimer on events.
        const FLASH_RAMP_UP = 0.1; // seconds to ramp to full red
        const FLASH_RAMP_DOWN = 0.5; // seconds to return to normal
        const FLASH_TOTAL = FLASH_RAMP_UP + FLASH_RAMP_DOWN; // 0.6s total
        let tRemaining = 0;
        if (typeof flashPolkadots === 'number') {
            tRemaining = Math.max(0, flashPolkadots);
            flashAmount = Math.max(0, Math.min(1, tRemaining / FLASH_TOTAL));
        } else if (flashPolkadots === true) {
            // legacy/boolean support: treat as full remaining time
            tRemaining = FLASH_TOTAL;
            flashAmount = 1;
        }

        // Default base shading (normal) - opaque colors (white/gray/black)
        c.strokeStyle = `hsl(${hue}, ${Math.max(30, Math.round(saturation))}%, ${Math.max(20, Math.round(lightness))}%)`;
        var highlight = `hsl(0, 0%, 100%)`;
        var midtone = `hsl(0, 0%, 50%)`;
        var shadow = `hsl(0, 0%, 0%)`;

        // Helper: linear mix for HSL components. Hue uses shortest direction.
        function mixHSL(h1, s1, l1, h2, s2, l2, t) {
            h1 = ((h1 % 360) + 360) % 360; h2 = ((h2 % 360) + 360) % 360;
            let dh = h2 - h1;
            if (Math.abs(dh) > 180) { if (dh > 0) dh -= 360; else dh += 360; }
            let h = h1 + dh * t; h = ((h % 360) + 360) % 360;
            let s = s1 + (s2 - s1) * t;
            let l = l1 + (l2 - l1) * t;
            return `hsl(${Math.round(h)}, ${Math.round(s)}%, ${Math.round(l)}%)`;
        }

        if (tRemaining > 0) {
            // elapsed since flash started
            let elapsed = Math.max(0, FLASH_TOTAL - tRemaining);
            if (elapsed <= FLASH_RAMP_UP) {
                // ramping up to red
                var p = elapsed / FLASH_RAMP_UP; // 0..1
                // base (white/gray/black) -> red targets (opaque)
                const baseH = 0, baseS = 0, baseHighL = 100, baseMidL = 50, baseShadowL = 0;
                const redH = 0, redS = 100, redHighL = 60, redMidL = 45, redShadowL = 25;
                highlight = mixHSL(baseH, baseS, baseHighL, redH, redS, redHighL, p);
                midtone = mixHSL(baseH, baseS, baseMidL, redH, redS, redMidL, p);
                shadow = mixHSL(baseH, baseS, baseShadowL, redH, redS, redShadowL, p);
                // stroke mixes from normal hue toward red midtone
                c.strokeStyle = mixHSL(hue, Math.max(30, Math.round(saturation)), Math.max(20, Math.round(lightness)), redH, redS, redMidL, p);
            } else {
                // ramping down from full red back to normal
                var p = (elapsed - FLASH_RAMP_UP) / FLASH_RAMP_DOWN; // 0..1
                let a = Math.max(0, 1 - p); // 1->0 over ramp down
                const baseH = 0, baseS = 0, baseHighL = 100, baseMidL = 50, baseShadowL = 0;
                const redH = 0, redS = 100, redHighL = 60, redMidL = 45, redShadowL = 25;
                highlight = mixHSL(baseH, baseS, baseHighL, redH, redS, redHighL, a);
                midtone = mixHSL(baseH, baseS, baseMidL, redH, redS, redMidL, a);
                shadow = mixHSL(baseH, baseS, baseShadowL, redH, redS, redShadowL, a);
                c.strokeStyle = mixHSL(hue, Math.max(30, Math.round(saturation)), Math.max(20, Math.round(lightness)), redH, redS, redMidL, a);
            }
            var pulsate = p;
        } else {
            var pulsate = 0;
        }

        //  DRAW INNER ROID  --------------------
        // Base inner radius (pixels)
        const baseInnerRoid = 0.04 * cScale;
        // Compute time-synced scale: ramp to 2x over FLASH_RAMP_UP, return to 1x over FLASH_RAMP_DOWN
        let innerScale = 1.0;
        if (tRemaining > 0) {
            let elapsed = Math.max(0, FLASH_TOTAL - tRemaining);
            if (elapsed <= FLASH_RAMP_UP) {
                // ramp-up 0..1
                let pUp = elapsed / FLASH_RAMP_UP;
                innerScale = 1.0 + pUp; // 1 -> 2
            } else {
                // ramp-down 0..1
                let pDown = (elapsed - FLASH_RAMP_UP) / FLASH_RAMP_DOWN;
                let a = Math.max(0, 1 - pDown); // 1 -> 0 over ramp-down
                innerScale = 1.0 + a; // 2 -> 1
            }
        }
        var innerRoidRadius = baseInnerRoid * innerScale;
        drawCircle(cx, cy, innerRoidRadius);
        if (roidFill.checked == true) {
            var sphereGradient = c.createRadialGradient(
                    cx - (0.1 * innerRoidRadius),
                    cy - (0.2 * innerRoidRadius),
                    0,
                    cx - (0.1 * innerRoidRadius),
                    cy - (0.2 * innerRoidRadius),
                    innerRoidRadius);
            sphereGradient.addColorStop(0.0, highlight);
            sphereGradient.addColorStop(0.3, midtone);
            sphereGradient.addColorStop(1.0, shadow);
            c.fillStyle = sphereGradient;
            c.fill();
        } else {
            c.strokeStyle = `hsl(0, 0%, 100%)`;
            c.stroke();
        }
        
        // Now draw BRIGHT front-facing arcs on top  ----------
        for (let li = 0; li < latDegrees.length; li++) {
            const phi = latDegrees[li] * Math.PI / 180; // latitude angle
            const rLat = radius * Math.cos(phi);
            const z0 = radius * Math.sin(phi);
            const steps = 96;
            let started = false;
            let any = false;
            c.beginPath();
            for (let s = 0; s <= steps; s++) {
                const theta = (s / steps) * 2 * Math.PI + spin;
                const x0 = rLat * Math.cos(theta);
                const y0 = rLat * Math.sin(theta);
                const rot = rotatePoint(x0, y0, z0);
                if (rot.z > 0.0001) {
                    const p = project(rot.x, rot.y, rot.z);
                    if (!started) {
                        c.moveTo(p.x, p.y);
                        started = true;
                    } else {
                        c.lineTo(p.x, p.y);
                    }
                    any = true;
                } else {
                    // allow future re-entry: finish current subpath and continue
                    started = false;
                }
            }
            if (any) {
                c.lineWidth = 0.02 * radius;
                c.strokeStyle = `hsl(${hue}, ${Math.max(30, Math.round(saturation))}%, ${Math.max(20, Math.round(lightness))}%)`;
                c.stroke();
            }
        }

        // Longitudes (meridians): draw arcs that are on the front hemisphere (z>0). These vary in z with latitude.
        const numLong = 12;
        const phiSteps = 80;
        for (let k = 0; k < numLong; k++) {
            const lambda = (k / numLong) * 2 * Math.PI + spin; // longitude
            let started = false;
            let any = false;
            c.beginPath();
            for (let pi = 0; pi <= phiSteps; pi++) {
                // phi: -pi/2 .. +pi/2
                const phi = (-0.5 + pi / phiSteps) * Math.PI;
                const x0 = radius * Math.cos(phi) * Math.cos(lambda);
                const y0 = radius * Math.cos(phi) * Math.sin(lambda);
                const z0 = radius * Math.sin(phi);
                const rot = rotatePoint(x0, y0, z0);
                if (rot.z > 0.0001) {
                    const p = project(rot.x, rot.y, rot.z);
                    if (!started) {
                        c.moveTo(p.x, p.y);
                        started = true;
                    } else {
                        c.lineTo(p.x, p.y);
                    }
                    any = true;
                } else {
                    // allow re-entry later: finish current subpath
                    started = false;
                }
            }
            if (any) {
                c.lineWidth = 0.02 * radius;
                c.strokeStyle = `hsl(${hue}, ${Math.max(30, Math.round(saturation))}%, ${Math.max(20, Math.round(lightness))}%)`;
                c.stroke();
            }
        }
        c.restore();

        // Draw outer silhouette (rim) as a circle so the roid reads round
        c.lineWidth = 0.02 * radius;
        c.strokeStyle = `hsl(${hue}, ${Math.max(30, Math.round(saturation))}%, ${Math.max(20, Math.round(lightness))}%)`;
        c.lineCap = 'round';  
        c.beginPath();
        c.arc(cx, cy, radius, 0, 2 * Math.PI);
        c.stroke();
    }

    //  DEFINE CLASSES -----------------------------------------------------------------
    //  VECTOR OPERATIONS -----------
    class Vector2 {
        constructor(x = 0.0, y = 0.0) {
            this.x = x; 
            this.y = y;
        }
        clone() {
            return new Vector2(this.x, this.y);
        }
        add(v, s=1) {
            this.x += v.x * s;
            this.y += v.y * s;
            return this;
        }
        subtract(a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            return this;			
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        scale(s) {
            this.x *= s;
            this.y *= s;
            return this;
        }
        dot(v) {
            return this.x * v.x + this.y * v.y;
        }
        normalize() {
            let len = Math.sqrt(this.x * this.x + this.y * this.y);
            if (len === 0) {
                this.x = 0; this.y = 0; return this;
            }
            this.x /= len;
            this.y /= len;
            return this;
        }
    }

    //  PACMAN DIRECTION CHOOSER ---------------------------------------------------------------
    function setNewPacDir() {
        var dirSeed = Math.random();
        const pacman = PacMan[0];
        // ...if going right...
        if (pacman.vel.x > 0) {
            if (dirSeed < 0.33) {
                pacDir = 'up';
            } else if (dirSeed < 0.67) {
                  pacDir = 'right';
              } else if (dirSeed < 1.00) {
                  pacDir = 'down';
            }
        }
        // ...if going left...
        if (pacman.vel.x < 0) {
            if (dirSeed < 0.33) {
                 pacDir = 'up';
             } else if (dirSeed < 0.67) {
                   pacDir = 'left';
            } else if (dirSeed < 1.00) {
                   pacDir = 'down';
               }
        }
        // ...if going up...
        if (pacman.vel.y > 0) {
            if (dirSeed < 0.33) {
                pacDir = 'left';
            } else if (dirSeed < 0.67) {
                pacDir = 'up';
            } else if (dirSeed < 1.00) {
                pacDir = 'right';
            }
        }
        // ...if going down...
        if (pacman.vel.y < 0) {
            if (dirSeed < 0.33) {
                pacDir = 'left';
            } else if (dirSeed < 0.67) {
                pacDir = 'down';
            } else if (dirSeed < 1.00) {
                pacDir = 'right';
            }
        }
    }

    //  PAC-MAN CONSTRUCTOR  ------------------------------------------------------------------------
    class PACMAN {
        constructor(yLoc) {
            this.radius = 0.0003 * cScale;
            this.pos = new Vector2(-this.radius, yLoc);
            this.vel = new Vector2(0.7, 0);
            this.rot = 0;
            this.mouthMotor = 0;
            this.mouthSize = 0;
        }
        get left() {
            return this.pos.x - this.radius;
        }
        get right() {
            return this.pos.x + this.radius;
        }
        simulate() {
            this.mouthMotor += 0.1;
            this.mouthSize = 0.05 * Math.PI + 0.55 * Math.PI * Math.abs(Math.cos(this.mouthMotor));

            // overrun RIGHT side  ------------
            if (this.pos.x > simWidth + 2 * this.radius) {
                this.vel.x *= -1.0;
                var oldPacHeight = this.pos.y;
                var randPacHeight = this.radius + Math.random() * (simHeight - this.radius);
                var tries = 0;
                while (randPacHeight < oldPacHeight + 3 * this.radius && randPacHeight > oldPacHeight - 3 * this.radius) {
                    randPacHeight = this.radius + Math.random() * (simHeight - this.radius);
                    tries += 1;
                    if (tries > 10) {
                        break
                    }
                }
                this.pos.y = randPacHeight;
                //walkoutH = 0.2 * simWidth + 0.8 * simWidth * Math.random();
                setNewPacDir();
            }
            // overrun left side --------------
            if (this.pos.x < -2 * this.radius) {
                this.vel.x *= -1.0;
                var oldPacHeight = this.pos.y;
                var randPacHeight = Math.random() * simHeight;
                var tries = 0;
                while (randPacHeight < oldPacHeight + this.radius && randPacHeight > oldPacHeight - this.radius) {
                    randPacHeight = this.radius + Math.random() * (simHeight - this.radius);
                    tries += 1;
                    if (tries > 10) {
                        tries = 0;
                        break
                    }
                }
                this.pos.y = randPacHeight;
                //walkoutH = 0.2 * simWidth + 0.8 * simWidth * Math.random();
                setNewPacDir();
            }
            // overrun floor --------------
            if (this.pos.y < -2 * this.radius) {
                this.vel.y *= -1.0;
                var oldPacLateral = this.pos.x;
                var randPacLateral = Math.random() * simWidth;
                var tries = 0;
                while (randPacLateral < oldPacLateral + this.radius && randPacLateral > oldPacLateral - this.radius) {
                    randPacLateral = this.radius + Math.random() * (simHeight - this.radius);
                    tries += 1;
                    if (tries > 10) {
                        tries = 0;
                        break
                    }
                }
                this.pos.x = randPacLateral;
                //walkoutV = 0.2 * simHeight + 0.8 * simHeight * Math.random();
                setNewPacDir();
            }
            // overrun ceiling --------------
            if (this.pos.y > 2 * this.radius + simHeight) {
                this.vel.y *= -1.0;
                var oldPacLateral = this.pos.x;
                var randPacLateral = Math.random() * simWidth;
                var tries = 0;
                while (randPacLateral < oldPacLateral + this.radius && randPacLateral > oldPacLateral - this.radius) {
                    randPacLateral = this.radius + Math.random() * (simHeight - this.radius);
                    tries += 1;
                    if (tries > 10) {
                        tries = 0;
                        break
                    }
                }
                this.pos.x = randPacLateral;
                //walkoutV = 0.2 * simHeight + 0.8 * simHeight * Math.random();
                setNewPacDir();
            }
            this.pos.add(this.vel, 1/60);
        }
        draw() {
            drawCircle(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale);
            var sphereGradient = c.createRadialGradient(
                this.pos.x * cScale, 
                this.pos.y * cScale, 
                0, 
                this.pos.x * cScale, 
                this.pos.y * cScale, 
                this.radius * cScale
            );
            sphereGradient.addColorStop(0, `hsla(0, 0%, 0%, 100%)`);
            sphereGradient.addColorStop(0.5, `hsla(0, 0%, 0%, 100%)`);
            sphereGradient.addColorStop(1, `hsla(0, 0%, 0%, 0%)`);
            c.fillStyle = sphereGradient;
            //c.fillStyle = 'black'
            c.fill();

            c.beginPath();
            if (this.vel.x > 0) {  // RIGHT
                // body
                c.arc(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale, 0.5 * this.mouthSize, 2 * Math.PI - 0.5 * this.mouthSize);
                // top jaw
                c.moveTo((this.pos.x * cScale + this.radius * cScale * Math.sin(0.5 * this.mouthSize + 0.5 * Math.PI)), 
                this.pos.y * cScale + this.radius * cScale * Math.cos(0.5 * this.mouthSize + 0.5 * Math.PI));
                // center
                c.lineTo((this.pos.x - 0.4 * this.radius) * cScale, this.pos.y * cScale);
                // bottom jaw
                c.lineTo((this.pos.x * cScale + this.radius * cScale * Math.sin(0.5 * this.mouthSize + 0.5 * Math.PI)), 
                this.pos.y * cScale - this.radius * cScale * Math.cos(0.5 * this.mouthSize + 0.5 * Math.PI));
            } 
            if (this.vel.x < 0) {  // LEFT 
                // body
                c.arc(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale, 0.5 * this.mouthSize + Math.PI, 2 * Math.PI - 0.5 * this.mouthSize + Math.PI);
                // bottom jaw
                c.moveTo((this.pos.x * cScale - this.radius * cScale * Math.sin(0.5 * this.mouthSize + 0.5 * Math.PI)), 
                this.pos.y * cScale - this.radius * cScale * Math.cos(0.5 * this.mouthSize + 0.5 * Math.PI));
                // center
                c.lineTo((this.pos.x + 0.4 * this.radius) * cScale, this.pos.y * cScale);
                // top jaw
                c.lineTo((this.pos.x * cScale - this.radius * cScale * Math.sin(0.5 * this.mouthSize + 0.5 * Math.PI)), 
                this.pos.y * cScale + this.radius * cScale * Math.cos(0.5 * this.mouthSize + 0.5 * Math.PI));
            }
            if (this.vel.y > 0) { // UP
                // body
                c.arc(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale, -0.5*Math.PI + 0.5 * this.mouthSize, -0.5*Math.PI - 0.5 * this.mouthSize);
                // top jaw
                c.moveTo((this.pos.x * cScale + this.radius * cScale * Math.cos(0.5 * this.mouthSize + .5 * Math.PI)), 
                this.pos.y * cScale - this.radius * cScale * Math.sin(0.5 * this.mouthSize + 0.5 * Math.PI));
                // center
                c.lineTo((this.pos.x) * cScale, (simHeight - this.pos.y + 0.4 * this.radius) * cScale);
                // bottom jaw
                c.lineTo((this.pos.x * cScale - this.radius * cScale * Math.cos(0.5 * this.mouthSize + 0.5 * Math.PI)), 
                this.pos.y * cScale + this.radius * cScale * Math.sin(0.5 * this.mouthSize - 0.5 * Math.PI));
            } 

            if (this.vel.y < 0) { // DOWN
                // body
                c.arc(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale, 0.5*Math.PI + 0.5 * this.mouthSize, 0.5*Math.PI - 0.5 * this.mouthSize);
                // bottom jaw
                c.lineTo((this.pos.x * cScale - this.radius * cScale * Math.cos(0.5 * this.mouthSize + 0.5 * Math.PI)), 
                this.pos.y * cScale - this.radius * cScale * Math.sin(0.5 * this.mouthSize - 0.5 * Math.PI));
                // center
                c.lineTo((this.pos.x) * cScale, (simHeight - this.pos.y - 0.4 * this.radius) * cScale);
                // top jaw
                c.moveTo((this.pos.x * cScale + this.radius * cScale * Math.cos(0.5 * this.mouthSize + .5 * Math.PI)), 
                this.pos.y * cScale + this.radius * cScale * Math.sin(0.5 * this.mouthSize + 0.5 * Math.PI));
            } 
            
            /*if (brightnessSlider.value > 50) {
                c.strokeStyle = 'black';
                c.lineWidth = 4;
                c.stroke();

                c.font = `${0.8 * this.radius * cScale}px Andale Mono`;
                c.fillStyle = "hsl(0, 0%, 10%)";
                c.textAlign = "center";
                c.verticalAlign = "center";
                c.fillText("1UP", cX(this.pos), this.pos.y * cScale - 1.4 * this.radius * cScale);
            }*/

            c.fillStyle = 'yellow';
            c.shadowColor = 'yellow';
            c.shadowBlur = 15;
            c.fill();
            c.shadowBlur = 0;
            //c.strokeStyle = 'yellow';
            //c.lineWidth = 4;
            //c.stroke();
        }
    }
    
    //  THAT'S NO MOON  --------------
    class MOON {
        constructor() {
            this.pos = new Vector2((-0.4 * cScale), 0.3 * simHeight * cScale);
            this.vel = new Vector2();
            this.radius = 0;
            this.phase = 0;
            this.angle = 0.58 * Math.PI;
            this.maxRadius = 0.3 * cScale;
            this.bandStart = 0.07 * Math.PI;  // right side
            this.bandEnd = 0.91 * Math.PI;  // left side
            this.TopLiteRow = [];
            this.MiddleLiteRow = [];
            this.BottomLiteRow = [];
            for (var s = 0; s < 10; s += 1) {
                //  TOP LIGHT ROW  ---------
                this.TopLiteRow.push(this.bandStart + Math.random() * (this.bandEnd - this.bandStart));
                //  MIDDLE LIGHT ROW  ---------
                this.MiddleLiteRow.push(this.bandStart + Math.random() * (this.bandEnd - this.bandStart));
                //  BOTTOM LIGHT ROW  ---------
                this.BottomLiteRow.push(this.bandStart + Math.random() * (this.bandEnd - this.bandStart));
            }   
            // one-shot spawn guard for PacMan when moon finishes arrival
            this.pacmanSpawned = false;
        }
        simulate(){
            if (this.radius < this.maxRadius && gameOver != true) {
                this.radius += 0.0006 * cScale;
            }
            if (this.radius > this.maxRadius) {
                this.radius = this.maxRadius;
            }
            this.angle -= .00005 * 60 * dT; 
            if (this.angle < 0.5 * Math.PI && (this.pos.x > canvas.width + this.radius || this.pos.y > canvas.height + this.radius)) {
                this.angle = 0.7 * Math.PI;
            }
            var moonRise = (earthriseAdj / 2.95);
            if (gameOver != true) {
                this.pos.x = (0.5 * simWidth * cScale) + (imageCenterY - 3 * 0.2 * cScale) * Math.cos(this.angle);
                this.pos.y = ((imageCenterY / moonRise) - ((imageCenterY - 7 * 0.2 * cScale) * Math.sin(this.angle)));
            } else {
                // Smoothly shrink radius toward a target pixel size
                const TARGET_RADIUS_PX = 25;
                // lerp factor per second (higher = faster shrink)
                const SHRINK_SPEED = 0.3;
                this.radius += (TARGET_RADIUS_PX - this.radius) * SHRINK_SPEED * dT;

                // Critically-damped spring controller (stable, avoids overshoot)
                var home = new Vector2(0.5 * simWidth * cScale, 0.3 * simHeight * cScale);
                var error = new Vector2();
                // error = home - pos
                error.subtract(home, this.pos);
                var dist = error.length();
                // snap threshold (pixels) - start gentle braking earlier
                const SNAP_DIST = 8.0;
                // velocity threshold for snapping (px/sec)
                const VEL_SNAP = 6.0;
                // core dynamics params: lower natural frequency and overdamp to avoid overshoot
                const omega = 2.5; // natural frequency (rad/s) — lower = slower acceleration
                const zeta = 1.8;  // damping ratio (>1 => overdamped, prevents overshoot)
                const ACCEL_SCALE = 0.12; // global accel/damping scale (smaller => gentler forces)

                if (dist > SNAP_DIST) {
                    // Full critically-damped spring when far away
                    var ax = ACCEL_SCALE * ((omega * omega) * error.x - 2.0 * zeta * omega * this.vel.x);
                    var ay = ACCEL_SCALE * ((omega * omega) * error.y - 2.0 * zeta * omega * this.vel.y);
                    this.vel.x += ax * dT;
                    this.vel.y += ay * dT;
                    // clamp max speed for safety
                    const MAX_SPEED = 800; // px/s
                    var sp = this.vel.length();
                    if (sp > MAX_SPEED) {
                        this.vel.normalize();
                        this.vel.scale(MAX_SPEED);
                    }
                    this.pos.add(this.vel, dT);
                } else {
                    // Within the snap radius: progressively fade the proportional pull
                    // so we brake smoothly rather than snapping immediately.
                    // scaleFactor goes from 1 at SNAP_DIST to 0 at 0 — square for a softer fade near zero
                    var scaleFactor = Math.max(0, Math.pow(dist / SNAP_DIST, 2));
                    // proportional term reduced by scaleFactor
                    var ax_p = (omega * omega) * error.x * scaleFactor;
                    var ay_p = (omega * omega) * error.y * scaleFactor;
                    // damping term (braking) still active to remove velocity
                    var ax_d = -2.0 * zeta * omega * this.vel.x;
                    var ay_d = -2.0 * zeta * omega * this.vel.y;
                    var ax = ACCEL_SCALE * (ax_p + ax_d);
                    var ay = ACCEL_SCALE * (ay_p + ay_d);
                    this.vel.x += ax * dT;
                    this.vel.y += ay * dT;
                    this.pos.add(this.vel, dT);

                    // Snap only when both position and velocity are sufficiently small
                    var curSpeed = this.vel.length();
                    if (dist < SNAP_DIST && curSpeed < VEL_SNAP) {
                        this.pos.x = home.x;
                        this.pos.y = home.y;
                        this.vel.x = 0;
                        this.vel.y = 0;
                        // spawn PacMan once: position in sim units, offscreen-left
                        if (!this.pacmanSpawned) {
                            var pm = new PACMAN();
                            pm.pos = new Vector2(-0.2, this.pos.y / cScale); // x offscreen-left, y aligned to moon (sim units)
                            pm.vel = new Vector2(0.7, 0); // rightward motion in sim units
                            PacMan.push(pm);
                            this.pacmanSpawned = true;
                        }
                    }
                }
            }
        }
        draw() {
            //  OUTLINE  ----------
            drawCircle(this.pos.x, this.pos.y, this.radius);
            //  OVERALL SHADING  ----------
            var sphereGradient = c.createRadialGradient(
                this.pos.x - (0.5 * this.radius), 
                this.pos.y - (0.6 * this.radius), 
                0, 
                this.pos.x - (0.5 * this.radius), 
                this.pos.y - (0.6 * this.radius), 
                1.5 * this.radius
            );
            var highlight = `hsl(0, 0%, 18%)`;
            var midtone = `hsl(0, 0%, 8%)`;
            var shadow = `hsl(0, 0%, 0%)`;
            sphereGradient.addColorStop(0.0, highlight);
            sphereGradient.addColorStop(0.5, midtone);
            sphereGradient.addColorStop(1.0, shadow);
            c.fillStyle = sphereGradient;
            c.fill();
            //  RIM SHADING  ----------
            var sphereGradient = c.createRadialGradient(
                (this.pos.x + (0.2 * this.radius)), 
                (this.pos.y + (0.2 * this.radius)), 
                0, 
                (this.pos.x + (0.2 * this.radius)), 
                (this.pos.y + (0.2 * this.radius)), 
                1.25 * this.radius
            );
            var highlight = `hsla(240, 30%, 90%)`;
            var midtone = `hsla(240, 0%, 10%, 10%)`;
            var shadow = `hsla(0, 0%, 0%, 0%)`;
            sphereGradient.addColorStop(0.0, shadow);
            sphereGradient.addColorStop(0.7, shadow);
            sphereGradient.addColorStop(1.0, highlight);
            c.fillStyle = sphereGradient;
            c.fill();
            //  EQUATORIAL BANDS  ----------
            this.bandStart = 0.07 * Math.PI;  // right side
            this.bandEnd = 0.91 * Math.PI;  // left side
            var bandLength = this.bandEnd - this.bandStart;
            var bandSegs = bandLength / 50;
            for (var s = this.bandStart; s < this.bandEnd; s += bandSegs) {
                //  TOP LIGHT EQUATORIAL BAND  ---------
                c.beginPath();
                c.ellipse(
                    this.pos.x,
                    this.pos.y - 0.04 * this.radius,
                    this.radius,
                    0.2 * this.radius,
                    0,
                    s,  // right side
                    s + bandSegs,  // left side
                );
                c.lineCap = 'butt';
                c.lineWidth = 0.15 * this.radius;
                c.strokeStyle = `hsla(0, 0%, 100%, ${s / (8 * bandLength)})`;
                c.stroke();
                //  BOTTOM LIGHT EQUATORIAL BAND  ---------
                c.beginPath();
                c.ellipse(
                    this.pos.x,
                    this.pos.y + 0.04 * this.radius,
                    this.radius,
                    0.2 * this.radius,
                    0,
                    s,  // right side
                    s + bandSegs,  // left side
                );
                c.strokeStyle = `hsla(0, 0%, 80%, ${s / (10 * bandLength)})`;
                c.stroke();
            }
            //  MIDDLE DARK EQUATORIAL BAND  ---------
            c.beginPath();
            c.ellipse(
                this.pos.x,
                this.pos.y,
                this.radius,
                0.2 * this.radius,
                0,
                0.05 * Math.PI,  // right side
                0.98 * Math.PI   // left side
            );
            c.lineCap = 'round';
            c.lineWidth = 0.04 * this.radius;
            c.strokeStyle = `hsl(0, 0%, 0%)`;
            c.stroke();
            //  DRAW DISH  ----------
            c.beginPath()
            c.ellipse(
                this.pos.x - 0.35 * this.radius, 
                this.pos.y - 0.4 * this.radius,
                0.32 * this.radius,
                0.28 * this.radius,
                0.75 * Math.PI,
                0,
                2 * Math.PI
            )
            c.closePath();
            //  DISH SHADING  ----------
            /*var sphereGradient = c.createRadialGradient(
                this.pos.x - 0.45 * this.radius, 
                this.pos.y - 0.5 * this.radius,
                0, 
                (this.pos.x - 0.45 * this.radius), 
                (this.pos.y - 0.5 * this.radius), 
                0.4 * this.radius
            );
            var highlight = `hsl(240, 20%, 70%)`;
            var midtone = `hsl(240, 0%, 20%)`;
            var fadeout = `hsl(240, 0%, 10%)`;
            var shadow = `hsl(0, 0%, 5%)`;
            sphereGradient.addColorStop(0.0, shadow);
            sphereGradient.addColorStop(0.7, shadow);
            sphereGradient.addColorStop(1.0, highlight);
            c.fillStyle = sphereGradient;
            c.fill();*/
            var sphereGradient = c.createRadialGradient(
                this.pos.x - 0.6 * this.radius, 
                this.pos.y - 0.65 * this.radius,
                0, 
                (this.pos.x - 0.6 * this.radius), 
                (this.pos.y - 0.65 * this.radius), 
                0.66 * this.radius
            );
            var highlight = `hsl(0, 0%, 50%)`;
            var midtone2 = `hsl(0, 0%, 10%)`;
            var midtone1 = `hsl(0, 0%, 6%)`;
            var shadow = `hsl(0, 0%, 3%)`;
            sphereGradient.addColorStop(0.0, shadow);
            sphereGradient.addColorStop(0.62, midtone1);
            sphereGradient.addColorStop(0.7, midtone2);
            sphereGradient.addColorStop(1.0, highlight);
            c.fillStyle = sphereGradient;
            c.fill();
            c.lineWidth = 0.02 * this.radius;
            c.strokeStyle = 'hsl(0, 0%, 25%)';
            c.stroke();

            /*//  LITES  --------------------
            function drawLites(pos, radMultiplier, lite, radius) {
                c.beginPath();
                c.ellipse(
                    pos.x,
                    pos.y + radMultiplier,
                    radius,
                    0.2 * radius,
                    0,
                    lite,  // right side
                    lite + 0.001 * cScale,  // left side
                );
                c.closePath();
                c.fillStyle = 'hsl(0, 0%, 90%)';
                c.fill();
            }
            for (var l = 0; l < this.TopLiteRow.length; l += 1) {
                console.log(this.TopLiteRow[l]);
                drawLites(this.pos, -0.02, this.TopLiteRow[l], this.radius);
            }
            for (var l = 0; l < this.MiddleLiteRow.length; l += 1) {
                drawLites(this.pos, 0.0, this.MiddleLiteRow[l], this.radius);
            }
            for (var l = 0; l < this.BottomLiteRow.length; l += 1) {
                drawLites(this.pos, 0.02, this.BottomLiteRow[l], this.radius);
            }*/

            //  DISH CENTER  ----------
            c.lineWidth = 0.005 * this.radius;
            c.strokeStyle = 'hsl(0, 0%, 7%)';
            c.fillStyle = 'hsl(0, 0%, 10%)';
            c.beginPath()
            c.ellipse(
                this.pos.x - 0.35 * this.radius, 
                this.pos.y - 0.4 * this.radius,
                0.3 * 0.32 * this.radius,
                0.3 * 0.28 * this.radius,
                0.75 * Math.PI,
                0,
                2 * Math.PI
            );
            c.closePath();
            c.fill();
            c.stroke();
            //  DISH DOT  ---------
            c.beginPath()
            c.ellipse(
                this.pos.x - 0.35 * this.radius, 
                this.pos.y - 0.4 * this.radius,
                0.05 * 0.32 * this.radius,
                0.05 * 0.28 * this.radius,
                0.75 * Math.PI,
                0,
                2 * Math.PI
            );
            c.closePath();
            c.fill();
        }  
    }

    //  SPAWN MOON  ----------
    function spawnMoon() {
        Moon.push(new MOON());
        // bew minn
    }

    //  DEFINE STARS FOR BACKGROUND  -----------------
    class STAR {
        constructor(pos, radius, hue, lightness, velY, falling) {
            this.pos = pos.clone();
            this.radius = radius;
            this.hue = hue;
            this.lightness = lightness;
            this.velY = velY;
            this.falling = falling;
        }
        simulate() {
            this.velY += 0.005;
            this.pos.y += this.velY * this.velY * dT;
        }     
        draw(n) {
            starfieldC.beginPath();
            starfieldC.arc(this.pos.x * cScale, this.pos.y * cScale,
            this.radius, 0, 2*Math.PI)
            starfieldC.fillStyle = `hsl(${this.hue}, 10%, ${this.lightness*100}%)`
            starfieldC.closePath();
            starfieldC.fill();
        }
        drawForReal(n) {
            c.beginPath();
            c.arc(this.pos.x * cScale, this.pos.y * cScale,
            this.radius, 0, 2*Math.PI)
            c.fillStyle = `hsl(${this.hue}, 10%, ${this.lightness*100}%)`
            c.closePath();
            c.fill();
        }
    }

    //  SPAWN STARS FOR BACKGROUND  -----------------
    function makeStars() {
        StarField = [];
        for (r = 0; r < (0.003 * Math.floor(canvas.height * canvas.width)); r++) {
            var pos = new Vector2(-0.1 * simWidth + Math.random() * 1.2 * simWidth,
                -0.1 + Math.random() * 1.2 * simHeight);
            var radius = 0.3 + .8 * Math.random();
            var hue = Math.random() * 360;
            var lightness = Math.random();
            var velY = 0.01;
            var falling = false;
            StarField.push(new STAR(pos, radius, hue, lightness, velY, falling));
        }
        for (r = 0; r < (0.0001 * Math.floor(canvas.height * canvas.width)); r++) {
            var pos = new Vector2(-0.1 * simWidth + Math.random() * 1.2 * simWidth,
                -0.1 + Math.random() * 1.2 * simHeight);
            var radius = 1.0 + 1.5 * Math.random();
            var hue = Math.random() * 360;
            var lightness = 0.6 * Math.random();
            var velY = 0.01;
            var falling = false;
            StarField.push(new STAR(pos, radius, hue, lightness, velY, falling));
        }
    }

    //  PICK FALLING STARS AT GAME OVER  -------------------
    function dropStar() {
        if (pickFallingStar < StarField.length) {
            StarField[pickFallingStar].falling = true;
            pickFallingStar += 1;
        }
    }

    //  DEFINE SOLO ALIEN  ---------------------
    class ALIEN {
        constructor(pos, vel, radius, lol, birthday) {
            this.pos = pos.clone();
            this.vel = vel.clone();
            this.radius = radius;
            this.lol = lol;
            this.birthday = birthday;
        }
        simulate() {
            this.pos.add(this.vel, dT);
            this.age = (Date.now() - this.birthday) / 1000;
            this.vel.scale(1.05);

            this.radius += 0.005;
            if (this.pos.x > simWidth + this.radius ||
                this.pos.x < 0 - this.radius ||
                this.pos.y > simHeight + this.radius ||
                this.pos.y < 0 - this.radius) {
                    Alien = [];
            }
        }
        draw() {
            // START OF SOLO ALIEN--------------------
            //  LAUGH  -----------
            if (this.lol == true) {
                lol += 0.8 * Math.random();
                lolX += 0.2 * Math.random();
                lolAdjY = 2.5 * Math.abs(Math.cos(lol));
                lolAdjX = 5.0 * Math.abs(Math.sin(lolX));
                
                toothAdj = 0.02 * this.radius + 0.05 * this.radius * Math.abs(Math.cos(lol));
            } else {
                lolAdjX = 1;
                lolAdjY = 1;
                toothAdj = 0;
                lolTime = 1.0 + 3.0 * Math.random();
            }
            //  left arm ----------
            if (leftArmAngle >= 1.1 * Math.PI) {
                leftArmAngle -= 0.07 * Math.random();
                wavingForward = false;
            } else
            if (leftArmAngle <= 1.0 * Math.PI) {
                leftArmAngle += 0.07 * Math.random();;
                wavingForward = true;
            } else
            if (leftArmAngle > 0.95  * Math.PI && leftArmAngle < 1.3  * Math.PI && wavingForward == true) {
                leftArmAngle += 0.07 * Math.random();;
            } else {
                leftArmAngle -= 0.07 * Math.random();;
            } 
            var armCos = Math.cos(leftArmAngle);
            var armSin = Math.sin(leftArmAngle);

            c.strokeStyle = 'hsl(110, 50%, 40%)';
            c.lineWidth = 0.04 * this.radius * cScale;
            c.beginPath();
            c.moveTo(this.pos.x * cScale, (this.pos.y - 0.1 * this.radius) * cScale);
            c.lineTo((this.pos.x + 0.4 * this.radius * armCos) * cScale, ((this.pos.y - 0.1 * this.radius) + 0.4 * this.radius * armSin) * cScale);
            c.closePath();
            c.stroke();

            drawHand(
                (this.pos.x + 0.9*0.4 * this.radius * armCos) * cScale, 
                ((this.pos.y - 0.9*0.1 * this.radius) + 0.4 * this.radius * armSin) * cScale, 
                leftArmAngle,
                this.radius * cScale,
                [1.3, 0.3, -0.5]);

            //  right arm ----------
            if (rightArmAngle >= 0 * Math.PI) {
                rightArmAngle -= 0.07 * Math.random();
                wavingForward = false;
            } else
            if (rightArmAngle <= -0.2 * Math.PI) {
                rightArmAngle += 0.07 * Math.random();;
                wavingForward = true;
            } else
            if (rightArmAngle > -0.2 * Math.PI && rightArmAngle < 0 * Math.PI && wavingForward == true) {
                rightArmAngle += 0.07 * Math.random();;
            } else {
                rightArmAngle -= 0.07 * Math.random();;
            } 
            var armCos = Math.cos(rightArmAngle);
            var armSin = Math.sin(rightArmAngle);

            c.beginPath();
            c.moveTo(this.pos.x * cScale, (this.pos.y - 0.1 * this.radius) * cScale);
            c.lineTo((this.pos.x + 0.4 * this.radius * armCos) * cScale, ((this.pos.y - 0.1 * this.radius) + 0.4 * this.radius * armSin) * cScale);
            c.closePath();
            c.stroke();

            drawHand(
                (this.pos.x + 0.9*0.4 * this.radius * armCos) * cScale, 
                ((this.pos.y - 0.9*0.1 * this.radius) + 0.4 * this.radius * armSin) * cScale, 
                rightArmAngle,
                this.radius * cScale,
                [-1.2, -0.4, 0.4]);   

            function drawHand(x, y, angle, radius, fingerAngles) {
                c.save();
                c.translate(x, y);
                c.rotate(angle);

                var fingerLength;
                var tipRadius;
                for (let i = 0; i < 3; i++) {
                    if (i == 0) {
                        c.lineWidth = 0.000081 * radius * cScale;
                        fingerLength = .1 * radius; 
                        tipRadius = .025 * radius; // Thumb
                    } else {
                        c.lineWidth = 0.00005 * radius * cScale;
                        fingerLength = .15 * radius;
                        tipRadius = .02 * radius;  // Other fingers
                    }
                    
                c.save();
                c.rotate(fingerAngles[i]);

                // First segment
                c.beginPath();
                c.moveTo(0, 0);
                c.lineTo(fingerLength, 0);
                c.stroke();

                // Fingertip
                c.beginPath();
                c.arc(fingerLength, 0, tipRadius, 0, 2 * Math.PI);
                c.fillStyle = 'yellow';
                c.fill();

                c.restore();
                }

                c.restore();
            }

            //  left leg ----------
            if (leftLegAngle >= 0.9 * Math.PI) {
                leftLegAngle -= 0.1;
                wavingForward = false;
            } else
            if (leftLegAngle <= 0.7 * Math.PI) {
                leftLegAngle += 0.1;
                wavingForward = true;
            } else
            if (leftLegAngle > 0.7 * Math.PI && leftLegAngle < 0.9 * Math.PI && wavingForward == true) {
                leftLegAngle += 0.1;
            } else {
                leftLegAngle -= 0.1;
            } 
            var armCos = Math.cos(leftLegAngle);
            var armSin = Math.sin(leftLegAngle);

            /*//  left sole  ----------
            c.strokeStyle = 'hsl(0, 0%, 70%)';
            c.lineWidth = 0.13 * this.radius * cScale;
            c.beginPath();
            c.moveTo((this.pos.x + 0.30 * this.radius * armCos) * cScale, ((this.pos.y + 0.3 * this.radius) + 0.30 * this.radius * armSin) * cScale);
            c.lineTo((this.pos.x + 0.32 * this.radius * armCos) * cScale, ((this.pos.y + 0.3 * this.radius) + 0.32 * this.radius * armSin) * cScale);
            c.closePath();
            c.stroke();*/

            //  left leg  ----------
            c.strokeStyle = 'hsl(110, 50%, 15%)';
            c.lineWidth = 0.08 * this.radius * cScale;
            c.beginPath();
            c.moveTo((this.pos.x - 0.1 * this.radius) * cScale, (this.pos.y + 0.3 * this.radius) * cScale);
            c.lineTo((this.pos.x + 0.3 * this.radius * armCos) * cScale, ((this.pos.y + 0.3 * this.radius) + 0.3 * this.radius * armSin) * cScale);
            c.closePath();
            c.stroke();
  
            // Curly jester's left shoe (smaller)
            const leftLegEndX = this.pos.x + 0.3 * this.radius * armCos;
            const leftLegEndY = (this.pos.y + 0.3 * this.radius) + 0.3 * this.radius * armSin;
            const leftAnkleLen = 0.035 * this.radius;
            // Offset ankle to back of leg by half leg thickness
            const legThickness = 0.08 * this.radius; // matches c.lineWidth for leg
            const perpX = Math.cos(leftLegAngle + Math.PI / 2);
            const perpY = Math.sin(leftLegAngle + Math.PI / 2);
            const leftAnkleX = leftLegEndX - leftAnkleLen * Math.sin(leftLegAngle) - 0.5 * legThickness * perpX;
            const leftAnkleY = leftLegEndY + leftAnkleLen * Math.cos(leftLegAngle) - 0.5 * legThickness * perpY;
            const curlLen = 0.09 * this.radius;
            // Rotate left shoe 30 degrees (π/6) away from the leg
            const shoeOffset = Math.PI / 6;
            // Move left shoe inward by 20% of curlLen
            function lerp(a, b, t) { return a + (b - a) * t; }
            const ctrlX_raw = leftAnkleX - curlLen * Math.sin(leftLegAngle - 0.7 + shoeOffset);
            const ctrlY_raw = leftAnkleY + curlLen * Math.cos(leftLegAngle - 0.7 + shoeOffset);
            const tipX_raw = leftAnkleX - curlLen * Math.sin(leftLegAngle - 1.2 + shoeOffset);
            const tipY_raw = leftAnkleY + curlLen * Math.cos(leftLegAngle - 1.2 + shoeOffset);
            const inwardT = 0.2;
            const curlCtrlX = lerp(ctrlX_raw, leftAnkleX, inwardT);
            const curlCtrlY = lerp(ctrlY_raw, leftAnkleY, inwardT);
            const curlTipX = lerp(tipX_raw, leftAnkleX, inwardT);
            const curlTipY = lerp(tipY_raw, leftAnkleY, inwardT);
            c.save();
            c.beginPath();
            c.moveTo(leftLegEndX * cScale, leftLegEndY * cScale);
            c.lineTo(leftAnkleX * cScale, leftAnkleY * cScale);
            c.quadraticCurveTo(curlCtrlX * cScale, curlCtrlY * cScale, curlTipX * cScale, curlTipY * cScale);
            c.lineWidth = 0.065 * this.radius * cScale;
            c.strokeStyle = 'hsl(0, 50%, 50%)'
            c.stroke();
            /*// Bell at tip
            c.beginPath();
            c.arc(curlTipX * cScale, curlTipY * cScale, 0.0125 * this.radius * cScale, 0, 2 * Math.PI);
            c.fillStyle = 'hsl(0, 0%, 20%)';
            c.fill();
            c.restore();*/

            //  right leg ----------
            if (rightLegAngle >= 0.3 * Math.PI) {
                rightLegAngle -= 0.1;
                wavingForward = false;
            } else
            if (rightLegAngle <= 0.1 * Math.PI) {
                rightLegAngle += 0.1;
                wavingForward = true;
            } else
            if (rightLegAngle > 0.1 * Math.PI && rightLegAngle < 0.3 * Math.PI && wavingForward == true) {
                rightLegAngle += 0.1;
            } else {
                rightLegAngle -= 0.1;
            } 
            armCos = Math.cos(rightLegAngle);
            armSin = Math.sin(rightLegAngle);

            /*//  right sole  ----------
            c.lineWidth = 0.13 * this.radius * cScale;
            c.strokeStyle = 'hsl(0, 0%, 70%)';
            c.beginPath();
            c.moveTo((this.pos.x + 0.30 * this.radius * armCos) * cScale, ((this.pos.y + 0.3 * this.radius) + 0.30 * this.radius * armSin) * cScale);
            c.lineTo((this.pos.x + 0.32 * this.radius * armCos) * cScale, ((this.pos.y + 0.3 * this.radius) + 0.32 * this.radius * armSin) * cScale);
            c.closePath();
            c.stroke();*/

            //  right leg  ----------
            c.lineWidth = 0.08 * this.radius * cScale;
            c.strokeStyle = 'hsl(110, 50%, 15%)';
            c.beginPath();
            c.moveTo((this.pos.x + 0.1 * this.radius) * cScale, (this.pos.y + 0.3 * this.radius) * cScale);
            c.lineTo((this.pos.x + 0.3 * this.radius * armCos) * cScale, ((this.pos.y + 0.3 * this.radius) + 0.3 * this.radius * armSin) * cScale);
            c.closePath();
            c.stroke();

            // Curly jester's right shoe (smaller)
            const rightLegEndX = this.pos.x + 0.3 * this.radius * armCos;
            const rightLegEndY = (this.pos.y + 0.3 * this.radius) + 0.3 * this.radius * armSin;
            const rightAnkleLen = 0.035 * this.radius;
            // Offset ankle to back of leg by half leg thickness
            const rlegThickness = 0.08 * this.radius; // matches c.lineWidth for leg
            const rperpX = Math.cos(rightLegAngle - Math.PI / 2);
            const rperpY = Math.sin(rightLegAngle - Math.PI / 2);
            const rightAnkleX = rightLegEndX + rightAnkleLen * Math.sin(rightLegAngle) - 0.5 * rlegThickness * rperpX;
            const rightAnkleY = rightLegEndY - rightAnkleLen * Math.cos(rightLegAngle) - 0.5 * rlegThickness * rperpY;
            const rcurlLen = 0.09 * this.radius;
            // Rotate right shoe 30 degrees (π/6) away from the leg
            // Move right shoe inward by 20% of rcurlLen
            const rctrlX_raw = rightAnkleX + rcurlLen * Math.sin(rightLegAngle + 0.7 - shoeOffset);
            const rctrlY_raw = rightAnkleY - rcurlLen * Math.cos(rightLegAngle + 0.7 - shoeOffset);
            const rtipX_raw = rightAnkleX + rcurlLen * Math.sin(rightLegAngle + 1.2 - shoeOffset);
            const rtipY_raw = rightAnkleY - rcurlLen * Math.cos(rightLegAngle + 1.2 - shoeOffset);
            const rcurlCtrlX = lerp(rctrlX_raw, rightAnkleX, inwardT);
            const rcurlCtrlY = lerp(rctrlY_raw, rightAnkleY, inwardT);
            const rcurlTipX = lerp(rtipX_raw, rightAnkleX, inwardT);
            const rcurlTipY = lerp(rtipY_raw, rightAnkleY, inwardT);
            c.save();
            c.beginPath();
            c.moveTo(rightLegEndX * cScale, rightLegEndY * cScale);
            c.lineTo(rightAnkleX * cScale, rightAnkleY * cScale);
            c.quadraticCurveTo(rcurlCtrlX * cScale, rcurlCtrlY * cScale, rcurlTipX * cScale, rcurlTipY * cScale);
            c.lineWidth = 0.065 * this.radius * cScale;
            c.strokeStyle = 'hsl(0, 50%, 50%)'
            c.stroke();
            /*// Bell at tip
            c.beginPath();
            c.arc(rcurlTipX * cScale, rcurlTipY * cScale, 0.0125 * this.radius * cScale, 0, 2 * Math.PI);
            c.fillStyle = 'hsl(0, 0%, 20%)';
            //c.fill();
            c.restore();*/

            //  RAISE EYEBROWS  ----------
            if (this.vel.x >= 0) {
                eyeLiftL = 0;
                eyeLiftR = -0.03 * this.radius;
            } else {
                eyeLiftL = -0.03 * this.radius;
                eyeLiftR = 0;
            }
            
            // antennas  ----------
            c.fillStyle = 'green';
            c.strokeStyle = 'cyan';
            c.lineWidth = 0.015 * this.radius * cScale;
            c.beginPath();
            //  left  ----------
            c.moveTo((this.pos.x - 0.04 * this.radius) * cScale, (this.pos.y - 0.2 * this.radius) * cScale);
            c.lineTo((this.pos.x - 0.13 * this.radius) * cScale, (this.pos.y - 0.44 * this.radius) * cScale);
            c.lineTo((this.pos.x - 0.22 * this.radius) * cScale, (this.pos.y - 0.4 * this.radius) * cScale);
            //  middle  ----------
            c.moveTo(this.pos.x * cScale, (this.pos.y - 0.2 * this.radius) * cScale);
            c.lineTo(this.pos.x * cScale, (this.pos.y - 0.5 * this.radius) * cScale);
            //  right  ----------
            c.moveTo((this.pos.x + 0.04 * this.radius) * cScale, (this.pos.y - 0.2 * this.radius) * cScale);
            c.lineTo((this.pos.x + 0.18 * this.radius) * cScale, (this.pos.y - 0.5 * this.radius) * cScale);
            c.stroke();

            //  antenna knobs  ----------
            c.strokeStyle = 'green';
            knobLight += 0.01;
            var knobHue = 360 * Math.cos(knobLight);
            //  right
            c.fillStyle = `hsl(${90 + knobHue}, 90%, 50%)`;
            drawCircle((this.pos.x + 0.18 * this.radius) * cScale, (this.pos.y - 0.5 * this.radius) * cScale, 0.045 * this.radius * cScale);
            c.fill();
            drawCircle((this.pos.x + 0.18 * this.radius) * cScale, (this.pos.y - 0.5 * this.radius) * cScale, 0.045 * this.radius * cScale);
            c.stroke();
            //  middle
            c.fillStyle = `hsl(${180 + knobHue}, 90%, 50%)`;
            drawCircle(this.pos.x * cScale, (this.pos.y - 0.5 * this.radius) * cScale, 0.045 * this.radius * cScale);
            c.fill();
            drawCircle(this.pos.x * cScale, (this.pos.y - 0.5 * this.radius) * cScale, 0.045 * this.radius * cScale);
            c.stroke();
            //  left
            drawCircle((this.pos.x - 0.22 * this.radius) * cScale, (this.pos.y - 0.4 * this.radius) * cScale, 0.045 * this.radius * cScale);
            if (knobOn == true) {
                knobCounter += 1;
                if (knobCounter <= knobOffCycles) {
                    c.fillStyle = `hsl(${270 + knobHue}, 30%, 40%)`;
                    c.fill();
                } else {
                    c.fillStyle = `black`;
                    c.fill();
                    knobOn = false;
                    needNewCycleCounter = true;
                    knobCounter = 0;
                }
            } 
            if (needNewCycleCounter == true) {
                knobOn = true;
                knobOffCycles = Math.floor(2 * Math.random());
                needNewCycleCounter = false;
            }
            drawCircle((this.pos.x - 0.22 * this.radius) * cScale, (this.pos.y - 0.4 * this.radius) * cScale, 0.045 * this.radius * cScale);
            c.stroke();
            
            //  head/body  ----------
            drawVertEllipse(this.pos.x * cScale, (this.pos.y) * cScale, 0.4 * this.radius * cScale);
            var sphereGradient = c.createRadialGradient(
                (this.pos.x - (0.0 * this.radius)) * cScale, 
                (this.pos.y - (0.45 * this.radius)) * cScale, 
                0.1 * this.radius * cScale, 
                (this.pos.x - (0.0 * this.radius)) * cScale, 
                (this.pos.y - (0.45 * this.radius)) * cScale, 
                0.5 * this.radius * cScale);
                
            var highlight = `hsl(110, 100%, 50%)`;
            var midtone = `hsl(110, 50%, 30%)`;
            var shadow = `hsl(110, 50%, 15%)`;
            sphereGradient.addColorStop(0.0, highlight);
            sphereGradient.addColorStop(0.5, midtone);
            sphereGradient.addColorStop(1.0, shadow);
            c.fillStyle = sphereGradient;
            c.fill();

            //  underpants  ----------
            /*
            //c.fillStyle = 'hsl(0, 0%, 90%)';
            //c.strokeStyle = 'hsl(0, 0%, 90%)';
            //c.lineWidth = 0.01 * this.radius * cScale;

            drawCircle( // left
                (this.pos.x - 0.26 * this.radius) * cScale,
                (this.pos.y + 0.15 * this.radius) * cScale,
                0.02 * this.radius * cScale);
            c.fill();

            drawCircle(  // right
                (this.pos.x + 0.26 * this.radius) * cScale,
                (this.pos.y + 0.15 * this.radius) * cScale,
                0.02 * this.radius * cScale);
            c.fill();

            drawCircle(  // top of right leg hole
                (this.pos.x + 0.20 * this.radius) * cScale,
                (this.pos.y + 0.27 * this.radius) * cScale,
                0.02 * this.radius * cScale);
            c.fill();

            drawCircle(  // bottom of right leg hole
                (this.pos.x + 0.10 * this.radius) * cScale,
                (this.pos.y + 0.37 * this.radius) * cScale,
                0.02 * this.radius * cScale);
            c.fill();

            drawCircle(  // bottom of left leg hole
                (this.pos.x - 0.10 * this.radius) * cScale,
                (this.pos.y + 0.37 * this.radius) * cScale,
                0.02 * this.radius * cScale);
            c.fill();

            drawCircle(  // top of left leg hole
                (this.pos.x - 0.20 * this.radius) * cScale,
                (this.pos.y + 0.27 * this.radius) * cScale,
                0.02 * this.radius * cScale);
            c.fill();

             drawCircle(  // top of left leg hole
                this.pos.x * cScale,
                (this.pos.y - 0.05 * this.radius) * cScale,
                0.02 * this.radius * cScale);
            c.fill();
            */

            c.beginPath();
            c.moveTo(
                (this.pos.x - 0.26 * this.radius) * cScale,
                (this.pos.y + 0.15 * this.radius) * cScale)
            c.arcTo(  // top of right waistband
                this.pos.x * cScale,
                (this.pos.y + 0.25 * this.radius) * cScale,
                (this.pos.x + 0.26 * this.radius) * cScale,
                (this.pos.y + 0.15 * this.radius) * cScale,
                0.7 * this.radius * cScale);
            c.arcTo(  // right waist
                (this.pos.x + 0.27 * this.radius) * cScale,
                (this.pos.y + 0.24 * this.radius) * cScale,
                (this.pos.x + 0.20 * this.radius) * cScale,
                (this.pos.y + 0.27 * this.radius) * cScale,
                0.1 * this.radius * cScale);
            c.arcTo(  // right leg
                (this.pos.x + 0.06 * this.radius) * cScale,
                (this.pos.y + 0.25 * this.radius) * cScale,
                (this.pos.x + 0.10 * this.radius) * cScale,
                (this.pos.y + 0.37 * this.radius) * cScale,
                0.08 * this.radius * cScale);
            c.arcTo(  // crotch
                this.pos.x * cScale,
                (this.pos.y + 0.45 * this.radius) * cScale,
                (this.pos.x - 0.10 * this.radius) * cScale,
                (this.pos.y + 0.37 * this.radius) * cScale,
                0.15 * this.radius * cScale);
            c.arcTo(  // left leg
                (this.pos.x - 0.09 * this.radius) * cScale,
                (this.pos.y + 0.22 * this.radius) * cScale, 
                (this.pos.x - 0.20 * this.radius) * cScale,
                (this.pos.y + 0.27 * this.radius) * cScale,
                0.08 * this.radius * cScale);
            c.arcTo(  // left waist
                (this.pos.x - 0.28 * this.radius) * cScale,
                (this.pos.y + 0.25 * this.radius) * cScale,
                (this.pos.x - 0.26 * this.radius) * cScale,
                (this.pos.y + 0.15 * this.radius) * cScale,
                0.1 * this.radius * cScale);
            c.closePath();

            var rainbowpants = c.createLinearGradient((
                this.pos.x - 0.2 * this.radius) * cScale, 
                0, 
                (this.pos.x + 0.4 * this.radius) * cScale, 
                0);
            for (col = 0; col <= 360; col += 30) {
                rainbowpants.addColorStop(col / 360, `hsl(${col}, 100%, 50%)`);
                if (col + 15 <= 360) {
                    rainbowpants.addColorStop((col + 15) / 360, `hsl(${col}, 100%, 50%)`);
                }
            }
            c.lineWidth = .01 * this.radius * cScale;
            if (weaponLevel < 7) {
                c.fillStyle = 'hsl(0, 0%, 40%)';
            } else {
                c.fillStyle = rainbowpants;
            }
            
            //  underpants outline  ----------
            c.strokeStyle = 'hsl(0, 0%, 10%)';
            c.fill();
            c.stroke();

            //  waistband  ----------
            c.beginPath();
            c.moveTo(
                (this.pos.x - 0.26 * this.radius) * cScale,
                (this.pos.y + 0.15 * this.radius) * cScale)
            c.arcTo(  // top of right waistband
                this.pos.x * cScale,
                (this.pos.y + 0.25 * this.radius) * cScale,
                (this.pos.x + 0.26 * this.radius) * cScale,
                (this.pos.y + 0.15 * this.radius) * cScale,
                0.7 * this.radius * cScale);
            c.lineWidth = .03 * this.radius * cScale;
            c.strokeStyle = 'hsl(0, 0%, 80%)';
            c.stroke();
            c.beginPath();
            
            //  vertical seam  ------------
            c.lineWidth = .01 * this.radius * cScale;
            c.strokeStyle = 'hsl(0, 0%, 80%)';
            c.beginPath();
            c.arc((this.pos.x - 0.49 * this.radius) * cScale, (this.pos.y + 0.3 * this.radius) * cScale, 0.5 * this.radius * cScale, -0.18, 0.21);
            c.stroke();
            
            //  the fly  ----------
            c.beginPath();
            c.arc((this.pos.x + 0.01 * this.radius) * cScale, (this.pos.y + 0.32 * this.radius) * cScale, 0.03 * this.radius * cScale, -4.7, -1.5, true);
            c.stroke();
            
            //  mouth  ----------
            c.fillStyle = 'black';
            drawCustomEllipse2(
                this.pos.x * cScale, 
                (this.pos.y + 0.01 * this.radius) * cScale, 
                (0.12 * this.radius + lolAdjX * 0.02 * this.radius) * cScale, 
                (0.12 * this.radius + lolAdjY * 0.02 * this.radius) * cScale);
            c.fill();

            //  toofs  ----------
            // Mouth parameters (should match your drawCustomEllipse2 call)
            const mouthCenterX = this.pos.x;
            const mouthCenterY = this.pos.y + 0.01 * this.radius;
            const mouthRadiusX = 0.12 * this.radius + lolAdjX * 0.02 * this.radius;
            const mouthRadiusY = 0.12 * this.radius + lolAdjY * 0.02 * this.radius;
            // Helper to get Y on the ellipse for a given X
            function mouthEdgeY(x) {
                const dx = (x - mouthCenterX) / mouthRadiusX;
                if (Math.abs(dx) > 1) return mouthCenterY; // outside ellipse
                return mouthCenterY - Math.sqrt(1 - dx * dx) * mouthRadiusY;
            }
            // right toof
            const toofX = this.pos.x + 0.06 * this.radius;
            const toofY = mouthEdgeY(toofX) + 0.03 * this.radius; // 0.02 for tooth height offset
            c.beginPath();
            c.moveTo(
                toofX * cScale, (toofY + 0.08 * this.radius) * cScale);
            c.lineTo(
                (toofX + 0.04 * this.radius) * cScale, (toofY + 0.0 * this.radius) * cScale);
            c.lineTo(
                (toofX - 0.04 * this.radius) * cScale, (toofY + 0.0 * this.radius) * cScale);
            c.closePath();
            c.fillStyle = 'hsl(0, 0%, 90%)';
            c.fill();

            //  tongue  ----------
            c.fillStyle = 'darkred';
            drawCustomEllipse2(
                this.pos.x * cScale, 
                (this.pos.y + 0.03 * this.radius + lolAdjY * 0.02 * this.radius) * cScale, 
                (0.08 * this.radius + lolAdjX * 0.01 * this.radius) * cScale, 
                (0.03 * this.radius + lolAdjX * 0.003 * this.radius)* cScale);
            c.fill();

            //  lips  ----------
            c.lineWidth = .03 * this.radius * cScale;
            c.strokeStyle = 'hsl(330, 75%, 50%)';
            drawCustomEllipse2(
                this.pos.x * cScale, 
                (this.pos.y + 0.01 * this.radius) * cScale, 
                (0.11 * this.radius + lolAdjX * 0.02 * this.radius) * cScale, 
                (0.11 * this.radius + lolAdjY * 0.02 * this.radius) * cScale);
            c.shadowBlur = 10 * this.radius;
            c.stroke();
            
            //  lips inner shadow ----------
            c.lineWidth = .01 * this.radius * cScale;
            //c.strokeStyle = 'hsl(0, 100%, 50%)';
            c.strokeStyle = 'hsla(0, 0%, 0%, 0%)';
            drawCustomEllipse2(
                this.pos.x * cScale, 
                (this.pos.y + 0.01 * this.radius) * cScale, 
                (0.10 * this.radius + lolAdjX * 0.02 * this.radius) * cScale, 
                (0.10 * this.radius + lolAdjY * 0.02 * this.radius) * cScale);
                c.shadowBlur = 5 * this.radius;
                c.stroke();
                c.shadowBlur = 0;
            
            //  eyebrows  ----------
            c.lineWidth = .03 * this.radius * cScale;
            c.strokeStyle = 'black'
            c.beginPath();
            c.moveTo((this.pos.x + 0.04 * this.radius) * cScale, (this.pos.y - 0.22*(1.02) * this.radius) * cScale);
            c.lineTo((this.pos.x + 0.13 * this.radius) * cScale, (this.pos.y - 0.26*(1.07) * this.radius + eyeLiftR) * cScale);
            c.moveTo((this.pos.x - 0.04 * this.radius) * cScale, (this.pos.y - 0.22*(1.02) * this.radius) * cScale);
            c.lineTo((this.pos.x - 0.13 * this.radius) * cScale, (this.pos.y - 0.26*(1.07) * this.radius + eyeLiftL) * cScale);
            c.closePath();
            c.stroke();

            //  eyes  ----------
            c.lineWidth = .04 * this.radius * cScale;
            c.strokeStyle = 'white'
            c.beginPath();
            c.moveTo((this.pos.x + 0.04 * this.radius) * cScale, (this.pos.y - 0.22 * this.radius) * cScale);
            c.lineTo((this.pos.x + 0.13 * this.radius) * cScale, (this.pos.y - 0.25 * this.radius + eyeLiftR) * cScale);
            c.moveTo((this.pos.x - 0.04 * this.radius) * cScale, (this.pos.y - 0.22 * this.radius) * cScale);
            c.lineTo((this.pos.x - 0.13 * this.radius) * cScale, (this.pos.y - 0.25 * this.radius + eyeLiftL) * cScale);
            c.closePath();
            c.stroke();

            //  pupils  ----------
            eyeRoll += 0.3;
            //  left eye ----------
            var xCos = this.pos.x + 0.005 * Math.cos(eyeRoll);
            var ySin = this.pos.y + 0.005 * Math.sin(eyeRoll);
            drawCircle((xCos + 0.07 * this.radius) * cScale, (ySin - 0.23 * this.radius) * cScale, (0.035 * this.radius + 0.4 * Math.abs(eyeLiftR) * this.radius) * cScale);
            c.shadowColor = 'black';
            c.shadowBlur = 10;
            c.shadowOffsetX = 2 * this.radius;
            c.shadowOffsetY = 5 * this.radius;
            c.fillStyle = 'hsl(0, 0%, 90%)';
            c.fill();
            c.shadowBlur = 0;
            c.shadowOffsetX = 0;
            c.shadowOffsetY = 0;

            drawCircle((xCos + 0.07 * this.radius) * cScale, (ySin - 0.23 * this.radius) * cScale, (0.025 * this.radius + 0.4 * Math.abs(eyeLiftR) * this.radius) * cScale);
            c.fillStyle = 'red';
            c.fill();

            drawCircle((xCos + 0.07 * this.radius) * cScale, (ySin - 0.23 * this.radius) * cScale, (0.01 * this.radius + 0.4 * Math.abs(eyeLiftR) * this.radius) * cScale);
            c.fillStyle = 'black';
            c.fill();

            //  right eye ----------
            var xCos = this.pos.x + 0.005 * Math.sin(eyeRoll);
            var ySin = this.pos.y + 0.005 * Math.cos(eyeRoll);
            drawCircle((xCos - 0.07 * this.radius) * cScale, (ySin - 0.23 * this.radius) * cScale, (0.035 * this.radius + 0.4 * Math.abs(eyeLiftL) * this.radius) * cScale);
            c.shadowColor = 'black';
            c.shadowBlur = 10;
            c.shadowOffsetX = 2 * this.radius;
            c.shadowOffsetY = 5 * this.radius;
            c.fillStyle = 'hsl(0, 0%, 80%)';
            c.fill();
            c.shadowBlur = 0;
            c.shadowOffsetX = 0;
            c.shadowOffsetY = 0;

            drawCircle((xCos - 0.07 * this.radius) * cScale, (ySin - 0.23 * this.radius) * cScale, (0.025 * this.radius + 0.4 * Math.abs(eyeLiftL) * this.radius) * cScale);
            c.fillStyle = 'red';
            c.fill();

            drawCircle((xCos - 0.07 * this.radius) * cScale, (ySin - 0.23 * this.radius) * cScale, (0.01 * this.radius + 0.4 * Math.abs(eyeLiftL) * this.radius) * cScale);
            c.fillStyle = 'black';
            c.fill();
            
            // SUNGLASSES  ----------
            if (weaponLevel > maxWeaponLevel - 3) {
                // bridge
                c.beginPath();
                c.lineWidth = 0.01 * this.radius * cScale;
                c.strokeStyle = 'red';
                c.arc((this.pos.x) * cScale, (this.pos.y - 0.2 * this.radius) * cScale, 0.04 * this.radius * cScale, 1.2 * Math.PI, 1.8 * Math.PI);
                c.stroke();

                // lenses
                drawStar(new Vector2(this.pos.x - 0.07 * this.radius, this.pos.y - 0.23 * this.radius), 0.14 * this.radius, 0);
                c.fillStyle = 'hsla(310, 100%, 50%, 40%)';
                c.strokeStyle = 'orange';
                c.lineWidth = 0.01 * Alien[0].radius * cScale;
                c.fill();
                c.stroke();
                drawStar(new Vector2(this.pos.x + 0.07 * this.radius, this.pos.y - 0.23 * this.radius), 0.14 * this.radius, Math.PI);
                c.fill();
                c.stroke();

                // temples
                c.beginPath();
                c.moveTo((this.pos.x - 0.14 * this.radius) * cScale, (this.pos.y - 0.23 * this.radius) * cScale);
                c.lineTo((this.pos.x - 0.23 * this.radius) * cScale, (this.pos.y - 0.24 * this.radius) * cScale);
                c.lineWidth = 0.015 * this.radius * cScale;
                c.strokeStyle = 'red';
                c.stroke();

                c.beginPath();
                c.moveTo((this.pos.x + 0.14 * this.radius) * cScale, (this.pos.y - 0.23 * this.radius) * cScale);
                c.lineTo((this.pos.x + 0.23 * this.radius) * cScale, (this.pos.y - 0.24 * this.radius) * cScale);
                c.stroke();
            }

            // 'stache  ----------
            c.lineWidth = .025 * this.radius * cScale;
            c.strokeStyle = 'black';
            c.beginPath();
            c.moveTo((this.pos.x - 0.02 * this.radius) * cScale, (this.pos.y - 0.18 * this.radius) * cScale);
            c.lineTo((this.pos.x + 0.02 * this.radius) * cScale, (this.pos.y - 0.18 * this.radius) * cScale);
            c.closePath();
            c.stroke();

            //  SPEECH BUBBLE  ----------
            if (this.lol == true) {
                c.fillStyle = 'hsl(0, 0%, 80%)';
                c.strokeStyle = 'hsl(0, 0%, 80%)';
                c.lineWidth = 2;

                var eX = 0.9 * this.radius * cScale;
                var eY = 0.5 * this.radius * cScale;
                var posX = (this.pos.x + 0.05 * this.radius) * cScale;
                var posY = (this.pos.y - 1.0 * this.radius) * cScale;
                c.beginPath();
                c.moveTo(posX + eX * .75, posY + eY * .25);
                c.quadraticCurveTo(posX + eX * 0.25, posY + eY * 0.25, posX + eX * 0.25, posY + eY * 0.625);
                c.quadraticCurveTo(posX + eX * 0.25, posY + eY * 1.00, posX + eX * 0.50, posY + eY * 1.00);
                c.quadraticCurveTo(posX + eX * 0.50, posY + eY * 1.20, posX + eX * 0.30, posY + eY * 1.25);
                c.quadraticCurveTo(posX + eX * 0.60, posY + eY * 1.20, posX + eX * 0.65, posY + eY * 1.00);
                c.quadraticCurveTo(posX + eX * 1.25, posY + eY * 1.00, posX + eX * 1.25, posY + eY * 0.625);
                c.quadraticCurveTo(posX + eX * 1.25, posY + eY * 0.25, posX + eX * 0.75, posY + eY * 0.25);
                c.closePath();
                c.stroke();

                c.fillStyle = 'yellow';
                c.textBaseline = 'middle';
                c.textAlign = "center";
                c.font = `${0.1 * this.radius * cScale}px monospace`;
                c.fillText(trash, (this.pos.x + 0.73 * this.radius) * cScale, (this.pos.y - 0.67 * this.radius) * cScale);
            }

            /*//  SWILRLING STAR  -------------------
                // ellipse track  ----------
                this.angle = 0;
                f += 0.1;
                var drawX = this.pos.x +                    Math.cos(f + this.angle) * ( 0.15 * this.radius / Math.sqrt( 0.15 * this.radius * Math.pow(Math.cos(f), 2) + 1.0 * this.radius * Math.pow(Math.sin(f), 2)) );
                var drawY = this.pos.y - 1.1 * this.radius +  Math.sin(f + this.angle) * ( 0.05 * this.radius / Math.sqrt( 0.05 * this.radius * Math.pow(Math.cos(f), 2) + 1.0 * this.radius * Math.pow(Math.sin(f), 2)) );
                // star
                var starWedges = Math.PI / 5;
                var innerRadius = 0.05 * this.radius;
                var outerRadius = 0.1 * this.radius;
                c.beginPath();
                for (var v = 0; v < 10; v++) {
                    if (v == 0) {
                        c.moveTo((drawX + innerRadius * Math.cos(this.angle + v * starWedges)) * cScale, (drawY + innerRadius * Math.sin(this.angle + v * starWedges)) * cScale);
                    } else 
                    if (v % 2 == 0) {  //inner
                        c.lineTo((drawX + innerRadius * Math.cos(this.angle + v * starWedges)) * cScale, (drawY + innerRadius * Math.sin(this.angle + v * starWedges)) * cScale);
                    } else {  //outer
                        c.lineTo((drawX + outerRadius * Math.cos(this.angle + v * starWedges)) * cScale, (drawY + outerRadius * Math.sin(this.angle + v * starWedges)) * cScale);
                    }
                }
                c.closePath();
                c.strokeStyle = 'white';
                //drawCircle(drawX * cScale, drawY * cScale, 0.1 * this.radius * cScale);
                c.stroke();*/
            
            //  END OF SOLO ALIEN----------
        }
    }

    //  SPAWN SOLO ALIEN  ----------
    function spawnSoloAlien(pos) {
        // spawn alien
        var pos = pos.clone();
        var radius = 0.1;
        var flyTo = new Vector2(
            0.2 * simWidth + 0.6 * simWidth * Math.random(),
            1.0 * simHeight);
        var vel = new Vector2(); 
        vel.subtract(flyTo, pos);
        vel.scale(0.002);
        var lol = true;
        var birthday = Date.now();
        trash = SmackTalk[Math.floor(Math.random() * SmackTalk.length)];

        Alien.push(new ALIEN(pos, vel, radius, lol, birthday));
    }

    //  DEFINE ENEMY SHIP ---------------------
    class ENEMY {
        constructor(pos, vel, radius, gunAngle, start, lol, birthday) {
            this.pos = pos.clone();
            this.vel = vel.clone();
            this.radius = radius;
            this.mass = radius;
            this.gunAngle = gunAngle;
            this.start = start;
            this.lol = lol;
            this.birthday = birthday;
        }
        simulate() {
            this.pos.add(this.vel, dT);
            if (this.start == true) {
                if (this.pos.x > this.radius && this.pos.x < simWidth - this.radius) {
                    this.start = false;
                }
            } else {
                if (this.pos.x < this.radius) {
                    //this.pos.x = simWidth;
                    //this.vel.x *= -1;
                }
                    if (this.pos.x > simWidth - this.radius) {
                    //this.pos.x = 0;
                    //this.vel.x *= -1;
                }
            }
            if (this.pos.y < 0.8 * this.radius) {
                //this.pos.y = simHeight;
                //this.vel.y *= -1;
            }
            if (this.pos.y > simHeight - 0.8 * this.radius) {
                //this.pos.y = 0;
                //this.vel.y *= -1;
            }

            //  TARGETING  ----------
            var torpSpeed = 1;
            var enemyTimeout = 20;
            //  ENEMY TIMEOUT  ----------
            // Ensure Roket[0] exists before inspecting its collision state to avoid runtime errors
            var rokExists = (typeof Roket !== 'undefined' && Roket && Roket.length > 0 && Roket[0]);
            if ((Date.now() - this.birthday) / 1000 < enemyTimeout && rokExists && Roket[0].collision != 2) {
                // Compute desired intercept angle, then smoothly rotate gunAngle toward it
                var desired = getInterceptAngle(this.pos, Roket[0].pos, Roket[0].vel, torpSpeed);
                // normalize helper
                function wrapAngle(a) {
                    while (a <= -Math.PI) a += 2 * Math.PI;
                    while (a > Math.PI) a -= 2 * Math.PI;
                    return a;
                }
                var da = wrapAngle(desired - this.gunAngle);
                // max angular speed (radians per second); tweak for feel
                var maxAngularSpeed = 12.0; // rad/s (very fast but not instant)
                // clamp by frame
                var maxStep = maxAngularSpeed * dT;
                if (Math.abs(da) > maxStep) da = (da > 0) ? maxStep : -maxStep;
                this.gunAngle = wrapAngle(this.gunAngle + da);
            } else {
                if (this.gunAngle > 0) {
                    this.gunAngle -= 0.1;
                } else {
                    //  LEAVE A BOMB BEHINS WHEN ENEMY LEAVES ----------

                    //  POINT GUN TO THE RIGHT  ----------
                    this.gunAngle = 0;
                    window.clearInterval(gonnaGetcha);
                    if (this.pos.x > simWidth + this.radius) {
                        Enemy = [];
                    }
                }

            }

            //  LEAVE AFTER HIT ON PLAYER  ----------
            if (sayByeBye == true && Enemy[0] != null) {
                this.gunAngle = 0;
                window.clearInterval(gonnaGetcha);
                if (this.pos.x > simWidth + this.radius) {
                    Enemy = [];
                    sayByeBye = false;
                }
            }

            //  STEER IN GUN DIRECTION  ----------
            var speedLimit = 0.6;
            var aimVector = new Vector2(Math.cos(this.gunAngle), Math.sin(this.gunAngle))
            aimVector.scale(0.5);
            this.vel.add(aimVector, dT) 
            if (this.vel.length() > speedLimit) {  
                this.vel.scale(0.99);
            }

            //  RAISE EYEBROWS  ----------
            if (this.vel.x >= 0) {
                eyeLiftL = 0;
                eyeLiftR = -0.03 * this.radius;
            } else {
                eyeLiftL = -0.03 * this.radius;
                eyeLiftR = 0;
            }

            //  LAUGH  -----------
            if (this.lol == true) {
                if ((Date.now() - lolStart) / 1000 > lolTime) {
                    this.lol = false;
                } else {
                    lol += 0.2;
                    lolAdjY = 1.5 * Math.abs(Math.sin(lol));
                    toothAdj = 0.05 * Math.abs(Math.sin(lol)) - 0.1 * this.radius;
                }
            } else {
                lolAdjY = 1;
                toothAdj = 0;
                lolTime = 1.0 + 3.0 * Math.random();
            }

            //  SPAWN IDLE Exhaustlets  ----------
            spawnIdleExhaustlets(this.pos.x, this.pos.y, 0, 'foe');
        }
        draw() {
            // START OF ALIEN--------------------
            // antennas  ----------
            c.fillStyle = 'green';
            c.strokeStyle = 'green';
            c.lineWidth = 0.005 * cScale;
            c.beginPath();
            c.moveTo((this.pos.x + 0.04 * this.radius) * cScale, (this.pos.y - 0.5 * this.radius) * cScale);
            c.lineTo((this.pos.x + 0.18 * this.radius) * cScale, (this.pos.y - 0.8 * this.radius) * cScale);

            c.moveTo(this.pos.x * cScale, (this.pos.y - 0.5 * this.radius) * cScale);
            c.lineTo(this.pos.x * cScale, (this.pos.y - 0.8 * this.radius) * cScale);

            c.moveTo((this.pos.x - 0.04 * this.radius) * cScale, (this.pos.y - 0.5 * this.radius) * cScale);
            c.lineTo((this.pos.x - 0.18 * this.radius) * cScale, (this.pos.y - 0.8 * this.radius) * cScale);
            c.closePath();
            c.stroke();

            //  antenna knobs  ----------
            knobLight += 0.01;
            var knobHue = 360 * Math.cos(knobLight);
            //c.fillStyle = 'deeppink';
            c.fillStyle = `hsl(${90 + knobHue}, 90%, 50%)`;
            drawCircle((this.pos.x + 0.18 * this.radius) * cScale, (this.pos.y - 0.8 * this.radius) * cScale, 0.045 * this.radius * cScale);
            c.fill();
            //c.fillStyle = 'gold';
            c.fillStyle = `hsl(${180 + knobHue}, 90%, 50%)`;
            drawCircle(this.pos.x * cScale, (this.pos.y - 0.8 * this.radius) * cScale, 0.045 * this.radius * cScale);
            c.fill();
            //c.fillStyle = 'orangered';
            c.fillStyle = `hsl(${270 + knobHue}, 90%, 50%)`;
            drawCircle((this.pos.x - 0.18 * this.radius) * cScale, (this.pos.y - 0.8 * this.radius) * cScale, 0.045 * this.radius * cScale);
            c.fill();
            
            //  head/body  ----------
            c.fillStyle = 'hsl(110, 100%, 50%)';
            drawVertEllipse(this.pos.x * cScale, (this.pos.y - 0.3 * this.radius) * cScale, 0.4 * this.radius * cScale);
            c.fill();

            //  mouth  ----------
            c.fillStyle = 'black';
            drawCustomEllipse(this.pos.x * cScale, (this.pos.y - 0.4 * this.radius) * cScale, 0.21 * this.radius * cScale, lolAdjY * 0.35);
            c.fill();

            //  teeth: draw two small triangular teeth positioned relative to the mouth ellipse
            c.fillStyle = 'hsl(0, 0%, 90%)';
            // mouth center in canvas coords
            const mx = this.pos.x * cScale;
            const my = (this.pos.y - 0.4 * this.radius) * cScale;
            // mouth radii (matches drawCustomEllipse usage)
            const mouthRx = 0.21 * this.radius * cScale;
            const mouthRy = (lolAdjY * 0.35) * mouthRx; // scaleY * radius
            // place teeth just under the top rim of the mouth
            const toothTopY = my - 0.9 * mouthRy; // slightly below the topmost point
            const toothHeight = 0.08 * this.radius * cScale;
            const toothHalfWidth = 0.03 * this.radius * cScale;
            const toothXOffset = 0.08 * this.radius * cScale;

            // right tooth  ---------
            c.beginPath();
            c.moveTo(mx + toothXOffset, toothTopY + toothHeight);
            c.lineTo(mx + toothXOffset - toothHalfWidth, toothTopY);
            c.lineTo(mx + toothXOffset + toothHalfWidth, toothTopY);
            c.closePath();
            c.fill();

            // left tooth  ---------
            c.beginPath();
            c.moveTo(mx - toothXOffset, toothTopY  + toothHeight);
            c.lineTo(mx - toothXOffset - toothHalfWidth, toothTopY);
            c.lineTo(mx - toothXOffset + toothHalfWidth, toothTopY);
            c.closePath();
            c.fill();
            
            //  eyebrows  ----------
            c.lineWidth = .008 * cScale;
            c.strokeStyle = 'black'
            c.beginPath();
            c.moveTo((this.pos.x + 0.04 * this.radius) * cScale, (this.pos.y - 0.52*(1.02) * this.radius) * cScale);
            c.lineTo((this.pos.x + 0.13 * this.radius) * cScale, (this.pos.y - 0.55*(1.07) * this.radius + eyeLiftR) * cScale);
            c.moveTo((this.pos.x - 0.04 * this.radius) * cScale, (this.pos.y - 0.52*(1.02) * this.radius) * cScale);
            c.lineTo((this.pos.x - 0.13 * this.radius) * cScale, (this.pos.y - 0.55*(1.07) * this.radius + eyeLiftL) * cScale);
            c.closePath();
            c.stroke();

            //  eyes  ----------
            c.lineWidth = .006 * cScale;
            c.strokeStyle = 'white'
            c.beginPath();
            c.moveTo((this.pos.x + 0.04 * this.radius) * cScale, (this.pos.y - 0.52 * this.radius) * cScale);
            c.lineTo((this.pos.x + 0.13 * this.radius) * cScale, (this.pos.y - 0.55 * this.radius + eyeLiftR) * cScale);
            c.moveTo((this.pos.x - 0.04 * this.radius) * cScale, (this.pos.y - 0.52 * this.radius) * cScale);
            c.lineTo((this.pos.x - 0.13 * this.radius) * cScale, (this.pos.y - 0.55 * this.radius + eyeLiftL) * cScale);
            c.closePath();
            c.stroke();

            //  pupils  ----------
            c.fillStyle = 'red';
            drawCircle((this.pos.x + 0.065 * this.radius + eyeLiftL) * cScale, (this.pos.y - 0.53 * this.radius) * cScale, 0.004 * cScale);
            c.fill();
            drawCircle((this.pos.x - 0.065 * this.radius - eyeLiftR) * cScale, (this.pos.y - 0.53 * this.radius) * cScale, 0.004 * cScale);
            c.fill();

            // 'stache  ----------
            c.lineWidth = .003 * cScale;
            c.strokeStyle = 'black';
            c.beginPath();
            c.moveTo((this.pos.x - 0.03 * this.radius) * cScale, (this.pos.y - 0.48 * this.radius) * cScale);
            c.lineTo((this.pos.x + 0.03 * this.radius) * cScale, (this.pos.y - 0.48 * this.radius) * cScale);
            c.closePath();
            c.stroke();

            //  SPEECH BUBBLE  ----------
            if (this.lol == true && gameIdle != true) {
                c.fillStyle = 'hsl(0, 0%, 80%)';
                c.strokeStyle = 'hsl(0, 0%, 80%)';
                c.lineWidth = 2;

                var eX = 0.2 * cScale;
                var eY = 0.125 * cScale;
                var posX = this.pos.x * cScale;
                var posY = (this.pos.y - 2.5 * this.radius) * cScale;
                c.beginPath();
                c.moveTo(posX + eX * .75, posY + eY * .25);
                c.quadraticCurveTo(posX + eX * .25, posY + eY * .25, posX + eX * .25, posY + eY * .625);
                c.quadraticCurveTo(posX + eX * .25, posY + eY * 1.00, posX + eX * .50, posY + eY * 1.00);
                c.quadraticCurveTo(posX + eX * .50, posY + eY * 1.20, posX + eX * .30, posY + eY * 1.25);
                c.quadraticCurveTo(posX + eX * .60, posY + eY * 1.20, posX + eX * .65, posY + eY * 1.00);
                c.quadraticCurveTo(posX + eX * 1.25, posY + eY * 1.00, posX + eX * 1.25, posY + eY * .625);
                c.quadraticCurveTo(posX + eX * 1.25, posY + eY * .25, posX + eX * .75, posY + eY * .25);
                c.closePath();
                c.stroke();

                c.fillStyle = 'yellow';
                c.textBaseline = 'middle';
                c.textAlign = "center";
                c.font = `${0.3 * this.radius * cScale}px monospace`;
                c.fillText(trash, (this.pos.x + 1.5*this.radius) * cScale, (this.pos.y - 1.65 * this.radius) * cScale);
            }
            //  END OF ALIEN----------

            // dome  ----------
            var domeGradient = c.createRadialGradient(
                this.pos.x * cScale, 
                (this.pos.y - 0.3 * this.radius) * cScale,
                0, 
                this.pos.x * cScale, 
                (this.pos.y - 0.3 * this.radius) * cScale,
                0.65 * this.radius * cScale);
            var shadow = `hsla(0, 0%, 50%, 20%)`;
            var highlight = `hsla(230, 50%, 80%, 70%)`;
            domeGradient.addColorStop(0.6, shadow);
            domeGradient.addColorStop(1.0, highlight);
            c.fillStyle = domeGradient;
            
            c.strokeStyle = 'hsl(0, 0%, 80%)';
            c.lineWidth = 2;
            drawCircle(this.pos.x * cScale, (this.pos.y - 0.3 * this.radius) * cScale, 0.65 * this.radius * cScale);
            c.fill();
            //c.stroke();

            // left leg support  ----------
            c.strokeStyle = `hsl(60, 20%, 40%)`;
            c.lineWidth = .025 * cScale;
            c.beginPath();
            c.moveTo((this.pos.x - 0.3 * this.radius) * cScale, this.pos.y * cScale);
            c.lineTo((this.pos.x - 0.52 * this.radius) * cScale, (this.pos.y + 0.440 * this.radius) * cScale);
            c.closePath();
            c.stroke();

            // right leg support  ----------
            c.beginPath();
            c.moveTo((this.pos.x + 0.3 * this.radius) * cScale, this.pos.y * cScale);
            c.lineTo((this.pos.x + 0.52 * this.radius) * cScale, (this.pos.y + 0.440 * this.radius) * cScale);
            c.closePath();
            c.stroke();

            // left leg  ----------
            c.strokeStyle = `hsl(0, 0%, 80%)`;
            c.lineWidth = .007 * cScale;
            c.beginPath();
            c.moveTo((this.pos.x - 0.3 * this.radius) * cScale, this.pos.y * cScale);
            c.lineTo((this.pos.x - 0.7 * this.radius) * cScale, (this.pos.y + 0.8 * this.radius) * cScale);
            c.closePath();
            c.stroke();

            // right leg  ----------
            c.beginPath();
            c.moveTo((this.pos.x + 0.3 * this.radius) * cScale, this.pos.y * cScale);
            c.lineTo((this.pos.x + 0.7 * this.radius) * cScale, (this.pos.y + 0.8 * this.radius) * cScale);
            c.closePath();
            c.stroke();

            // left foot  ----------
            c.strokeStyle = `hsl(0, 0%, 80%)`;
            c.fillStyle = 'hsl(0, 30%, 30%)';
            c.lineWidth = .003 * cScale;
            c.beginPath();
            c.ellipse(
                (this.pos.x - 0.7 * this.radius) * cScale, 
                (this.pos.y + 0.8 * this.radius) * cScale, 
                0.15 * this.radius * cScale, 
                0.1 * this.radius * cScale, 
                0, 
                0,
                3.14,
                false);
            c.closePath();
            c.fill();
            c.stroke();

            // right foot  ----------
            c.beginPath();
            c.ellipse(
            (this.pos.x + 0.7 * this.radius) * cScale, 
            (this.pos.y + 0.8 * this.radius) * cScale, 
            0.15 * this.radius * cScale, 
            0.1 * this.radius * cScale, 
            0, 
            0,
            3.14,
            false);
            c.closePath();
            c.fill();
            c.stroke();

            // fuselage  ----------
            var bodyGradient = c.createRadialGradient(
                this.pos.x * cScale, 
                (this.pos.y - 0.85 * this.radius) * cScale,
                0, 
                this.pos.x * cScale, 
                (this.pos.y - 0.85 * this.radius) * cScale,
                1 * this.radius * cScale);
            
            var highlight = `hsl(335, 100%, 100%)`;
            var midtone = `hsl(335, 80%, 50%)`;
            var shadow = `hsl(335, 50%, 20%)`;
            bodyGradient.addColorStop(0.0, highlight);
            bodyGradient.addColorStop(0.7, midtone);
            bodyGradient.addColorStop(1.0, shadow);
            c.fillStyle = bodyGradient;

            // fuselage fill  -----------
            c.lineWidth = .004 * cScale;
            c.strokeStyle = `hsl(0, 0%, 80%)`;
            drawHorizEllipse(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale);
            c.fill();

            //  small latitudes  ----------
            c.lineWidth = .002 * cScale;
            c.strokeStyle = `hsl(0, 0%, 20%)`;
            c.beginPath();
            c.ellipse(
                this.pos.x * cScale, 
                (this.pos.y - 0.33 * this.radius) * cScale, 
                0.4 * this.radius * cScale, 
                0.05 * this.radius * cScale, 
                0, 
                0,
                3.1,
                false);
            c.stroke();
            
            c.beginPath();
            c.ellipse(
                this.pos.x * cScale, 
                (this.pos.y + 0.33 * this.radius) * cScale, 
                0.4 * this.radius * cScale, 
                0.05 * this.radius * cScale, 
                0, 
                0,
                3.1,
                true);
            //c.closePath();
            c.stroke();

            //  mid latitudes  ----------
            //c.lineWidth = .006 * cScale;
            c.beginPath();
            c.ellipse(
                this.pos.x * cScale, 
                (this.pos.y - 0.29 * this.radius) * cScale, 
                0.67 * this.radius * cScale, 
                0.09 * this.radius * cScale, 
                0, 
                0.35,
                2.85,
                false);
            c.stroke();

            c.beginPath();
            c.ellipse(
                this.pos.x * cScale, 
                (this.pos.y + 0.3 * this.radius) * cScale, 
                0.67 * this.radius * cScale, 
                0.09 * this.radius * cScale, 
                0, 
                -0.35,
                -2.85,
                true);
            c.stroke();

            //  big latitudes, top  ----------
            //c.lineWidth = .004 * cScale;
            c.beginPath();
            c.ellipse(
                this.pos.x * cScale, 
                (this.pos.y - 0.2 * this.radius) * cScale, 
                0.8 * this.radius * cScale, 
                0.09 * this.radius * cScale, 
                0, 
                -.2,
                3.3,
                false);
            c.stroke();

            c.beginPath();
            c.ellipse(
                this.pos.x * cScale, 
                (this.pos.y + 0.2 * this.radius) * cScale, 
                0.8 * this.radius * cScale, 
                0.09 * this.radius * cScale, 
                0,  
                0.2,
                -3.3,
                true);
            c.stroke();

            //  equator  ----------
            //c.lineWidth = .003 * cScale;
            c.beginPath();
            c.moveTo((this.pos.x - this.radius) * cScale, this.pos.y * cScale);
            c.lineTo((this.pos.x + this.radius) * cScale, this.pos.y * cScale);
            c.closePath();
            c.stroke();

            //  sectors  ----------
            //c.strokeStyle = `hsl(0, 0%, 80%)`;
            drawHorizEllipse2(this.pos.x * cScale, this.pos.y * cScale, 0.9 * this.radius * cScale);
            c.stroke();
            drawHorizEllipse2(this.pos.x * cScale, this.pos.y * cScale, 0.6 * this.radius * cScale);
            c.stroke();
            drawHorizEllipse2(this.pos.x * cScale, this.pos.y * cScale, 0.23 * this.radius * cScale);
            c.stroke();

            // fuselage outline  -----------
            c.lineWidth = .003 * cScale;
            c.strokeStyle = `hsl(0, 20%, 70%)`;
            drawHorizEllipse(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale);
            c.stroke();
            
            // portholes  ----------
            c.strokeStyle = 'white';
            c.fillStyle = 'hsl(0, 0%, 20%)';
            c.lineWidth = .007 * cScale;
            drawVertEllipse((this.pos.x - 0.72 * this.radius) * cScale, this.pos.y * cScale, 0.07 * this.radius * cScale);
            c.stroke();
            c.fill();
            drawVertEllipse((this.pos.x - 0.38 * this.radius) * cScale, this.pos.y * cScale, 0.12 * this.radius * cScale);
            c.stroke();
            c.fill();
            drawCircle((this.pos.x - 0.00 * this.radius) * cScale, this.pos.y * cScale, 0.14 * this.radius * cScale);
            c.stroke();
            c.fill();
            drawVertEllipse((this.pos.x + 0.38 * this.radius) * cScale, this.pos.y * cScale, 0.12 * this.radius * cScale);
            c.stroke();
            c.fill();
            drawVertEllipse((this.pos.x + 0.72 * this.radius) * cScale, this.pos.y * cScale, 0.07 * this.radius * cScale);
            c.stroke();
            c.fill();

            // blinky lights  ----------
            c.fillStyle = `orange`;
            var secFrac = new Date().getMilliseconds()/1000;
            if (secFrac < 1/12) {
                // no lights'
            } else 
            if (secFrac < 2/12) {
                // light up #1
                drawVertEllipse((this.pos.x - 0.72 * this.radius) * cScale, this.pos.y * cScale, 0.07 * this.radius * cScale);
                c.fill();
            } else 
            if (secFrac < 3/12) {
                // light up #2
                drawVertEllipse((this.pos.x - 0.38 * this.radius) * cScale, this.pos.y * cScale, 0.12 * this.radius * cScale);
                c.fill();
            } else 
            if (secFrac < 4/12) {
                // light up #3
                drawCircle((this.pos.x - 0.00 * this.radius) * cScale, this.pos.y * cScale, 0.14 * this.radius * cScale);
                c.fill();
            } else 
            if (secFrac < 5/12) {
                // light up #4
                drawVertEllipse((this.pos.x + 0.38 * this.radius) * cScale, this.pos.y * cScale, 0.12 * this.radius * cScale);
                c.fill();
            } else
            if (secFrac < 6/12) {
                // light up #5
                drawVertEllipse((this.pos.x + 0.72 * this.radius) * cScale, this.pos.y * cScale, 0.07 * this.radius * cScale);
                c.fill();
            } else
            if (secFrac < 7/12) {
                // no lights
            } else 
            if (secFrac < 8/12) {
                // light up #5
                c.fillStyle = `hsl(320, 90%, 50%)`;
                drawVertEllipse((this.pos.x + 0.72 * this.radius) * cScale, this.pos.y * cScale, 0.07 * this.radius * cScale);
                c.fill();
            } else 
            if (secFrac < 9/12) {
                // light up #4
                c.fillStyle = `hsl(320, 90%, 50%)`;
                drawVertEllipse((this.pos.x + 0.38 * this.radius) * cScale, this.pos.y * cScale, 0.12 * this.radius * cScale);
                c.fill();
            } else 
            if (secFrac < 10/12) {
                // light up #3
                c.fillStyle = `hsl(320, 90%, 50%)`;
                drawCircle((this.pos.x - 0.00 * this.radius) * cScale, this.pos.y * cScale, 0.14 * this.radius * cScale);
                c.fill();
            } else 
            if (secFrac < 11/12) {
                // light up #2
                c.fillStyle = `hsl(320, 90%, 50%)`;
                drawVertEllipse((this.pos.x - 0.38 * this.radius) * cScale, this.pos.y * cScale, 0.12 * this.radius * cScale);
                c.fill();
            } else
            if (secFrac < 12/12) {
                // light up #1
                c.fillStyle = `hsl(320, 90%, 50%)`;
                drawVertEllipse((this.pos.x - 0.72 * this.radius) * cScale, this.pos.y * cScale, 0.07 * this.radius * cScale);
                c.fill();
            } 

            //  gun  ----------
            bbl = 0.7 * this.radius + 0.5 * this.radius * (Date.now() - enemyShotBirthday) / 1000;
            if (bbl >= 1.2 * this.radius) {
                bbl = 1.2 * this.radius;
            }

            //  muzzle  ----------
            var offset = 0.15 * this.radius;
            c.strokeStyle = 'yellow';
            c.lineWidth = 0.025 * cScale;
            c.beginPath();
            c.moveTo((this.pos.x + offset * Math.cos(this.gunAngle)) * cScale, (this.pos.y + offset * Math.sin(this.gunAngle)) * cScale);
            c.lineTo((this.pos.x + bbl*(1.0) * Math.cos(this.gunAngle)) * cScale, (this.pos.y + bbl*(1.0) * Math.sin(this.gunAngle)) * cScale);
            c.closePath();
            c.stroke();

            // bbl  ---------
            c.strokeStyle = `hsl(0, 0%, 30%)`;
            c.lineWidth = 0.025 * cScale;
            c.beginPath();
            c.moveTo((this.pos.x + offset * Math.cos(this.gunAngle)) * cScale, (this.pos.y + offset * Math.sin(this.gunAngle)) * cScale);
            c.lineTo((this.pos.x + bbl*(.85) * Math.cos(this.gunAngle)) * cScale, (this.pos.y + bbl*(.85) * Math.sin(this.gunAngle)) * cScale);
            c.closePath();
            c.stroke();

            c.strokeStyle = 'cyan';
            c.lineWidth = 0.020 * cScale;
            c.beginPath();
            c.moveTo((this.pos.x + offset * Math.cos(this.gunAngle)) * cScale, (this.pos.y + offset * Math.sin(this.gunAngle)) * cScale);
            c.lineTo((this.pos.x + bbl*(0.85) * Math.cos(this.gunAngle)) * cScale, (this.pos.y + bbl*(0.85) * Math.sin(this.gunAngle)) * cScale);
            c.closePath();
            c.stroke();

            //  butt  ----------
            c.strokeStyle = `hsl(0, 0%, 30%)`;
            c.lineWidth = 0.04 * cScale;
            c.beginPath();
            c.moveTo((this.pos.x + offset * Math.cos(this.gunAngle)) * cScale, (this.pos.y + offset * Math.sin(this.gunAngle)) * cScale);
            c.lineTo((this.pos.x + 1.2*this.radius*(.4) * Math.cos(this.gunAngle)) * cScale, (this.pos.y + 1.2*this.radius*(.4) * Math.sin(this.gunAngle)) * cScale);
            c.closePath();
            c.stroke();

            c.strokeStyle = 'cyan';
            c.lineWidth = 0.03 * cScale;
            c.beginPath();
            c.moveTo((this.pos.x + offset * Math.cos(this.gunAngle)) * cScale, (this.pos.y + offset * Math.sin(this.gunAngle)) * cScale);
            c.lineTo((this.pos.x + 1.2*this.radius*(0.4) * Math.cos(this.gunAngle)) * cScale, (this.pos.y + 1.2*this.radius*(0.4) * Math.sin(this.gunAngle)) * cScale);
            c.closePath();
            c.stroke();
            
            //  bore  ----------
            c.strokeStyle = 'hsl(0, 0%, 15%)';
            c.lineWidth = 0.005 * cScale;
            c.beginPath();
            c.moveTo((this.pos.x + offset * Math.cos(this.gunAngle)) * cScale, (this.pos.y + offset * Math.sin(this.gunAngle)) * cScale);
            c.lineTo((this.pos.x + bbl*(1.0) * Math.cos(this.gunAngle)) * cScale, (this.pos.y + bbl*(1.0) * Math.sin(this.gunAngle)) * cScale);
            c.closePath();
            c.stroke();

            //  gun mount  ----------
            c.strokeStyle = 'cyan';
            c.lineWidth = 0.01 * cScale;
            drawCircle(this.pos.x * cScale, this.pos.y * cScale, offset * cScale);
            c.stroke();

            c.strokeStyle = 'black';
            c.lineWidth = 0.005 * cScale;
            drawCircle(this.pos.x * cScale, this.pos.y * cScale, 0.17 * this.radius * cScale);
            c.stroke();

            /*//  draw enemy aiming target point  -----------
            c.strokeStyle = `white`;
            c.beginPath();
            c.moveTo((targetImage.x - 0.1 * this.radius)* cScale, targetImage.y * cScale);
            c.lineTo((targetImage.x + 0.1 * this.radius)* cScale, targetImage.y * cScale);
            c.moveTo(targetImage.x * cScale, (targetImage.y - 0.1 * this.radius) * cScale);
            c.lineTo(targetImage.x * cScale, (targetImage.y + 0.1 * this.radius) * cScale);
            c.stroke();*/
        }
    }

    //  SPAWN ENEMY ENEMY  -------------------
    function spawnEnemy() {
        var go = 0
        if (Math.random() < 0.5) {
            var pos = new Vector2(-0.2 * simWidth, 0.1 * simHeight + 0.8 * Math.random() * simHeight);
        } else {
            var pos = new Vector2(1.2 * simWidth, 0.1 * simHeight + 0.8 * Math.random() * simHeight);
        }
        var vel = new Vector2(0, 0);
        var radius = 0.10;
        var gunAngle = 0;
        var start = true;
        var lol = false;
        var birthday = Date.now();
        trash = TrashTalk[Math.floor(Math.random() * TrashTalk.length)];

        Enemy.push(new ENEMY(pos, vel, radius, gunAngle, start, lol, birthday));
    }

    //  DEFINE TORPEDO  -----------------
    class TORPEDO {
        constructor(pos, vel, squangle, radius, hue, friendOrFoe) {
            this.pos = pos.clone();
            this.vel = vel.clone();
            this.squangle = squangle;
            this.radius = radius;
            this.hue = hue;
            this.friendOrFoe = friendOrFoe;
        }
        get left() {
            return this.pos.x - this.radius;
        }
        get right() {
            return this.pos.x + this.radius;
        }
        simulate() {
            this.pos.add(this.vel, dT);
            if (this.friendOrFoe == 'foe') {
                if (this.vel.x > 0) {
                    this.squangle += 1;
                } else {
                    this.squangle -= 1;
                }
            }
        }
        draw() {
            if (this.friendOrFoe == 'foe') {
                const points = 4;
                const starWedges = Math.PI / points;
                var radius = 1.5 * this.radius; // + 0.5 * this.radius * Math.cos(2*this.squangle);
                var innerRadius = 0.4 * radius;
                var outerRadius = 1.4 * radius;
                //function spawnParticleDebris(origin, radius, hue1, hue2, sat, debrisQuant, debrisVel, type)
                spawnParticleDebris(this.pos, 0.003, 60, 60, 100, 20, 0.4, 'torpedo');
                //  draw star-shapee torpedo  ----------
                c.beginPath();
                for (var v = 0; v < 2 * points; v++) {
                    if (v == 0) {
                        c.moveTo((this.pos.x + innerRadius * Math.cos(this.squangle + v * starWedges)) * cScale, (this.pos.y + innerRadius * Math.sin(this.squangle + v * starWedges)) * cScale);
                    } else 
                    if (v % 2 == 0) {  //inner
                        c.lineTo((this.pos.x + innerRadius * Math.cos(this.squangle + v * starWedges)) * cScale, (this.pos.y + innerRadius * Math.sin(this.squangle + v * starWedges)) * cScale);
                    } else {  //outer
                        c.lineTo((this.pos.x + outerRadius * Math.cos(this.squangle + v * starWedges)) * cScale, (this.pos.y + outerRadius * Math.sin(this.squangle + v * starWedges)) * cScale);
                    }
                }
                c.closePath();
                c.fillStyle = `yellow`;
                c.fill();
                c.lineWidth = 0.15 * this.radius * cScale;
                c.strokeStyle = `cyan`;
                c.stroke();
            } else {
                if (debrisPassOne == true) {
                    spawnParticleDebris(this.pos, 0.003, this.hue, this.hue, 100, 2, 0.2, 'torpedo');
                    debrisPassOne = false;
                } else {
                    debrisPassOne = true;
                }
                drawCircle(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale);
                //c.fillStyle = `hsl(${this.hue}, ${40 + 70 * Math.random()}%, ${40 + 50 * Math.random()}%)`;
                //c.fillStyle = `hsl(${this.hue}, ${40 + 60 * Math.random()}%, ${40 + 40 * Math.random()}%)`;
                c.fillStyle = `hsl(${this.hue}, 100%, ${40 + 40 * Math.random()}%)`;
                c.fill();
            }
            
        }
    }

    //  SPAWN PLAYER TORPEDO  -----------------
    function spawnTorpedo() {
        if (bombsAway == false) {
            var numTorpedos = weaponLevel + 1;
            if (numTorpedos > 7) {
                numTorpedos = 7;
            }
            var spread = 0.2;
        var roket = Roket[0];
        var torpSpeed = 2;
        var tipOffset = 0.9 * roket.radius;
        if (weaponLevel > maxWeaponLevel - 1) {
            wagTorpedoIndex += 1;
            var wagTorpedos = 0.1 * Math.PI * Math.sin(wagTorpedoIndex);
        } else {
            var wagTorpedos = 0;
        }
        
        for (var i = 0; i < numTorpedos; i++) {
            bombsAway = true;
            var t = i - (numTorpedos - 1) / 2;
            var angleOffset = (weaponLevel == 1) ? (t * spread - 0.1) : (t * spread);
            //  calculate tip position  ----------
            var tipX = roket.pos.x + tipOffset * Math.cos(roket.angle);
            var tipY = roket.pos.y + tipOffset * Math.sin(roket.angle);
            var tipPos = new Vector2(tipX, tipY);
            var torpVel = new Vector2(
                roket.vel.x + torpSpeed * Math.cos(roket.angle + angleOffset + wagTorpedos),
                roket.vel.y + torpSpeed * Math.sin(roket.angle + angleOffset + wagTorpedos)
            );
            var squangle = 0;
            var radius = 0.012;
            rainbowTorpedoIndex += 5;
            if (rainbowTorpedoIndex > 360) {
                rainbowTorpedoIndex -= 360;
            }
            var hue = (weaponLevel < maxWeaponLevel - 2)
                ? 0
                : rainbowTorpedoIndex;
            var friendly = 'friend';
            torpedosFired += 1;

            Torpedo.push(new TORPEDO(tipPos, torpVel, squangle, radius, hue, friendly));
        }
        //  PLAYER TORPEDO FIRE RATE  -----------
        if (weaponLevel < maxWeaponLevel - 1) {
            var torpedoFireRate = 100;
        } else {
            var torpedoFireRate = 33.3;
        }
        
        setTimeout(() => { bombsAway = false }, torpedoFireRate);
        } 
    }

    //  SPAWN ENEMY TORPEDO  -----------------
    // Helper: Calculate intercept angle for leading a moving target
    function getInterceptAngle(enemyPos, roketPos, roketVel, torpSpeed) {
        const dx = roketPos.x - enemyPos.x;
        const dy = roketPos.y - enemyPos.y;
        const dvx = roketVel.x;
        const dvy = roketVel.y;

        // Quadratic formula coefficients
        const a = dvx * dvx + dvy * dvy - torpSpeed * torpSpeed;
        const b = 2 * (dx * dvx + dy * dvy);
        const c = dx * dx + dy * dy;

        // Solve for t (time to intercept)
        const disc = b * b - 4 * a * c;
        if (disc < 0 || Math.abs(a) < 1e-6) {
            // No solution, aim directly at current position
            return Math.atan2(dy, dx);
        }
        const t1 = (-b + Math.sqrt(disc)) / (2 * a);
        const t2 = (-b - Math.sqrt(disc)) / (2 * a);
        const t = Math.max(t1, t2, 0.01); // pick the positive, nonzero time

        // Predicted position
        const tx = roketPos.x + roketVel.x * t;
        const ty = roketPos.y + roketVel.y * t;
        return Math.atan2(ty - enemyPos.y, tx - enemyPos.x);
    }

    function spawnEnemyTorpedo() {
        var enemy = Enemy[0];
        var roket = Roket[0];
        var torpSpeed = 1;

        // Calculate intercept angle
        var interceptAngle = getInterceptAngle(
            enemy.pos,
            roket.pos,
            roket.vel,
            torpSpeed
        );

        var pos = new Vector2(
            enemy.pos.x + 1 * enemy.radius * Math.cos(interceptAngle),
            enemy.pos.y + 1 * enemy.radius * Math.sin(interceptAngle)
        );
        var torpVel = new Vector2(
            torpSpeed * Math.cos(interceptAngle),
            torpSpeed * Math.sin(interceptAngle)
        );
        var radius = 0.015;
        var color = 'yellow';
        var friendly = 'foe';
        bbl = 0.06;
        enemyShotBirthday = Date.now();
        spawnMuzzleFlash(interceptAngle);

        Torpedo.push(new TORPEDO(pos, torpVel, interceptAngle, radius, color, friendly));
    }

    //  DEFINE ROIDS  -----------------
    class ROID {
        constructor (type, pos, vel, radius, mass, hue, saturation, lightness, 
        polkaSeed, randomNo, yaw, pitch, roll) {
            this.type = type;
            this.pos = pos.clone();
            this.vel = vel.clone();
            this.radius = radius;
            this.originalRadius = radius;
            this.mass = mass;
            this.hue = hue;
            this.saturation = saturation;
            this.lightness = lightness;
            this.polkaSeed = polkaSeed;
            this.randomNo = randomNo;
            this.spinAngle = 0;
            this.polkadotFlashTimer = 0;
            // initialize eyeball state object when requested
            if (this.type == 'eyeball') {
                this.eyeball = {
                    lookAngle: 0,
                    targetAngle: 0,
                    lastGlanceTime: Date.now(),
                    glanceInterval: 1000,
                    lookAtRocketUntil: 0,
                    // collision-based point look (preferred over looking at Roket)
                    lookAtPointX: 0,
                    lookAtPointY: 0,
                    lookAtPointUntil: 0,
                    irisOffset: 0,
                    // transient spin animation (radians)
                    spinRotation: 0,
                    spinStart: 0,
                    spinDuration: 0,
                    spinTarget: 0,
                    spinActive: false
                    ,
                    // pupil sizing & animation: scale is fraction of iris radius used for pupil
                    pupilScale: 0.45,
                    // remember the original (rest) pupil scale so shrink never exceeds half of this
                    pupilOriginalScale: 0.45,
                    // animation state for smooth pupil size changes
                    pupilAnimActive: false,
                    pupilAnimStart: 0,
                    pupilAnimDuration: 0,
                    pupilAnimFrom: 0,
                    pupilAnimTo: 0,
                    // flag set when a collision-induced look should trigger the shrink once rotation completes
                    shrinkOnFace: false
                    ,
                    // automatic recovery (re-expand) scheduling
                    pupilRecoveryAt: 0,       // timestamp (ms) when recovery should start
                    pupilRecoveryDelay: 1000, // ms to wait while pupil is small before re-expanding
                    pupilRecoveryDuration: 2000, // ms duration for re-expansion
                    pupilRecoveryTarget: 0    // target scale for recovery (usually original)
                };
            }
            // enable rotation only for non-globe roids (spin for polkadots)
            this.angularVelocity = this.type == 'globe' ? 0.0 : 0.01 * (Math.random() - 0.5);
            // pole spin state for globe roids (controls longitudes rotation)
            this.poleSpinAngle = Math.random() * 2 * Math.PI;
            this.poleSpinSpeed = this.type == 'globe' ? (Math.random() - 0.5) * 0.1 : 0.0;
            // orientation: store as a quaternion to avoid gimbal lock; also keep Euler cache for code compatibility
            if (this.type == 'globe') {
                this.yaw = Math.random() * 2 * Math.PI; // initial Euler cache
                this.pitch = (Math.random() - 0.5) * Math.PI; // initial Euler cache
                this.roll = Math.random() * 2 * Math.PI; // initial Euler cache
            } else {
                this.yaw = (typeof yaw === 'number') ? yaw : Math.random() * 2 * Math.PI;
                this.pitch = (typeof pitch === 'number') ? pitch : (Math.random() * Math.PI - Math.PI/2);
                this.roll = (typeof roll === 'number') ? roll : Math.random() * 2 * Math.PI;
            }
            // quaternion orientation initialized from euler cache
            this.orientation = quatFromEuler(this.yaw, this.pitch, this.roll);
            // 3D angular velocity vector (rad/frame). Keep scalar angularVelocity in sync with omega.z
            if (this.type == 'globe') {
                this.omega = {
                    x: (Math.random() - 0.5) * 0.02, // pitch rate
                    y: (Math.random() - 0.5) * 0.02, // roll rate
                    z: (Math.random() - 0.5) * 0.02  // yaw rate
                };
                // also mirror z into scalar for compatibility
                this.angularVelocity = this.omega.z;
            } else {
                this.omega = { x: 0, y: 0, z: this.angularVelocity };
            }
        }
        get left() {
            return this.pos.x - this.radius;
        }
        get right() {
            return this.pos.x + this.radius;
        }
        get top() {
            return this.pos.y - this.radius;
        }
        get bottom() {
            return this.pos.y + this.radius;
        }
        simulate() {
            this.pos.add(this.vel, dT);

            const maxSpeed = 0.5 + wave / 20;
            if (this.vel.length() > maxSpeed) {
                this.vel.x *= maxSpeed / this.vel.length();
                this.vel.y *= maxSpeed / this.vel.length();
            }

            // angular control constants (declared early so non-globe code can use them)
            const omegaDamping = 1.0; // no automatic damping: tumbling persists until another force acts
            // maximum angular rate (radians/frame) allowed per-axis to avoid runaway
            const maxOmega = 0.5;
            // maximum spin about axis (scalar spin rate applied to spinAngle/poleSpinAngle)
            const maxSpin = 0.05;

            //if (this.vel.length() < 0.05) {
            //    this.vel.scale(1.01);
            //}

            // update spin only for polkadot roids (polkadot spin)  ----------
            if (this.type == 'polkadot') {
                // clamp scalar spin to same maxSpin used for globes  ----------
                this.angularVelocity = Math.max(-maxSpin, Math.min(maxSpin, this.angularVelocity));
                this.spinAngle += this.angularVelocity;
            }
            // Integrate 3D omega into visible orientation for globe roids
            // and keep scalar angularVelocity roughly in sync with omega.z
            if (this.type == 'globe') {
                // pole spin continues to include poleSpinSpeed
                // include yaw rate (omega.z) in poleSpinAngle so visible longitude rotation follows yaw
                // clamp the resulting axial spin so roids don't spin faster than maxSpin
                let spinInc = 60 * dT * (this.poleSpinSpeed + this.omega.z);
                spinInc = Math.max(-maxSpin, Math.min(maxSpin, spinInc));
                this.poleSpinAngle += spinInc;
                if (this.poleSpinAngle > 2 * Math.PI) this.poleSpinAngle -= 2 * Math.PI;
                if (this.poleSpinAngle < -2 * Math.PI) this.poleSpinAngle += 2 * Math.PI;
                // Integrate angular velocity vector (this.omega) into quaternion orientation using small-angle quaternion
                // delta_q ~ [1, 0.5*omega*dt]
                const half_dt = 0.5 * dT;
                const dq = {
                    w: 1.0,
                    x: this.omega.x * half_dt,
                    y: this.omega.y * half_dt,
                    z: this.omega.z * half_dt
                };
                // new orientation = orientation * dq  (apply small-body-frame rotation)
                this.orientation = quatMultiply(this.orientation, dq);
                quatNormalize(this.orientation);
                // update Euler cache from quaternion for any code that still reads yaw/pitch/roll
                // conversion: yaw (Z), pitch (X), roll (Y) inverse of quatFromEuler
                const qw = this.orientation.w, qx = this.orientation.x, qy = this.orientation.y, qz = this.orientation.z;
                // yaw (Z)
                this.yaw = Math.atan2(2*(qw*qz + qx*qy), 1 - 2*(qy*qy + qz*qz));
                // pitch (X)
                const sinp = 2*(qw*qx - qy*qz);
                this.pitch = Math.abs(sinp) >= 1 ? Math.sign(sinp) * Math.PI/2 : Math.asin(sinp);
                // roll (Y)
                this.roll = Math.atan2(2*(qw*qy + qz*qx), 1 - 2*(qx*qx + qy*qy));
                // apply damping (may be 1.0 for no damping) and then clamp to max allowed rates
                this.omega.x *= omegaDamping;
                this.omega.y *= omegaDamping;
                this.omega.z *= omegaDamping;
                // clamp per-axis angular rates
                this.omega.x = Math.max(-maxOmega, Math.min(maxOmega, this.omega.x));
                this.omega.y = Math.max(-maxOmega, Math.min(maxOmega, this.omega.y));
                this.omega.z = Math.max(-maxOmega, Math.min(maxOmega, this.omega.z));
                // keep scalar angularVelocity in sync with clamped z
                this.angularVelocity = this.omega.z;
                // clamp scalar axial spin used for visual spin/pole spin
                this.angularVelocity = Math.max(-maxSpin, Math.min(maxSpin, this.angularVelocity));
            }
            
            if (this.spinAngle > 2 * Math.PI) {
                this.spinAngle -= 2 * Math.PI;
            }

            //  WRAP TO OTHER SIDE OF SCREEN  -------------------
            let isOffScreen = false;
            if (this.pos.x < -this.radius) {
                this.pos.x = simWidth + this.radius;
                isOffScreen = true;
            } else if (this.pos.x > simWidth + this.radius) {
                this.pos.x = -this.radius;
                isOffScreen = true;
            }
            if (this.pos.y < -this.radius) {
                this.pos.y = simHeight + this.radius;
                isOffScreen = true;
            } else if (this.pos.y > simHeight + this.radius) {
                this.pos.y = -this.radius;
                isOffScreen = true;
            }

            // Boost velocity if off-screen and too slow  -------------------
            if (isOffScreen == true && this.vel.length() < 0.1) {
                this.vel.scale(2.0);
            }

            //  POLKADOT FLASH TIMER  -------------------
            if (this.polkadotFlashTimer > 0) {
                this.polkadotFlashTimer -= dT;
                if (this.polkadotFlashTimer < 0) {
                    this.polkadotFlashTimer = 0;
                }
            }
            // EYEBALL behavior: random glance gaze and look atrocket override
            if (this.eyeball) {
                var now = Date.now();
                var dtSec = (this._lastEyeballTime ? (now - this._lastEyeballTime) / 1500 : 0.016);
                this._lastEyeballTime = now;
                // Priority: collision point look (lookAtPointUntil) > look at rocket (lookAtRocketUntil) > random glances
                if (now < this.eyeball.lookAtPointUntil) {
                    // look at the collision contact point
                    this.eyeball.targetAngle = Math.atan2(this.eyeball.lookAtPointY - this.pos.y, this.eyeball.lookAtPointX - this.pos.x);
                } else if (now < this.eyeball.lookAtRocketUntil && typeof Roket !== 'undefined' && Roket[0]) {
                    // look at rocket only when the rocket-timer is set (set only on player torpedo hits)
                    this.eyeball.targetAngle = Math.atan2(Roket[0].pos.y - this.pos.y, Roket[0].pos.x - this.pos.x);
                } else {
                    // schedule random glance gaze look about once per second
                    if (now - this.eyeball.lastGlanceTime > this.eyeball.glanceInterval) {
                        this.eyeball.lastGlanceTime = now + (Math.random() * 200 - 100);
                        var a = Math.random() * Math.PI * 2;
                        var r = this.radius * (0.2 + Math.random() * 0.8);
                        var tx = this.pos.x + Math.cos(a) * r;
                        var ty = this.pos.y + Math.sin(a) * r;
                        this.eyeball.targetAngle = Math.atan2(ty - this.pos.y, tx - this.pos.x);
                    }
                }

                // smoothly rotate toward targetAngle
                // If actively looking at a collision point or rocket, rotate up to 2x faster for a snappier but smooth response
                var maxTurnSpeed = 8; // default rad/sec
                if (now < this.eyeball.lookAtPointUntil || now < this.eyeball.lookAtRocketUntil) {
                    maxTurnSpeed *= 2.0; // double speed while responding to events
                }
                var angDiff = this.eyeball.targetAngle - this.eyeball.lookAngle;
                while (angDiff <= -Math.PI) angDiff += 2 * Math.PI;
                while (angDiff > Math.PI) angDiff -= 2 * Math.PI;
                var maxStep = maxTurnSpeed * dtSec;
                if (angDiff > maxStep) angDiff = maxStep;
                if (angDiff < -maxStep) angDiff = -maxStep;
                // advance look angle
                var prevLookAngle = this.eyeball.lookAngle;
                this.eyeball.lookAngle = this.eyeball.lookAngle + angDiff;

                // If we were requested to shrink on facing a collision, start pupil animation once rotation completes
                if (this.eyeball.shrinkOnFace) {
                    // determine if we've essentially reached the target (small remaining angle or overshot)
                    var remaining = Math.abs(this.eyeball.targetAngle - this.eyeball.lookAngle);
                    while (remaining > Math.PI) remaining -= 2 * Math.PI;
                    remaining = Math.abs(remaining);
                    // threshold: less than 0.02 rad (~1.1°) or if we didn't change angle this frame (snapped)
                    if (remaining < 0.02 || Math.abs(this.eyeball.lookAngle - prevLookAngle) < 1e-6) {
                        // start pupil animation if not already active
                        if (!this.eyeball.pupilAnimActive) {
                            this.eyeball.pupilAnimActive = true;
                            this.eyeball.pupilAnimStart = Date.now();
                            this.eyeball.pupilAnimFrom = this.eyeball.pupilScale;
                            // pupilAnimTo was set at collision time
                            this.eyeball.shrinkOnFace = false; // consume request
                        }
                    }
                }

                // small iris wobble
                this.eyeball.irisOffset = Math.sin(now * 0.002 + (this.randomNo || 0)) * 0.1 * this.radius;

                // transient spin animation advancement (if active)
                if (this.eyeball.spinActive) {
                    var tSpin = (now - this.eyeball.spinStart) / this.eyeball.spinDuration;
                    if (tSpin >= 1) {
                        this.eyeball.spinRotation = this.eyeball.spinTarget;
                        this.eyeball.spinActive = false;
                    } else {
                        // ease-out cubic for a snappy feel
                        var e = 1 - Math.pow(1 - tSpin, 3);
                        this.eyeball.spinRotation = this.eyeball.spinTarget * e;
                    }
                } else {
                    // keep at zero when inactive
                    this.eyeball.spinRotation = 0;
                }

                // Advance pupil size animation if active
                if (this.eyeball.pupilAnimActive) {
                    var t = (now - this.eyeball.pupilAnimStart) / this.eyeball.pupilAnimDuration;
                    if (t >= 1) {
                        this.eyeball.pupilScale = this.eyeball.pupilAnimTo;
                        this.eyeball.pupilAnimActive = false;
                        // If this was a shrink initiated by collision, schedule automatic recovery
                        // Recovery target defaults to the original-ish size (0.45) unless set otherwise
                        // restore back to the original rest scale
                        this.eyeball.pupilRecoveryTarget = this.eyeball.pupilOriginalScale || 0.45;
                        this.eyeball.pupilRecoveryAt = Date.now() + (this.eyeball.pupilRecoveryDelay || 1000);
                    } else {
                        // ease-out cubic for a smooth feel
                        var e = 1 - Math.pow(1 - t, 3);
                        this.eyeball.pupilScale = this.eyeball.pupilAnimFrom + (this.eyeball.pupilAnimTo - this.eyeball.pupilAnimFrom) * e;
                    }
                }

                // If recovery is scheduled and delay elapsed, start recovery animation
                if (!this.eyeball.pupilAnimActive && this.eyeball.pupilRecoveryAt && Date.now() >= this.eyeball.pupilRecoveryAt) {
                    // start recovery animation back to pupilRecoveryTarget over pupilRecoveryDuration
                    this.eyeball.pupilAnimActive = true;
                    this.eyeball.pupilAnimStart = Date.now();
                    this.eyeball.pupilAnimFrom = this.eyeball.pupilScale;
                    this.eyeball.pupilAnimTo = this.eyeball.pupilRecoveryTarget || 0.45;
                    this.eyeball.pupilAnimDuration = this.eyeball.pupilRecoveryDuration || 1000;
                    // clear the scheduled time so we don't restart repeatedly
                    this.eyeball.pupilRecoveryAt = 0;
                }
            }
        }
        draw() {
            if (this.type == 'suds') {
                drawCircle(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale);
                //  OVERALL BUBBLE SHADING  ----------
                var sphereGradient = c.createRadialGradient(
                    this.pos.x * cScale, 
                    this.pos.y * cScale, 
                    0, 
                    this.pos.x * cScale, 
                    this.pos.y * cScale, 
                    1 * this.radius * cScale
                );
                var highlight = `hsla(${this.hue}, 40%, 70%, 90%)`;
                var midtone = `hsla(${this.hue}, 50%, 40%, 60%)`;
                var shadow = `hsla(0, 0%, 0%, 0%)`;
                sphereGradient.addColorStop(0.0, shadow);
                sphereGradient.addColorStop(0.8, midtone);
                sphereGradient.addColorStop(1.0, highlight);
                c.fillStyle = sphereGradient;
                c.fill();
                //  HIGHLIGHT OVERLAY  ----------
                var sphereGradient = c.createRadialGradient(
                    (this.pos.x - (0.2 * this.radius)) * cScale, 
                    (this.pos.y - (0.4 * this.radius)) * cScale, 
                    0, 
                    (this.pos.x - (0.2 * this.radius)) * cScale, 
                    (this.pos.y - (0.4 * this.radius)) * cScale, 
                    1.45 * this.radius * cScale
                );
                var highlight = `hsla(${this.hue}, 20%, 60%, 100%)`;
                var midtone = `hsla(${this.hue}, 50%, 20%, 60%)`;
                var shadow = `hsla(0, 0%, 0%, 0%)`;
                sphereGradient.addColorStop(0.0, highlight);
                sphereGradient.addColorStop(0.2, midtone);
                sphereGradient.addColorStop(1.0, shadow);
                c.fillStyle = sphereGradient;
                c.fill();
                return;
            }

            if (this.type == 'eyeball') {
                //  DRAW EYEBALL ROIDS  ---------
                drawEyeballRoid(this.pos.x * cScale, this.pos.y * cScale, 
                    this.radius * cScale, this.eyeball.lookAngle, 
                    this.eyeball.irisOffset * cScale, this.hue, 
                    this.saturation, this.lightness, this.eyeball.spinRotation,
                    this.eyeball.pupilScale
                );
                return;
            }

            //  DRAW GLOBE ROIDS  ------------------------------------
            if (this.type == 'globe') {
                drawGlobeRoid(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale, 
                    this.originalRadius * cScale, this.hue, this.saturation, this.lightness, 
                    this.poleSpinAngle, this.orientation, this.polkadotFlashTimer
                );

                if (roidFill.checked == true) {
                    //  HIGHLIGHT SHADING ----------
                    drawCircle(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale);
                    var sphereGradient = c.createRadialGradient(
                        (this.pos.x - (0.3 * this.radius)) * cScale, 
                        (this.pos.y - (0.5 * this.radius)) * cScale, 
                        0, 
                        (this.pos.x - (0.3 * this.radius)) * cScale, 
                        (this.pos.y - (0.5 * this.radius)) * cScale, 
                        2 * this.radius * cScale);
                    var highlight = `hsla(${this.hue + 60}, 50%, 50%, 0.6)`;
                    var shadow = `hsla(0, 0%, 0%, 0)`;
                    sphereGradient.addColorStop(0.0, highlight);
                    sphereGradient.addColorStop(1.0, shadow);
                    c.fillStyle = sphereGradient;
                    c.fill();

                    //  OVERALL BUBBLE SHADING  ----------
                    var sphereGradient = c.createRadialGradient(
                            this.pos.x * cScale, 
                            this.pos.y * cScale, 
                            0, 
                            this.pos.x * cScale, 
                            this.pos.y * cScale, 
                            this.radius * cScale);
                    var highlight = `hsla(${this.hue + 60}, 50%, 40%, 0.5)`;
                    var midtone = `hsla(${this.hue + 60}, 50%, 20%, 0.4)`;
                    var shadow = `hsla(${this.hue + 60}, 50%, 10%, 0.2)`;
                    sphereGradient.addColorStop(0.0, shadow);
                    sphereGradient.addColorStop(0.8, midtone);
                    sphereGradient.addColorStop(1.0, highlight);
                    c.fillStyle = sphereGradient;
                    c.fill();
                    return;
                }
            }

            if (this.type == 'polkadot') {
                //  DRAW POLKADOTS HERE IF ROIDS ARE *NOT* FILLED ----------
                if (roidFill.checked != true) {
                    var polkaPulseLightness = 50 * Math.abs(Math.cos(((this.polkaSeed + Date.now()) / 2000 / this.radius)));
                    drawPolkadots(
                        this.pos.x * cScale,
                        this.pos.y * cScale,
                        this.radius * cScale,
                        6,     // quantity
                        0.3,    // fractional size of roid radius
                        this.hue,
                        this.saturation,
                        polkaPulseLightness,
                        this.lightness,
                        this.polkaSeed,
                        this.randomNo,
                        this.spinAngle || 0,
                        this.polkadotFlashTimer
                    );
                }

                //  DRAW ROID OUTLINE ------------------
                drawCircle(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale);
                //  DRAW POLKADOT ROIDS OVERALL SHADING ----------
                if (roidFill.checked == true) {
                    var sphereGradient = c.createRadialGradient(
                        (this.pos.x - (0.2 * this.radius)) * cScale, 
                        (this.pos.y - (0.4 * this.radius)) * cScale, 
                        0, 
                        (this.pos.x - (0.2 * this.radius)) * cScale, 
                        (this.pos.y - (0.4 * this.radius)) * cScale, 
                        1.5 * this.radius * cScale
                    );
                    var highlight = `hsl(${this.hue}, ${this.saturation}%, ${this.lightness}%)`;
                    var midtone = `hsl(${this.hue}, ${this.saturation - 20}%, ${this.lightness - 30}%)`;
                    var shadow = `hsl(0, ${this.saturation - 40}%, ${this.lightness - 65}%)`;
                    sphereGradient.addColorStop(0.0, highlight);
                    sphereGradient.addColorStop(0.7, midtone);
                    sphereGradient.addColorStop(1.0, shadow);
                    c.fillStyle = sphereGradient;
                    c.fill();
                } else {
                    c.strokeStyle = `hsl(${this.hue}, 80%, ${this.lightness}%)`;
                    c.lineWidth = Math.max(0.007 * cScale, 0.03 * this.radius * cScale);
                    c.stroke();
                }

                //  DRAW POLKADOTS HERE IF ROIDS ARE FILLED ----------
                if (roidFill.checked == true) {
                    var polkaPulseLightness = 50 * Math.abs(Math.cos(((this.polkaSeed + Date.now()) / 2000 / this.radius)));
                    drawPolkadots(
                        this.pos.x * cScale,
                        this.pos.y * cScale,
                        this.radius * cScale,
                        12,     // quantity
                        0.3,    // fractional size of roid radius
                        this.hue,
                        this.saturation,
                        polkaPulseLightness,
                        this.lightness,
                        this.polkaSeed,
                        this.randomNo,
                        this.spinAngle || 0,
                        this.polkadotFlashTimer
                    );
                }
                return;
            }
        }
    }

    //  ROID SPAWN POSITION HELPERS  ------------------
    function roidSpawnTopPos(radius) {
        // top
        var pos = new Vector2(
            2 * radius + Math.random() * (simWidth - 4 * radius),
            -1.0 * radius);
        return pos;
    }

    function roidSpawnBottomPos(radius) {
        // bottom
        var pos = new Vector2(
            2 * radius + Math.random() * (simWidth - 4 * radius),
            simHeight + radius);
        return pos;
    }

    function roidSpawnLeftPos(radius) {
        // left
        var pos = new Vector2(
            -1.0 * radius,
            2 * radius + Math.random() * (simHeight - 4 * radius));
        return pos;
    }

    function roidSpawnRightPos(radius) {
        // right
        var pos = new Vector2(
            simWidth + radius,
            2 * radius + Math.random() * (simHeight - 4 * radius));
        return pos;
    }

    //  ROID SPAWN VELOCITY HELPERS ---------------
    function roidSpawnTopVel(waveIncr) {
        // top
        var vel = new Vector2(
            -0.02 + 0.04 * Math.random(), 
            waveIncr * (0.1 + 0.1 * Math.random()));
        return vel;
    }
            
    function roidSpawnBottomVel(waveIncr) {
        // bottom
        var vel = new Vector2(
            -0.2 + 0.4 * Math.random(), 
            waveIncr * (-0.1 + -0.1 * Math.random()));
        return vel;
    }

    function roidSpawnLeftVel(waveIncr) {
        // left
        var vel = new Vector2(
            waveIncr * (0.1 + 0.1 * Math.random()), 
            -0.2 + 0.4 * Math.random());
        return vel;
    }
        
    function roidSpawnRightVel(waveIncr) {
        // right
        var vel = new Vector2(
            waveIncr * (-0.1 + -0.1 * Math.random()),
            -0.2 + 0.4 * Math.random());
        return vel;
    }

    //  AUTO SPAWN MODE HELPER  ----------
    function threePasser() {
        if (firstSpawnPass == true) {
            firstSpawnPass = false;
            secondSpawnPass = true;
            var type = 'polkadot';
        } else if (secondSpawnPass == true) {
            secondSpawnPass = false;
            var type = 'globe';
        } else {
            firstSpawnPass = true;
            var type = 'eyeball';
        }
        return type;
    }

    //  SPAWN ROIDS  --------------------------------------
    function spawnRoids() {
        //  SET SPAWN FREQUENCY AND GATEKEEP ----------
        if (spawnMode == 'suds') {
            if ((Date.now() - lastRoidSpawnTime) < 20) {
                return;
            }   
        } else {
            if ((Date.now() - lastRoidSpawnTime) < (3100 - (1000 * wave / 10))) {
                return;
            }
        }
        //  CHOOSE ROID IN AUTO MODE  -----------
        if (auto.checked == true) {
            spawnMode = 'other';
            if (spawnCycle == 1) {
                var type = 'polkadot';
            } else if (spawnCycle == 2) {
                var type = threePasser()
            } else if (spawnCycle == 3) {
                var type = 'globe';
            } else if (spawnCycle == 4) {
                var type = threePasser()
            } else if (spawnCycle == 5) {
                var type = 'eyeball';
            } else if (spawnCycle == 6) {
                var type = threePasser()
            } else if (spawnCycle == 7) {
                var type = 'suds';
                spawnMode = 'suds';
            } else if (spawnCycle == 8) {
                var type = threePasser()
            }
        } 
        //  BUTTON OVERRIDES  ----------
        if (polkadot.checked == true) {
            var type = 'polkadot';
            spawnMode = 'other';
        } else if (globe.checked == true) {
            var type = 'globe';
            spawnMode = 'other';
        } else if (eyeball.checked == true) {
            var type = 'eyeball';
            spawnMode = 'other';
        } else if (suds.checked == true) {
            var type = 'suds';
            spawnMode = 'suds';
        }

        //  LIMIT ROIDS PER WAVE  ----------
        if (spawnMode == 'suds') {
            var roidLimit = 250 * ((weaponLevel + 1) / 10);
        } else {
            var roidLimit = startingRoidLimit + Math.floor(wave / 3);
        }
        if (spawnCounter >= roidLimit) {
            spawning = false;
            return;
        }

        //  INCREASE ROID SPEED WITH WAVE  ----------
        var waveIncr = 4/5 + wave/5;
        var maxAttempts = 20;
        var attempts = 0;
        var spawned = false;

        // random 3D orientation  ----------
        let yaw = Math.random() * 2 * Math.PI;
        let pitch = (Math.random() - 0.5) * Math.PI; // -pi/2 .. +pi/2
        let roll = Math.random() * 2 * Math.PI;

        //  make suds  ----------
        while (!spawned && attempts < maxAttempts) {
            if (type == 'suds') {
                var radius = 0.02 + 0.02 * Math.random();
            } else {
                var radius = 0.2 + 0.2 * Math.random();
            }
            var mass = radius;
            var maxColorAngleSep = 0.5 * 360 / roidLimit;
            var colorCloseCounter = 1;
            while (colorCloseCounter > 0) {
                colorCloseCounter = 0;
                var hue = Math.random() * 360;
                for (var r = 0; r < Roids.length; r++) {
                    if (Roids[r].hue + maxColorAngleSep > hue && Roids[r].hue - maxColorAngleSep < hue ) {
                        colorCloseCounter += 1;
                    }
                }
            }
            var saturation = 30 + 70 * Math.random();
            var lightness = 40 + 50 * Math.random();
            // Pick a random side and position  ----------
            var pickSide = Math.random();
            var pos, vel;
            if (pickSide <= 0.25) {
                pos = roidSpawnTopPos(radius);
                vel = roidSpawnTopVel(waveIncr);
            } else if (pickSide <= 0.50) {
                pos = roidSpawnBottomPos(radius);
                vel = roidSpawnBottomVel(waveIncr);
            } else if (pickSide <= 0.75) {
                pos = roidSpawnLeftPos(radius);
                vel = roidSpawnLeftVel(waveIncr);
            } else {
                pos = roidSpawnRightPos(radius);
                vel = roidSpawnRightVel(waveIncr);
            }
            // Helper for safe spawn  ----------
            function isSafeRoidSpawn(x, y, radius, roids, simWidth, simHeight) {
                for (let i = 0; i < roids.length; i++) {
                    let other = roids[i];
                    let { dist } = minImageDistance(x, y, other.pos.x, other.pos.y, simWidth, simHeight);
                    if (dist < radius + other.radius + 0.1 *radius) { // 10 is a buffer, adjust as needed
                        return false;
                    }
                }
                return true;
            }
            //  SPAWN IF LOCATION SAFE  ----------
            if (isSafeRoidSpawn(pos.x, pos.y, radius, Roids, simWidth, simHeight)) {
                let seed = Math.floor(Math.random() * 0xFFFFFFFF);
                let randomNo = Math.random();

                Roids.push(new ROID(type, pos, vel, radius, mass, hue, saturation, lightness, seed, randomNo, yaw, pitch, roll, 0));
                lastRoidSpawnTime = Date.now();
                spawnCounter += 1;
                spawned = true;
            }
            attempts++;
        }
    }

    //  DEFINE BOMB  ----------
    class BOMB {
        constructor(pos, vel, radius) {
            this.pos = pos.clone();
            this.vel = vel.clone();
            this.radius = radius;
            this.mass = radius;
            this.birthday = Date.now();
            this.exploding = false;
            this.explosionTime = 0;
            this.firstPulse = true;
            this.jobDone = false;
            this.age = 0;
            this.shake = 0;
            this.shaker = 0;
            this.rando = Math.random();
        }
            startExplosion() {
                // Idempotent: if already exploding, don't restart/refresh timing
                if (this.exploding === true) return;
                // mark exploding and reset timing so radius growth starts now
                this.exploding = true;
                this.birthday = Date.now();
                if (typeof this._explosionOrigin !== 'undefined') delete this._explosionOrigin;
                this.explosionTime = this.birthday;
                    // clear any per-roket cooldown/affected flags so the explosion can
                    // immediately affect a Roket even if it was recently tumbled by this bomb
                    if (typeof this._roketLastHit !== 'undefined') this._roketLastHit = 0;
                    if (typeof this._roketAffected !== 'undefined') this._roketAffected = false;
            }
        get left() {
            return this.pos.x - this.radius;
        }
        get right() {
            return this.pos.x + this.radius;
        }
        simulate() {
            this.age = Date.now() - this.birthday;
            if (this.exploding !== true) {
                //  EXPAND BOMB BEFORE COMPRESSION  ----------
                if (this.age > 1800 && this.age < 2800) {
                    this.radius *= 1.01;
                }
                //  COMPRESS BOMB BEFORE EXPLODING  ----------
                if (this.age > 2800) {
                    this.radius *= 0.8;
                }
                // Guard: if no player roket exists, just coast
                if (!Roket || Roket.length === 0 || !Roket[0] || !Roket[0].pos) {
                    this.pos.add(this.vel, dT);
                    return;
                }

                // Tunable parameters (adjust for feel)
                const maxSpeed = 0.20 + wave / 100;      // desired top speed for the bomb
                const maxAccel = 0.30 + wave / 100;      // max change in velocity (units/sec); lower = smoother
                const angleSmoothing = 0.22; // 0 = no smoothing, 1 = instant

                // Predict intercept heading using the bomb's max speed
                const desiredAngle = getInterceptAngle(this.pos, Roket[0].pos, Roket[0].vel, maxSpeed);

                // Smooth heading to avoid rapid flips
                if (typeof this._smoothedAngle === 'undefined') this._smoothedAngle = desiredAngle;
                const a0 = this._smoothedAngle;
                let da = desiredAngle - a0;
                while (da > Math.PI) da -= 2 * Math.PI;
                while (da < -Math.PI) da += 2 * Math.PI;
                this._smoothedAngle = a0 + da * angleSmoothing;

                const desiredDir = new Vector2(Math.cos(this._smoothedAngle), Math.sin(this._smoothedAngle));

                // desired velocity vector
                const desiredVel = desiredDir.clone();
                desiredVel.scale(maxSpeed);

                // steering = desiredVel - currentVel
                const steering = desiredVel.clone();
                // Vector2.subtract(a,b) expects two args in this codebase; do component subtract here
                steering.x -= this.vel.x;
                steering.y -= this.vel.y;

                // clamp steering to maxAccel * dT so changes are smooth and framerate-independent
                const maxStep = maxAccel * dT;
                const steerLen = steering.length();
                if (steerLen > maxStep && steerLen > 0) {
                    steering.normalize();
                    steering.scale(maxStep);
                }

                // record the actual steering direction applied (after clamping)
                if (steering.x === 0 && steering.y === 0) {
                    // if no steering, prefer the smoothed desired heading or current velocity
                    if (typeof this._smoothedAngle !== 'undefined') {
                        this._steerAngle = this._smoothedAngle;
                    } else {
                        this._steerAngle = Math.atan2(this.vel.y, this.vel.x);
                    }
                } else {
                    this._steerAngle = Math.atan2(steering.y, steering.x);
                }

                // apply steering and clamp speed
                this.vel.add(steering);
                if (this.vel.length() > maxSpeed) {
                    this.vel.normalize();
                    this.vel.scale(maxSpeed);
                }

                //  UPDATE POSITION BASED ON NEW CALCULATED VELOCITY  ----------
                this.pos.add(this.vel, dT);
            } else { 
                //  BOMB IS EXPLODING  -------------------
                var elapsed = (this.age) / 1000; // seconds
                if (typeof this._explosionOrigin === 'undefined') {
                    this._explosionOrigin = this.radius; // store radius at explosion start
                }
                // peak expansion 
                var peak = Math.max(0.15, this._explosionOrigin * 8);
                // decay rate (higher => faster onset)
                var decay = 12.0;
                // exponential ease-out: origin + peak * (1 - e^{-decay * t})
                this.radius = this._explosionOrigin + peak * (1 - Math.exp(-decay * elapsed));
            }
        }
        draw() {
            this.age = Date.now() - this.birthday;
            if (this.exploding != true) {
                //  BOMB IS NOT YET EXPLODING  ----------
                //  DRAW RADAR PULSE  ---------
                c.lineWidth = 0.01 * cScale;
                for (var r = 1; r < 5; r++) {
                    c.strokeStyle = `hsla(0, ${radarPulser * 100}%, ${80}%, ${100 - radarPulser * 100}%)`;
                    var radarPulseRadius = radarPulser * 0.5 * r / 10;
                    drawCircle(this.pos.x * cScale, this.pos.y * cScale, radarPulseRadius * cScale);
                    c.stroke();
                }
                
                let whiteHot = 0;
                if (this.age > 2800) {
                    whiteHot = 30 * (this.age - 2800) / 200;
                }
                
                drawCircle(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale);
                var sphereGradient = c.createRadialGradient(
                    (this.pos.x - 0.3 * this.radius) * cScale,
                    (this.pos.y - 0.5 * this.radius) * cScale,
                    0,
                    (this.pos.x - 0.3 * this.radius) * cScale,
                    (this.pos.y - 0.5 * this.radius) * cScale,
                    1.5 * this.radius * cScale);
                var highlight = `hsl(${whiteHot}, ${100 * this.age / 3000}%, ${70}%)`;
                var midtone = `hsl(${whiteHot}, ${100 * this.age / 3000}%, ${50}%)`;
                var shadow = `hsl(0, 0%, 10%)`;
                sphereGradient.addColorStop(0.0, highlight);
                sphereGradient.addColorStop(0.5, midtone);
                sphereGradient.addColorStop(1.0, shadow);
                c.fillStyle = sphereGradient;
                c.fill();

                //  DRAW BOMB FACE  ----------
                if (this.age > 500 && this.age < 2800) {
                    //  index face shaker  ---------
                    this.shaker += this.age / 2800 * 1.0 * dT * 60;
                    if (this.shaker > 2 * Math.PI) {
                        this.shaker -= 2 * Math.PI;
                    }
                    this.shake = Math.sin(this.shaker) * 0.2 * this.radius;
                    var xPos = this.pos.x + this.shake;
                    var eyeLift = 0.25 + this.age / 2500 * 0.15;
                    var faceAlpha = Math.min(100, this.age / 2000 * 100);
                    //  draw angry lines for eyes  ---------
                    c.strokeStyle = `hsla(0, 0%, 0%, ${faceAlpha}%)`;
                    c.lineWidth = 0.12 * this.radius * cScale;
                    c.lineCap = 'butt'
                    c.beginPath();
                    c.moveTo((xPos - 0.2 * this.radius) * cScale, (this.pos.y - 0.25 * this.radius) * cScale);
                    c.lineTo((xPos - 0.55 * this.radius) * cScale, (this.pos.y - eyeLift * this.radius) * cScale);
                    c.stroke();
                    c.beginPath();
                    c.moveTo((xPos + 0.2 * this.radius) * cScale, (this.pos.y - 0.25 * this.radius) * cScale);
                    c.lineTo((xPos + 0.55 * this.radius) * cScale, (this.pos.y - eyeLift * this.radius) * cScale);
                    c.stroke();

                    //  DRAW MOUTH  ----------
                    if (this.rando < 0.33) {
                        //  POUTY MOUTH  ---------
                        //c.lineWidth = 0.006 * cScale;
                        c.beginPath();
                        c.ellipse(
                            xPos * cScale, 
                            (this.pos.y + 0.25 * this.radius) * cScale, 
                            0.22 * this.radius * cScale, 
                            (this.age / 2500) * 0.22 * this.radius * cScale, 
                            0, 
                            Math.PI, 
                            0);
                        c.stroke();
                    } else if (this.rando < 0.67) {
                        //  YELLY MOUTH  ---------
                        c.lineWidth = 0.1 * this.radius * cScale;
                        c.beginPath();
                        c.ellipse(
                            xPos * cScale, 
                            (this.pos.y + 0.25 * this.radius) * cScale, 
                            (0.05 * this.radius + (this.age / 2500) * 0.25 * this.radius) * cScale, 
                            (0.05 * this.radius +(this.age / 2500) * 0.18 * this.radius) * cScale, 
                            0, 
                            2 * Math.PI, 
                            0);
                        c.fillStyle = `hsla(0, 0%, 0%, ${faceAlpha}%)`;
                        c.fill();
                    } else {
                        // TOOTHY MOUTH  ---------
                        // white mouth
                        c.lineWidth = 0.1 * this.radius * cScale;
                        c.beginPath();
                        var longAxis = (0.05 * this.radius + (this.age / 2500) * 0.25 * this.radius);
                        var shortAxis = (0.05 * this.radius + (this.age / 2500) * 0.18 * this.radius);
                        c.ellipse(
                            xPos * cScale, 
                            (this.pos.y + 0.25 * this.radius) * cScale, 
                            longAxis * cScale,
                            shortAxis * cScale,
                            0, 
                            2 * Math.PI, 
                            0);
                        c.fillStyle = `hsla(0, 0%, 90%, ${faceAlpha}%)`;
                        c.fill();
                        // mouth outline
                        c.lineWidth = 0.04 * this.radius * cScale;
                        c.stroke();
                        //  DRAW TEETH  ---------
                        c.lineWidth = 0.06 * this.radius * cScale;
                        c.beginPath();
                        c.moveTo((xPos - longAxis) * cScale, (this.pos.y + 0.25 * this.radius) * cScale);
                        c.lineTo((xPos + longAxis) * cScale, (this.pos.y + 0.25 * this.radius) * cScale);
                        c.stroke();
                        // draw left tooth gap
                        c.lineWidth = 0.04 * this.radius * cScale;
                        c.beginPath();
                        c.moveTo((xPos - 0.5 * longAxis) * cScale, (this.pos.y + 0.25 * this.radius - 0.8 * shortAxis) * cScale);
                        c.lineTo((xPos - 0.5 * longAxis) * cScale, (this.pos.y + 0.25 * this.radius + 0.8 * shortAxis) * cScale);
                        c.stroke();
                        //  DRAW mid TOOTH gap 
                        c.beginPath();
                        c.moveTo(xPos * cScale, (this.pos.y + 0.25 * this.radius - shortAxis) * cScale);
                        c.lineTo(xPos * cScale, (this.pos.y + 0.25 * this.radius + shortAxis) * cScale);
                        c.stroke();
                        // draw right tooth gap
                        c.beginPath();
                        c.moveTo((xPos + 0.5 * longAxis) * cScale, (this.pos.y + 0.25 * this.radius - 0.8 * shortAxis) * cScale);
                        c.lineTo((xPos + 0.5 * longAxis) * cScale, (this.pos.y + 0.25 * this.radius + 0.8 * shortAxis) * cScale);
                        c.stroke();
                        c.closePath();
                    }
                }

                //  DRAW HEADING ARROW  ----------
                if (this.age < 2800) {
                    let heading;
                    if (this.vel && (this.vel.x !== 0 || this.vel.y !== 0)) {
                        heading = Math.atan2(this.vel.y, this.vel.x);
                    } else if (typeof this._smoothedAngle !== 'undefined') {
                        heading = this._smoothedAngle;
                    } else {
                        heading = 0;
                    }
                    let arrowAngle;
                    arrowAngle = 0.5 * Math.PI - heading + Math.PI;
                    var bombDirPulseDisp = 2.5 * this.radius + 0.7 * this.radius * Math.abs(Math.sin(bombDirShake));
                    const arrowX = this.pos.x + bombDirPulseDisp * Math.cos(heading);
                    const arrowY = this.pos.y + bombDirPulseDisp * Math.sin(heading);
                    drawArrow(arrowX, arrowY, arrowAngle, Math.abs(Math.sin(bombDirShake) * 0.12));
                    c.fillStyle = `hsla(60, 100%, 70%, 60%)`;
                    c.lineWidth = 0.005 * cScale;
                    //c.strokeStyle = `hsla(0, 100%, 30%, 60%)`;
                    c.strokeStyle = `white`;
                    c.fill();
                    c.stroke();
                }
            } else {
                //  BOMB IS EXPLODING  ------------------
                drawCircle(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale);
                this.alpha = 100 * this.age / 250;
                if (this.firstPulse == true) {
                    this.firstPulse = false;
                    c.drawImage(offscreenFlashCanvas, (this.pos.x - 0.2) * cScale, (this.pos.y - 0.2) * cScale); 
                    spawnParticleDebris(this.pos, 0.004, 0, 60, 100, 1500, 4.0, 'bomb');
                    //function spawnParticleDebris(origin, radius, hue1, hue2, sat, debrisQuant, debrisVel, type)
                }
                //  OVERALL BUBBLE SHADING  ----------
                var sphereGradient = c.createRadialGradient(
                    this.pos.x * cScale, 
                    this.pos.y * cScale, 
                    0, 
                    this.pos.x * cScale, 
                    this.pos.y * cScale, 
                    this.radius * cScale);
                var highlight = `hsla(0, 0%, 100%, ${100 - this.alpha}%)`;
                var midtone = `hsla(50, 100%, 60%, ${100 - this.alpha}%)`;
                var shadow = `hsla(0, 0%, 0%, 0%)`;
                sphereGradient.addColorStop(0.0, highlight);
                sphereGradient.addColorStop(0.3, midtone);
                sphereGradient.addColorStop(1.0, shadow);
                c.fillStyle = sphereGradient;
                c.fill();

                //  OUTER CIRCLE
                drawCircle(this.pos.x * cScale, this.pos.y * cScale, Math.pow(this.radius * cScale, 1.3));
                c.lineWidth = 0.0001 * (100 - this.alpha) * cScale;
                c.strokeStyle = `hsla(0, 0%, ${100 - this.alpha}%, ${100 - this.alpha}%)`;
                //c.strokeStyle = `hsl(0, 0%, 100%)`;
                //c.stroke();

                //  SHOCK WAVES  --------------------
                c.lineWidth = (100 - this.alpha) * 0.0008 * cScale;
                c.strokeStyle = `hsla(0, 70%, 80%, ${60 - this.alpha}%)`;
                //  lethal radius
                drawCircle(this.pos.x * cScale, this.pos.y * cScale, 3 * this.radius * cScale);
                c.stroke();
                c.strokeStyle = `hsla(60, 90%, 40%, ${60 - this.alpha}%)`;
                //  tumble radius
                drawCircle(this.pos.x * cScale, this.pos.y * cScale, 7 * this.radius * cScale);
                c.stroke();
            }
        }
    }

    //  DEFINE PUSHER  ------------------
    class PUSHER {
        constructor(pos, radius, birthday) {
            this.pos = pos.clone();
            this.radius = radius;
            this.birthday = birthday;
        }
        simulate() {
            this.radius += 0.005;
        }
        draw() {
            drawCircle(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale);
            var pusherHue = 3600 * this.radius;
            var pusherAlpha = 100 - ((Date.now() - this.birthday) / 20);
            if (pusherAlpha < 0) {
                pusherAlpha = 0;
            }
            var sphereGradient = c.createRadialGradient(
                this.pos.x * cScale, 
                this.pos.y * cScale, 
                0, 
                this.pos.x * cScale, 
                this.pos.y * cScale, 
                this.radius * cScale
            );
            var shadow = `hsla(0, 0%, 0%, ${pusherAlpha}%)`;
            var highlight = `hsla(${pusherHue}, 50%, 80%, ${pusherAlpha}%)`;
            
            sphereGradient.addColorStop(1 - pusherAlpha/100, shadow);
            sphereGradient.addColorStop(1.0, highlight);
            sphereGradient.addColorStop(0.95, highlight);
            sphereGradient.addColorStop(1.0, shadow);
            c.fillStyle = sphereGradient;
            c.fill();
        }
    }

    //  CHECK IF ROKET PUSHER RESPAWN POINT IS CLEAR  -------------------
    function isPointClear(pos) {
        for (let roid of Roids) {
            var dir = new Vector2();
            dir.subtract(pos, roid.pos);
            var d = dir.length();
            if (d < roid.radius) {
                return false;
            }
        }
        return true;
    }

    //  SPAWN PUSHER  -------------------
    function makePusher() {
        const centerX = 0.5 * simWidth;
        const centerY = 0.5 * simHeight;
        const maxRadius = Math.max(simWidth, simHeight) / 2;
        let foundSpot = false;
        let testPos = new Vector2();
        let pos = new Vector2();
        // Spiral search outwards from center
        for (let r = 0; r < maxRadius && foundSpot != true; r += 0.1) {
            for (let theta = 0; theta < 2 * Math.PI && foundSpot != true; theta += Math.PI / 16) {
                let x = centerX + r * Math.cos(theta);
                let y = centerY + r * Math.sin(theta);
                testPos = new Vector2(x, y);
                if (isPointClear(testPos)) {
                    foundSpot = true;
                }
            }
        }
        let radius = 0;
        let birthday = Date.now();
        Pusher.push(new PUSHER(testPos, radius, birthday));
    }

    //  DEFINE TIME BOMB  --------------------
    //  needs simulate, draw, collision detection, animation, time effect...
    class TIMEBOMB {
    constructor(pos, radius) {
            this.pos = pos.clone();
            this.radius = radius;
            this.birthday = Date.now();
        }
        simulate() {
            //  PHASE 1, ANIMATE INITIAL EXPLOSION PULSE 
            this.age = Date.now() - this.birthday;
            if (this.age < 250) {
                this.radius += 0.005;
            } 
            this.alpha = 100 - (this.age / 50);
            //  PHASE 1, INITIATE PUSHER 

            //  PHASE 2, SLOW TIME

            //  PHASE 3, HANDLE TIMER

            //  PHASE 4, RESTORE TIME

        }
        draw() {
            //  PHASE 1, DRAW INITIAL EXPLOSION PULSE

            //  PHASE 2, DRAW SLOW TIME EFFECT

            //  PHASE 3, DRAW TIMER

            //  PHASE 4, DRAW RESTORE TIME EFFECT

        }
    }

    //  DEFINE OFFSCREEN ROKET  ------------------
    function defineOffscreenRoket(radius) {
        //  DRAW ROKET TO OFFSCREEN CANVAS  ------------------
        // radius is expected in simulation units; if not provided, try to
        // derive it from the existing Roket instance (which stores radius in pixels)
        if (!radius || typeof radius !== 'number') {
            if (typeof Roket !== 'undefined' && Roket && Roket[0] && Roket[0].radius) {
                // Roket[0].radius in this project is stored as the base value used throughout
                // (previous edits keep it as 0.0003 * cScale). To compute the final pixel radius
                // for offscreen drawing we will multiply by cScale below (rpx = radius * cScale).
                // So keep the same base value here.
                radius = Roket[0].radius;
            } else {
                // match the constructor default (0.0003 * cScale stored as base)
                radius = 0.0003 * cScale;
            }
        }

        // size the offscreen canvas to comfortably contain the sprite (pixels)
        // convert sim-units to pixels with cScale
        var spriteDiameterPx = Math.max(64, Math.ceil(2 * radius * cScale * 1.6 + 8));
        offscreenRoketCanvas.width = spriteDiameterPx;
        offscreenRoketCanvas.height = spriteDiameterPx;
        roketCtx = offscreenRoketCanvas.getContext('2d');

        // clear and prepare coordinate system: origin at canvas center
        roketCtx.clearRect(0, 0, offscreenRoketCanvas.width, offscreenRoketCanvas.height);
        roketCtx.save();
        roketCtx.translate(offscreenRoketCanvas.width / 2, offscreenRoketCanvas.height / 2);

        var roketVars = {
            radius: radius,
            // FUSELAGE -----
            // 1 bottom center
            a1cos: Math.cos(rads(0 - 90)),
            a1sin: Math.sin(rads(0 - 90)),
            r1: 0,
            // 2 bottom 
            a2cos: Math.cos(rads(0 - 90)),
            a2sin: Math.sin(rads(0 - 90)),
            r2: 0.07893,
            al2cos: Math.cos(rads(180 - 90)),
            al2sin: Math.sin(rads(180 - 90)),
            rl2: 0.07893,
            // 6 top fin attach point
            a6cos: Math.cos(rads(66.6 - 90)),
            a6sin: Math.sin(rads(66.6 - 90)),
            r6: 0.2859,
            al6cos: Math.cos(rads(113.4 - 90)),
            al6sin: Math.sin(rads(113.4 - 90)),
            rl6: 0.2859,
            // 7 mid side tip
            a7cos: Math.cos(rads(70.1 - 90)),
            a7sin: Math.sin(rads(70.1 - 90)),
            r7: 0.4383,
            al7cos: Math.cos(rads(109.9 - 90)),
            al7sin: Math.sin(rads(109.9 - 90)),
            rl7: 0.4383,
            // 8 mid top
            a8cos: Math.cos(rads(78.4 - 90)),
            a8sin: Math.sin(rads(78.4 - 90)),
            r8: 0.6089,
            al8cos: Math.cos(rads(101.6 - 90)),
            al8sin: Math.sin(rads(101.6 - 90)),
            rl8: 0.6089,
            // 9 tip
            a9cos: Math.cos(0),
            a9sin: Math.sin(0),
            r9: 0.7630,
            // 10 nozzle top right
            a10cos: Math.cos(rads(0 - 90)),
            a10sin: Math.sin(rads(0 - 90)),
            r10: 0.03508,
            //  11 nozzle bottom right
            a11cos: Math.cos(rads(-45 - 90)),
            a11sin: Math.sin(rads(-45 - 90)),
            r11: 0.1,
            //  12 nozzle bottom left
            a12cos: Math.cos(rads(225 - 90)),
            a12sin: Math.sin(rads(225 - 90)),
            r12: 0.1,
            // 13 nozzle top left
            a13cos: Math.cos(rads(180 - 90)),
            a13sin: Math.sin(rads(180 - 90)),
            r13: 0.03508,
            // RIGHT FIN -----
            // 3 fin tip bottom
            a3cos: Math.cos(rads(-43.9 - 90)),
            a3sin: Math.sin(rads(-43.9 - 90)),
            r3: 0.3287,
            // 4 fin tip top
            a4cos: Math.cos(rads(-16.7 - 90)),
            a4sin: Math.sin(rads(-16.7 - 90)),
            r4: 0.2747,
            // 5 fin side
            a5cos: Math.cos(rads(30.3 - 90)),
            a5sin: Math.sin(rads(30.3 - 90)),
            r5: 0.2426,
            // LEFT FIN
            // 3l fin tip bottom
            al3cos: Math.cos(rads(223.9 - 90)),
            al3sin: Math.sin(rads(223.9 - 90)),
            rl3: 0.3287,
            // 4l fin tip top
            al4cos: Math.cos(rads(196.7 - 90)),
            al4sin: Math.sin(rads(196.7 - 90)),
            rl4: 0.2747,
            // 5l fin side
            al5cos: Math.cos(rads(139.7 - 90)),
            al5sin: Math.sin(rads(139.7 - 90)),
            rl5: 0.2426,
            // portholes
            windowCos: Math.cos(0),
            windowSin: Math.sin(0),
            rTop: 0.6,
            rMid: 0.456,
            rBot: 0.3,
        }
        // convert simulation radius -> pixel radius for drawing convenience
        const rpx = roketVars.radius * cScale;

        //  ANTENNA  ----------
        roketCtx.beginPath();
        roketCtx.moveTo(0, 0);
        roketCtx.lineTo(
            (1.15 * roketVars.r9 * rpx * Math.cos(0)), 
            (-1.15 * roketVars.r9 * rpx * Math.sin(0))
        );
        roketCtx.strokeStyle = 'hsl(0, 0%, 90%)';
        roketCtx.lineWidth = 0.015 * rpx;
        roketCtx.shadowBlur = 10;
        roketCtx.shadowColor = 'black';
        roketCtx.stroke();

        // FUSELAGE (smooth Catmull-Rom spline)
        const pts = [
            { x: (roketVars.r1 * rpx * roketVars.a1cos), y: (-roketVars.r1 * rpx * roketVars.a1sin) },
            { x: (roketVars.r2 * rpx * roketVars.a2cos), y: (-roketVars.r2 * rpx * roketVars.a2sin) },
            { x: (roketVars.r6 * rpx * roketVars.a6cos), y: (-roketVars.r6 * rpx * roketVars.a6sin) },
            { x: (roketVars.r7 * rpx * roketVars.a7cos), y: (-roketVars.r7 * rpx * roketVars.a7sin) },
            { x: (roketVars.r8 * rpx * roketVars.a8cos), y: (-roketVars.r8 * rpx * roketVars.a8sin) },
            { x: (roketVars.r9 * rpx * roketVars.a9cos), y: (-roketVars.r9 * rpx * roketVars.a9sin) },
            { x: (roketVars.rl8 * rpx * roketVars.al8cos), y: (-roketVars.rl8 * rpx * roketVars.al8sin) },
            { x: (roketVars.rl7 * rpx * roketVars.al7cos), y: (-roketVars.rl7 * rpx * roketVars.al7sin) },
            { x: (roketVars.rl6 * rpx * roketVars.al6cos), y: (-roketVars.rl6 * rpx * roketVars.al6sin) },
            { x: (roketVars.rl2 * rpx * roketVars.al2cos), y: (-roketVars.rl2 * rpx * roketVars.al2sin) }
        ];
        const smoothPts = catmullRomSpline(pts, 0.5, 12);
        roketCtx.beginPath();
        roketCtx.moveTo(smoothPts[0].x, smoothPts[0].y);
        for (let i = 1; i < smoothPts.length; i++) {
            roketCtx.lineTo(smoothPts[i].x, smoothPts[i].y);
        }
        roketCtx.closePath();
        roketCtx.fillStyle = 'hsl(120, 60%, 40%)';
        roketCtx.shadowBlur = 8;
        roketCtx.fill();
        roketCtx.strokeStyle = 'black';
        roketCtx.lineWidth = 1;
        roketCtx.stroke();

        //  NOZZLE  ---------
        roketCtx.beginPath();
        roketCtx.moveTo((roketVars.radius * roketVars.r10 * roketVars.a10cos) * cScale,
            (-roketVars.radius * roketVars.r10 * roketVars.a10sin) * cScale);
        roketCtx.lineTo((roketVars.radius * roketVars.r10 * roketVars.a10cos) * cScale,
            (-roketVars.radius * roketVars.r10 * roketVars.a10sin) * cScale);
        roketCtx.lineTo((roketVars.radius * roketVars.r11 * roketVars.a11cos) * cScale,
            (-roketVars.radius * roketVars.r11 * roketVars.a11sin) * cScale);
        roketCtx.lineTo((roketVars.radius * roketVars.r12 * roketVars.a12cos) * cScale,
            (-roketVars.radius * roketVars.r12 * roketVars.a12sin) * cScale);
        roketCtx.lineTo((roketVars.radius * roketVars.r13 * roketVars.a13cos) * cScale,
            (-roketVars.radius * roketVars.r13 * roketVars.a13sin) * cScale);
        roketCtx.stroke();
        roketCtx.fillStyle = 'hsl(30, 70%, 60%)';
        roketCtx.fill();

        // RIGHT FIN (smooth)
        const rightFinPts = [
            { x: (roketVars.r2 * rpx * roketVars.a2cos), y: (-roketVars.r2 * rpx * roketVars.a2sin) },
            { x: (roketVars.r3 * rpx * roketVars.a3cos), y: (-roketVars.r3 * rpx * roketVars.a3sin) },
            { x: (roketVars.r4 * rpx * roketVars.a4cos), y: (-roketVars.r4 * rpx * roketVars.a4sin) },
            { x: (roketVars.r5 * rpx * roketVars.a5cos), y: (-roketVars.r5 * rpx * roketVars.a5sin) },
            { x: (roketVars.r6 * rpx * roketVars.a6cos), y: (-roketVars.r6 * rpx * roketVars.a6sin) },
            { x: (roketVars.r2 * rpx * roketVars.a2cos), y: (-roketVars.r2 * rpx * roketVars.a2sin) }
        ];
        const rightFinSmooth = catmullRomSpline(rightFinPts, 0.5, 10);
        roketCtx.beginPath();
        roketCtx.moveTo(rightFinSmooth[0].x, rightFinSmooth[0].y);
        for (let i = 1; i < rightFinSmooth.length; i++) {
            roketCtx.lineTo(rightFinSmooth[i].x, rightFinSmooth[i].y);
        }
        roketCtx.closePath();
        roketCtx.fillStyle = 'hsl(180, 90%, 44%)';
        roketCtx.shadowBlur = 5;
        roketCtx.fill();
        roketCtx.strokeStyle = 'black';
        roketCtx.lineWidth = 1;
        roketCtx.stroke();

        // LEFT FIN (smooth)
        const leftFinPts = [
            { x: (roketVars.rl2 * rpx * roketVars.al2cos), y: (-roketVars.rl2 * rpx * roketVars.al2sin) },
            { x: (roketVars.rl3 * rpx * roketVars.al3cos), y: (-roketVars.rl3 * rpx * roketVars.al3sin) },
            { x: (roketVars.rl4 * rpx * roketVars.al4cos), y: (-roketVars.rl4 * rpx * roketVars.al4sin) },
            { x: (roketVars.rl5 * rpx * roketVars.al5cos), y: (-roketVars.rl5 * rpx * roketVars.al5sin) },
            { x: (roketVars.rl6 * rpx * roketVars.al6cos), y: (-roketVars.rl6 * rpx * roketVars.al6sin) },
            { x: (roketVars.rl2 * rpx * roketVars.al2cos), y: (-roketVars.rl2 * rpx * roketVars.al2sin) }
        ];
        const leftFinSmooth = catmullRomSpline(leftFinPts, 0.5, 10);
        roketCtx.beginPath();
        roketCtx.moveTo(leftFinSmooth[0].x, leftFinSmooth[0].y);
        for (let i = 1; i < leftFinSmooth.length; i++) {
            roketCtx.lineTo(leftFinSmooth[i].x, leftFinSmooth[i].y);
        }
        roketCtx.closePath();
        roketCtx.fill();
        roketCtx.shadowBlur = 0;
        roketCtx.stroke();

        //  WINDOWS  ----------
        offscreenRoketDrawCircle((roketVars.rTop * rpx * Math.cos(0)),
            (-roketVars.rTop * rpx * Math.sin(0)),
            0.04 * rpx
        );
        roketCtx.strokeStyle = 'hsl(0, 0%, 90%)';
        roketCtx.lineWidth = 0.015 * roketVars.radius * cScale;
        roketCtx.fillStyle = 'black';
        roketCtx.fill();
        roketCtx.stroke();

        offscreenRoketDrawCircle((roketVars.rMid * rpx * Math.cos(0)),
            (-roketVars.rMid * rpx * Math.sin(0)),
            0.05 * rpx
        );
        roketCtx.fill();
        roketCtx.stroke();

        offscreenRoketDrawCircle((roketVars.rBot * rpx * Math.cos(0)),
            (-roketVars.rBot * rpx * Math.sin(0)),
            0.05 * rpx
        );
        roketCtx.fill();
        roketCtx.stroke();
        
        // compute and store sprite metadata
        // tip offset in pixels relative to sprite center
        try {
            var tipX_center = (1.15 * roketVars.r9 * rpx * Math.cos(0));
            var tipY_center = (-1.15 * roketVars.r9 * rpx * Math.sin(0));
        } catch (e) {
            var tipX_center = 0;
            var tipY_center = - (roketVars.radius * cScale);
        }

        // estimate geometric centroid (pivot) from the fuselage smooth points
    var avgX = 0, avgY = 0;
        if (typeof smoothPts !== 'undefined' && smoothPts.length > 0) {
            for (var i = 0; i < smoothPts.length; i++) {
                avgX += smoothPts[i].x;
                avgY += smoothPts[i].y;
            }
            avgX /= smoothPts.length;
            avgY /= smoothPts.length;
        } else {
            avgX = 0; avgY = 0;
        }

        // pivot relative to top-left image coordinates
    var halfW = offscreenRoketCanvas.width / 2;
    var halfH = offscreenRoketCanvas.height / 2;
    var pivotImgX = halfW + avgX;
    var pivotImgY = halfH + avgY;

        // expose for runtime drawing
        window.roketSprite = {
            canvas: offscreenRoketCanvas,
            ctx: roketCtx,
            tipX_center: tipX_center,
            tipY_center: tipY_center,
            pivotCenterX: avgX, // relative to sprite center (pixels)
            pivotCenterY: avgY,
            pivotImgX: pivotImgX, // relative to image top-left (pixels)
            pivotImgY: pivotImgY,
            radius: rpx // store pixel radius for runtime clarity
        };

        // sanity check
        if (!offscreenRoketCanvas || offscreenRoketCanvas.width < 2 || offscreenRoketCanvas.height < 2) {
            console.warn('defineOffscreenRoket: invalid offscreen canvas', offscreenRoketCanvas && offscreenRoketCanvas.width, offscreenRoketCanvas && offscreenRoketCanvas.height);
        }

        roketCtx.restore();
    }

    //  SPAWN ROKET  -----------------
    function spawnRoket() {
        Roket.push(new ROKET());
    }

    //  DEFINE ROKET  -------------------
    class ROKET {
        constructor() {
            this.pos = new Vector2(0.5 * simWidth, 0.7 * simHeight);
            this.vel = new Vector2();
            this.radius = 0.0003 * cScale;
            this.mass = this.radius;
            this.angle = 0
            this.collision = 0;
        }
        get leftForHits() {
            return this.pos.x - 0.5 * this.radius;
        }
        get leftForShields() {
            return this.pos.x - this.radius;
        }
        get center() {
            return new Vector2(
                this.pos.x + this.radius * 0.4 * Math.cos(this.angle),
                this.pos.y - this.radius * 0.4 * Math.sin(this.angle)
            );
        }
        startSimulate() {
            this.angle -= 0.017;{
            this.vel = new Vector2(
                0.5 * Math.cos(this.angle),
                0.5 * Math.sin(this.angle))
            };
            this.pos.add(this.vel, dT);
            spawnIdleExhaustlets(this.pos.x, this.pos.y, this.angle, 'friend');
        }
        simulate() {
            if (leftPressed == true) {
                tumbling = false;
                Roket[0].collision = 0;
                this.angle -= 0.1;
                var spawnRetros = true;
            };
            if (rightPressed == true) {
                tumbling = false;
                Roket[0].collision = 0
                this.angle += 0.1;
                var spawnRetros = true;
            };
            if (tumbling == true) {
                if (this.vel.x > 0) {
                    this.angle -= 0.25 * this.vel.length();
                } else {
                    this.angle += 0.25 * this.vel.length();
                } 
                if (score > 0) {
                    score -= (0.005 * score);
                    if (score < 1) {
                        score = 0;
                    }
                }
                var spawnRetros = true;
            }
            if (spawnRetros == true) {
                spawnRetro(this.pos.x, this.pos.y);
            }
            if (thrustKey == true) {
                spawnThrustExhaustlets(this.pos.x, this.pos.y, this.angle)
                var power = .02;
                var thrust = new Vector2(power * Math.cos(this.angle), 
                power * Math.sin(this.angle));
                this.vel.add(thrust);
                if (this.vel.length() > 2) {
                    this.vel.scale(0.9);
                }
            } else {
                spawnIdleExhaustlets(this.pos.x, this.pos.y, this.angle, 'friend');
            }

            this.pos.add(this.vel, 1/60);
            totalTravelX += Roket[0].vel.x * (1/60);
            totalTravelY += Roket[0].vel.y * (1/60);

            //  HANDLE BOUNDS  -------------------
            //  TOO FAR RIGHT  ----------
            if (this.pos.x > simWidth) {
                startReentryPos = new Vector2(0, this.pos.y);
                if (Roids.length > 0) {
                    for (var r = 0; r < Roids.length; r++) {
                        var roid = Roids[r];
                        this.pos = findSafeReentry(roid, startReentryPos);
                    }
                } else {
                    this.pos = startReentryPos;
                }
            }
            //  TOO FAR LEFT  ----------
            if (this.pos.x < 0) {
                startReentryPos = new Vector2(simWidth, this.pos.y);
                if (Roids.length > 0) {
                    for (var r = 0; r < Roids.length; r++) {
                        var roid = Roids[r];
                        this.pos = findSafeReentry(roid, startReentryPos);
                    }
                } else {
                    this.pos = startReentryPos;
                }
            }
            //  TOO HIGH  ----------
            if (this.pos.y < 0) {
                startReentryPos = new Vector2(this.pos.x, simHeight);
                if (Roids.length > 0) {
                    for (var r = 0; r < Roids.length; r++) {
                        var roid = Roids[r];
                        this.pos = findSafeReentry(roid, startReentryPos);
                    }
                } else {
                    this.pos = startReentryPos;
                }
            }
            //  TOO LOW  ----------
            if (this.pos.y > simHeight) {
                startReentryPos = new Vector2(this.pos.x, 0);
                if (Roids.length > 0) {
                    for (var r = 0; r < Roids.length; r++) {
                        var roid = Roids[r];
                        this.pos = findSafeReentry(roid, startReentryPos);
                    }
                } else {
                    this.pos = startReentryPos;
                }
            }
        }
        draw() {
            //  DRAW ROKET SPRITE (rotated to match simulation angle)  ------------------
            if (window.roketSprite && window.roketSprite.canvas) {
                const spriteCanvas = window.roketSprite.canvas;
                const cx = this.pos.x * cScale;
                const cy = this.pos.y * cScale;
                // pivot within image (relative to top-left)
                const pivotImgX = window.roketSprite.pivotImgX;
                const pivotImgY = window.roketSprite.pivotImgY;
                c.save();
                // move to where the pivot should be on-screen
                c.translate(cx, cy);
                // rotate by simulation angle
                c.rotate(this.angle);
                // draw the image so that its pivot aligns at origin (0,0)
                c.drawImage(spriteCanvas, -pivotImgX, -pivotImgY);
                
                c.restore();
            } else {
                // fallback: draw vector (minimal) if sprite missing
                c.save();
                c.translate(this.pos.x * cScale, this.pos.y * cScale);
                c.fillStyle = 'white';
                c.fillRect(-2, -2, 4, 4);
                c.restore();
            }

            //  ADVANCE RUDOLPH AND BLINKER ----------
            rudolph += 0.03;
            if (rudolph > 2 * Math.PI) {
                rudolph -= 2 * Math.PI;
            }
            rudolphIntensity = 10 + 50 * Math.abs(Math.sin(rudolph));

            // draw blinking tip on top of sprite using stored tip offset (rotate the offset by this.angle)
            if (window.roketSprite) {
                // tip coords are stored relative to sprite center; rotate around pivot
                var tx = window.roketSprite.tipX_center;
                var ty = window.roketSprite.tipY_center;
                // pivot relative to sprite center
                var px = window.roketSprite.pivotCenterX;
                var py = window.roketSprite.pivotCenterY;
                // compute tip offset relative to pivot, then rotate
                var relX = tx - px;
                var relY = ty - py;
                var rotX = relX * Math.cos(this.angle) - relY * Math.sin(this.angle);
                var rotY = relX * Math.sin(this.angle) + relY * Math.cos(this.angle);
                const tipCanvasX = this.pos.x * cScale + rotX;
                const tipCanvasY = this.pos.y * cScale + rotY;
                // use the sprite's pixel radius so the tip scales with the sprite
                var spriteRpx = (window.roketSprite && window.roketSprite.radius) ? window.roketSprite.radius : (this.radius * cScale);
                drawCircle(tipCanvasX, tipCanvasY, 0.05 * spriteRpx);
                c.fillStyle = `hsl(0, 100%, ${rudolphIntensity}%)`;
                c.shadowBlur = 0;
                c.shadowColor = 'black';
                c.fill();
            }

            // DRAW SHIELDS  ----------------
            if (shieldKey == true && shieldLevel < 10) {
                //  BLINK RED (2 Hz) ----------
                // show the red fill only when the time-based toggle is true
                var nowMs = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
                // frequency = 2 flashes per second. Use sine wave so on/off each 0.25s (visible window)
                var show = Math.sin((nowMs / 1000) * 2 * Math.PI * 2) > 0;
                if (show) {
                    drawCircle(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale);
                    var sphereGradient = c.createRadialGradient(
                        this.pos.x * cScale, 
                        this.pos.y * cScale, 
                        0, 
                        this.pos.x * cScale, 
                        this.pos.y * cScale, 
                        1 * this.radius * cScale
                    );
                    var highlight = `hsla(0, 80%, 70%, 60%)`;
                    var midtone = `hsla(0, 50%, 40%, 40%)`;
                    var shadow = `hsla(0, 0%, 0%, 0%)`;
                    sphereGradient.addColorStop(0.0, shadow);
                    sphereGradient.addColorStop(0.8, midtone);
                    sphereGradient.addColorStop(1.0, highlight);
                    c.fillStyle = sphereGradient;
                    c.fill();
                }
            }
            if (shieldsUp == true) {
                var shieldHue = 240 - shieldLevel / 100 * (240 - 180);
                drawCircle(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale);
                //  bubble shading ---------
                var sphereGradient = c.createRadialGradient(
                    this.pos.x * cScale, 
                    this.pos.y * cScale, 
                    0, 
                    this.pos.x * cScale, 
                    this.pos.y * cScale, 
                    1 * this.radius * cScale
                );
                if (shieldLevel  <= 20) {
                    var alpha = shieldLevel / 20 * 100;
                } else {
                    var alpha = 100;
                }
                var highlight = `hsla(${shieldHue}, 80%, 70%, ${alpha - 40}%)`;
                var midtone = `hsla(${shieldHue}, 50%, 40%, ${alpha - 60}%)`;
                var shadow = `hsla(0, 0%, 0%, 0%)`;
                sphereGradient.addColorStop(0.0, shadow);
                sphereGradient.addColorStop(0.8, midtone);
                sphereGradient.addColorStop(1.0, highlight);
                c.fillStyle = sphereGradient;
                c.fill();
                //  lighting shading  ---------
                var sphereGradient = c.createRadialGradient(
                    (this.pos.x - 0.3 * this.radius) * cScale, 
                    (this.pos.y - 0.45 * this.radius) * cScale, 
                    0, 
                    (this.pos.x - 0.3 * this.radius) * cScale, 
                    (this.pos.y - 0.45 * this.radius) * cScale, 
                    2 * this.radius * cScale
                );
                var superhighlight = `hsla(${shieldHue}, 80%, 80%, ${alpha}%)`;
                var highlight = `hsla(${shieldHue}, 80%, 70%, ${alpha - 60}%)`;
                var midtone = `hsla(${shieldHue}, 50%, 40%, ${alpha - 90}%)`;
                var shadow = `hsla(0, 0%, 0%, 0%)`;
                sphereGradient.addColorStop(0.0, superhighlight);
                sphereGradient.addColorStop(0.15, highlight);
                sphereGradient.addColorStop(0.8, midtone);
                sphereGradient.addColorStop(1.0, shadow);
                c.fillStyle = sphereGradient;
                c.fill();
            }
            /*drawCircle(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale);
            c.strokeStyle = 'red';
            c.stroke();*/
        }
    }

    //  DEFINE ROKET DEBRIS -------------------
    class DEBRIS {
        constructor(pos, vel, radius, angle, hue, alpha, birthday) {
            this.pos = pos.clone();
            this.vel = vel.clone();
            this.radius = radius;
            this.angle = angle;
            this.hue = hue;
            this.alpha = alpha;
            this.birthday = birthday;
            this.mass = 0;
        }
        simulate() {
            this.vel.scale(0.97);
            this.pos.add(this.vel, dT)
            this.angle += 0.2;
            this.alpha = 100 - ((Date.now() - this.birthday)) * 100 / 2000;
        }
        get left() {
            return this.pos.x - this.radius;
        }
        get right() {
            return this.pos.x + this.radius;
        }
        draw() {  
            c.beginPath();
            for (var s = 0; s < 3; s++) {
                if (s == 0) {
                    c.moveTo((this.pos.x + this.radius * Math.cos((s * 2 * Math.PI / 3) + this.angle)) * cScale, 
                    (this.pos.y - this.radius * Math.sin((s * 2 * Math.PI / 3) + this.angle)) * cScale);
                } else {
                    c.lineTo((this.pos.x + this.radius * Math.cos((s * 2 * Math.PI / 3) + this.angle)) * cScale, 
                    (this.pos.y - this.radius * Math.sin((s * 2 * Math.PI / 3) + this.angle)) * cScale);
                }
            }
            c.closePath();
            c.fillStyle = `hsla(${this.hue}, 50%, 50%, ${this.alpha}%)`;
            c.fill();
        }
    }

    //  SPAWN ENEMY ENEMY DEBRIS  -------------------
    function makeEnemyDebris() {
        for (var u = 0; u < 500; u++) {
            var pos = Enemy[0].pos.clone();
            var kapow = 0.015 + Math.random();
            var huh = 2 * Math.PI * Math.random()
            var vel = new Vector2(
                0.01 + kapow * Math.cos(huh), 
                0.01 + kapow * Math.sin(huh));
            var radius = .01 + 0.005 * Math.random();
            var angle = 0;
            var randi = Math.random();
            if (randi <= 0.33) {  
                var hue = 0;
            } else
            if (randi <= 0.67) {
                var hue = 60;
            } else 
            if (randi <= 1.0) {
                var hue = 230;
            }
            var alpha = 100;
            var birthday = Date.now();
            
            EnemyDebris.push(new DEBRIS(pos, vel, radius, angle, hue, alpha, birthday));
        }
    }

    //  SPAWN ROKET DEBRIS  -------------------
    function spawnRoketDebris() {
        debrisMade = true;
        lives -= 1
        for (var u = 0; u < 500; u++) {
            var pos = Roket[0].pos.clone();
            var kapow = 0.1 + 2 * Math.random();
            var huh = 2 * Math.PI * Math.random()
            if (bombBlastAngle == null) {
                var vel = new Vector2(
                0.1 + kapow * Math.cos(huh), 
                0.1 + kapow * Math.sin(huh));
            } else {
                var vel = new Vector2(
                0.1 + kapow * Math.cos(huh) - 1.5 * Math.cos(bombBlastAngle), 
                0.1 + kapow * Math.sin(huh) - 1.5 * Math.sin(bombBlastAngle));
            }
            var radius = .003 + 0.01 * Math.random();
            var angle = 0;
            var randi = Math.random();
            if (randi < 0.01) {  
                var hue = 0;
            } else
            if (randi < 0.33) {
                var hue = 180;
            } else 
            if (randi < 0.67) {
                var hue = 120;
            } else
            if (randi < 1.00) {
                var hue = 300;
            }
            var alpha = 100;
            var birthday = Date.now();
            
            RoketDebris.push(new DEBRIS(pos, vel, radius, angle, hue, alpha, birthday));
        }
        bombBlastAngle = null;
    }

    //  DEFINE ROID DEBRIS -------------------
    class PARTICLEDEBRIS {
        constructor(pos, vel, radius, hue, sat, alpha, birthday, type) {
            this.pos = pos.clone();
            this.vel = vel.clone();
            this.radius = radius;
            this.hue = hue;
            this.sat = sat;
            this.alpha = alpha;
            this.birthday = birthday;
            this.type = type;
        }
        simulate() {
            this.pos.add(this.vel, dT)
            if (this.type == 'torpedo') {
                this.alpha = 70 - ((Date.now() - this.birthday)) * 50 / 1000;
            } else {
                this.alpha = 100 - ((Date.now() - this.birthday)) * 100 / 1000;
            }
        }
        draw() {  
            drawCircle(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale);
            if (this.type == 'torpedo') {
                c.fillStyle = `hsl(${this.hue}, ${this.sat}%, ${this.alpha + 30}%, ${this.alpha}%)`;
            } else {
                c.fillStyle = `hsl(${this.hue}, ${this.sat}%, ${this.alpha + 20}%, ${this.alpha}%)`;
            }
            c.fill();
        }
    }

    //  SPAWN PARTICLE DEBRIS  -------------------
    function spawnParticleDebris(origin, radius, hue1, hue2, sat, debrisQuant, debrisVel, type) {
        var pos = origin.clone();
        var firstpass = true;
        var birthday = Date.now();
        for (var u = 0; u < debrisQuant; u++) {
            //var kapow = 0.8 * 0.5 * Math.random();
            var kapow = debrisVel * 0.5 * Math.random();
            var dangle = 2 * Math.PI * Math.random()
            var vel = new Vector2(
                kapow * Math.cos(dangle), 
                kapow * Math.sin(dangle));
            if (hue1 == hue2) {
                var hue = hue1;
            } 
            if (type == 'roid') {
                var alpha = 100;
                if (firstpass == true) {
                    var hue = hue1;
                    firstpass = false;
                } else {
                    var hue = hue2;
                    firstpass = true;
                }
            } else if (type == 'torpedo') {
                var alpha = 0;
                var hue = hue1;
                var sat = 100;   
            } else {
                var alpha = 100;
                if (firstpass == true) {
                    var hue = hue1;
                    var sat = 100;
                    firstpass = false;
                } else {
                    var sat = 0;
                    firstpass = true;
                }
            }
            if (hue1 == hue2) {
                var hue = hue1;
            } 
            
            RoidDebris.push(new PARTICLEDEBRIS(pos, vel, radius, hue, sat, alpha, birthday, type));
        } 
    }

    //  DEFINE RING OF FIRE -------------------
    class RINGOFFIRE {
        constructor(pos, hue, vel) {
            this.pos = pos.clone();
            this.birthday = Date.now();
            this.vel = new Vector2((-0.25 + 0.5 * Math.random()), (-0.25 + 0.5 * Math.random()));
            this.hue = hue;
        }
        simulate() {
            this.pos.add(this.vel, dT)
        }
        draw() {
            var alpha = 100 - (100 * (Date.now() - this.birthday) / 500);
            drawCircle(this.pos.x * cScale, this.pos.y * cScale, 0.004 * cScale)
            c.fillStyle = `hsl(${this.hue}, 60%, 60%, ${alpha}%)`;
            c.fill();
        }
    }

    function spawnRingOfFire(pos, radius, hue, vel) {
        for (var i = 0; i < 300; i++) {
            var angle = i * (2 * Math.PI / 300);
            var x = pos.x + radius * Math.cos(angle);
            var y = pos.y + radius * Math.sin(angle);
            var newPos = new Vector2(x, y);
            RingOfFire.push(new RINGOFFIRE(newPos, hue, vel));
        }
    }

    //  DEFINE MUZZLE FLASH  -------------------
    class MUZZLE_FLASH {
        constructor(pos, vel, radius, alpha, birthday) {
            this.pos = pos.clone();
            this.vel = vel.clone();
            this.radius = radius;
            this.alpha = alpha;
            this.birthday = birthday;
        }
        simulate() {
            this.pos.add(this.vel, dT)
            this.alpha = 100 - ((Date.now() - this.birthday)) * 100 / 500;
            if (Date.now() - this.birthday > 500) {
                MuzzleFlash.splice(0,1)
            }
            this.vel.scale(0.95);
        }
        draw() {  
            drawCircle(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale)
            c.fillStyle = `hsl(60, 100%, 40%, ${this.alpha}%)`;
            c.fill();
        }
    }

    //  SPAWN MUZZLE EXHAUST  -------------------
    function spawnMuzzleFlash(interceptAngle) {
        var radius = .003;
        var alpha = 100;
        var birthday = Date.now();
        for (var u = 0; u < 100; u++) {
            var pos = new Vector2(
                Enemy[0].pos.x + Enemy[0].radius * Math.cos(interceptAngle), 
                Enemy[0].pos.y + Enemy[0].radius * Math.sin(interceptAngle));
            var kapow = 0.1 + 4*Math.random();
            var spreadAngle = 0.1 * Math.PI * (-0.5 + Math.random());
            var vel = new Vector2(
                Enemy[0].vel.x + kapow * Math.cos(interceptAngle + spreadAngle), 
                Enemy[0].vel.y + kapow * Math.sin(interceptAngle + spreadAngle));

            MuzzleFlash.push(new MUZZLE_FLASH(pos, vel, radius, alpha, birthday));
        } 
    }

    //  DEFINE TORPEDO HIT PULSE  -------------------
    class PULSE {
        constructor(pos, radius, alpha, birthday) {
            this.pos = pos.clone();
            this.radius = radius;
            this.alpha = alpha;
            this.birthday = birthday;
        }
        simulate() {
            this.radius += 0.03;
            this.alpha = 100 - ((Date.now() - this.birthday)) * 100 / 300;
        }
        draw() {
            drawCircle(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale);
            c.lineWidth = this.alpha/10000 * cScale;
            c.strokeStyle = `hsla(0, 0%, 70%, ${this.alpha}%)`;
            c.stroke();
            if (firstPulse == true) {
                firstPulse = false;
                c.drawImage(offscreenFlashCanvas, (this.pos.x - 0.2) * cScale, (this.pos.y - 0.2) * cScale); 
            }
        }
    }

    //  SPAWN TORPEDO PULSE  -------------------
    function makePulse(pos) {
        var pos = pos.clone();
        var radius = 0;
        var alpha = 100;
        var birthday = Date.now();

        Pulse.push(new PULSE(pos, radius, alpha, birthday))
    }

    //  DEFINE WARP IN GRAPHIC  -------------------
    class WARP {
        constructor(pos, radius, alpha, birthday) {
            this.pos = pos.clone();
            this.radius = radius;
            this.alpha = alpha;
            this.birthday = birthday;
        }
        simulate() {
            if ((Date.now() - this.birthday) / 1000 < 0.25) {
                this.radius += 0.015;
            } 
            if ((Date.now() - this.birthday) / 1000 >= 0.25 ) {
                this.radius -= 0.02;
                if (this.radius < 0.0) {
                    this.radius = 0.0;
                }
            }
            this.alpha = 100 - ((Date.now() - this.birthday)) * 0.1;
            if ((Date.now() - this.birthday) / 1000 > 1.0) {
                WarpIn = [];
            }
        }
        draw() {
            var warpArrowAngle = getDangle(0, 0, Roket[0].vel.x, -Roket[0].vel.y);
            drawArrow(this.pos.x, this.pos.y, warpArrowAngle - 0.5 * Math.PI, this.radius);
            
            c.fillStyle = `hsl(0, 0%, 70%, ${this.alpha}%)`;
            c.strokeStyle = `hsl(0, 0%, 70%, ${this.alpha}%)`;
            c.lineWidth = 0.02 * cScale * (Date.now() - this.birthday) / 1000;
            if ((Date.now() - this.birthday) / 1000 < 0.3) {  
                c.stroke();
            } 
            if ((Date.now() - this.birthday) / 1000 >= 0.25 ) {
                c.stroke();
            }
        }
    }

    //  SPAWN WARP-IN GRAPHIC  -----------------
    function spawnWarpIn(pos) {
        var pos = pos;
        var radius = 0.01;
        var alpha = 0;
        var birthday = Date.now();

        WarpIn.push(new WARP(pos, radius, alpha, birthday));
    }

    //  DEFINE SCORER GRAPHIC  --------------------
    class SCORER {
        constructor(pos, vel, radius, alpha, birthday, score) {
            this.pos = pos.clone();
            this.vel = vel;
            this.radius = radius;
            this.alpha = alpha;
            this.birthday = birthday;
            this.score = score;
        }
        simulate() {
            this.radius += 0.05;
            this.alpha = 100 - ((Date.now() - this.birthday)) / 15;
            this.pos.add(this.vel, dT);
        }
        draw() {
            c.font = `${0.04 * cScale}px verdana`;
            c.fillStyle = `hsl(105, 0%, 80%, ${this.alpha}%)`;
            c.fillText(Math.floor(this.score), this.pos.x * cScale, this.pos.y * cScale);
        }
    }

    //  SPAWN HIT SCORER GRAPHIC ------------------
    function spawnScorer(pos, score) {
        var vel = new Vector2(-0.05 + 0.01 * Math.random(), -0.05 + 0.1 * Math.random());
        Scorer.push (new SCORER(pos, vel, 0, 0, Date.now(), score));
    }

    //  DEFINE ENGINE THRUST PARTICLE  -------------------
    class THRUSTLET {
        constructor(pos, vel, radius, maxRadius, 
        hue, saturation, lightness, alpha, birthday, lifespan, age) {
            this.pos = pos.clone();
            this.vel = vel.clone();
            this.radius = radius;
            this.maxRadius = maxRadius;
            this.hue = hue;
            this.saturation = saturation;
            this.lightness = lightness;
            this.alpha = alpha;
            this.birthday = birthday;
            this.lifespan = lifespan;
            this.age = age;
        }
        simulate() {
            this.age = Date.now() - this.birthday;
            this.radius = Math.abs(this.maxRadius * (this.age) / this.lifespan);  //this came up negative once. don't know why. crashed game.
            this.alpha = 100 - (this.age) * 100 / this.lifespan;
            this.pos.add(this.vel, dT)

            if (this.age > this.lifespan) {
                Exhaustlets.splice(0, 1);
            }
        }
        draw() {
            drawCircle(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale);
            c.lineWidth = 1;
            if (roidFill.checked == true) {
                c.fillStyle = `hsl(${this.hue}, ${this.saturation}%, ${this.lightness}%, ${this.alpha}%)`;
                c.fill();
            } else {
                c.strokeStyle = `hsla(${this.hue}, ${this.saturation}%, ${this.lightness}%, ${this.alpha}%)`;
                c.stroke();
            }
        }
    }

    //  SPAWN EXHAUST  -----------------------------------------
    function spawnThrustExhaustlets(x, y, ang) {
        for (var s = 0; s < 10; s++) {
            var exhaustScatterX = -0.15 + 0.30 * Math.random();
            var exhaustScatterY = -0.15 + 0.30 * Math.random();
            var pos = new Vector2(
                x - 0.3 * Roket[0].radius * Math.cos(ang), 
                y - 0.3 * Roket[0].radius * Math.sin(ang));
            var vel = new Vector2(
                -0.45 * Math.cos(ang) + exhaustScatterX + Roket[0].vel.x, 
                -0.45 * Math.sin(ang) + exhaustScatterY + Roket[0].vel.y);
            var radius = 0;     
            var maxRadius = 0.01 + 0.02 * Math.random();
            if (weaponLevel < maxWeaponLevel - 2) {
                var hue = 300;
            } else {
                var hue = 360 * Math.random();
            }
            var saturation = 30 + 50 * Math.random();
            var lightness = 30 + 50 * Math.random();
            var alpha = 0;
            var birthday = Date.now();
            var lifespan = 1000;
            var age = 0;
        
            //  SPAWN AT ROKET POSITION  -----------------
            Exhaustlets.push (new THRUSTLET(pos, vel, radius, maxRadius, 
            hue, saturation, lightness, alpha, birthday, lifespan, age));
        }
    }

    //  SPAWN ENGINE IDLE EXHAUST  -------------------
    function spawnIdleExhaustlets(x, y, ang, iff) {
        var exhaustScatterX = -0.05 + 0.1 * Math.random();
        var exhaustScatterY = -0.05 + 0.1 * Math.random();
        var pos = new Vector2(
            x - 0.02 * Math.cos(ang), 
            y - 0.02 * Math.sin(ang));
        var vel = new Vector2(
            -0.05 * Math.cos(ang) + exhaustScatterX, 
            0.05 * Math.sin(ang) + exhaustScatterY);
        var radius = 0;     
        var maxRadius = 0.01 + 0.03 * Math.random();
        if (iff == 'friend') {
            var hue = 0;
        } else {
            var hue = 180;
        }
        var saturation = 10 + 20 * Math.random();
        var lightness = 30 + 50 * Math.random();
        var alpha = 0;
        var birthday = Date.now();
        var lifespan = 1000;
        var age = 0;
      
        //  SPAWN AT ROKET POSITION  -----------------
        Exhaustlets.push (new THRUSTLET(pos, vel, radius, maxRadius, 
        hue, saturation, lightness, alpha, birthday, lifespan, age));
    }

    //  DEFINE STEERING RETRO THRUSTLET  -------------------
    class RETROLET {
        constructor(pos, vel, maxRadius, 
        hue, saturation, lightness, alpha, birthday, lifespan, age) {
            this.pos = pos.clone();
            this.vel = vel.clone();
            this.maxRadius = maxRadius;
            this.hue = hue;
            this.saturation = saturation;
            this.lightness = lightness;
            this.alpha = alpha;
            this.birthday = birthday;
            this.lifespan = lifespan;
            this.age = age;
        }
        simulate() {
            this.age = Date.now() - this.birthday;
            this.radius = this.maxRadius * (this.age / this.lifespan);
            this.alpha = 100 - ((Date.now() - this.birthday)) * 100 / this.lifespan;
            this.pos.add(this.vel, dT)
            if (Date.now() - this.birthday > this.lifespan) {
                RetroLets.splice(0, 1);
            }
        }
        draw() {
            drawCircle(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale);
            c.lineWidth = 1;
            if (roidFill.checked == true) {
                c.fillStyle = `hsl(${this.hue}, ${this.saturation}%, ${this.lightness}%, ${this.alpha}%)`;
                c.fill();
            } else {
                c.strokeStyle = `hsla(${this.hue}, ${this.saturation}%, ${this.lightness}%, ${this.alpha}%)`;
                c.stroke();
            }
        }
    }

    //  SPAWN RETRO EXHAUST  -----------------------------------------
    function spawnRetro(x, y) {
        roket = Roket[0];
        if (firstRetroPass == true) {
            var pos = new Vector2(
            roket.pos.x + 0.3 * roket.radius * Math.cos(roket.angle), 
            roket.pos.y + 0.3 * roket.radius * Math.sin(roket.angle)
            );
            var vel = new Vector2(
            0.5 * Math.cos(roket.angle),
            0.5 * Math.sin(roket.angle)
            );
            firstRetroPass = false;
        } else {
            var pos = new Vector2(
            roket.pos.x - 0.3 * roket.radius * Math.cos(roket.angle), 
            roket.pos.y - 0.3 * roket.radius * Math.sin(roket.angle)
            );
            var vel = new Vector2(
            0.5 * Math.cos(Math.PI + roket.angle),
            0.5 * Math.sin(Math.PI + roket.angle)
            );
            firstRetroPass = true;
        }
        var maxRadius = 0.01 + 0.02 * Math.random();
        var hue = 60;
        var saturation = 30 + 50 * Math.random();
        var lightness = 30 + 50 * Math.random();
        var alpha = 0;
        var birthday = Date.now();
        var lifespan = 1000;
        var age = 0;
      
        //  SPAWN AT ROKET POSITION  -----------------
        RetroLets.push (new RETROLET(pos, vel, maxRadius, 
        hue, saturation, lightness, alpha, birthday, lifespan, age));
    }

    //  DEFINE RESPAWN STARS AND GRAPHIC  -------------------
    class SPAWNLET {
        constructor(pos, vel, radius, maxRadius, 
        hue, saturation, lightness, alpha, birthday, lifespan, spin, angle) {
            this.pos = pos.clone();
            this.vel = vel.clone();
            this.radius = radius;
            this.maxRadius = maxRadius;
            this.hue = hue;
            this.saturation = saturation;
            this.lightness = lightness;
            this.alpha = alpha;
            this.birthday = birthday;
            this.lifespan = lifespan;
            this.spin = spin;
            this.angle = angle;
        }
        simulate() {
            this.radius = this.maxRadius * ((Date.now() - this.birthday)) / this.lifespan;
            this.alpha = 100 - ((Date.now() - this.birthday)) * 100 / this.lifespan;
            this.pos.add(this.vel, dT)
            this.angle += this.spin;
            if (Date.now() - this.birthday > this.lifespan) {
                Spawnlets.splice(0, 1);
            }
        }
        draw() {
            const starWedges = Math.PI / 5;
            var innerRadius = 0.5 * this.radius;
            var outerRadius = 1.5 * this.radius;
            c.beginPath();
            for (var v = 0; v < 10; v++) {
                if (v == 0) {
                    c.moveTo((this.pos.x + innerRadius * Math.cos(this.angle + v * starWedges)) * cScale, (this.pos.y + innerRadius * Math.sin(this.angle + v * starWedges)) * cScale);
                } else 
                if (v % 2 == 0) {  //inner
                    c.lineTo((this.pos.x + innerRadius * Math.cos(this.angle + v * starWedges)) * cScale, (this.pos.y + innerRadius * Math.sin(this.angle + v * starWedges)) * cScale);
                } else {  //outer
                    c.lineTo((this.pos.x + outerRadius * Math.cos(this.angle + v * starWedges)) * cScale, (this.pos.y + outerRadius * Math.sin(this.angle + v * starWedges)) * cScale);
                }
            }
            c.closePath();
            //drawCircle(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale);
            c.fillStyle = `hsla(${this.hue}, ${this.saturation}%, ${this.lightness}%, ${this.alpha}%)`;
            c.fill();
        }
    }

    //  SPAWN SPAWNLETS  -----------------------------------------
    function spawnSpawnlets(x, y, quant, rad, life) {
        for (var s = 0; s < quant; s++) {
            var spawnletScatterX = -0.1 + 0.2 * Math.random();
            var spawnletScatterY = -0.1 + 0.2 * Math.random();
            var spawnRad = rad * Math.random();
            var spawnAng = 2 * Math.PI * Math.random();
            var spawnX = spawnRad * Math.cos(spawnAng)
            var spawnY = spawnRad * Math.sin(spawnAng)
            var pos = new Vector2(x + spawnX, y + spawnY);
            var vel = new Vector2(spawnletScatterX, spawnletScatterY);
            var radius = 0;  
            var maxRadius = 0.02 + 0.04 * Math.random();
            var hue = 360 * Math.random();
            var saturation = 50 + 50 * Math.random();
            var lightness = 30 + 30 * Math.random();
            var alpha = 0;
            var birthday = Date.now();
            var lifespan = life;
            var spin = 0.05 * (-0.5 + Math.random());
            var angle = 360 * Math.random();
        
            Spawnlets.push (new SPAWNLET(pos, vel, radius, maxRadius, 
            hue, saturation, lightness, alpha, birthday, lifespan, spin, angle));
        }
    }

    //  DEFINE UPGRADE PRIZE  --------------------
    class PRIZE {
        constructor(pos, vel, radius, birthday) {
            this.pos = pos.clone();
            this.vel = vel.clone()
            this.radius = radius;
            this.birthday = birthday;
            this.angularposition = 0;
            this.startingRadius = radius;
        }
        simulate() {
            this.pos.add(this.vel, dT);
            this.angularposition += 0.08;
        }
        draw() {
            c.fillStyle = 'black'
            drawCircle(
                this.pos.x * cScale,
                this.pos.y * cScale,
                this.radius * cScale);
            c.fill();

            c.strokeStyle = 'yellow'
            c.lineWidth = 0.2 * this.radius * cScale;
            drawCircle(
                this.pos.x * cScale,
                this.pos.y * cScale,
                this.radius * cScale);
            c.shadowColor = 'black';
            c.shadowBlur = 10;
            c.stroke();
            c.shadowBlur = 0;
            
            textPulse += 0.2;
            var lightness = 50 * Math.abs(Math.cos(textPulse));
            c.fillStyle = `hsl(0, 90%, ${lightness}%)`
            c.textAlign = 'center';
            c.textBaseline = 'middle';
            c.font = `bold ${3 * this.radius * cScale}px monospace`;
            c.fillText('+', this.pos.x * cScale, (this.pos.y + 0.15 * this.radius) * cScale);

            //  STARS  ----------------- (drawStar function applies cScale itself)
            var starQuant = 8;
            if (poofPrize == true) {
                poofStars += 0.5;
                for (var d = 0; d < starQuant; d++) {
                    var stardist = 2 * this.startingRadius + 0.6 * poofStars * this.startingRadius;
                    var radialGrowthFade = 100 - 1.5 * (this.startingRadius - this.radius) / this.startingRadius * 100;
                    drawStar(new Vector2(
                        (this.pos.x + stardist * Math.cos(this.angularposition + d * 2 * Math.PI / starQuant)), 
                        (this.pos.y + stardist * Math.sin(this.angularposition + d * 2 * Math.PI / starQuant))), 
                        this.startingRadius + 0.2 * poofStars * this.startingRadius, 
                        Math.PI / 5 + this.angularposition + d * 2 * Math.PI / starQuant);
                    if (weaponLevel < maxWeaponLevel - 2 || weaponLevel > maxWeaponLevel - 2) {
                        if (d % 2 == 0) {
                            c.fillStyle = `hsla(0, 0%, 80%, ${radialGrowthFade}%)`;
                        } else {    
                            c.fillStyle = `hsla(0, 100%, 50%, ${radialGrowthFade}%)`;
                        }
                    } else {
                        c.fillStyle = `hsla(${360 * d / starQuant}, 80%, 50%, ${radialGrowthFade}%)`;     
                    }
                    c.lineWidth = (0.1 * this.startingRadius + 0.00005 * poofStars) * cScale;
                    c.fill();
                } 
            } else {
                poofStars = 1;
                for (var d = 0; d < starQuant; d++) {
                    var stardist = 2 * this.radius + 2 * this.radius * Math.abs(Math.cos(this.angularposition));
                    drawStar(new Vector2(
                        (this.pos.x + stardist * Math.cos(this.angularposition + d * 2 * Math.PI / starQuant)), 
                        (this.pos.y + stardist * Math.sin(this.angularposition + d * 2 * Math.PI / starQuant))), 
                        1 * this.radius + 10 * (stardist - 2 * this.radius) * this.radius, 
                        Math.PI / 5 + 1.5 * this.angularposition + d * 2 * Math.PI / starQuant);
                    if (weaponLevel < maxWeaponLevel - 3) {
                        if (d % 2 == 0) {
                            c.fillStyle = `hsl(0, 0%, 80%)`;
                        } else {    
                            c.fillStyle = `hsl(0, 100%, 50%)`;
                        }
                    } else {
                        c.fillStyle = `hsl(${360 * d / starQuant}, 90%, 50%)`;     
                    }
                    c.fill();
                }

            }
            
            // DISAPPEAR PRIZE  ----------------
            if (poofPrize == true) {
                this.radius -= 0.0002;
                if (this.radius <= 0) {
                    Prize = [];
                    poofPrize = false;
                }
                c.fillStyle = `hsl(60, 50%, 50%)`
                c.font = `${1.9 * this.radius * cScale}px monospace`;
                c.textAlign = 'center';
                //c.strokeStyle = 'green'
                c.lineWidth = 0.05 * this.radius * cScale;
                if (weaponLevel <= maxWeaponLevel - 3) {
                    c.fillText(`TORPEDO x ${weaponLevel + 1}`, this.pos.x * cScale, (this.pos.y - 3.5 * this.radius) * cScale);
                } else if (weaponLevel == maxWeaponLevel - 2) {
                    c.fillText(`TASTE THE RAINBOW!!!`, this.pos.x * cScale, (this.pos.y - 3.5 * this.radius) * cScale);
                } else if (weaponLevel == maxWeaponLevel - 1) {
                    c.fillText(`MASTER BLASTER!!!`, this.pos.x * cScale, (this.pos.y - 3.5 * this.radius) * cScale);
                } else if (weaponLevel == maxWeaponLevel) {
                    c.fillText(`NO CAN DEFEND!!!`, this.pos.x * cScale, (this.pos.y - 3.5 * this.radius) * cScale);
                }
                
            }
        }
    }

    //  SPAWN UPGRADE PRIZE  --------------------
    function spawnPrize(pos) {
        var pos = new Vector2(pos.x, pos.y);
        var vel = new Vector2(0.1 * Math.random(), 0.1 * Math.random());
        var radius = 0.035;
        var birthday = Date.now();

        Prize.push(new PRIZE(pos, vel, radius, birthday));
    }

    //  COLLISION DETECTION  ========================================
    
    //  HANDLE  PRIZE  COLLECTION  -------------------
    function handlePrizeCollisions(roket, prize) {
        var dir = new Vector2();
        dir.subtract(roket.pos, prize.pos);
        var d = dir.length();
        if (d < roket.radius + prize.radius && (Date.now() - prizeTimer) > 5000) {
            //  HIT  --------------------
            prizeTimer = Date.now();
            weaponLevel += 1;
            if (weaponLevel > maxWeaponLevel) {
                weaponLevel = maxWeaponLevel;
            }
            poofPrize = true;
            poofPrizeDate = Date.now();
        }
    }

    //  HANDLE ROKET ROID COLLISIONS  -------------------
    function handleRoketRoidCollisions(roket, roid1) {
        var dir = new Vector2();
        dir.subtract(roket.pos, roid1.pos);
        var d = dir.length();
        dir.scale(1.0 / d);
        var now = Date.now();
        roid1.polkadotFlashTimer = 0.5;
        if (shieldsUp != true) {  //  shields are down  ----------
            if (d <= 0.5 * roket.radius + roid1.radius) {
                var corr = (roid1.radius + 0.5 * roket.radius - d);
                var v1 = roid1.vel.dot(dir);
                var v2 = roket.vel.dot(dir);
                var m1 = roid1.mass;
                var m2 = roid1.mass;
                var newV2 = (m1 * v1 + m2 * v2 - m1 * (v2 - v1) * 1) / (m1 + m2);
                if (roid1.type != 'suds') {
                    spawnParticleDebris(roket.pos, 0.003, roid1.hue, roid1.hue2, 80, 200, 0.8, 'roid');
                } else {
                    spawnParticleDebris(roket.pos, 0.003, roid1.hue, roid1.hue2, 80, 1, 0.8, 'roid');
                }

                roket.pos.add(dir, corr);
                roket.vel.add(dir, newV2 - v2);

                tumbling = true;
                if (!athena.checked) {
                    Roket[0].collision += 1;
                }

                if (roid1.eyeball) {
                    var collisionX = roid1.pos.x + dir.x * roid1.radius;
                    var collisionY = roid1.pos.y + dir.y * roid1.radius;
                    var ang = Math.atan2(collisionY - roid1.pos.y, collisionX - roid1.pos.x);
                    roid1.eyeball.targetAngle = ang;
                    roid1.eyeball.lookAtPointX = collisionX;
                    roid1.eyeball.lookAtPointY = collisionY;
                    roid1.eyeball.lookAtPointUntil = now + 1000; // ms
                    roid1.eyeball.shrinkOnFace = true;
                    roid1.eyeball.pupilAnimTo = Math.max(roid1.eyeball.pupilOriginalScale * 0.5, roid1.eyeball.pupilScale * 0.5, 0.01);
                    roid1.eyeball.pupilAnimDuration = 500; // ms
                }
            }
        } else {  //  shields are up  ---------
            if (d <= 1.0 * roket.radius + roid1.radius) {
                var corr = (roid1.radius + 1.0 * roket.radius - d);
                var v1 = roid1.vel.dot(dir);
                var v2 = roket.vel.dot(dir);
                var m1 = roid1.mass;
                var m2 = roid1.mass;
                var newV1 = (m1 * v1 + m2 * v2 - m2 * (v1 - v2) * 1) / (m1 + m2);
                var newV2 = (m1 * v1 + m2 * v2 - m1 * (v2 - v1) * 1) / (m1 + m2);

                roid1.pos.add(dir, -corr);
                roid1.vel.add(dir, newV1 - v1);
                
                if (roid1.eyeball) {
                    // collision point on the surface of the roid toward the Roket
                    var collisionX = roid1.pos.x + dir.x * roid1.radius;
                    var collisionY = roid1.pos.y + dir.y * roid1.radius;
                    var ang = Math.atan2(collisionY - roid1.pos.y, collisionX - roid1.pos.x);
                    roid1.eyeball.targetAngle = ang;
                    roid1.eyeball.lookAtPointX = collisionX;
                    roid1.eyeball.lookAtPointY = collisionY;
                    roid1.eyeball.lookAtPointUntil = now + 1000; // ms
                    roid1.eyeball.shrinkOnFace = true;
                    roid1.eyeball.pupilAnimTo = Math.max(roid1.eyeball.pupilOriginalScale * 0.5, roid1.eyeball.pupilScale * 0.5, 0.01);
                    roid1.eyeball.pupilAnimDuration = 500; // ms
                }
            }
        }
    }

    //  HANDLE ROKET BOMB COLLISIONS  -------------------
    function handleRoketBombCollisions(roket, bomb) {
        var dir = new Vector2();
        dir.subtract(roket.pos, bomb.pos);
        var d = dir.length();
        if (shieldsUp != true && athena.checked != true) {  //  shields are down  ----------
            if (d < 0.5 * roket.radius + bomb.radius) {
                //  HIT  --------------------
                Roket[0].collision = 2;
                streak = 1;
                //  EXPLODE BOMB  -------------
                if (typeof bomb.startExplosion === 'function') bomb.startExplosion(); 
                    else { bomb.exploding = true; bomb.birthday = Date.now(); 
                if (typeof bomb._explosionOrigin !== 'undefined') delete bomb._explosionOrigin; }
            }
        } else {
            if (d < 1.0 * roket.radius + bomb.radius) {
                //  EXPLODE BOMB  -------------
                if (typeof bomb.startExplosion === 'function') bomb.startExplosion(); 
                    else { bomb.exploding = true; bomb.birthday = Date.now(); 
                if (typeof bomb._explosionOrigin !== 'undefined') delete bomb._explosionOrigin; }
            }
        } 
    }

    //  HANDLE ENEMY ROKET COLLISIONS  -------------------
    function handleRoketEnemyCollisions(roket, enemy) {
        var dir = new Vector2();
        dir.subtract(roket.pos, enemy.pos);
        var d = dir.length();
        //dir.scale(1.0 / d);
        if (shieldsUp != true && athena.checked != true) {  //  shields are down  ---------
            if (d < 0.5 * roket.radius + enemy.radius) {
                //  HIT  --------------------
                trash = TrashTalk[Math.floor(Math.random() * TrashTalk.length)];
                Enemy[0].lol = true;
                lolStart = Date.now();
                Roket[0].collision = 2;
                streak = 1;
            }
            if (gameIdle == true) {
                makePulse(Roket[0].pos);
                spawnSpawnlets(Roket[0].pos.x, Roket[0].pos.y, 50, 0.05, 2000);
            } 
        } else {  //  shields are up  ----------
            if (d < 1.0 * roket.radius + enemy.radius) {
                //  HIT  --------------------
                var corr = (enemy.radius + 1.0 * roket.radius - d);
                var v1 = enemy.vel.dot(dir);
                var v2 = roket.vel.dot(dir);
                var m1 = .01;
                var m2 = .01;
                var newV1 = (m1 * v1 + m2 * v2 - m2 * (v1 - v2) * 1) / (m1 + m2);
                var newV2 = (m1 * v1 + m2 * v2 - m1 * (v2 - v1) * 1) / (m1 + m2);

                roket.pos.add(dir, corr);
                roket.vel.add(dir, newV1 - v1);
                enemy.pos.add(dir, -corr);
                enemy.vel.add(dir, newV2 - v2);
            }
        }
    }

    //  HANDLE  ROKET TO ROID  REENTRY INTERFERENCCE  -------------------
    function findSafeReentry(roid, startReentryPos) {
        var entryPos = new Vector2(startReentryPos.x, startReentryPos.y);
        var dir = new Vector2();
        dir.subtract(startReentryPos, roid.pos);
        var d = dir.length();
        if (d <= roid.radius) {
            if (startReentryPos.x == 0) {
                // go right
                entryPos.x = roid.right + Roket[0].radius;
            }
            if (startReentryPos.x == simWidth) {
                // go left
                entryPos.x = roid.left - Roket[0].radius;
            }
            if (startReentryPos.y == simHeight) {
                // go up
                entryPos.y = roid.top - Roket[0].radius;
            }
            if (entryPos.y == 0) {
                // go down
                entryPos.y = roid.bottom + Roket[0].radius;
            }
            spawnWarpIn(entryPos);
        }
        return entryPos;
    }

    //  HANDLE BOMB ROKET COLLISIONS  -------------------
    function handleBombRoketCollisions(roket, bomb) {
        var dir = new Vector2();
        dir.subtract(bomb.pos, roket.pos);
        var d = dir.length();
        var now = Date.now();

        // safety: ensure roket collision counter exists
        //if (typeof Roket[0].collision === 'undefined') Roket[0].collision = 0;
        // Cooldown (milliseconds) to prevent repeated triggers from same bomb/roket
        const COOLDOWN_MS = 700;
        var now = Date.now();
        if (typeof bomb._roketLastHit === 'undefined') bomb._roketLastHit = 0;
        if (typeof roket._lastBombHit === 'undefined') roket._lastBombHit = 0;
        // If the bomb is already exploding, ignore prior cooldowns so the explosion
        // can lethally affect a roket immediately. For non-exploding bombs we still
        // respect the cooldown to avoid repeated triggers.
        if (!bomb.exploding) {
            if (now - bomb._roketLastHit < COOLDOWN_MS) return;
            if (now - roket._lastBombHit < COOLDOWN_MS) return;
        }

        // lethal and tumble radii thresholds  ----------
        if (bomb.exploding) {
            var lethalRadius = 3 * bomb.radius;
            var tumbleRadius = 7 * bomb.radius;
        } else {
            var lethalRadius = roket.radius + bomb.radius;
            var tumbleRadius = 0;
        }

        if (!athena.checked) {
            // Additional safety: if the bomb has an initialized visual explosion radius
            // (_explosionOrigin), compute the visual radius and require the distance
            // to be within that visual radius (plus roket radius) to trigger lethal.
            var visualRadiusOk = true;
            if (typeof bomb._explosionOrigin !== 'undefined') {
                var elapsed = (Date.now() - bomb.birthday) / 1000;
                var peak = Math.max(0.15, bomb._explosionOrigin * 8);
                var decay = 12.0;
                var visualRadius = bomb._explosionOrigin + peak * (1 - Math.exp(-decay * elapsed));
                visualRadiusOk = (d <= visualRadius + roket.radius + 0.0001);
            }
            //  check lethal radius distance  ----------
            if (d <= lethalRadius && visualRadiusOk && shieldsUp != true) {
                // lethal hit  ----------
                Roket[0].collision = 2;
                streak = 1;
                //  save relative rocket to bomb angle for blast ---------
                bombBlastAngle = Math.atan2(dir.y, dir.x);
                sayByeBye = true;
                if (typeof bomb.startExplosion === 'function') bomb.startExplosion(); else { bomb.exploding = true; bomb.birthday = Date.now(); if (typeof bomb._explosionOrigin !== 'undefined') delete bomb._explosionOrigin; }
                bomb._roketLastHit = now;
                roket._lastBombHit = now;
                bomb._roketAffected = true;
            } else if (d <= tumbleRadius) {
                //  check lethal radius distance  ----------
                if (!bomb._roketAffected) {
                    try {
                        var nd = dir.clone();
                        if (nd.length() > 0) {
                            nd.normalize();
                            var impulse = 3 * (tumbleRadius - d) / tumbleRadius;
                            // push roket away from bomb center
                            Roket[0].vel.add(nd, -impulse);
                        }
                    } catch (e) {}
                    bomb._roketLastHit = now;
                    roket._lastBombHit = now;
                    bomb._roketAffected = true;
                }
            } 
        }
    }

    //  HANDLE BOMB ROID COLLISIONS  -------------------
    function handleBombRoidCollisions(roid1, bomb) {
        var dir = new Vector2();
        dir.subtract(bomb.pos, roid1.pos);
        var d = dir.length();
        if (bomb.exploding != true) {
            if (d == 0.0 || d > roid1.radius + bomb.radius)
            return;
        }

        if (d < roid1.radius + bomb.radius) {
            if (typeof bomb.startExplosion === 'function') bomb.startExplosion(); else { bomb.exploding = true; bomb.birthday = Date.now(); if (typeof bomb._explosionOrigin !== 'undefined') delete bomb._explosionOrigin; }
        }

        if (bomb.exploding == true) {
            if (d < roid1.radius + 6 * bomb.radius) {
                // lazily initialize a Set of roids affected by this bomb
                if (!bomb._affectedRoids) bomb._affectedRoids = new Set();

                // only apply effect once per roid per bomb
                if (!bomb._affectedRoids.has(roid1)) {
                    bomb._affectedRoids.add(roid1);
                    //  HIT  -------------------------------
                    //  make ring of fire particles  ---------
                    var velocity = roid1.vel.clone();
                    velocity.normalize();
                    velocity.scale(0.05);
                    spawnRingOfFire(roid1.pos, roid1.radius, roid1.hue, velocity);
                    roid1.radius *= 0.80;
                    //  REMOVE IF TOO SMALL  ----------
                    if (roid1.type == 'globe') {
                        if (roid1.radius <= 0.3 * roid1.originalRadius) {
                            var ri = Roids.indexOf(roid1);
                            if (ri !== -1) Roids.splice(ri, 1);
                        } 
                    } else {
                        if (roid1.radius <= 0.05) {
                            var ri = Roids.indexOf(roid1);
                            if (ri !== -1) Roids.splice(ri, 1);
                        }
                    }
                }
            }   
        }
    }

    //  HANDLE PACMAN MOON COLLISIONS  -------------------
    function handlePacmanMoonCollisions(pacman, moon) {
        var scaledMoon = new Vector2(Moon[0].pos.x / cScale, Moon[0].pos.y / cScale);
        var dir = new Vector2();
        dir.subtract(scaledMoon, pacman.pos);
        var d = dir.length();
        if (d == 0.0 || d > (0.5 * pacman.radius) + moon.radius / cScale)
            return;
        Moon.splice(0, 1);
    }

    //  HANDLE ROID ROID COLLISIONS  -------------------
    function handleRoidRoidCollisions(roid1, roid2) {
        var dir = new Vector2();
        dir.subtract(roid2.pos, roid1.pos);
        var d = dir.length();
        if (d == 0.0 || d > roid1.radius + roid2.radius)
            return;

        dir.scale(1.0 / d);
        var corr = (roid1.radius + roid2.radius - d) / 2.0;
        var v1 = roid1.vel.dot(dir);
        var v2 = roid2.vel.dot(dir);
        var m1 = roid1.mass;
        var m2 = roid2.mass;
        var newV1 = (m1 * v1 + m2 * v2 - m2 * (v1 - v2) * 1) / (m1 + m2);
        var newV2 = (m1 * v1 + m2 * v2 - m1 * (v2 - v1) * 1) / (m1 + m2);

        roid1.pos.add(dir, -corr);
        roid2.pos.add(dir, corr);
        roid1.vel.add(dir, newV1 - v1);
        roid2.vel.add(dir, newV2 - v2);

        // MAKE ROID DEBRIS  ----------
        // Calculate collision point on the surface of roid1 (dir is already normalized)
        let collisionX = roid1.pos.x + dir.x * roid1.radius;
        let collisionY = roid1.pos.y + dir.y * roid1.radius;

        // Or, equivalently, on the surface of roid2:
        let collisionX2 = roid2.pos.x - dir.x * roid2.radius;
        let collisionY2 = roid2.pos.y - dir.y * roid2.radius;

        // Scale impulseMag to a debris count (adjust the factor as needed)
        // Linear impulse (magnitude) delivered to each roid (from velocity change along normal)
        let impulseMag = Math.abs(newV1 - v1) * roid1.mass; // same as for roid2
        let debrisCount = Math.max(5, Math.min(100, Math.round(impulseMag * 3000)));

        // Use the contact point on the surface of roid1 as the debris origin
        if (roid1.type != 'suds' || roid2.type != 'suds') {
            spawnParticleDebris(new Vector2(collisionX, collisionY), 0.003, roid1.hue, roid2.hue, 80, debrisCount, 0.8, 'bomb');
        } else {
            spawnParticleDebris(new Vector2(collisionX, collisionY), 0.003, roid1.hue, roid2.hue, 80, 0.1 * debrisCount, 0.8, 'bomb');
        }
        // polkadot visual flash remains optional
        //if (polkadots.checked == true) {
            
        roid1.polkadotFlashTimer = 0.5;

        // If either roid is an eyeball, have it look at the collision contact point for 1 second.
        var now = Date.now();
        if (roid1.eyeball) {
            var ang1 = Math.atan2(collisionY - roid1.pos.y, collisionX - roid1.pos.x);
            roid1.eyeball.targetAngle = ang1;
            // prefer collision point look (separate timer) so it doesn't get confused with rocket-looking
            roid1.eyeball.lookAtPointX = collisionX;
            roid1.eyeball.lookAtPointY = collisionY;
            roid1.eyeball.lookAtPointUntil = now + 1000; // ms
            // request pupil shrink after the eye has finished turning to face the collision
            roid1.eyeball.shrinkOnFace = true;
            // desired target scale is half of current, but never less than half the original pupil size
            roid1.eyeball.pupilAnimTo = Math.max(roid1.eyeball.pupilOriginalScale * 0.5, roid1.eyeball.pupilScale * 0.5, 0.01);
            // prepare animation duration (0.5s) but do not start yet; simulate() will begin it once rotation completes
            roid1.eyeball.pupilAnimDuration = 500; // ms
            // do NOT snap immediately; simulate() will smoothly rotate the eye toward target
        }
        if (roid2.eyeball) {
            // use collision point on roid2 surface (collisionX2, collisionY2)
            var ang2 = Math.atan2(collisionY2 - roid2.pos.y, collisionX2 - roid2.pos.x);
            roid2.eyeball.targetAngle = ang2;
            roid2.eyeball.lookAtPointX = collisionX2;
            roid2.eyeball.lookAtPointY = collisionY2;
            roid2.eyeball.lookAtPointUntil = now + 1000; // ms
            roid2.eyeball.shrinkOnFace = true;
            roid2.eyeball.pupilAnimTo = Math.max(roid2.eyeball.pupilOriginalScale * 0.5, roid2.eyeball.pupilScale * 0.5, 0.01);
            roid2.eyeball.pupilAnimDuration = 500; // ms
            // do NOT snap immediately; simulate() will smoothly rotate the eye toward target
        }

        roid2.polkadotFlashTimer = 0.5;

        // --- Always apply angular effects from collisions (torque + friction) ---
        // 1. Vector from A to B
        let dx = roid2.pos.x - roid1.pos.x;
        let dy = roid2.pos.y - roid1.pos.y;
        if (d == 0) return; // avoid division by zero
        // 2. Normal and tangent at contact
        let nx = dx / d, ny = dy / d;
        let tx = -ny, ty = nx;
        // 5. Moment of inertia for solid disk: I = 0.5 * m * r^2
        let IA = 0.5 * roid1.mass * roid1.radius * roid1.radius;
        let IB = 0.5 * roid2.mass * roid2.radius * roid2.radius;

        //  IMPULSE FROM COLLISION  ----------------
        // Contact point relative to center (assume contact at edge)
        let rA = roid1.radius;
        let rB = roid2.radius;
        // Direction of impact (tangent sign)
        let signA = Math.sign((roid1.vel.x - roid2.vel.x) * ty - (roid1.vel.y - roid2.vel.y) * tx);
        let signB = -signA;
        //  Apply angular impulse (torque = r x F, here F = impulse/dt)
        //  d(omega) = torque / I = (r * impulse) / I
        // increase torque factor so collisions produce visible 3D tumble
        // stronger collision torque for more visible tumble
        let deltaOmegaCollA = signA * 0.03 * impulseMag * rA / IA;
        let deltaOmegaCollB = signB * 0.03 * impulseMag * rB / IB;
        roid1.angularVelocity += deltaOmegaCollA;
        roid2.angularVelocity += deltaOmegaCollB;
        // update 3D angular rates: primarily affect yaw (z)
        roid1.omega.z += deltaOmegaCollA;
        roid2.omega.z += deltaOmegaCollB;
        // Deterministic tumble: map contact point on each roid to pitch/roll changes
        const collisionTumble = 3.0; // amplify mapping into pitch/roll
        // contact point relative to roid centers
        let relAx = (collisionX - roid1.pos.x) / roid1.radius; // -1..1
        let relAy = (collisionY - roid1.pos.y) / roid1.radius; // -1..1
        let relBx = (collisionX2 - roid2.pos.x) / roid2.radius;
        let relBy = (collisionY2 - roid2.pos.y) / roid2.radius;
        // Map relative position to pitch/roll: hit toward top (relAy < 0) -> positive pitch change
        roid1.omega.x += -relAy * collisionTumble * deltaOmegaCollA; // pitch
        roid1.omega.y += relAx * collisionTumble * deltaOmegaCollA;  // roll
        roid2.omega.x += -relBy * collisionTumble * deltaOmegaCollB;
        roid2.omega.y += relBx * collisionTumble * deltaOmegaCollB;

        //  FRICTIONAL TRANSFER OF ROTATIONAL VELOCITY  ----------------
        //  Relative velocity at contact point (linear + rotational)
        // Compute rotational surface velocity from 3D omega: v = omega x r_contact
        // For contact on rim, r_contact ~ (tx * r, ty * r, 0) in local plane.
        // omega cross r = (omega.y * 0 - omega.z * r_contact.y, omega.z * r_contact.x - omega.x * 0, omega.x * r_contact.y - omega.y * r_contact.x)
        let rA_contact = { x: tx * roid1.radius, y: ty * roid1.radius, z: 0 };
        let rB_contact = { x: -tx * roid2.radius, y: -ty * roid2.radius, z: 0 };
        let vA_rot_x = roid1.omega.y * rA_contact.z - roid1.omega.z * rA_contact.y;
        let vA_rot_y = roid1.omega.z * rA_contact.x - roid1.omega.x * rA_contact.z;
        let vB_rot_x = roid2.omega.y * rB_contact.z - roid2.omega.z * rB_contact.y;
        let vB_rot_y = roid2.omega.z * rB_contact.x - roid2.omega.x * rB_contact.z;
        // Project surface velocities onto tangent direction
        let vA = roid1.vel.x * tx + roid1.vel.y * ty + (vA_rot_x * tx + vA_rot_y * ty);
        let vB = roid2.vel.x * tx + roid2.vel.y * ty + (vB_rot_x * tx + vB_rot_y * ty);
        let relVel = vA - vB;
        //  Angular impulse (tweak frictionCoeff for realism)
        let frictionCoeff = 1;
        let impulse = frictionCoeff * relVel;
        //  Update angular velocities
        // Map friction impulse into change in angular rate (Δω = r * impulse / I)
        // stronger friction torque for visible tangential tumble transfer
        let deltaOmegaA = signA * 0.02 * impulse * roid1.radius / IA;
        let deltaOmegaB = signB * 0.02 * impulse * roid2.radius / IB;
        roid1.angularVelocity += deltaOmegaA;
        roid2.angularVelocity += deltaOmegaB;
        // Also nudge 3D omega vectors around the Z axis (yaw) and small X/Y for visible tumble transfer
        roid1.omega.z += deltaOmegaA;
        roid2.omega.z += deltaOmegaB;
        // Deterministic mapping of friction impulse into pitch/roll using contact tangent
        const frictionTumble = 2.0; // amplify mapping into pitch/roll from tangential impulse
        // tangent direction components (tx,ty) already computed
        // map tangent sign and contact offset into pitch/roll contributions
        roid1.omega.x += -ty * frictionTumble * deltaOmegaA; // pitch from tangent
        roid1.omega.y += tx * frictionTumble * deltaOmegaA;  // roll from tangent
        roid2.omega.x += -ty * frictionTumble * deltaOmegaB;
        roid2.omega.y += tx * frictionTumble * deltaOmegaB;
        // Keep scalar angularVelocity roughly in sync with omega.z
        roid1.angularVelocity = roid1.omega.z;
        roid2.angularVelocity = roid2.omega.z;

        //  limit angular velocity  ----------
        // Relax angularVelocity clamp to allow stronger spins from collisions
        roid1.angularVelocity = Math.max(-0.2, Math.min(roid1.angularVelocity, 0.2));
        roid2.angularVelocity = Math.max(-0.2, Math.min(roid2.angularVelocity, 0.2));
    }

    //  HANDLE PUSHER ROID PUSH  -------------------
    function handlePusherRoidPushes(roid1, pusher) {
        var dir = new Vector2();
        dir.subtract(pusher.pos, roid1.pos);
        var d = dir.length();
        if (d <= roid1.radius + 1.1 * pusher.radius) {
            roid1.polkadotFlashTimer = 0.5;
            // Normalize direction
            dir.scale(1.0 / d);
            var corr = 0.9 * (roid1.radius + pusher.radius - d) / 2.0;
            var pushSpeed = -0.2; 
            // Set velocity in push direction
            roid1.vel.x = dir.x * pushSpeed;
            roid1.vel.y = dir.y * pushSpeed;
            // Correct position to avoid sticking
            roid1.pos.add(dir, -corr);
        }
    }

    //  HANDLE ROKET DEBRIS TO ROID BOUNCES  -------------------
    function handleRoketDebrisCollisions(roid1, debris) {
        var dir = new Vector2();
        dir.subtract(debris.pos, roid1.pos);
        var d = dir.length();
        if (d == 0.0 || d > roid1.radius + debris.radius)
            return;

        dir.scale(1.0 / d);
        var corr = (roid1.radius + debris.radius - d) / 2.0;
        var v1 = roid1.vel.dot(dir);
        var v2 = debris.vel.dot(dir);
        var m1 = roid1.mass;
        var m2 = debris.mass;
        var newV1 = (m1 * v1 + m2 * v2 - m2 * (v1 - v2) * 0.8) / (m1 + m2);
        var newV2 = (m1 * v1 + m2 * v2 - m1 * (v2 - v1) * 0.8) / (m1 + m2);
        
        debris.pos.add(dir, corr);
        debris.vel.add(dir, newV2 - v2);
    }

    /*
    //  HANDLE  EXHAUST TO ROID  PUSHES  -------------------
    function handleExhaustPushes(roid1, exhaustlet) {
        var dir = new Vector2();
        dir.subtract(exhaustlet.pos, roid1.pos);
        var d = dir.length();
        if (d > roid1.radius + exhaustlet.radius)
            return;
        
        dir.scale(1.0 / d);
        var v1 = roid1.vel.dot(dir);
        var v2 = exhaustlet.vel.dot(dir);
        var m1 = roid1.mass;
        var m2 = .000001 / exhaustlet.radius;
        var newV1 = (m1 * v1 + m2 * v2 - m2 * (v1 - v2) * 1) / (m1 + m2);
        
        roid1.vel.add(dir, newV1 - v1);
    }
    */

    //  HANDLE PLAYER TORPEDO TO ROID  HITS  -------------------
    function handleTorpedoRoidHits(roid1, torpedo, r, u) {
        var dir = new Vector2();
        dir.subtract(torpedo.pos, roid1.pos);
        var d = dir.length();
        if (d <= torpedo.radius + roid1.radius) {
            //  HIT --------------------
            // Compute contact vector on the sphere surface in 3D with a small, robust
            // out-of-plane component so grazing torpedo hits still produce pitch/roll.
            let rx = torpedo.pos.x - roid1.pos.x;
            let ry = torpedo.pos.y - roid1.pos.y;
            const rlen2 = rx * rx + ry * ry;
            const rRadius = roid1.radius;
            const rlen = Math.sqrt(rlen2);

            // Unit approach direction from torpedo velocity (safeguard zero-length)
            let ax = torpedo.vel.x;
            let ay = torpedo.vel.y;
            let alen = Math.sqrt(ax*ax + ay*ay) || 1.0;
            ax /= alen; ay /= alen;

            // Surface normal (in-plane) from roid center toward impact (safeguard zero)
            let nx = rlen > 1e-9 ? rx / rlen : 0;
            let ny = rlen > 1e-9 ? ry / rlen : 0;

            // How head-on is the approach relative to the local normal? (positive = approaching)
            let approachDot = Math.max(0, -(ax * nx + ay * ny));

            // Heuristic alpha: larger when torpedo center is deeper inside the projected disk
            // and when approach is head-on. Always leave a small floor so rim hits still get some z.
            let penetrationFrac = Math.max(0, 1 - (rlen / rRadius));
            let alpha = Math.max(0.02, penetrationFrac * 0.8 * Math.max(0.1, approachDot));
            // contact z on the sphere surface (positive toward viewer)
            let rz = rRadius * alpha;

            // torpedo impulse vector (assume in-plane force from torpedo velocity)
            // Increase impulse scale so torpedoes can impart noticeable off-axis torque
            const IMPULSE_SCALE = 0.25; // was 0.025
            let fx = torpedo.vel.x * IMPULSE_SCALE;
            let fy = torpedo.vel.y * IMPULSE_SCALE;
            let fz = 0;

            let torqueX = -rz * fy;
            let torqueY = rz * fx;
            let torqueZ = rx * fy - ry * fx;

            let inertia = 0.5 * roid1.mass * rRadius * rRadius;

            // scale into angular velocity change
            // Use separate gains: keep axial (Z) modest to avoid only pole-spin,
            // but amplify off-axis (X/Y) so pitch/roll are visible.
            const TORP_GAIN_Z = 0.15;   // preserves previous axial feel
            const TORP_GAIN_OFF = 0.9;  // stronger off-axis effect
            let deltaOmegaX = TORP_GAIN_OFF * torqueX / inertia;
            let deltaOmegaY = TORP_GAIN_OFF * torqueY / inertia;
            let deltaOmegaZ = TORP_GAIN_Z * torqueZ / inertia;

            // apply to 3D omega so globe roids pick up off-axis tumble
            roid1.omega.x += deltaOmegaX;
            roid1.omega.y += deltaOmegaY;
            roid1.omega.z += deltaOmegaZ;

            // keep scalar compatibility and clamp axial spin used for pole visuals
            roid1.angularVelocity = roid1.omega.z;
            roid1.angularVelocity = Math.max(-0.05, Math.min(roid1.angularVelocity, 0.05));
            roid1.polkadotFlashTimer = 0.5;
            try {
                //console.log('torp hit angulars:', { id: roid1.id || '?', omega: roid1.omega, yaw: roid1.yaw, pitch: roid1.pitch, roll: roid1.roll });
            } catch (e) {}
           
            if (torpedo.friendOrFoe == 'friend') {
                torpedosHit += 1
                var thisScore = streak * ((wave + 4) / 5) * (hitPct/100 * 100 * roid1.vel.length() / roid1.radius);
                spawnScorer(torpedo.pos, thisScore);
                score += thisScore;
            }

            makePulse(torpedo.pos);
            spawnParticleDebris(torpedo.pos, 0.003, roid1.hue, roid1.hue, sat = 80, 200, 0.8, 'roid');
            
            roid1.hue += 5;
            roid1.lightness -= 2;
            if (roid1.type == 'globe') {
                spawnRingOfFire(roid1.pos, roid1.radius, roid1.hue, roid1.vel);
                roid1.radius *= 0.80;
            } else {
                roid1.radius *= 0.75;
            }
            roid1.mass = roid1.radius;
            dir.scale(1.0 / d);  
            var v1 = roid1.vel.dot(dir);
            var v2 = torpedo.vel.dot(dir);
            var m1 = roid1.mass;
            var m2 = 0.01; //roid1.mass;
            var newV1 = (m1 * v1 + m2 * v2 - m2 * (v1 - v2) * 1) / (m1 + m2);
            
            roid1.vel.add(dir, (-0.5 + Math.random()) + 0.2*(newV1 - v1));
            Torpedo.splice(u, 1);
            roid1.polkaSeed = Math.floor(Math.random() * 0xFFFFFFFF);

            if (roid1.eyeball && torpedo.friendOrFoe == 'friend') {
                // only look at the Roket when struck by a player (friend) torpedo
                var until = Date.now() + 3000; // ms
                // Have the struck eyeball look at the Roket
                roid1.eyeball.lookAtRocketUntil = until;
                if (Roket && Roket[0]) {
                    roid1.eyeball.targetAngle = Math.atan2(Roket[0].pos.y - roid1.pos.y, Roket[0].pos.x - roid1.pos.x);
                    // do NOT snap immediately; let simulate() smoothly rotate the eye toward target
                }
                // Additionally, make ALL eyeball roids look at the Roket smoothly for the same duration
                if (Roket && Roket[0]) {
                    for (var i = 0; i < Roids.length; i++) {
                        var rObj = Roids[i];
                        if (rObj && rObj.eyeball) {
                            rObj.eyeball.lookAtRocketUntil = until;
                            rObj.eyeball.targetAngle = Math.atan2(Roket[0].pos.y - rObj.pos.y, Roket[0].pos.x - rObj.pos.x);
                            // do NOT snap; simulate() governs smooth rotation
                        }
                    }
                }
                // Trigger transient iris/pupil spin on the struck eyeball: 720deg over 0.5s
                roid1.eyeball.spinActive = true;
                roid1.eyeball.spinStart = Date.now();
                roid1.eyeball.spinDuration = 500; // ms
                roid1.eyeball.spinTarget = 4 * Math.PI; // radians (720°)
                // Request pupil shrink for the struck eyeball (half size over 0.5s) after it turns to face the rocket
                roid1.eyeball.shrinkOnFace = true;
                roid1.eyeball.pupilAnimTo = Math.max(roid1.eyeball.pupilOriginalScale * 0.5, roid1.eyeball.pupilScale * 0.5, 0.01);
                roid1.eyeball.pupilAnimDuration = 500; // ms
            }

            //  REMOVE IF TOO SMALL  ----------
            if (roid1.type == 'globe') {
                if (roid1.radius <= 0.3 * roid1.originalRadius) {
                    //  SPAWN BOMB  ----------
                    // create bomb and explicitly set its velocity to the roid's current velocit
                    const __b = new BOMB(roid1.pos.clone(), roid1.vel.clone(), 0.0001 * cScale);
                    Bomb.push(__b);
                    // ensure the bomb's velocity matches the roid's (defensive in case constructor mutation occurs)
                    Bomb[Bomb.length - 1].vel = roid1.vel.clone();
                    Roids.splice(r, 1);
                } 
            } else {
                if (roid1.radius <= 0.05) {
                    Roids.splice(r, 1);
                }
            }

            //  SPAWN A NEW ROID IF ORIGINAL WAS BIG ENOUGH  ----------
            if (roid1.type != 'globe') {
                if (0.5 * roid1.radius > 0.05) {
                    var newDir = 2 * Math.PI * Math.random();
                    var pos = new Vector2(
                        roid1.pos.x + 2 * roid1.radius * Math.cos(newDir), 
                        roid1.pos.y + 2 * roid1.radius * Math.sin(newDir));
                    var vel = new Vector2(
                        roid1.vel.x + (-0.5 + Math.random()), 
                        roid1.vel.y + (-0.5 + Math.random()));
                    var radius = 0.5 * roid1.radius;
                    var mass = radius;
                    var hue = roid1.hue + 22.5;
                    var saturation = 30 + 70 * Math.random();
                    var lightness = roid1.lightness - 3;
                    let seed = Math.floor(Math.random() * 0xFFFFFFFF);
                    let randomNo = Math.random();

                    if (roid1.type == 'eyeball') {
                        var type = 'eyeball';
                        Roids.push(new ROID(type, pos, vel, radius, mass, hue, 
                        saturation, lightness, seed, randomNo,
                        roid1.eyeball.lookAngle, roid1.yaw, roid1.pitch, roid1.roll));
                    } else {
                        var type = 'polkadot';
                        Roids.push(new ROID(type, pos, vel, radius, mass, hue, 
                        saturation, lightness, seed, randomNo,
                        roid1.yaw, roid1.pitch, roid1.roll));
                    }
                }

                //  SPAWN ANOTHER NEW ROID IF ORIGINAL WAS BIG ENOUGH  ----------
                if (0.15 * roid1.radius > 0.05) {
                    var newDir = 2 * Math.PI * Math.random();
                    var pos = new Vector2(
                        roid1.pos.x + 2 * roid1.radius * Math.cos(newDir), 
                        roid1.pos.y + 2 * roid1.radius * Math.sin(newDir));
                    var vel = new Vector2(
                        roid1.vel.x + (-0.5 + Math.random()), 
                        roid1.vel.y + (-0.5 + Math.random()));
                    var radius = 0.5 * roid1.radius;
                    var mass = radius;
                    var hue = roid1.hue + 45;
                    var saturation = 30 + 70 * Math.random();
                    var lightness = roid1.lightness - 5;
                    /*// make sure not to spawn too close to existing roids
                    for (var i = 0; i < Roids.length; i++) {
                        var existingRoid = Roids[i];
                        var existingDir = new Vector2();
                        existingDir.subtract(existingRoid.pos, pos);
                        var existingD = existingDir.length();
                        if (existingD < 0.5 * (existingRoid.radius + radius)) {
                            // too close to existing roid, discard this spawn
                            return;
                        }
                    }*/
                    let seed = Math.floor(Math.random() * 0xFFFFFFFF);
                    let randomNo = Math.random();
                    if (roid1.type == 'eyeball') {
                        var type = 'eyeball'
                        Roids.push(new ROID(type, pos, vel, radius, mass, hue, 
                        saturation, lightness, seed, randomNo,
                        roid1.eyeball.lookAngle, roid1.yaw, roid1.pitch, roid1.roll));
                    } else {
                        var type = 'polkadot';
                        Roids.push(new ROID(type,pos, vel, radius, mass, hue, 
                        saturation, lightness, seed, randomNo,
                        roid1.yaw, roid1.pitch, roid1.roll));
                    }
                }
            }
        } 
    }

    //  HANDLE PLAYER TORPEDO ON ENEMY HITS  -------------------
    function handleTorpedoOnEnemyHits(enemy, torpedo) {
        if (torpedo != null && enemy != null) {
            var dir = new Vector2();
            dir.subtract(enemy.pos, torpedo.pos);
            var d = dir.length();
            if (d <= enemy.radius) {
                //  HIT --------------------
                torpedosHit += 1
                var thisScore = streak * ((wave + 4) / 5) * (hitPct / 100) * 10000;
                score += thisScore;
                makePulse(torpedo.pos);
                spawnParticleDebris(torpedo.pos, 0.004, 0, 0, 90, 1000, 1.5, 'torpedo');
                makeEnemyDebris();
                spawnScorer(torpedo.pos, thisScore);
                //  spawn prize -------------------
                if (weaponLevel < maxWeaponLevel) {
                    spawnPrize(Enemy[0].pos);
                }
                //  spawn solo alien in space  -----------
                spawnSoloAlien(enemy.pos);
                // remove the specific torpedo object from the array (find its index first)
                var ti = Torpedo.indexOf(torpedo);
                if (ti !== -1) Torpedo.splice(ti, 1);
                window.clearInterval(gonnaGetcha);
                Enemy = [];
            } 
        }
    }

    //  HANDLE ENEMY TORPEDO ON PLAYER  HITS  -------------------
    function handleTorpedoOnPlayerHits(torpedo) {
        if (torpedo != null && Roket[0] != null) {
            var dir = new Vector2();
            dir.subtract(Roket[0].center, torpedo.pos);
            var d = dir.length();
            if (d < 0.5 * Roket[0].radius && shieldsUp != true) {  // shields are down  ---------
                //  HIT --------------------
                trash = TrashTalk[Math.floor(Math.random() * TrashTalk.length)];
                if (Enemy[0] != null) {
                    Enemy[0].lol = true;
                }
                lolStart = Date.now();
                if (!athena.checked && gameIdle != true) {
                    Roket[0].collision = 2;
                    streak = 1;
                    sayByeBye = true;
                }
                if (gameIdle == true) {
                    makePulse(Roket[0].pos);
                    spawnSpawnlets(Roket[0].pos.x, Roket[0].pos.y, 50, 0.02, 1500);
                } 
                //  REMOVE TORPEDO  ----------
                var ti = Torpedo.indexOf(torpedo);
                if (ti !== -1) {
                    Torpedo.splice(ti, 1);
                }
            } else if (d < 1.0 * Roket[0].radius && shieldsUp == true) {  // shields are up  ---------
                spawnParticleDebris(torpedo.pos, 0.004, 60, 120, 90, 1000, 1.5, 'roid');
                var ti = Torpedo.indexOf(torpedo);
                if (ti !== -1) Torpedo.splice(ti, 1);
            }
        }
    }

    //  HANDLE TORPEDO PULSE AGE OUT  ------------------
    function handlePulseLifespan(pulse, p) {
        if (Date.now() - pulse.birthday > 300) {
                Pulse.splice(p,1);
                firstPulse = true;
        }
    }

    //  HANDLE ROKET DEBRIS AGE OUT  -------------------
    function handleRoketDebrisAge(debris, d) {
        if (Date.now() - debris.birthday > 2000) {
            RoketDebris.splice(d, 1);
            if (RoketDebris.length == 0 && lives > 0) {
                makePusher();
            }
        }
    }

    //  HANDLE ENEMY DEBRIS AGE OUT  -------------------
    function handleEnemyDebrisAge(debris, d) {
        if (Date.now() - debris.birthday > 2000) {
            EnemyDebris.splice(d, 1);
        }
    }
        
    //  HANDLE ROID DEBRIS AGE OUT  -------------------
    function handleRoidDebrisAge(debris, d) {
        if (Date.now() - debris.birthday > 1000) {
                RoidDebris.splice(d, 1);
        }
    }
    
    //  RESET ROKET  ------------------
    function resetRoket() {
        Roket[0].pos = PusherSpot.clone();
        Roket[0].vel = new Vector2(0.15, 0);
        Roket[0].angle = 0;
        Roket[0].collision = 0;
        streak = 1;
        tumbling = false;
        interference = 0;        
    }

    //  SPAWN ENEMY ON PAUSE  ----------
    function introSpawn() {
            spawnEnemy();
            gonnaGetcha = setInterval(spawnEnemyTorpedo, 4000);
        }

    //  PRE RENDER TORPEDO IMPACT FLASH
    function defineOffscreenFlash() {
        flashC.clearRect(0, 0, offscreenFlashCanvas.width, offscreenFlashCanvas.height);
        offscreenDrawCircle(0.2 * cScale, 0.2 * cScale, 0.2 * cScale);
        var sphereGradient = flashC.createRadialGradient(
        0.2 * cScale, 
        0.2 * cScale, 
        0, 
        0.2 * cScale, 
        0.2 * cScale, 
        0.2 * cScale);

        sphereGradient.addColorStop(0.0, `hsla(0, 0%, 100%, 80%)`);
        sphereGradient.addColorStop(0.5, `hsla(30, 50%, 20%, 40%)`);
        sphereGradient.addColorStop(1.0, `hsla(0, 0%, 0%, 0%)`);
        flashC.fillStyle = sphereGradient;
        flashC.fill();
    }

    //  DEFINE STARFIELD ON OFFSCREEN CANVAS  --------------------
    function defineOffscreenStarfield() {
        starfieldC.clearRect(0, 0, offscreenStarfieldCanvas.width, offscreenStarfieldCanvas.height);
        for (var n = 0; n < StarField.length; n++) {
            StarField[n].draw(n);
        }
    }


    //  SIMULATE   ===================================================
    function simulate() {   
        if (userPause == true) {
            return;
        }

        //  HANDLE SHIELD LEVELS  -----------------
        if (shieldsUp == true) {
            shieldLevel -= 0.5;
            if (shieldLevel < 0) {
                shieldLevel = 0;
                shieldsUp = false;
                //blinkShieldsRed = true;
            }
        } else {
            if (shieldLevel < 100) {
                shieldLevel += 0.1 * 60 * dT;
                if (shieldLevel > 100) {
                    shieldLevel = 100;
                }
            }
        }

        //  SLOW TIME  ------------------
        if (timeWarp == true) {
            dT *= 0.95;
            if (dT < 1/500) {dT = 1/500}
        } else {
            dT *= 1.1;
            if (dT >= 1/60) {dT = 1/60}
        }

        //  ADVANCE WAVE WHEN ALL ROIDS AND ENEMIES GONE  -------------------
        if (gameIdle != true) {
            if (wave == 0 || (Roids.length == 0 && spawning == false && Enemy.length == 0 && Bomb.length == 0)) {
                spawning = true;
                spawnCycle += 1;
                if (spawnCycle > 8) {
                    spawnCycle = 1;
                }
                wave += 1;
                if (wave > 1) {
                    streak += 1;
                }
                waveNoBday = Date.now();
                lastRoidSpawnTime = Date.now(); // Track last spawn time (global)
                spawnCounter = 0; // Reset spawnCounter at the start of a new wave
                animateWave = true;
                if (wave > 1) {
                    spawnEnemy();
                    //  SET EMENY FIRE RATE, DECREASE WITH WAVE+ ----------
                    gonnaGetcha = setInterval(spawnEnemyTorpedo, 4000 - (wave * 100));
                }
            }
        }

        //  SIMULATE MOON  -----------
        if (Moon.length > 0 && moonFill.checked == true) {
            Moon[0].simulate();
        }

        // SIMULATE PACMAN  -------------------
        if (gameOver == true) {
            for (var p = 0; p < PacMan.length; p++) {
                PacMan[p].simulate();
                if (Moon.length > 0) {
                    handlePacmanMoonCollisions(PacMan[p], Moon[0]);
                }
            }
        }

        //  SPAWN ROIDS PERIODICALLY (fixed interval)  -------------------
        if (spawning == true && Roket[0] != null) {
            spawnRoids();
        }

        //  SIMULATE ENGINE EXHAUST  ------------------
        for (var y = 0; y < Exhaustlets.length; y++) {
            Exhaustlets[y].simulate();
        }

        //  SIMULATE RETRO EXHAUST  -----------------
        for (var w = 0; w < RetroLets.length; w++) {
            RetroLets[w].simulate();
        }

        //  SIMULATE ROKET ON START  --------------------
        if (gameIdle == true && typeof Roket !== 'undefined' && Roket && Roket.length > 0 && Roket[0]) {
            if (typeof Roket[0].startSimulate === 'function') {
                Roket[0].startSimulate();
            }
        }

        //  SIMULATE PRIZE  -------------------
        if (Prize[0] != null) {
            var prize = Prize[0];
            prize.simulate();

            //  HANDLE PRIZE BOUNDARIES  -------------------  
            if (prize.pos.x > simWidth + 4 * prize.startingRadius ||
            prize.pos.x < 0 - 4 * prize.startingRadius ||
            prize.pos.y < 0 - 4 * prize.startingRadius ||
            prize.pos.y > simHeight + 4 * prize.startingRadius) {
                Prize = [];
            }
        }

        //  SIMULATE ROKET IN PLAY  --------------------
        if (typeof Roket !== 'undefined' && Roket && Roket.length > 0 && Roket[0] && Roket[0].collision < 2 && gameOn == true) {
            if (typeof Roket[0].simulate === 'function') {
                Roket[0].simulate();
            }
            if (untouchable != true) {
                //  HANDLE ROKET ENEMY COLLISIONS  ---------------------
                if (Enemy[0] != null) {
                    handleRoketEnemyCollisions(Roket[0], Enemy[0]);
                }

                //  HANDLE ROKET BOMB COLLISIONS  ------------------
                for (var b = 0; b < Bomb.length; b++) {
                    handleRoketBombCollisions(Roket[0], Bomb[b]);
                }
            }

            //  HANDLE PRIZE COLLECTION  -------------------
            if (Prize[0] != null) {
                handlePrizeCollisions(Roket[0], Prize[0]);
            }
        }  

        //  SIMULATE ENEMY  -------------------
        for (var e = 0; e < Enemy.length; e++) {
            Enemy[e].simulate();
        }

        //  SIMULATE ENEMY DEBRIS AND AGE OUT -------------------
        for (var e = 0; e < EnemyDebris.length; e++) {
            EnemyDebris[e].simulate();
            handleEnemyDebrisAge(EnemyDebris[e], e);
        }

        //  SIMULATE SEND ALIEN  -------------------
        for (var e = 0; e < Alien.length; e++) {
            Alien[e].simulate();
        }

        //  SPAWN TORPEDO  ------------------
        if (spawnTorpedoKey == true && typeof Roket !== 'undefined' && Roket && Roket.length > 0 && Roket[0] && Roket[0].collision < 2 && tumbling != true && gameOn == true) {
            spawnTorpedo();
        }

        //  SIMULATE MUZZLE EXHAUST  ------------------- 
        for (var m = 0; m < MuzzleFlash.length; m++) {
            MuzzleFlash[m].simulate();
        }

        //  SIMULATE PUSHER  ---------------------
        if (Pusher[0] != null && lives > -1) { 
            Pusher[0].simulate();
            PusherSpot = Pusher[0].pos.clone();
            if (Pusher[0].radius >= 0.3) {
                spawnSpawnlets(PusherSpot.x, PusherSpot.y, 4, 0.35, 1000);
            }
            if (Date.now() - Pusher[0].birthday > 2000) {
                //pusher = Pusher[0];
                Pusher = [];
                debrisMade = false;
                resetRoket();
            } 
        }

        // GAME OVER  -----------------
        if (gameOn == true && lives < 1) {
            gameOver = true;
            gameOn = false;
            gameOverTime = Date.now();
        }

        //  SIMULATE RING OF FIRE  -------------------
        for (var r = 0; r < RingOfFire.length; r++) {
            RingOfFire[r].simulate();
            if (Date.now() - RingOfFire[r].birthday > 300) {
                RingOfFire.splice(r, 1);
                r--;
                continue;
            }
        }   

        //  SIMULATE ROIDS  --------------------
        SortedRoids = Roids.sort((a, b) => a.left - b.left); 
        for (var r = 0; r < Roids.length; r++) {
            if (Roids[r] != null) {
                var sortedRoids1 = SortedRoids[r]
                sortedRoids1.simulate();

                //  HANDLE ROKET ROID COLLISIONS ------------------
                if (untouchable != true) {
                    var roket = Roket[0];
                    if (shieldsUp != true) {
                        if (roket.leftForShields < sortedRoids1.right && gameOn == true && roket.collision < 2) {
                            if (Math.abs(sortedRoids1.pos.y - roket.pos.y) <= sortedRoids1.radius + 0.5 * roket.radius) {
                                handleRoketRoidCollisions(roket, sortedRoids1);
                            }
                        }  
                    } else {
                        if (roket.leftForHits < sortedRoids1.right && gameOn == true  && roket.collision < 2) {
                            if (Math.abs(sortedRoids1.pos.y - roket.pos.y) <= sortedRoids1.radius + roket.radius) {
                                handleRoketRoidCollisions(roket, sortedRoids1);
                            }
                        }  
                    }
                }
                
                //  HANDLE RESPAWN PUSHER  ------------------
                if (Pusher[0] != null) {
                    handlePusherRoidPushes(sortedRoids1, Pusher[0]);
                }
            
                //  HANDLE ROID ROID COLLISIONS  ------------------
                if (Roids.length > 1) {
                    for (var t = r+1; t < SortedRoids.length; t++) {
                        var sortedRoids2 = SortedRoids[t];
                        if (sortedRoids2 != null && sortedRoids1 != null ) {
                            if (sortedRoids2.left < sortedRoids1.right) {
                                if (Math.abs(sortedRoids1.pos.y - sortedRoids2.pos.y) <= sortedRoids1.radius + sortedRoids2.radius) {
                                    handleRoidRoidCollisions(sortedRoids1, sortedRoids2);
                                }
                            }  
                        }
                    }
                }

                /*//  HANDLE BOMB ROID COLLISIONS  -------------------
                if (Bomb.length > 0) {
                    var SortedBombs = Bomb.sort((a, b) => a.left - b.left);
                    for (var b = 0; b < SortedBombs.length; b++) {
                        if (SortedBombs[b].left < sortedRoids1.right) {
                            if (Math.abs(sortedRoids1.pos.y - SortedBombs[b].pos.y) <= sortedRoids1.radius + SortedBombs[b].radius) {
                                handleBombRoidCollisions(sortedRoids1, Bomb[b]);
                            }
                        }   
                    }
                }*/

                //  HANDLE BOMB ROID COLLISIONS  -------------------
                if (untouchable != true) {
                    for (var b = 0; b < Bomb.length; b++) {
                        handleBombRoidCollisions(sortedRoids1, Bomb[b]);
                    }   
                }
                
                //  HANDLE SHIP DEBRIS HITS ON ROIDS ------------------
                var SortedRoketDebris = RoketDebris.sort((a, b) => a.left - b.left);
                for (var s = 0; s < SortedRoketDebris.length; s++) {
                    var sortedRoketDebris1 = SortedRoketDebris[s];
                    if (Roids[r] != null) {
                        if (sortedRoketDebris1.left < sortedRoids1.right) {
                            if (Math.abs(sortedRoids1.pos.y - sortedRoketDebris1.pos.y) <= sortedRoids1.radius + sortedRoketDebris1.radius) {
                                handleRoketDebrisCollisions(sortedRoids1, sortedRoketDebris1);
                            }
                        }   
                    }
                }

                //  HANDLE TORPEDO ROID HITS  --------------------
                var SortedTorpedos = Torpedo.sort((a, b) => a.left - b.left);
                for (var u = 0; u < SortedTorpedos.length; u++) {
                    var sortedTorpedo1 = SortedTorpedos[u];
                    if (Roids[r] != null) {
                        if (sortedTorpedo1.left < sortedRoids1.right) {
                            if (Math.abs(sortedRoids1.pos.y - sortedTorpedo1.pos.y) <= sortedRoids1.radius + sortedTorpedo1.radius) {
                                handleTorpedoRoidHits(sortedRoids1, sortedTorpedo1, r, u);
                            }
                        }   
                    }
                }

                /*//  HANDLE EXHAUST PUSHES  --------------------
                for (var e = 0; e < Exhaustlets.length; e++) {
                    if (Roids[r] != null) {
                        handleExhaustPushes(Roids[r], Exhaustlets[e]);
                    }
                }*/
            }
        } 

        //  SIMULATE BOMB  ----------------------------
        for (var b = 0; b < Bomb.length; b++) {
            Bomb[b].simulate();
            //  EXPLODE BOMB  ----------
            // Ensure bombs that have reached their auto-explode time are marked exploding
            // before we evaluate roket collisions so the collision logic sees the
            // 'exploding' state and large lethal/tumble radii.
            if (Bomb[b].exploding != true && Date.now() - Bomb[b].birthday > 3000) {
                if (typeof Bomb[b].startExplosion === 'function') Bomb[b].startExplosion(); else { Bomb[b].exploding = true; Bomb[b].birthday = Date.now(); if (typeof Bomb[b]._explosionOrigin !== 'undefined') delete Bomb[b]._explosionOrigin; }
            }
            if (untouchable != true) {
                //  HANDLE BOMB ROCKET COLLISIONS  -------------
                if (typeof Roket !== 'undefined' && Roket && Roket.length > 0 && Roket[0]) {
                    handleBombRoketCollisions(Roket[0], Bomb[b]);
                }
            }

            if (Bomb[b].exploding == true && Date.now() - Bomb[b].birthday > 300) {
                Bomb.splice(b, 1);
            }
        }
        if (Bomb.length > 0) {
            radarPulser += 0.04;
            if (radarPulser > 1) {
                radarPulser = 0;
            }
            bombDirShake += 3 * dT;
            if (bombDirShake > 2 * Math.PI) {
                bombDirShake -= 2 * Math.PI;
            }
        }

        //  HANDLE TORPEDO ENEMY HITS  --------------------
        for (var e = 0; e < Enemy.length; e++) {
            for (var f = 0; f < Torpedo.length; f++) {
                if (Torpedo[f].friendOrFoe == 'friend') {
                    handleTorpedoOnEnemyHits(Enemy[e], Torpedo[f]);
                }
            }
        }

        //  HANDLE ENEMY TORPEDO PLAYER HITS  --------------------
        //for (var e = 0; e < Enemy.length; e++) {
            for (var f = 0; f < Torpedo.length; f++)
                if (Torpedo[f].friendOrFoe == 'foe' && !athena.checked && untouchable != true) {
                    handleTorpedoOnPlayerHits(Torpedo[f]);
                }
        //}

        //  SIMULATE TORPEDO and HANDLE BOUNDS  ------------------
        for (var u = 0; u < Torpedo.length; u++) {
            torpedo = Torpedo[u];
            torpedo.simulate();
            if (torpedo.pos.x + torpedo.radius >= simWidth 
            || torpedo.pos.x - torpedo.radius <= 0 
            || torpedo.pos.y - torpedo.radius < 0 
            || torpedo.pos.y + torpedo.radius >= simHeight) {
                Torpedo.splice(u,1);
            }
        }

        //  SIMULATE ROKET DEBRIS  ------------------
        for (var d = 0; d < RoketDebris.length; d++) {
            RoketDebris[d].simulate();
            handleRoketDebrisAge(RoketDebris[d], d);
        }

        //  SIMULATE ROID DEBRIS  ------------------
        for (var d = 0; d < RoidDebris.length; d++) {
            RoidDebris[d].simulate();
            handleRoidDebrisAge(RoidDebris[d], d);
        }

        //  SIMULATE TORPEDO PULSE  -------------------
        for (var p = 0; p < Pulse.length; p++) {
            Pulse[p].simulate();
            handlePulseLifespan(Pulse[p], p);
        }

        //  SIMULATE SCORER  -------------------
        for (var p = 0; p < Scorer.length; p++) {
            Scorer[p].simulate();
            if (Date.now() - Scorer[p].birthday > 1500) {
                Scorer.splice(p, 1);
            }
        }

        //  SIMULATE SPAWNLETS  --------------------
        for (var b = 0; b < Spawnlets.length; b++) {
            Spawnlets[b].simulate();
        }

        //  SIMULATE WARP-IN  --------------------
        for (var w = 0; w < WarpIn.length; w++) {
            WarpIn[w].simulate();
        }

        //  DROP STARS  ---------------------
        for (var s = 0; s < StarField.length; s++) {
            star = StarField[s];
            if (star.falling == true) {
                star.simulate(); 
                if (star.posY > simHeight) {
                    StarField.splice(s, 1);
                }
            }
        }
    }

    //  DRAW   ===================================================
    function draw() {  
        //  CLEAR BACKGROUND  ----------------
        c.clearRect(0, 0, canvas.width, canvas.height);
        //  DRAW BLACK BACKGROUND  ----------------
        c.fillStyle = 'black';
        c.fillRect(0, 0, canvas.width, canvas.height);

        //  DRAW GALAXY IN THE BACKGROUND  ----------------------
        if (artFill.checked ==  true) {
            c.drawImage(andromedaImage, 650 - 0.01 * cScale, - 350 - 0.01 * cScale, canvas.width, canvas.height);
        }
        
        //  STARS  --------------------
        if (gameOn != true && lives < 1) {
            for (var n = 0; n < StarField.length; n++) {
                StarField[n].drawForReal(n);
            }
        } else {
            c.drawImage(offscreenStarfieldCanvas, 0, 0); 
        }

        //  DRAW MOON  -----------
        if (Moon.length > 0 && moonFill.checked == true) {
            Moon[0].draw();
        }

        // DRAW PACMAN  -------------------
        if (gameOver == true) {
            for (var p = 0; p < PacMan.length; p++) {
                PacMan[p].draw();
            }
            /*// pacman moon tests 
            drawCircle(Moon[0].pos.x, Moon[0].pos.y, 2 * Moon[0].radius);
            c.lineWidth = .01 * cScale
            c.strokeStyle = 'blue';
            c.stroke();
            if (PacMan.length > 0) {
                drawCircle(PacMan[0].pos.x * cScale, PacMan[0].pos.y * cScale, 2 * PacMan[0].radius * cScale);
                c.strokeStyle = 'red';
                c.stroke();
            }*/
            
        }

        //  EARTH BACKGROUND  ---------------------
        if (artFill.checked ==  true) {
            //  fix so southen hemisphere travel flips rotation of planet
            if (earthriseAdj > 2.95) {
                earthriseAdj -= 2 * (earthriseAdj - 2.9) / (3.3 - 2.9) * 0.002;;
            } else {
                earthriseAdj = 2.95;
            }

            if (gameIdle == true || gameStarting == true) {
                var elapsed = (Date.now() - gameBootTime) / 1000;
                if (elapsed <= 7) {
                    // start with an extra spin of 0.02 (i.e. 0.02 * dT) and decay exponentially
                    // choose tau so the extra is ~1% after 7s: tau = 7 / ln(100) ~= 1.52s
                    var extraSpin = 1 * Math.exp(-elapsed / 1.22);
                    var earthSpinIncrement = (0.002 + extraSpin) * dT;
                    var earthZoom = 1;

                } else {
                    var earthSpinIncrement = 0.002 * dT;
                    var earthZoom = 1;
                }
            } else {
                var earthSpinIncrement = 0.002 * dT;
                var earthZoom = 1;
            }

            earthSpinner += earthSpinIncrement;
            if (earthSpinner > 2 * Math.PI) {
                earthSpinner -= 2 * Math.PI;
            }
            const earthImage = document.getElementById("earth");
            const earthWidth = 9 * cScale * earthZoom;
            const earthHeight = 9 * cScale * earthZoom;
            const centerX = 0.5 * simWidth * cScale;
            const centerY = earthriseAdj * simHeight * cScale - 0.03 * totalTravelY * cScale;
            imageCenterY = centerY;
            //const earthAngle = -earthSpinner - 0.0025 * totalTravelX * Math.PI + 0.34 * Math.PI; // 180 degrees
            const earthAngle = -earthSpinner - 0.0025 * totalTravelX * Math.PI + 2.7 * Math.PI; // 180 degrees
            c.save();
            c.translate(centerX, centerY); // move origin
            c.rotate(earthAngle); 
            c.drawImage(
                earthImage,
                -0.5 * earthWidth, // center origin
                -0.5 * earthHeight,
                earthWidth,
                earthHeight);
            c.restore();
        }

        //  INSERT ROIDS TITLE ART  -----------
        if (gameIdle == true || gameStarting == true && lives > -1) {
            titleArt();
        }

        //  DRAW RING OF FIRE  -------------------
        for (var r = 0; r < RingOfFire.length; r++) {
            RingOfFire[r].draw();
        }   
        
        //  DRAW ROIDS  --------------------
        for (var r = 0; r < Roids.length; r++) {
            if (Roids[r] != null) {
                Roids[r].draw();
            }
        }

        //  DRAW TORPEDO  ------------------
        for (var v = 0; v < Torpedo.length; v++) {
            Torpedo[v].draw();
        }

        //  SIMULATE MUZZLE FLASH  ------------------- 
        for (var m = 0; m < MuzzleFlash.length; m++) {
            MuzzleFlash[m].draw();
        }

        //  DRAW PULSE  ------------------
        for (var p = 0; p < Pulse.length; p++) {
            Pulse[p].draw();
        }

        //  DRAW ROID DEBRIS  ------------------
        for (var d = 0; d < RoidDebris.length; d++) {
            RoidDebris[d].draw();
        }

        //  DRAW ROKET DEBRIS  ------------------
        for (var d = 0; d < RoketDebris.length; d++) {
            RoketDebris[d].draw();
        }

        //  DRAW ENEMY DEBRIS -------------------
        for (var e = 0; e < EnemyDebris.length; e++) {
            EnemyDebris[e].draw();
        }

        //  DRAW PRIZE  -------------------
        if (Prize[0] != null) {
            Prize[0].draw();
        }

        //  DRAW SEND ALIEN  -------------------
        for (var e = 0; e < Alien.length; e++) {
            Alien[e].draw();
        }

        //  DRAW SCORER  -------------------
        for (var p = 0; p < Scorer.length; p++) {
            Scorer[p].draw();
        }

        //  DRAW PUSHER  ---------------------
        if (Pusher[0] != null) {
            Pusher[0].draw();
        }

        //  DRAW WARP-IN  --------------------
        for (var w = 0; w < WarpIn.length; w++) {
            WarpIn[w].draw();
        }

        //  DRAW ENGINE EXHAUST  ------------------
        for (var y = 0; y < Exhaustlets.length; y++) {
            Exhaustlets[y].draw();
        }

        //  DRAW ENEMY  -------------------
        for (var e = 0; e < Enemy.length; e++) {
            Enemy[e].draw();
        }

        //  DRAW RETRO STEERING EXHAUST  -----------------
        for (var w = 0; w < RetroLets.length; w++) {
            RetroLets[w].draw();
        }

        //  DRAW BOMB  -------------------
        for (var b = 0; b < Bomb.length; b++) {
            Bomb[b].draw();
        }
        
        //  DRAW ROKET  --------------------
        if (typeof Roket !== 'undefined' && Roket && Roket.length > 0 && Roket[0]) {
            if (Roket[0].collision < 2) {
                if (typeof Roket[0].draw === 'function') Roket[0].draw();
            } else {
                //  ROKET HAS BEEN DESTROYED  ----------  ********* ----------
                if (debrisMade != true) {
                    weaponLevel -= 2;
                    if (weaponLevel < 0) weaponLevel = 0;  
                    if (Roket[0] && Roket[0].pos) makePulse(Roket[0].pos);
                    spawnRoketDebris();
                }
            }
        }

        //  DRAW SPAWNLETS  --------------------
        for (var b = 0; b < Spawnlets.length; b++) {
            Spawnlets[b].draw();
        }


        // DRAW OSD ELEMENTS ==================================================
        
        //  DRAW WAVE NUMBER  -------------------
            c.font = `${0.05 * cScale}px monospace`;
            c.textBaseline = 'middle';
            c.textAlign = "center";
            c.fillStyle = `hsla(30, 80%, 50%, 80%)`;
            c.lineWidth = 2;
            c.fillText('wave', 0.5 * simWidth * cScale, .05 * cScale);
            if (animateWave != true) {
                c.strokeStyle = `hsla(30, 80%, 50%, 80%)`;
                c.textBaseline = 'top';
                c.font = `${0.1 * cScale}px monospace`;
                c.strokeText(wave, 0.5 * simWidth * cScale, .09 * cScale);
            }

        //  ANIMATE WAVE NUMBER CHANGE  -----------------
        if (animateWave == true) {
            var waveNoAge = (Date.now() - waveNoBday) / 1000;
            var maxFont = 3;
            var minFont = 1 / (20 * waveNoAge);
            var fontSize = maxFont * minFont;
            
            var trans6 = 30 + 100 * waveNoAge / 3;
            c.textBaseline = 'top';
            if (fontSize > 0.1) {
                c.font = `${fontSize * cScale}px monospace`;
            } else {
                c.font = `${0.1 * cScale}px monospace`;
                animateWave = false;
            }
            c.strokeStyle = `hsla(30, 80%, 50%, ${trans6}%)`;
            c.strokeText(wave, 0.5 * simWidth * cScale, .09 * cScale);
        }

        if (gameOn == true) {
            huntingMsgTime = (Date.now() - gameStartTime) / 1000;
            if (huntingMsgTime < 4) {
                var sweepX = 0.2 * simWidth + (huntingMsgTime / 6) * simWidth;
                if (huntingMsgTime < 2) {
                    c.fillStyle = `hsla(180, 80%, 50%, ${100 * huntingMsgTime}%)`;
                } else {
                    dimmer += 1;
                    c.fillStyle = `hsla(180, 80%, 50%, ${80 - dimmer}%)`;
                }
                c.font = `italic ${0.06 * cScale}px verdana`;
                if (Roket[0].collision < 2) {
                    c.fillText("G O O D  L U C K  &  G O O D  H U N T I N G", sweepX * cScale, 0.2 * simHeight * cScale);
                } else {
                    c.fillText("H A H A H A H A H A H A . . .", sweepX * cScale, 0.2 * simHeight * cScale);
                }
            }
        }

        //  DRAW HIT PERCENTAGE  ------------------
        if (gameIdle != true) {
            if (torpedosFired > 1) {
                hitPct = Math.floor(100 * torpedosHit / torpedosFired);
            } else {
                hitPct = 100;
            }
        }

        //  DRAW STREAK AND DRAW SCORE  ------------------
        if (!athena.checked) {
            //  streak  ----------
            c.font = `${0.045 * cScale}px monospace`;
            c.textBaseline = 'middle';
            c.textAlign = "left";
            c.fillStyle = 'hsla(40, 90%, 50%, 80%)';
            c.beginPath();
            c.fillText(streak + "×", .045 * cScale, .07 * cScale);
            //  hit percent  ----------
            c.font = `${0.035 * cScale}px monospace`;
            c.fillText(hitPct + '%', .042 * cScale, .119 * cScale);
            c.closePath();
            
            //  score  ----------
            c.font = `${0.12 * cScale}px monospace`;
            c.textAlign = "left";
            if (score > -1) {
                c.strokeStyle = `hsla(105, 70%, 50%, 70%)`;
            } else {
                c.strokeStyle = `hsla(0, 70%, 50%, 70%)`;
            }
            
            c.lineWidth = 2;
            c.beginPath();
            c.strokeText(Math.floor(score).toLocaleString("el-GR"), .14 * cScale, .098 * cScale);
        } else {
            score = 0;
        }

        //  DRAW ROKET AND LIFE ICONS  ------------------
        const iconXpos = (simWidth - 0.1); 
        if (!athena.checked) {
            for (var l = 0; l < lives; l++) {
                c.beginPath();
                c.moveTo((iconXpos + 0.11*-l) * cScale, 0.05 * cScale);
                c.lineTo((iconXpos + 0.11*-l - 0.03) * cScale, 0.13 * cScale);
                c.lineTo((iconXpos + 0.11*-l) * cScale, 0.1 * cScale);
                c.lineTo((iconXpos + 0.11*-l + 0.03) * cScale, 0.13 * cScale);
                c.closePath();
                c.lineWidth = 0.0055 * cScale;
                if (l == lives - 1) {
                    c.strokeStyle = `hsla(120, 70%, 50%, 80%)`;
                    c.fillStyle = `hsla(120, 70%, 50%, ${rudolphIntensity}%)`;
                    c.fill()
                } else {
                    c.strokeStyle = `hsla(120, 70%, 50%, 80%)`;
                }
                c.stroke();
                //  beacons  ----------
                c.fillStyle = `hsla(0, 70%, 50%, ${rudolphIntensity + 30}%)`;
                drawCircle((iconXpos + 0.11*-l) * cScale, 0.033 * cScale, 0.007 * cScale);
                c.fill();
            } 
        } else {
            c.font = `${0.2 * cScale}px arial`;
            c.strokeStyle = `hsla(120, 70%, 50%, ${rudolphIntensity}%)`;
            c.lineWidth = 0.005 * cScale;
            c.strokeText('∞', (iconXpos - 0.1) * cScale, 0.002 * cScale);
        }

        //  ARC BAR GAUGE METER FOR SHIELD AND TORPEDO  ---------------------
        if (gameIdle == true || (gameOn == true && lives > 0)) {
        const curveXforShield = 0.35 * simWidth * cScale;
        const curveXforTorpedo = 0.65 * simWidth * cScale;
        const curveY = 0.55 * cScale;
        const midArc = 1.5 * Math.PI;
        const arcHalfWidth = 0.15 * Math.PI;
        var arcStart = midArc - arcHalfWidth;
        var arcFullEnd = midArc + arcHalfWidth;
        var torpedoArcIncrement = (2 * arcHalfWidth) / (maxWeaponLevel + 1);
        var torpedoArcEnd = arcStart + torpedoArcIncrement * (weaponLevel + 1);
        var shieldArcIncrement = (2 * arcHalfWidth) / 100;
        var shieldArcEnd = arcStart + shieldArcIncrement * (shieldLevel);

        const arcStartBk = midArc - (1.01 * arcHalfWidth);
        const arcEndBk = midArc + (1.01 * arcHalfWidth);
        const arcRadius = 0.5 * cScale;

        //  ADVANCE DISCO ----------
        disco += 0.03;
        if (disco > 2 * Math.PI) {
            disco -= 2 * Math.PI;
        }
        var discoIntensity = 50 + 50 * Math.abs(Math.sin(disco));

        //  SHIELD METER  -----------------------
        //  green background  ------------
        if (shieldLevel < 100) {
            c.strokeStyle = 'hsla(120, 70%, 50%, 70%)';
        } else {
            //  white background at maxWeaponlevel ----------
            c.strokeStyle = `hsla(0, 0%, 100%, ${discoIntensity}%)`;
        }
        c.beginPath();
        c.arc(curveXforShield, curveY, arcRadius, arcStartBk, arcEndBk);
        c.lineWidth = 0.038 * cScale;
        c.lineCap = 'round';
        c.stroke();
        //  black strip  -----------
        c.beginPath();
        c.arc(curveXforShield, curveY, arcRadius, arcStart, arcFullEnd);
        c.lineWidth = 0.023 * cScale;
        c.strokeStyle = 'hsl(0, 0%, 0%)';
        c.stroke();
        //  blue/cyan gauge  -----------
        c.beginPath();
        c.arc(curveXforShield, curveY, arcRadius, arcStart, shieldArcEnd);
        c.lineWidth = 0.023 * cScale;
        var coneGradient = c.createConicGradient(
            arcStart, 
            curveXforShield, 
            curveY
        );
        //  SHIELDS EMPTY OR NOT STROKE STYLE  ----------
        if (shieldLevel < 1) {
            coneGradient.addColorStop(0, "red");
            coneGradient.addColorStop(1, "red");
        } else {
            coneGradient.addColorStop(0, "blue");
            coneGradient.addColorStop(1, "blue");
        }
        coneGradient.addColorStop(0.13, "cyan");
        c.strokeStyle = coneGradient;
        c.stroke();
        c.closePath();

        //  SHIELD  ------------------
        if (shieldLevel < 100) {
            var shieldSpinner = Math.abs(Math.cos(disco));
            if (Math.cos(disco) > 0) {
                c.fillStyle = 'hsla(240, 80%, 50%, 80%)';
            } else {
                c.fillStyle = 'hsla(190, 80%, 30%, 80%)';
            }
        } else {
            var shieldSpinner = Math.abs(Math.cos(5 * disco));
            if (Math.cos(5 * disco) > 0) {
                c.fillStyle = 'hsla(240, 80%, 50%, 80%)';
            } else {
                c.fillStyle = 'hsla(190, 80%, 30%, 80%)';
            }
        }
        
        // SHIELD VARIABLES  ----------
        const sx = curveXforShield; // center x under meter
        const sy = curveY - arcRadius + 0.06 * cScale; // slightly below the arc
        var r = 0.03 * cScale; // base size for the shield icon
        const tipY =        r * 1.05;           // top
        const bulgeX =      r * 0.75 * shieldSpinner;           // shoulder width
        const bulgeY =      r * 0.7;            // shoulder height
        const crestW =      r * 0.65 * shieldSpinner;           // mid-point width
        const crestCY =     0;                  // crest center Y (small offset)
        const crestTopY =   crestCY - r * 0.75; // bottom
        
        c.save();
        c.translate(sx, sy);
        // flip vertically
        c.scale(1, -1);
        c.beginPath();
        const topX = 0, topY = crestTopY; // sharp top
        const rightShoulderX = crestW, rightShoulderY = crestCY;
        const rightBulgeX = bulgeX, rightBulgeY = bulgeY;
        const bottomX = 0, bottomY = tipY + Math.max(r * 0.02, 0.5); // sharp bottom
        const leftBulgeX = -bulgeX, leftBulgeY = bulgeY;
        const leftShoulderX = -crestW, leftShoulderY = crestCY;
        // FILL SHIELD  ----------
        c.moveTo(topX, topY);
        c.lineTo(rightShoulderX, rightShoulderY);
        c.lineTo(rightBulgeX, rightBulgeY);
        c.lineTo(bottomX, bottomY);
        c.lineTo(leftBulgeX, leftBulgeY);
        c.lineTo(leftShoulderX, leftShoulderY);
        c.closePath();
        c.fill();
        // STROKE SHIELD OUTLINE ----------
        c.lineWidth = 0.005 * cScale;
        c.lineJoin = 'round';
        c.lineCap = 'round';
        c.strokeStyle = 'hsl(0, 0%, 60%)';
        c.stroke();
        c.restore();
      
        //  TORPEDO METER  -----------------
        //  green background  ------------
        if (weaponLevel < maxWeaponLevel) {
            c.strokeStyle = 'hsla(120, 70%, 50%, 70%)';
        } else {
            //  white background at maxWeaponlevel ----------
            c.strokeStyle = `hsla(0, 0%, 100%, ${discoIntensity}%)`;
        }
        c.beginPath();
        c.arc(curveXforTorpedo, curveY, arcRadius, arcStartBk, arcEndBk);
        c.lineWidth = 0.038 * cScale;
        c.lineCap = 'round';
        c.stroke();
        //  black strip  -----------
        c.beginPath();
        c.arc(curveXforTorpedo, curveY, arcRadius, arcStart, arcFullEnd);
        c.lineWidth = 0.023 * cScale;
        c.strokeStyle = 'hsl(0, 0%, 0%)';
        c.stroke();
        //  red gauge  -----------
        c.beginPath();
        c.arc(curveXforTorpedo, curveY, arcRadius, arcStart, torpedoArcEnd);
        c.lineWidth = 0.023 * cScale;
        var coneGradient = c.createConicGradient(
            arcStart, 
            curveXforTorpedo, 
            curveY
        );
        coneGradient.addColorStop(0, "red");
        coneGradient.addColorStop(0.10, "orange");
        coneGradient.addColorStop(0.13, "yellow")
        coneGradient.addColorStop(1, "red");
        c.strokeStyle = coneGradient;
        c.stroke();
        c.closePath();
        c.lineCap = 'butt';
        //  full ticks  ----------
        for (var t = 1; t < maxWeaponLevel + 1; t++) {
            var tickArcStart = arcStart + (t * torpedoArcIncrement);
            var tickArcEnd = tickArcStart + 0.2 * torpedoArcIncrement;
            c.beginPath();
            c.arc(curveXforTorpedo, curveY, arcRadius, tickArcStart, tickArcEnd);
            //c.strokeStyle = 'hsl(0, 0%, 80%)';
            c.stroke();
        }
        //  partial ticks  ----------
        for (var t = 1; t < weaponLevel + 1; t++) {
            var tickArcStart = arcStart + (t * torpedoArcIncrement);
            var tickArcEnd = tickArcStart + 0.2 * torpedoArcIncrement;
            c.beginPath();
            c.arc(curveXforTorpedo, curveY, arcRadius, tickArcStart, tickArcEnd);
            c.strokeStyle = 'hsl(0, 0%, 10%)';
            c.stroke();
        }
        
        //  WEAPON LEVEL READOUT  ----------
        c.lineWidth = 0.005 * cScale;
        c.strokeStyle = 'hsl(0, 0%, 60%)';

        if (weaponLevel < maxWeaponLevel) {
            var iconSpinner1 = Math.abs(Math.cos(disco));
            var iconSpinner2 = Math.abs(Math.cos(disco + 0.2 * Math.PI));
            var iconSpinner3 = Math.abs(Math.cos(disco + 0.4 * Math.PI));
            if (Math.cos(disco) > 0) {
                c.fillStyle = 'hsla(0, 80%, 50%, 100%)';
            } else {
                c.fillStyle = 'hsla(0, 80%, 50%, 100%)';
        }
        } else {
            var iconSpinner1 = Math.abs(Math.cos(5 * disco));
            var iconSpinner2 = Math.abs(Math.cos(5 * disco + 0.2 * Math.PI));
            var iconSpinner3 = Math.abs(Math.cos(5 * disco + 0.4 * Math.PI));
            if (Math.cos(5 * disco) > 0) {
                c.fillStyle = 'hsla(0, 80%, 50%, 100%)';
            } else {
                c.fillStyle = 'hsla(0, 80%, 50%, 100%)';
            }
        }        
        c.beginPath();
        c.ellipse(  // left icon
            curveXforTorpedo - 0.045 * cScale, 
            (curveY - arcRadius) + 0.061 * cScale, 
            0.015 * cScale * iconSpinner1, 
            0.015 * cScale, 
            0,
            0 * Math.PI, 
            2 * Math.PI,
        );
        c.fill();
        c.stroke();
        c.beginPath();
        c.ellipse(  // middle icon 
            curveXforTorpedo + 0.005 * cScale, 
            (curveY - arcRadius) + 0.061 * cScale, 
            0.015 * cScale * iconSpinner2, 
            0.015 * cScale, 
            0,
            0 * Math.PI, 
            2 * Math.PI,
        );
        c.fill();
        c.stroke();
        c.beginPath();
        c.ellipse(  // right icon
            curveXforTorpedo + 0.055 * cScale, 
            (curveY - arcRadius) + 0.061 * cScale, 
            0.015 * cScale * iconSpinner3, 
            0.015 * cScale, 
            0,
            0 * Math.PI, 
            2 * Math.PI,
        );
        c.fill();
        c.stroke();
        }

        /*
        //  text  ----------
        c.font = `${0.04 * cScale}px monospace`;
        c.fillStyle = `hsla(0, 0%, 100%, ${40 + discoIntensity}%)`;
        c.textAlign = 'center';
        c.textBaseline = 'middle';
        c.fillText(weaponLevel + 1, curveXforTorpedo + 0.006 * cScale, (curveY - arcRadius) + 0.065 * cScale);
        */

        //  GAME OVER  ------------------------------------
        if (gameOn != true && lives < 1) {
            var trans5 = ((Date.now() - gameOverTime) / 30);
            if (trans5 > 100) {
                trans5 = 100;
            }
            //  TRIGGER FALLING STARS  ----------
            for (var i = 0; i < 10; i++) {
                dropStar();
            }
            //  GAME OVER MESSAGE  ----------
            disco += 0.03;
            if (disco > 2 * Math.PI) {
                disco -= 2 * Math.PI;
            }
            var msgPulse = 0.3 + Math.abs(0.7 * Math.sin(0.5 *disco));
            c.font = `${(trans5 / 100) * 120}px monospace`;
            c.textAlign = "center";
            c.strokeStyle = `hsla(0, 60%, 50%, ${trans5 * msgPulse}%)`;
            c.lineWidth = 0.006 * cScale;
            c.shadowColor = 'black'
            c.shadowBlur = 5;
            c.beginPath();
            c.strokeText('GAME 0VER', 0.5 * simWidth * cScale, 0.5 * simHeight * cScale);
            //  STAT CALCULATIONS  ----------
            var totalSeconds = Math.floor((gameOverTime - gameStartTime) / 1000);
            var gameMinutes = Math.floor(totalSeconds / 60);
            if (gameMinutes < 1) {
                var gameSeconds = Math.floor(totalSeconds);
            } else {
                var gameSeconds = totalSeconds - (gameMinutes * 60) ;
            }
            var tps = (torpedosFired / totalSeconds).toFixed(1);
            //  DRAW STATS  ----------
            c.font = `${(trans5/100) * 18}px monospace`;
            c.textAlign = "center";
            c.fillStyle = `hsla(30, 60%, 50%, ${trans5 - 20}%)`;
            c.lineWidth = 0.007 * cScale;
            c.fillText("Torpedos Hit/Fired: " + torpedosHit.toLocaleString() + "/" + torpedosFired.toLocaleString() + " (" + hitPct + "%)", 0.5 * simWidth * cScale, 0.6 * simHeight * cScale);
            if (tps < 1) {
                var tpsMessage = 'torpedos/sec';
            } else if (tps < 2) {
                var tpsMessage = 'torpedo/sec';
            } else {
                var tpsMessage = 'torpedos/sec';
            }
            c.fillText(gameMinutes + "'" + gameSeconds + '"   ' + tps + ' ' + tpsMessage, 0.5 * simWidth * cScale, 0.65 * simHeight * cScale);
            c.closePath();
            //  PRESS ANY KEY TO TO RETURN  ------------------
            rudolphIntensity = 100;
            c.fillStyle = `hsla(175, 100%, 50%, 80%)`;
            c.font = "italic ${(trans5/100) * 15}px verdana";
            c.beginPath();
            c.fillText('PRESS -R- TO RETURN', 0.5 * simWidth * cScale, 0.8 * simHeight * cScale);
            c.closePath();
            c.shadowBlur = 0;
        }
  
        //  TITLE ART  --------------------------------------
        function titleArt() {
            const fadeTime = 3000
            var timer = (Date.now() - programStartTime);
            
            if (timer > 4.0 * fadeTime) {
                gameStarting = false;
            }

            //  MAKE BOBBER  ----------------
            bob += 0.02;
            var bobDisp = 0.07 * simHeight;
            var bobberR = bobDisp * Math.sin(bob + Math.PI / 5);
            var bobberO = bobDisp * Math.sin(bob + 2 * Math.PI / 5);
            var bobberI = bobDisp * Math.sin(bob + 3 * Math.PI / 5);
            var bobberD = bobDisp * Math.sin(bob + 4 * Math.PI / 5);
            var bobberS = bobDisp * Math.sin(bob + Math.PI);
            var bobberLR = bobDisp * Math.cos(0.75*bob);

            //  SET TRANSPARENCY AND GROW  ------------------
            if (gameIdle == true) {
                
                var trans2 = 70;
                var trans3 = 80;
                var trans4 = 0;
                var maxFontSize = 0.25 * simWidth * cScale;
                if (timer < 2000) {
                    var fontSize = (timer / 2000) * maxFontSize;
                    var trans = (timer / 1000) * 100;
                } else {
                    var fontSize = maxFontSize;
                    var trans = 100;
                }
                
                c.font = `bolder ${fontSize}px monospace`;
            } else {
                var trans = 70 - (Date.now() - gameStartTime) * 100 / fadeTime;
                var trans2 = 70 - (Date.now() - gameStartTime) * 100 / (0.25 * fadeTime);
                var trans3 = 70 - (Date.now() - gameStartTime) * 100 / (4.0 * fadeTime);
                var grow = (Date.now() - gameStartTime) * 5 / fadeTime;
                c.font = `bolder ${(0.25 * simWidth + grow) * cScale}px monospace`;
            }

            //  SPAWN ENEMY ON PAUSE, OCCASSIONALLY  ----------
            if (gameIdle == true && gameStarting != true) {
                if (enemyCycling == true) {
                    enemyCycling = false;
                    nextWait = Date.now() + Math.random() * 5000;
                }
                if (Date.now() > nextWait && Enemy[0] == null) {
                    introSpawn();
                    enemyCycling = true;
                }
            }
        
            //  DRAW ROIDS TITLE FILL  --------------
            if (titleBallX >= simWidth || titleBallX <= 0) {
                titleBallHue = 360 * Math.random();
                titleBallSaturation = 20 + 60 * Math.random();
                titleBallLightness = 40 + 40 * Math.random();

                titleBallDir *= -1.0;
                titleBallY = 0.05 * (-0.5 + Math.random());
                titleBallYIndex = 0.005 * (-0.5 + Math.random());
                titleBallRadius = 0.1 + 0.3 * Math.random();
            }
            var sphereGradient = c.createRadialGradient(
                titleBallX * cScale, 
                (0.5 * simHeight + titleBallY) * cScale, 
                0, 
                titleBallX * cScale, 
                (0.5 * simHeight + titleBallY) * cScale, 
                titleBallRadius * cScale);  
            titleBallX += 0.01 * titleBallDir;
            titleBallY += titleBallYIndex;
            var highlight = `hsla(${titleBallHue}, ${titleBallSaturation}%, ${titleBallLightness}%, ${trans}%)`;
            var midtone = `hsla(${titleBallHue}, ${titleBallSaturation - 30}%, ${titleBallSaturation - 50}%, ${trans}%)`;
            var shadow = `hsla(225, 50%, 10%, ${trans - 50}%)`;
            sphereGradient.addColorStop(0.0, highlight);
            sphereGradient.addColorStop(0.95, midtone);
            sphereGradient.addColorStop(1.0, shadow);
            c.fillStyle = sphereGradient;
            c.textBaseline = "middle";
            c.textAlign = "center";
            //c.fillText('R0IDS', 0.5 * simWidth * cScale, 0.5 * simHeight * cScale);
            c.beginPath();
            c.fillText('R    ', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberR) * cScale);
            c.fillText(' 0   ', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberO) * cScale);
            c.fillText('  I  ', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberI) * cScale);
            c.fillText('   D ', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberD) * cScale);
            c.fillText('    S', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberS) * cScale);
                
            //  DRAW SECOND TITLE FILL  ------------------
            if (titleBallX2 >= simWidth || titleBallX2 <= 0) {
                titleBallHue2 = 360 * Math.random();
                titleBallSaturation2 = 20 + 60 * Math.random();
                titleBallLightness2 = 40 + 40 * Math.random();
                titleBallDir2 *= -1.0;
                titleBallY2 = 0.05 * (-0.5 + Math.random());
                titleBallYIndex2 = 0.005 * (-0.5 + Math.random());
                titleBallRadius2 = 0.1 + 0.3 * Math.random();
            }
            var sphereGradient = c.createRadialGradient(
                titleBallX2 * cScale, 
                (0.5 * simHeight + titleBallY2) * cScale, 
                0, 
                titleBallX2 * cScale, 
                (0.5 * simHeight + titleBallY2) * cScale, 
                titleBallRadius2 * cScale);  
            titleBallX2 += 0.01 * titleBallDir2;
            titleBallY2 += titleBallYIndex2;
            var highlight = `hsla(${titleBallHue2}, ${titleBallSaturation2}%, ${titleBallLightness2}%, ${trans}%)`;
            var midtone = `hsla(${titleBallHue2}, ${titleBallSaturation2 - 30}%, ${titleBallLightness2 - 50}%, ${trans}%)`;
            var shadow = `hsla(0, 0%, 0%, 0%)`;
            sphereGradient.addColorStop(0.0, highlight);
            sphereGradient.addColorStop(0.95, midtone);
            sphereGradient.addColorStop(1.0, shadow);
            c.fillStyle = sphereGradient;
            c.textBaseline = "middle";
            c.textAlign = "center";
            c.fillText('R    ', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberR) * cScale);
            c.fillText(' 0   ', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberO) * cScale);
            c.fillText('  I  ', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberI) * cScale);
            c.fillText('   D ', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberD) * cScale);
            c.fillText('    S', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberS) * cScale);

            //  DRAW THIRD UP-DOWN TITLE FILL  ------------------
            if (titleBallY3 >= simHeight || titleBallY3 <= 0) {
                titleBallHue3 = 360 * Math.random();
                titleBallSaturation3 = 20 + 60 * Math.random();
                titleBallLightness3 = 40 + 40 * Math.random();
                titleBallDir3 *= -1.0;
                titleBallX3 = 0.2 * simWidth + 0.6 * Math.random() * simWidth;
                titleBallXIndex3 = 0.01 * (-0.5 + Math.random());
                titleBallRadius3 = 0.1 + 0.3 * Math.random();
            }

            var sphereGradient = c.createRadialGradient(
                titleBallX3 * cScale, 
                titleBallY3 * cScale, 
                0, 
                titleBallX3 * cScale, 
                titleBallY3 * cScale, 
                titleBallRadius3 * cScale);  
            titleBallY3 += 0.01 * titleBallDir3;
            titleBallX3 += titleBallXIndex3;
            var highlight = `hsla(${titleBallHue3}, ${titleBallSaturation3}%, ${titleBallLightness3}%, ${trans}%)`;
            var midtone = `hsla(${titleBallHue3}, ${titleBallSaturation3 - 30}%, ${titleBallLightness3 - 50}%, ${trans}%)`;
            var shadow = `hsla(0, 0%, 0%, 0%)`;
            sphereGradient.addColorStop(0.0, highlight);
            sphereGradient.addColorStop(0.95, midtone);
            sphereGradient.addColorStop(1.0, shadow);
            c.fillStyle = sphereGradient;
            c.textBaseline = "middle";
            c.textAlign = "center";
            c.fillText('R    ', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberR) * cScale);
            c.fillText(' 0   ', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberO) * cScale);
            c.fillText('  I  ', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberI) * cScale);
            c.fillText('   D ', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberD) * cScale);
            c.fillText('    S', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberS) * cScale);
            
            //  draw outline  ----------
            c.lineWidth = 2;
            c.strokeStyle = `hsla(105, 0%, 70%, ${trans}%)`;
            c.strokeText('R    ', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberR) * cScale);
            c.strokeText(' 0   ', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberO) * cScale);
            c.strokeText('  I  ', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberI) * cScale);
            c.strokeText('   D ', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberD) * cScale);
            c.strokeText('    S', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberS) * cScale);
            
            //  ANY KEY TO TO START  ------------------
            c.fillStyle = `hsla(0, 0%, 100%, ${Math.min(trans2, rudolphIntensity)}%)`;
            c.font = `bold italic ${0.05 * cScale}px monospace`;
            c.shadowColor = 'black';
            c.shadowBlur = 7;
            c.beginPath();
            c.fillText("START FLYING T0 BEGIN", 0.5 * simWidth * cScale, 0.8 * simHeight * cScale);
            
            //  INSTRUCTION TEXT  ------------------
            c.strokeStyle = `hsla(105, 90%, 50%, ${trans3}%)`;
            c.fillStyle = `hsla(30, 90%, 50%, ${trans3}%)`;
            c.font = `bold ${0.055 * cScale}px monospace`;
            c.shadowColor = 'black';
            c.shadowBlur = 7;
            c.fillText('LEFT', (0.2 * simWidth + 0.15) * cScale, 0.91 * simHeight * cScale);
            c.fillText('RIGHT', (0.335 * simWidth + 0.16) * cScale, 0.91 * simHeight * cScale);
            c.fillText('THRUST', (0.47 * simWidth + 0.16) * cScale, 0.91 * simHeight * cScale);
            c.fillText('SH00T', (0.635 * simWidth + 0.15) * cScale, 0.91 * simHeight * cScale); 
            c.fillText('SHIELDS', (0.758 * simWidth + 0.15) * cScale, 0.91 * simHeight * cScale);
            c.lineWidth = 0.005 * cScale;
            c.font = `${0.08 * cScale}px monospace`;
            c.strokeText('S', (0.65 * simWidth - 0.12) * cScale, 0.912 * simHeight * cScale);
            c.strokeText('X', (0.79 * simWidth - 0.12) * cScale, 0.912 * simHeight * cScale);
            c.font = `${0.06 * cScale}px monospace`;
            c.fillText('/', (0.645 * simWidth - .06) * cScale, 0.912 * simHeight * cScale);
            
            //  ARROWS  ------------------
            c.lineWidth = 0.007 * cScale;
            drawArrow(0.2 * simWidth, 0.908 * simHeight, 0.5 * Math.PI, 0.08);
            c.stroke();
            drawArrow(0.335 * simWidth, 0.908 * simHeight, 1.5 * Math.PI, 0.08);
            c.stroke();
            drawArrow(0.47 * simWidth, 0.908 * simHeight, 0, 0.08);
            c.stroke();
            drawArrow(0.64 * simWidth, 0.908 * simHeight, Math.PI, 0.08);
            c.stroke();
            c.shadowBlur = 0;
        }
        
    }

    //  RUN  --------------------
    setupScene();
    function update() {
        simulate();
        draw();
        requestAnimationFrame(update);
    }
    update();

</script> 
</body>
</html>