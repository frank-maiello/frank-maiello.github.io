<!-- Frank Maiello -->

<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=500, initial-scale=1.0">
<!-- <meta name="viewport" content="width=device-width, initial-scale=1.0"> -->
<style>

    .title {font-family: verdana; 
        font-size: 38px;
        font-weight: bold;
        color: hsl(30, 60%, 50%);
        text-align: left;
        text-shadow: 5px 7px 10px hsl(0, 0%, 0%);
        margin-left: 0px;
        margin-right: 0px;
        padding-left: 10px;
        padding-right: 5px;
    }

    .appTitle {font-family: monospace; 
        font-size: 20px;
        font-weight: bold;
        color : #C93226;
        text-align: left;
        text-shadow: 5px 7px 10px hsl(0, 0%, 0%);
        margin: 0;
        padding: 0;
        font-weight: bold;
    }

    .description {font-family: monospace; 
        font-size: 20px;
        color: hsl(0, 0%, 89%);
        text-align: left;
        text-shadow: 5px 7px 10px hsl(0, 0%, 0%);
        margin: 0;
        padding: 0;
    }

    h4 {
        color: hsl(0, 90%, 59%);
    }

    h3 {font-family: verdana; 
        font-size: 2px;
        color: hsl(0, 0%, 89%);
        text-align: left;
        text-shadow: 5px 7px 10px hsl(0, 0%, 0%);
        margin-left: 0px;
        margin-right: 0px;
        padding-left: 10px;
        padding-right: 5px;
    }

    .verbiage1 {font-family: verdana; 
        font-size: 14px;
        color: hsl(0, 0%, 89%);
        text-align: left;
        text-shadow: 5px 7px 10px hsl(0, 0%, 0%);
        margin-left: 5px;
        margin-right: 0px;
        padding-left: 10px;
        padding-right: 5px;
    }

    .verbiage1b {font-family: verdana; 
        font-style: italic;
        font-size: 14px;
       
        text-align: left;
        text-shadow: 5px 7px 10px hsl(0, 0%, 0%);
        margin-left: 5px;
        margin-right: 0px;
        padding-left: 10px;
        padding-right: 5px;
    }

    .verbiage1b a {
        color: hsl(37, 100%, 58%);
        text-decoration: none;
    }
    
    .verbiage1b a:hover {
        color: #C93226;
        text-decoration: underline;
    }

    .verbiage2a {font-family: verdana; 
        font-size: 13px;
        font-style: italic;
        color: hsl(0, 0%, 89%);
        text-align: left;
        text-shadow: 5px 7px 10px hsl(0, 0%, 0%);
        margin-left: 5px;
        margin-right: 0px;
        padding-left: 10px;
        padding-right: 5px;
    }
    
    .verbiage2 {font-family: verdana; 
        font-size: 13px;
        font-style: italic;
        color: hsl(0, 0%, 89%);
        text-align: left;
        text-shadow: 5px 7px 10px hsl(0, 0%, 0%);
        margin-left: 0px;
        margin-right: 0px;
        padding-left: 10px;
        padding-right: 5px;
    }
    
    

    table#pubTable {
        text-align: left;
        width: 100%;
        font-size: 18px;
        vertical-align: bottom;
    }
    td {
    vertical-align: top;
    white-space: nowrap;
    padding : 10px 20px;
    }

    

    thead tr th:first-child,
    tbody tr td:first-child {
    width: 400px;
    min-width: 400px;
    max-width: 400px;
    }

    .paperButton:hover {
    background-color: #777777; 
    color: white;
    }

    .button {
    font-family: verdana; 
    background-color: #555555;
    border: none;
    color: white;
    padding: 5px 5px;
    margin: 2px 0px 2px 0px;  
    border-radius: 5px;
    
    text-align: center;
    text-decoration: none;
    display: inline-block;
    font-size: 14px;
    box-shadow: 5px 7px 10px hsl(0, 0%, 0%);
    }
    
    .paperImage {
    width: 400px;
    box-shadow: 5px 7px 10px hsl(0, 0%, 0%);
    }
</style>

</head>
<body>

<canvas id="myCanvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0;"></canvas>

<div style="position: relative; z-index: 1; padding: 10px;">
<title>FM Home</title>

<div class = "title">I Like to Move it Move it </div>

<div class = "verbiage1"><br>A small collection of realtime physics and animation exercises with JavaScript</div>
<div class = "verbiage1b"><a href="mailto:maiello.frank@gmail.com">maiello.frank@gmail.com</a></div>
<div class = "verbiage2a"><br>Please use Chrome or Edge for best performance</div>
<table id = "pubTable">

<tr>
  <td>
    <a href = "https://frank-maiello.github.io//slosh.html"><img class = "paperImage" src = "https://frank-maiello.github.io/screen_slosh.png"></a>
  </td>
  <td>
    <div class = "appTitle">3 - SL0SH (CHEF'S CHOICE)</div>
    <h3><br></h3>
    <div class = "description">Particle Physics Sandbox</div>
    <div class = "verbiage2"><br>Fluid-like "sloshy" particle simulation with </div>
    <div class = "verbiage2">interactive toys and a menu-driven user interface. </div>
    <div class = "verbiage2">Created with the help of Claude. Go Claude!</div>
    <br>
    <a href = "https://frank-maiello.github.io/slosh.html" target="_blank" class="button">Play</a>
    <a href = "https://github.com/frank-maiello/frank-maiello.github.io/blob/main/slosh.html" target="_blank" class="button">Code</a>
    &nbsp; &nbsp; &nbsp;
  </td>
</tr>

<tr>
  <td>
    <a href = "https://frank-maiello.github.io//roids.html"><img class = "paperImage" src = "https://frank-maiello.github.io/screen_roids.png"></a>
  </td>
  <td>
    <div class = "appTitle">2 - R0IDS (STAFF PICK!)</div>
    <h3><br></h3>
    <div class = "description">A Take on Asteroids</div>
    <div class = "verbiage2"><br>First there was Space Invaders, then came Asteroids.</div>
    <div class = "verbiage2">Unique obstacles, cranky enemy, weapon power-ups,</div>
    <div class = "verbiage2">floaty physics, increasing difficulty... and cheats.</div>
    <br>
    <a href = "https://frank-maiello.github.io/roids.html" target="_blank" class="button">Play</a>
    <a href = "https://github.com/frank-maiello/frank-maiello.github.io/blob/main/roids.html" target="_blank" class="button">Code</a>
    &nbsp; &nbsp; &nbsp;
  </td>
</tr>
  
<tr>
  <td>
    <a href = "https://frank-maiello.github.io/droplets.html"><img class = "paperImage" src = "https://frank-maiello.github.io/screen_droplets.png"></a>
  </td>
  <td>
    <div class = "appTitle">1 - DR0PLETS</div>
    <h3><br></h3>
    <div class = "description">Abstract Algorithmic Line 'Art'</div>
    <div class = "verbiage2"><br>Repetetive line-drawing the slow way, using</div>
    <div class = "verbiage2">trigonometry and polar coordinates.</div>
    <div class = "verbiage2"><br>Click the Auto button for instant gratification.</div>
    <br>
    <a href = "https://frank-maiello.github.io/droplets.html" target="_blank" class="button">Play</a>
    <a href = "https://github.com/frank-maiello/frank-maiello.github.io/blob/6404a30fcd3e544bf28b16d2a8adea4be639b728/droplets.html" target="_blank" class="button">Code</a>
    &nbsp; &nbsp; &nbsp;
  </td>
</tr>
              
<tr>
  <td>
    <a href = "https://frank-maiello.github.io/plinkolab.html"><img class = "paperImage" src = "https://frank-maiello.github.io/screen_plinkolab.png"></a>
  </td>
  <td>
  <div class = "appTitle">0 - PLINK0 LAB</div>
  <h3><br></h3>
  <div class = "description">Intro to Particle Physics Simulation</div>
  <div class = "verbiage2"><br>If you dare. My first undertaking. Consult a child</div>
  <div class = "verbiage2">to best navigate the Playskool user interface.</div>

  <br>
  <a href = "https://frank-maiello.github.io/plinkolab.html" target="_blank" class="button">Play</a>
  <a href = "https://github.com/frank-maiello/frank-maiello.github.io/blob/6404a30fcd3e544bf28b16d2a8adea4be639b728/plinkolab.html" target="_blank" class="button">Code</a>
  &nbsp; &nbsp; &nbsp;  
  </td>
</tr>      
</table>
</div>
</body>
    
<script>

    //  CANVAS SETUP AND SCALING --------------------------------------------------------------
    canvas = document.getElementById("myCanvas");
	    c = canvas.getContext("2d");
        canvas.style.cursor = "pointer";
       
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

        simMinWidth = 2.0;
        cScale = Math.min(canvas.width, canvas.height) / simMinWidth;
        simWidth = canvas.width / cScale;
        simHeight = canvas.height / cScale;
        topMargin = 0;
        bottomMargin = 0;
    
    function resizeCanvas() {
        canvas = document.getElementById("myCanvas");
	    c = canvas.getContext("2d");
        canvas.style.cursor = "pointer";
       
        // Store old dimensions
        const oldSimWidth = simWidth;
        const oldSimHeight = simHeight;
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;        simMinWidth = 2.0;
        cScale = Math.min(canvas.width, canvas.height) / simMinWidth;
        simWidth = canvas.width / cScale;
        simHeight = canvas.height / cScale;
        
        // Calculate scale factors
        const scaleX = simWidth / oldSimWidth;
        const scaleY = simHeight / oldSimHeight;
        
        // Scale all node positions
        if (typeof PrimaryNodes !== 'undefined') {
            for (let i = 0; i < PrimaryNodes.length; i++) {
                PrimaryNodes[i].pos.x *= scaleX;
                PrimaryNodes[i].pos.y *= scaleY;
                // Scale trail positions
                for (let j = 0; j < PrimaryNodes[i].trail.length; j++) {
                    PrimaryNodes[i].trail[j].x *= scaleX;
                    PrimaryNodes[i].trail[j].y *= scaleY;
                }
            }
        }
        
        if (typeof SecondaryNodes !== 'undefined') {
            for (let i = 0; i < SecondaryNodes.length; i++) {
                SecondaryNodes[i].pos.x *= scaleX;
                SecondaryNodes[i].pos.y *= scaleY;
                // Scale trail positions
                for (let j = 0; j < SecondaryNodes[i].trail.length; j++) {
                    SecondaryNodes[i].trail[j].x *= scaleX;
                    SecondaryNodes[i].trail[j].y *= scaleY;
                }
            }
        }
        
        // Scale roid positions
        if (typeof Roid !== 'undefined') {
            for (let i = 0; i < Roid.length; i++) {
                Roid[i].pos.x *= scaleX;
                Roid[i].pos.y *= scaleY;
            }
        }
        
        // Scale cube position
        if (typeof Cube !== 'undefined' && Cube != null) {
            Cube.pos.x *= scaleX;
            Cube.pos.y *= scaleY;
        }
    }

    window.addEventListener("resize", resizeCanvas);

    function drawCircle(x, y, radius) {
        c.beginPath();			
		c.arc(x, y, radius, 0.0, 2.0 * Math.PI) 
		c.closePath();
	}
    function drawEllipse(x, y, radiusX, radiusY) {
        c.beginPath();			
		c.ellipse(x * cScale, y * cScale, radiusX * cScale, radiusY * cScale, 0, 0, 2 * Math.PI) 
		c.closePath();
	}

    //  SETUP SCENE ======================================================
	function setupScene() {
        PrimaryNodes = [];
        SecondaryNodes = [];
        spawnNodes();
        spinner = 0;
        f = 0;

        //  INITIALIZE ARRAYS  
        Roid = [];
        Cube = null; // Single cube instance
        PongGame = null; // Pong game instance

        //  INITIALIZE BOOLEANS 
        dT = 1/60;

        //  SPAWN INITIAL OBJECTS  
        spawnRoid();
        spawnCube();
        spawnPong();
    }
    
	//  VECTOR OPERATIONS ---------------------------------------------------------------------
	class Vector2 {
		constructor(x = 0.0, y = 0.0) {
			this.x = x; 
			this.y = y;
		}
		set(v) {
			this.x = v.x; 
            this.y = v.y;
		}
		clone() {
			return new Vector2(this.x, this.y);
		}
		add(v, s=1) {
			this.x += v.x * s;
			this.y += v.y * s;
			return this;
		}
		addVectors(a, b) {
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			return this;
		}
		subtract(v, s = 1.0) {
			this.x -= v.x * s;
			this.y -= v.y * s;
			return this;
		}
		subtractVectors(a, b) {
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			return this;			
		}
		length() {
			return Math.sqrt(this.x * this.x + this.y * this.y);
		}
		scale(s) {
			this.x *= s;
			this.y *= s;
		}
		dot(v) {
			return this.x * v.x + this.y * v.y;
		}
        perp() {
			return new Vector2(-this.y, this.x);
		}
	}

    function cX(pos) {
        return pos.x * cScale;
    }
	function cY(pos) {
        return canvas.height - pos.y * cScale;
    }

    //  NORMALIZE DISTANCE  -------------------
    function measureDistAndShade(node1, node2) {
		var dir = new Vector2();
		dir.subtractVectors(node1.pos, node2.pos);
		d = dir.length();
		
		return 1 / d;
	}

    // Quaternion helpers to avoid gimbal lock when integrating orientation
        function quatFromEuler(yaw, pitch, roll) {
            // yaw (Z), pitch (X), roll (Y) â€” same convention as earlier Euler usage
            const cy = Math.cos(yaw * 0.5);
            const sy = Math.sin(yaw * 0.5);
            const cp = Math.cos(pitch * 0.5);
            const sp = Math.sin(pitch * 0.5);
            const cr = Math.cos(roll * 0.5);
            const sr = Math.sin(roll * 0.5);
            // q = q_yaw * q_pitch * q_roll
            const w = cy * cp * cr + sy * sp * sr;
            const x = cy * sp * cr + sy * cp * sr;
            const y = cy * cp * sr - sy * sp * cr;
            const z = sy * cp * cr - cy * sp * sr;
            return { w: w, x: x, y: y, z: z };
        }

        function quatMultiply(a, b) {
            return {
                w: a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z,
                x: a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y,
                y: a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x,
                z: a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w
            };
        }

        function quatNormalize(q) {
            const len = Math.sqrt(q.w*q.w + q.x*q.x + q.y*q.y + q.z*q.z) || 1.0;
            q.w /= len; q.x /= len; q.y /= len; q.z /= len;
            return q;
        }

        function quatRotateVec(q, vx, vy, vz) {
            // Standard, stable quaternion-vector rotation using cross products:
            // t = 2 * cross(q.xyz, v)
            // v' = v + q.w * t + cross(q.xyz, t)
            const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
            // cross(q.xyz, v)
            const cx = qy * vz - qz * vy;
            const cy = qz * vx - qx * vz;
            const cz = qx * vy - qy * vx;
            const tx = 2 * cx;
            const ty = 2 * cy;
            const tz = 2 * cz;
            // cross(q.xyz, t)
            const c2x = qy * tz - qz * ty;
            const c2y = qz * tx - qx * tz;
            const c2z = qx * ty - qy * tx;
            return {
                x: vx + qw * tx + c2x,
                y: vy + qw * ty + c2y,
                z: vz + qw * tz + c2z
            };
        }

    //  DEFINE ROIDS  -----------------
    class ROID {
        constructor (pos, vel, radius, hue, saturation, lightness, 
        randomNo, yaw, pitch, roll) {
            this.pos = pos.clone();
            this.vel = vel.clone();
            this.radius = radius;
            this.originalRadius = radius;
            this.mass = radius * radius * radius; // volume proportional to r^3, density constant
            this.hue = hue;
            this.saturation = saturation;
            this.lightness = lightness;
            this.randomNo = randomNo;
            this.spinAngle = 0;
            // pole spin state for globe roids (controls longitudes rotation)
            this.poleSpinAngle = Math.random() * 2 * Math.PI;
            this.poleSpinSpeed = (Math.random() - 0.5) * 0.1;
            // orientation: store as a quaternion to avoid gimbal lock; also keep Euler cache for code compatibility
            this.yaw = Math.random() * 2 * Math.PI; // initial Euler cache
            this.pitch = (Math.random() - 0.5) * Math.PI; // initial Euler cache
            this.roll = Math.random() * 2 * Math.PI; // initial Euler cache
            // quaternion orientation initialized from euler cache
            this.orientation = quatFromEuler(this.yaw, this.pitch, this.roll);
            // 3D angular velocity vector (rad/frame). Keep scalar angularVelocity in sync with omega.z
            this.omega = {
                x: (Math.random() - 0.5) * 0.2, // pitch rate (tumbling)
                y: (Math.random() - 0.5) * 0.2, // roll rate (tumbling)
                z: (Math.random() - 0.5) * 0.08  // yaw rate (main axis spin)
            };
            // also mirror z into scalar for compatibility
            this.angularVelocity = this.omega.z;
            // Orbiting ball around equator
            this.orbitAngle = Math.random() * 2 * Math.PI;
            this.orbitSpeed = 0.03; // radians per frame
            // Three sub-orbiters that orbit the first orbiter, evenly spaced
            this.subOrbitAngle = Math.random() * 2 * Math.PI;
            this.subOrbitSpeed = 0.05; // radians per frame (faster than main orbiter)
            this.subOrbitDistanceMultiplier = 4.0; // Distance from main orbiter to sub-orbiter
        }
        get left() {
            return this.pos.x - this.radius;
        }
        get right() {
            return this.pos.x + this.radius;
        }
        get top() {
            return this.pos.y - this.radius;
        }
        get bottom() {
            return this.pos.y + this.radius;
        }
        simulate() {
            this.pos.add(this.vel, dT);

            const maxSpeed = 0.5;
            if (this.vel.length() > maxSpeed) {
                this.vel.x *= maxSpeed / this.vel.length();
                this.vel.y *= maxSpeed / this.vel.length();
            }

            // angular control constants (declared early so non-globe code can use them)
            const omegaDamping = 1.0; // no automatic damping: tumbling persists until another force acts
            // maximum angular rate (radians/frame) allowed per-axis to avoid runaway
            const maxOmega = 0.5;
            // maximum spin about axis (scalar spin rate applied to spinAngle/poleSpinAngle)
            const maxSpin = 0.01;

            // Integrate 3D omega into visible orientation for globe roids
            // and keep scalar angularVelocity roughly in sync with omega.z
            // pole spin continues to include poleSpinSpeed
            // include yaw rate (omega.z) in poleSpinAngle so visible longitude rotation follows yaw
            // clamp the resulting axial spin so roids don't spin faster than maxSpin
            let spinInc = 60 * dT * (this.poleSpinSpeed + this.omega.z);
            spinInc = Math.max(-maxSpin, Math.min(maxSpin, spinInc));
            this.poleSpinAngle += spinInc;
            if (this.poleSpinAngle > 2 * Math.PI) this.poleSpinAngle -= 2 * Math.PI;
            if (this.poleSpinAngle < -2 * Math.PI) this.poleSpinAngle += 2 * Math.PI;
            // Integrate angular velocity vector (this.omega) into quaternion orientation using small-angle quaternion
            // delta_q ~ [1, 0.5*omega*dt]
            const half_dt = 0.5 * dT;
            const dq = {
                w: 1.0,
                x: this.omega.x * half_dt,
                y: this.omega.y * half_dt,
                z: this.omega.z * half_dt
            };
            // new orientation = orientation * dq  (apply small-body-frame rotation)
            this.orientation = quatMultiply(this.orientation, dq);
            quatNormalize(this.orientation);
            // update Euler cache from quaternion for any code that still reads yaw/pitch/roll
            // conversion: yaw (Z), pitch (X), roll (Y) inverse of quatFromEuler
            const qw = this.orientation.w, qx = this.orientation.x, qy = this.orientation.y, qz = this.orientation.z;
            // yaw (Z)
            this.yaw = Math.atan2(2*(qw*qz + qx*qy), 1 - 2*(qy*qy + qz*qz));
            // pitch (X)
            const sinp = 2*(qw*qx - qy*qz);
            this.pitch = Math.abs(sinp) >= 1 ? Math.sign(sinp) * Math.PI/2 : Math.asin(sinp);
            // roll (Y)
            this.roll = Math.atan2(2*(qw*qy + qz*qx), 1 - 2*(qx*qx + qy*qy));
            // apply damping (may be 1.0 for no damping) and then clamp to max allowed rates
            this.omega.x *= omegaDamping;
            this.omega.y *= omegaDamping;
            this.omega.z *= omegaDamping;
            // clamp per-axis angular rates
            this.omega.x = Math.max(-maxOmega, Math.min(maxOmega, this.omega.x));
            this.omega.y = Math.max(-maxOmega, Math.min(maxOmega, this.omega.y));
            this.omega.z = Math.max(-maxOmega, Math.min(maxOmega, this.omega.z));
            // keep scalar angularVelocity in sync with clamped z
            this.angularVelocity = this.omega.z;
            // clamp scalar axial spin used for visual spin/pole spin
            this.angularVelocity = Math.max(-maxSpin, Math.min(maxSpin, this.angularVelocity));
            
            // Update orbiting ball angle
            this.orbitAngle += this.orbitSpeed;
            if (this.orbitAngle > 2 * Math.PI) {
                this.orbitAngle -= 2 * Math.PI;
            }
            
            // Update second orbiter angle
            this.subOrbitAngle += this.subOrbitSpeed;
            if (this.subOrbitAngle > 2 * Math.PI) {
                this.subOrbitAngle -= 2 * Math.PI;
            }
         
            if (this.spinAngle > 2 * Math.PI) {
                this.spinAngle -= 2 * Math.PI;
            }
        }
        draw() {
            // Calculate orbiter's 3D position to determine if it's behind or in front
            const orbitRadius = this.radius * 2.5;
            const ballX0 = orbitRadius * Math.cos(this.orbitAngle);
            const ballY0 = orbitRadius * Math.sin(this.orbitAngle);
            const ballZ0 = 0;
            const rotBall = quatRotateVec(this.orientation, ballX0, ballY0, ballZ0);
            
            // Calculate sub-orbiter's 3D position relative to main orbiter
            const subOrbitRadius = this.radius * 0.15 * this.subOrbitDistanceMultiplier; // Orbit around the main orbiter
            const axisOffset = 30 * Math.PI / 180; // 30-degree offset
            const subX0 = subOrbitRadius * Math.cos(this.subOrbitAngle);
            const subY0 = subOrbitRadius * Math.sin(this.subOrbitAngle) * Math.cos(axisOffset);
            const subZ0 = subOrbitRadius * Math.sin(this.subOrbitAngle) * Math.sin(axisOffset);
            // Position relative to main orbiter
            const subBallX = ballX0 + subX0;
            const subBallY = ballY0 + subY0;
            const subBallZ = ballZ0 + subZ0;
            const rotSubBall = quatRotateVec(this.orientation, subBallX, subBallY, subBallZ);
            
            // Draw orbiters BEHIND globe if z < 0 (facing away from camera)
            if (rotBall.z < 0) {
                // Get orbiter positions
                const mainOrbiterInfo = drawOrbiter(this.radius, this.pos, this.orientation, this.orbitAngle);
                
                // Get five sub-orbiters spaced 72 degrees apart (first plane)
                const angleOffset = (2 * Math.PI) / 5; // 72 degrees
                const orbiterScaleFactor = mainOrbiterInfo.scaleFactor; // Use main orbiter's scale
                const subOrbiterInfos = [
                    getSubOrbiterPosition(this.radius, this.pos, this.orientation, this.orbitAngle, this.subOrbitAngle, this.subOrbitDistanceMultiplier, orbiterScaleFactor),
                    getSubOrbiterPosition(this.radius, this.pos, this.orientation, this.orbitAngle, this.subOrbitAngle + angleOffset, this.subOrbitDistanceMultiplier, orbiterScaleFactor),
                    getSubOrbiterPosition(this.radius, this.pos, this.orientation, this.orbitAngle, this.subOrbitAngle + angleOffset * 2, this.subOrbitDistanceMultiplier, orbiterScaleFactor),
                    getSubOrbiterPosition(this.radius, this.pos, this.orientation, this.orbitAngle, this.subOrbitAngle + angleOffset * 3, this.subOrbitDistanceMultiplier, orbiterScaleFactor),
                    getSubOrbiterPosition(this.radius, this.pos, this.orientation, this.orbitAngle, this.subOrbitAngle + angleOffset * 4, this.subOrbitDistanceMultiplier, orbiterScaleFactor)
                ];
                
                // Get five sub-orbiters on perpendicular plane (second plane)
                const subOrbiterInfos2 = [
                    getSubOrbiterPosition2(this.radius, this.pos, this.orientation, this.orbitAngle, this.subOrbitAngle, this.subOrbitDistanceMultiplier, orbiterScaleFactor),
                    getSubOrbiterPosition2(this.radius, this.pos, this.orientation, this.orbitAngle, this.subOrbitAngle + angleOffset, this.subOrbitDistanceMultiplier, orbiterScaleFactor),
                    getSubOrbiterPosition2(this.radius, this.pos, this.orientation, this.orbitAngle, this.subOrbitAngle + angleOffset * 2, this.subOrbitDistanceMultiplier, orbiterScaleFactor),
                    getSubOrbiterPosition2(this.radius, this.pos, this.orientation, this.orbitAngle, this.subOrbitAngle + angleOffset * 3, this.subOrbitDistanceMultiplier, orbiterScaleFactor),
                    getSubOrbiterPosition2(this.radius, this.pos, this.orientation, this.orbitAngle, this.subOrbitAngle + angleOffset * 4, this.subOrbitDistanceMultiplier, orbiterScaleFactor)
                ];
                
                const mainOrbiterRadius = this.radius * 0.15;
                const subOrbiterHues = [25, 30, 35, 20, 40]; // Different shades of orange
                const subOrbiterHues2 = [180, 185, 190, 175, 195]; // Different shades of cyan for second plane
                
                // Draw sub-orbiters that are behind the main orbiter (first plane)
                for (let i = 0; i < 5; i++) {
                    const subInfo = subOrbiterInfos[i];
                    if (subInfo.worldPos.z < rotBall.z) {
                        drawSubOrbiterBall(subInfo.screenX, subInfo.screenY, subInfo.pixelRadius, subOrbiterHues[i]);
                    }
                }
                
                // Draw sub-orbiters that are behind the main orbiter (second plane)
                for (let i = 0; i < 5; i++) {
                    const subInfo = subOrbiterInfos2[i];
                    if (subInfo.worldPos.z < rotBall.z) {
                        drawSubOrbiterBall(subInfo.screenX, subInfo.screenY, subInfo.pixelRadius, subOrbiterHues2[i]);
                    }
                }
                
                // Draw main orbiter ball
                drawOrbiterBall(mainOrbiterInfo.screenX, mainOrbiterInfo.screenY, mainOrbiterInfo.pixelRadius);
                
                // Draw sub-orbiters that are in front of the main orbiter (first plane)
                for (let i = 0; i < 5; i++) {
                    const subInfo = subOrbiterInfos[i];
                    if (subInfo.worldPos.z >= rotBall.z) {
                        drawSubOrbiterBall(subInfo.screenX, subInfo.screenY, subInfo.pixelRadius, subOrbiterHues[i]);
                    }
                }
                
                // Draw sub-orbiters that are in front of the main orbiter (second plane)
                for (let i = 0; i < 5; i++) {
                    const subInfo = subOrbiterInfos2[i];
                    if (subInfo.worldPos.z >= rotBall.z) {
                        drawSubOrbiterBall(subInfo.screenX, subInfo.screenY, subInfo.pixelRadius, subOrbiterHues2[i]);
                    }
                }
            }
            
            drawGlobeRoid(
                this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale, 
                this.originalRadius * cScale, this.hue, this.saturation, this.lightness, 
                this.poleSpinAngle, this.orientation);

            //  HIGHLIGHT SHADING ----------
            drawCircle(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale);
            var sphereGradient = c.createRadialGradient(
                (this.pos.x - (0.3 * this.radius)) * cScale, 
                (this.pos.y - (0.5 * this.radius)) * cScale, 
                0, 
                (this.pos.x - (0.3 * this.radius)) * cScale, 
                (this.pos.y - (0.5 * this.radius)) * cScale, 
                2 * this.radius * cScale);
            var highlight = `hsla(${this.hue + 60}, 50%, 50%, 0.6)`;
            var shadow = `hsla(0, 0%, 0%, 0)`;
            sphereGradient.addColorStop(0.0, highlight);
            sphereGradient.addColorStop(1.0, shadow);
            c.fillStyle = sphereGradient;
            c.fill();

            //  OVERALL BUBBLE SHADING  ----------
            var sphereGradient = c.createRadialGradient(
                    this.pos.x * cScale, 
                    this.pos.y * cScale, 
                    0, 
                    this.pos.x * cScale, 
                    this.pos.y * cScale, 
                    this.radius * cScale);
            var highlight = `hsla(${this.hue + 60}, 50%, 40%, 0.5)`;
            var midtone = `hsla(${this.hue + 60}, 50%, 20%, 0.4)`;
            var shadow = `hsla(${this.hue + 60}, 50%, 10%, 0.2)`;
            sphereGradient.addColorStop(0.0, shadow);
            sphereGradient.addColorStop(0.8, midtone);
            sphereGradient.addColorStop(1.0, highlight);
            c.fillStyle = sphereGradient;
            c.fill();

            // Draw orbiters IN FRONT of globe if z >= 0 (facing toward camera)
            if (rotBall.z >= 0) {
                // Get orbiter positions
                const mainOrbiterInfo = drawOrbiter(this.radius, this.pos, this.orientation, this.orbitAngle);
                
                // Get five sub-orbiters spaced 72 degrees apart (first plane)
                const angleOffset = (2 * Math.PI) / 5; // 72 degrees
                const orbiterScaleFactor = mainOrbiterInfo.scaleFactor; // Use main orbiter's scale
                const subOrbiterInfos = [
                    getSubOrbiterPosition(this.radius, this.pos, this.orientation, this.orbitAngle, this.subOrbitAngle, this.subOrbitDistanceMultiplier, orbiterScaleFactor),
                    getSubOrbiterPosition(this.radius, this.pos, this.orientation, this.orbitAngle, this.subOrbitAngle + angleOffset, this.subOrbitDistanceMultiplier, orbiterScaleFactor),
                    getSubOrbiterPosition(this.radius, this.pos, this.orientation, this.orbitAngle, this.subOrbitAngle + angleOffset * 2, this.subOrbitDistanceMultiplier, orbiterScaleFactor),
                    getSubOrbiterPosition(this.radius, this.pos, this.orientation, this.orbitAngle, this.subOrbitAngle + angleOffset * 3, this.subOrbitDistanceMultiplier, orbiterScaleFactor),
                    getSubOrbiterPosition(this.radius, this.pos, this.orientation, this.orbitAngle, this.subOrbitAngle + angleOffset * 4, this.subOrbitDistanceMultiplier, orbiterScaleFactor)
                ];
                
                // Get five sub-orbiters on perpendicular plane (second plane)
                const subOrbiterInfos2 = [
                    getSubOrbiterPosition2(this.radius, this.pos, this.orientation, this.orbitAngle, this.subOrbitAngle, this.subOrbitDistanceMultiplier, orbiterScaleFactor),
                    getSubOrbiterPosition2(this.radius, this.pos, this.orientation, this.orbitAngle, this.subOrbitAngle + angleOffset, this.subOrbitDistanceMultiplier, orbiterScaleFactor),
                    getSubOrbiterPosition2(this.radius, this.pos, this.orientation, this.orbitAngle, this.subOrbitAngle + angleOffset * 2, this.subOrbitDistanceMultiplier, orbiterScaleFactor),
                    getSubOrbiterPosition2(this.radius, this.pos, this.orientation, this.orbitAngle, this.subOrbitAngle + angleOffset * 3, this.subOrbitDistanceMultiplier, orbiterScaleFactor),
                    getSubOrbiterPosition2(this.radius, this.pos, this.orientation, this.orbitAngle, this.subOrbitAngle + angleOffset * 4, this.subOrbitDistanceMultiplier, orbiterScaleFactor)
                ];
                
                const mainOrbiterRadius = this.radius * 0.15;
                const subOrbiterHues = [25, 30, 35, 20, 40]; // Different shades of orange
                const subOrbiterHues2 = [180, 185, 190, 175, 195]; // Different shades of cyan
                
                // Draw sub-orbiters that are behind the main orbiter (first plane)
                for (let i = 0; i < 5; i++) {
                    const subInfo = subOrbiterInfos[i];
                    if (subInfo.worldPos.z < rotBall.z) {
                        drawSubOrbiterBall(subInfo.screenX, subInfo.screenY, subInfo.pixelRadius, subOrbiterHues[i]);
                    }
                }
                
                // Draw sub-orbiters that are behind the main orbiter (second plane)
                for (let i = 0; i < 5; i++) {
                    const subInfo = subOrbiterInfos2[i];
                    if (subInfo.worldPos.z < rotBall.z) {
                        drawSubOrbiterBall(subInfo.screenX, subInfo.screenY, subInfo.pixelRadius, subOrbiterHues2[i]);
                    }
                }
                
                // Draw main orbiter ball
                drawOrbiterBall(mainOrbiterInfo.screenX, mainOrbiterInfo.screenY, mainOrbiterInfo.pixelRadius);
                
                // Draw sub-orbiters that are in front of the main orbiter (first plane)
                for (let i = 0; i < 5; i++) {
                    const subInfo = subOrbiterInfos[i];
                    if (subInfo.worldPos.z >= rotBall.z) {
                        drawSubOrbiterBall(subInfo.screenX, subInfo.screenY, subInfo.pixelRadius, subOrbiterHues[i]);
                    }
                }
                
                // Draw sub-orbiters that are in front of the main orbiter (second plane)
                for (let i = 0; i < 5; i++) {
                    const subInfo = subOrbiterInfos2[i];
                    if (subInfo.worldPos.z >= rotBall.z) {
                        drawSubOrbiterBall(subInfo.screenX, subInfo.screenY, subInfo.pixelRadius, subOrbiterHues2[i]);
                    }
                }
            }
        }
    }

    //  DEFINE CUBE  -----------------
    class CUBE {
        constructor(pos, size) {
            this.pos = pos.clone();
            this.size = size; // Half-size of cube (distance from center to face)
            
            // Quaternion orientation
            this.orientation = quatFromEuler(
                Math.random() * 2 * Math.PI,
                Math.random() * 2 * Math.PI,
                Math.random() * 2 * Math.PI
            );

             // Quaternion orientation
            this.orientation = quatFromEuler(
                0.25 * Math.PI,
                0.25 * Math.PI,
                0.25 * Math.PI
            );
            
            // 3D angular velocity (tumbling in all dimensions)
            this.omega = {
                x: 0.2, // slow pitch
                y: -1, // slow roll
                z: 1.5  // slow yaw
            };
        }
        
        simulate() {
            // Update orientation by integrating angular velocity
            const half_dt = dT * 0.5;
            const dq = {
                w: 1,
                x: this.omega.x * half_dt,
                y: this.omega.y * half_dt,
                z: this.omega.z * half_dt
            };
            // new orientation = orientation * dq  (apply small-body-frame rotation)
            this.orientation = quatMultiply(this.orientation, dq);
            this.orientation = quatNormalize(this.orientation);
        }
        
        draw() {
            // Define 8 vertices of the cube in local space
            const s = this.size * cScale;
            const vertices = [
                { x: -s, y: -s, z: -s }, // 0: back-bottom-left
                { x:  s, y: -s, z: -s }, // 1: back-bottom-right
                { x:  s, y:  s, z: -s }, // 2: back-top-right
                { x: -s, y:  s, z: -s }, // 3: back-top-left
                { x: -s, y: -s, z:  s }, // 4: front-bottom-left
                { x:  s, y: -s, z:  s }, // 5: front-bottom-right
                { x:  s, y:  s, z:  s }, // 6: front-top-right
                { x: -s, y:  s, z:  s }  // 7: front-top-left
            ];
            
            // Rotate all vertices by current orientation
            const rotated = vertices.map(v => quatRotateVec(this.orientation, v.x, v.y, v.z));
            
            // Project to screen space
            const screenVerts = rotated.map(v => ({
                x: this.pos.x * cScale + v.x,
                y: this.pos.y * cScale - v.y, // flip Y for canvas
                z: v.z
            }));
            
            // Define 6 faces (each face as array of 4 vertex indices)
            const faces = [
                { indices: [0, 1, 2, 3], normal: { x: 0, y: 0, z: -1 }, baseHue: 170 }, // back
                { indices: [4, 5, 6, 7], normal: { x: 0, y: 0, z: 1 }, baseHue: 170 },  // front
                { indices: [0, 1, 5, 4], normal: { x: 0, y: -1, z: 0 }, baseHue: 170 }, // bottom
                { indices: [3, 2, 6, 7], normal: { x: 0, y: 1, z: 0 }, baseHue: 170 },  // top
                { indices: [0, 3, 7, 4], normal: { x: -1, y: 0, z: 0 }, baseHue: 170 }, // left
                { indices: [1, 2, 6, 5], normal: { x: 1, y: 0, z: 0 }, baseHue: 170 }   // right
            ];
            
            // Calculate each face's average Z and rotated normal for depth sorting and shading
            const facesWithDepth = faces.map(face => {
                // Average Z of face vertices
                const avgZ = face.indices.reduce((sum, idx) => sum + screenVerts[idx].z, 0) / 4;
                
                // Rotate the face normal
                const rotNormal = quatRotateVec(this.orientation, face.normal.x, face.normal.y, face.normal.z);
                
                // Simple lighting: assume light from front-top-right (normalized)
                const lightDir = { x: 0.3, y: 0.5, z: 0.8 };
                const lightMag = Math.sqrt(lightDir.x * lightDir.x + lightDir.y * lightDir.y + lightDir.z * lightDir.z);
                const lightDot = (rotNormal.x * lightDir.x + rotNormal.y * lightDir.y + rotNormal.z * lightDir.z) / lightMag;
                
                // Map dot product to brightness (0.3 to 1.0 range)
                const brightness = 0.3 + 0.7 * Math.max(0, lightDot);
                
                return {
                    face: face,
                    avgZ: avgZ,
                    brightness: brightness,
                    rotNormal: rotNormal
                };
            });
            
            // Sort faces by depth (back to front)
            facesWithDepth.sort((a, b) => a.avgZ - b.avgZ);
            
            // Draw rear faces (facing away) with faint lines first
            facesWithDepth.forEach(({ face, brightness, rotNormal }) => {
                if (rotNormal.z >= 0) { // Facing away from camera
                    c.beginPath();
                    face.indices.forEach((idx, i) => {
                        const v = screenVerts[idx];
                        if (i === 0) {
                            c.moveTo(v.x, v.y);
                        } else {
                            c.lineTo(v.x, v.y);
                        }
                    });
                    c.closePath();
                    
                    // Faint rear edges
                    c.strokeStyle = `hsla(${face.baseHue}, 40%, 30%, 0.8)`;
                    c.lineWidth = 2;
                    c.stroke();
                }
            });
            
            // Draw front faces (facing toward camera)
            facesWithDepth.forEach(({ face, brightness, rotNormal }) => {
                if (rotNormal.z < 0) { // Facing toward camera
                    c.beginPath();
                    face.indices.forEach((idx, i) => {
                        const v = screenVerts[idx];
                        if (i === 0) {
                            c.moveTo(v.x, v.y);
                        } else {
                            c.lineTo(v.x, v.y);
                        }
                    });
                    c.closePath();
                    
                    // Use transparency and shading based on lighting
                    const lightness = 10 + brightness * 30;
                    c.fillStyle = `hsla(${face.baseHue}, 70%, ${lightness}%, 0.4)`;
                    c.fill();
                    
                    // Edge outline
                    c.strokeStyle = `hsla(${face.baseHue}, 70%, ${lightness + 10}%, 0.9)`;
                    c.lineWidth = 3;
                    c.stroke();
                }
            });
        }
    }

    //  PONG GAME  -----------------
    class PONG {
        constructor() {
            // Game area in simulation coordinates (bottom right corner)
            this.width = 0.7; // Game width in sim units (doubled from 0.35)
            this.height = 0.375; // Game height in sim units (50% taller: 0.25 * 1.5)
            this.padding = 0.05; // Fixed padding from edges
            this.updatePosition(); // Calculate initial position
            
            // Paddles
            this.paddleWidth = 0.0075;
            this.paddleHeight = 0.04;
            
            // Goal area (half height, centered)
            this.goalHeight = this.height * 0.5;
            this.goalTop = this.height * 0.25;
            this.goalBottom = this.goalTop + this.goalHeight;
            this.goalCenter = this.goalTop + this.goalHeight / 2;
            
            this.leftPaddleY = this.goalCenter;
            this.rightPaddleY = this.goalCenter;
            this.paddleSpeed = 0.004;
            
            // Ball
            this.ballSize = 0.012;
            this.ballX = this.width / 2;
            this.ballY = this.height / 2;
            this.ballVelX = 0.006;
            this.ballVelY = 0.004;
            
            // AI tracking
            this.leftPaddleTarget = this.ballY;
            this.rightPaddleTarget = this.ballY;
            
            // Scores
            this.leftScore = 0;
            this.rightScore = 0;
        }
        
        updatePosition() {
            // Recalculate position based on current simWidth/simHeight
            this.x = simWidth - this.width - this.padding;
            this.y = simHeight - this.height - this.padding;
        }
        
        simulate() {
            // Update position in case window was resized
            this.updatePosition();
            // Move ball
            this.ballX += this.ballVelX;
            this.ballY += this.ballVelY;
            
            // Bounce off top/bottom walls
            if (this.ballY - this.ballSize / 2 <= 0) {
                this.ballY = this.ballSize / 2;
                this.ballVelY = Math.abs(this.ballVelY);
            }
            if (this.ballY + this.ballSize / 2 >= this.height) {
                this.ballY = this.height - this.ballSize / 2;
                this.ballVelY = -Math.abs(this.ballVelY);
            }
            
            // Check paddle collisions
            const paddlePadding = 0.02;
            
            // Left paddle
            const leftPaddleX = paddlePadding;
            if (this.ballX - this.ballSize / 2 <= leftPaddleX + this.paddleWidth &&
                this.ballX - this.ballSize / 2 >= leftPaddleX &&
                this.ballY >= this.leftPaddleY - this.paddleHeight / 2 &&
                this.ballY <= this.leftPaddleY + this.paddleHeight / 2) {
                this.ballX = leftPaddleX + this.paddleWidth + this.ballSize / 2;
                this.ballVelX = Math.abs(this.ballVelX);
                // Add some variation to Y velocity based on where it hit the paddle
                const hitPos = (this.ballY - this.leftPaddleY) / (this.paddleHeight / 2);
                this.ballVelY += hitPos * 0.002;
            }
            
            // Right paddle
            const rightPaddleX = this.width - this.paddleWidth - paddlePadding;
            if (this.ballX + this.ballSize / 2 >= rightPaddleX &&
                this.ballX + this.ballSize / 2 <= rightPaddleX + this.paddleWidth &&
                this.ballY >= this.rightPaddleY - this.paddleHeight / 2 &&
                this.ballY <= this.rightPaddleY + this.paddleHeight / 2) {
                this.ballX = rightPaddleX - this.ballSize / 2;
                this.ballVelX = -Math.abs(this.ballVelX);
                // Add some variation to Y velocity
                const hitPos = (this.ballY - this.rightPaddleY) / (this.paddleHeight / 2);
                this.ballVelY += hitPos * 0.002;
            }
            
            // Check if ball goes out of bounds - only score if through goal area
            if (this.ballX < 0) {
                // Check if ball went through goal area
                if (this.ballY >= this.goalTop && this.ballY <= this.goalBottom) {
                    // Right player scores
                    this.rightScore++;
                    // Reset scores if either player passes 9
                    if (this.rightScore > 9) {
                        this.rightScore = 0;
                        this.leftScore = 0;
                    }
                } else {
                    // Ball hit wall outside goal - just bounce back
                    this.ballX = 0;
                    this.ballVelX = Math.abs(this.ballVelX);
                }
                // Reset ball position if scored
                if (this.ballX < 0) {
                    this.ballX = this.width / 2;
                    this.ballY = this.height / 2;
                    this.ballVelX = (Math.random() > 0.5 ? 1 : -1) * 0.006;
                    this.ballVelY = (Math.random() - 0.5) * 0.008;
                }
            } else if (this.ballX > this.width) {
                // Check if ball went through goal area
                if (this.ballY >= this.goalTop && this.ballY <= this.goalBottom) {
                    // Left player scores
                    this.leftScore++;
                    // Reset scores if either player passes 9
                    if (this.leftScore > 9) {
                        this.rightScore = 0;
                        this.leftScore = 0;
                    }
                } else {
                    // Ball hit wall outside goal - just bounce back
                    this.ballX = this.width;
                    this.ballVelX = -Math.abs(this.ballVelX);
                }
                // Reset ball position if scored
                if (this.ballX > this.width) {
                    this.ballX = this.width / 2;
                    this.ballY = this.height / 2;
                    this.ballVelX = (Math.random() > 0.5 ? 1 : -1) * 0.006;
                    this.ballVelY = (Math.random() - 0.5) * 0.008;
                }
            }
            
            // AI: paddles only track when ball is moving toward them
            const trackingSpeed = this.paddleSpeed * 1.2;
            const deadZone = 0.005; // Don't move if within this range
            
            // Left paddle AI - only track when ball is moving left
            if (this.ballVelX < 0) {
                if (this.leftPaddleY < this.ballY - deadZone) {
                    this.leftPaddleY += trackingSpeed;
                } else if (this.leftPaddleY > this.ballY + deadZone) {
                    this.leftPaddleY -= trackingSpeed;
                }
            }
            
            // Right paddle AI - only track when ball is moving right
            if (this.ballVelX > 0) {
                if (this.rightPaddleY < this.ballY - deadZone) {
                    this.rightPaddleY += trackingSpeed;
                } else if (this.rightPaddleY > this.ballY + deadZone) {
                    this.rightPaddleY -= trackingSpeed;
                }
            }
            
            // Keep paddles in bounds (allow half paddle length beyond goal opening)
            const paddleExtension = this.paddleHeight / 2;
            this.leftPaddleY = Math.max(this.goalTop - paddleExtension + this.paddleHeight / 2, 
                                        Math.min(this.goalBottom + paddleExtension - this.paddleHeight / 2, this.leftPaddleY));
            this.rightPaddleY = Math.max(this.goalTop - paddleExtension + this.paddleHeight / 2, 
                                         Math.min(this.goalBottom + paddleExtension - this.paddleHeight / 2, this.rightPaddleY));
        }
        
        // Draw seven-segment style digit (classic Pong look)
        drawDigit(digit, x, y, segWidth, segHeight) {
            // Seven segments: top, top-right, bottom-right, bottom, bottom-left, top-left, middle
            const segments = {
                0: [1,1,1,1,1,1,0],
                1: [0,1,1,0,0,0,0],
                2: [1,1,0,1,1,0,1],
                3: [1,1,1,1,0,0,1],
                4: [0,1,1,0,0,1,1],
                5: [1,0,1,1,0,1,1],
                6: [1,0,1,1,1,1,1],
                7: [1,1,1,0,0,0,0],
                8: [1,1,1,1,1,1,1],
                9: [1,1,1,1,0,1,1]
            };
            
            const segs = segments[digit] || [0,0,0,0,0,0,0];
            const gap = segWidth * 0.15;
            
            c.fillStyle = 'hsla(0, 0%, 90%, 0.9)';
            
            // Top
            if (segs[0]) c.fillRect(x + gap, y, segHeight, segWidth);
            // Top-right
            if (segs[1]) c.fillRect(x + gap + segHeight, y + gap, segWidth, segHeight);
            // Bottom-right
            if (segs[2]) c.fillRect(x + gap + segHeight, y + gap + segHeight + gap, segWidth, segHeight);
            // Bottom
            if (segs[3]) c.fillRect(x + gap, y + 2*gap + 2*segHeight, segHeight, segWidth);
            // Bottom-left
            if (segs[4]) c.fillRect(x, y + gap + segHeight + gap, segWidth, segHeight);
            // Top-left
            if (segs[5]) c.fillRect(x, y + gap, segWidth, segHeight);
            // Middle
            if (segs[6]) c.fillRect(x + gap, y + gap + segHeight, segHeight, segWidth);
        }
        
        draw() {
            c.save();

            // fill game border
            c.fillStyle = 'hsla(0, 0%, 0%, 0.8)';
            c.fillRect(
                (this.x) * cScale,
                (this.y) * cScale,
                this.width * cScale,
                this.height * cScale
            );
            
            // Draw game border with goal gaps (half height, centered vertically) 
            c.strokeStyle = 'hsla(0, 0%, 100%, 0.6)';
            c.lineWidth = 2;
            
            const goalHeight = this.height * 0.5; // Goal is half the height
            const goalTop = this.height * 0.25; // Centered vertically
            const goalBottom = goalTop + goalHeight;
            
            c.beginPath();
            // Top border (full width)
            c.moveTo(this.x * cScale, this.y * cScale);
            c.lineTo((this.x + this.width) * cScale, this.y * cScale);
            
            // Bottom border (full width)
            c.moveTo(this.x * cScale, (this.y + this.height) * cScale);
            c.lineTo((this.x + this.width) * cScale, (this.y + this.height) * cScale);
            
            // Left border segments (top and bottom, with gap in middle)
            c.moveTo(this.x * cScale, this.y * cScale);
            c.lineTo(this.x * cScale, (this.y + goalTop) * cScale);
            c.moveTo(this.x * cScale, (this.y + goalBottom) * cScale);
            c.lineTo(this.x * cScale, (this.y + this.height) * cScale);
            
            // Right border segments (top and bottom, with gap in middle)
            c.moveTo((this.x + this.width) * cScale, this.y * cScale);
            c.lineTo((this.x + this.width) * cScale, (this.y + goalTop) * cScale);
            c.moveTo((this.x + this.width) * cScale, (this.y + goalBottom) * cScale);
            c.lineTo((this.x + this.width) * cScale, (this.y + this.height) * cScale);
            c.stroke();
            
            // Draw center line (dashed)
            c.setLineDash([5, 5]);
            c.strokeStyle = 'hsla(0, 0%, 100%, 0.5)';
            c.lineWidth = 1;
            c.beginPath();
            c.moveTo((this.x + this.width / 2) * cScale, this.y * cScale);
            c.lineTo((this.x + this.width / 2) * cScale, (this.y + this.height) * cScale);
            c.stroke();
            c.setLineDash([]);
            
            // Draw left paddle
            c.fillStyle = 'hsla(0, 0%, 100%, 0.9)';
            const paddlePadding = 0.02; // Distance from edge
            c.fillRect(
                (this.x + paddlePadding) * cScale,
                (this.y + this.leftPaddleY - this.paddleHeight / 2) * cScale,
                this.paddleWidth * cScale,
                this.paddleHeight * cScale
            );
            
            // Draw right paddle
            c.fillStyle = 'hsla(0, 0%, 100%, 0.9)';
            c.fillRect(
                (this.x + this.width - this.paddleWidth - paddlePadding) * cScale,
                (this.y + this.rightPaddleY - this.paddleHeight / 2) * cScale,
                this.paddleWidth * cScale,
                this.paddleHeight * cScale
            );
            
            // Draw ball (square)
            c.fillStyle = 'hsla(0, 0%, 100%, 0.95)';
            c.fillRect(
                (this.x + this.ballX - this.ballSize / 2) * cScale,
                (this.y + this.ballY - this.ballSize / 2) * cScale,
                this.ballSize * cScale,
                this.ballSize * cScale
            );
            
            // Draw scores with seven-segment display style
            const digitSegWidth = 3.0;
            const digitSegHeight = 10.8;
            const digitWidth = digitSegHeight + digitSegWidth * 2;
            
            // Left score (closer to center)
            const leftX = (this.x + this.width * 0.4) * cScale - digitWidth / 2;
            const leftY = (this.y + 0.015) * cScale;
            this.drawDigit(this.leftScore, leftX, leftY, digitSegWidth, digitSegHeight);
            
            // Right score (closer to center)
            const rightX = (this.x + this.width * 0.6) * cScale - digitWidth / 2;
            const rightY = (this.y + 0.015) * cScale;
            this.drawDigit(this.rightScore, rightX, rightY, digitSegWidth, digitSegHeight);
            
            c.restore();
        }
    }

    //  DRAW GLOBE ROIDS  --------------------
    function drawGlobeRoid(cx, cy, radius, originalRadius, hue, saturation, lightness, spinAngle = 0, orientation = {w:1,x:0,y:0,z:0}) {
        // Parametric globe-style globe (latitude & longitude) with front-hemisphere clipping
        c.save();
        
        // line width scales with roid size (radius is in pixels already)
        c.lineWidth = 0.02 * radius;
        c.strokeStyle = `hsl(${hue}, ${Math.round(saturation)}%, ${Math.round(lightness)}%)`;
        c.lineCap = 'round';

        // Use orthographic projection with equal X/Y scale so circles remain circular
        const verticalSquash = 1.0;
        // Helper: project 3D point (x,y,z) to screen (no non-uniform squash)
        function project(x, y, z) {
            const sx = cx + x;
            const sy = cy - y; // invert Y to canvas coords
            return { x: sx, y: sy, z: z };
        }

        // rotate by yaw (around Z), pitch (around X), roll (around Y)
        const spin = spinAngle || 0;

        function rotatePoint(x, y, z) {
            return quatRotateVec(orientation, x, y, z);
        }

        // Latitudes: Draw back-facing first (faint), then front-facing (bright)  ----------
        const latStep = 20; 
        const maxLat = 60;  
        const latDegrees = [0];
        for (let d = latStep; d <= maxLat; d += latStep) {
            latDegrees.push(d, -d);
        }
        
        // BACK HEMISPHERE - faint lines
        c.save();
        c.lineWidth = 0.015 * radius;
        c.strokeStyle = `hsla(${hue}, ${Math.round(saturation)}%, ${Math.round(Math.max(20, lightness - 10))}%, 0.6)`;
        for (let li = 0; li < latDegrees.length; li++) {
            const phi = latDegrees[li] * Math.PI / 180;
            const rLat = radius * Math.cos(phi);
            const z0 = radius * Math.sin(phi);
            const steps = 96;
            c.beginPath();
            let hasBack = false;
            for (let s = 0; s <= steps; s++) {
                const theta = (s / steps) * 2 * Math.PI + spin;
                const x0 = rLat * Math.cos(theta);
                const y0 = rLat * Math.sin(theta);
                const rot = rotatePoint(x0, y0, z0);
                const p = project(rot.x, rot.y, rot.z);
                
                // Only draw if facing away (z < 0)
                if (rot.z < 0) {
                    if (!hasBack) {
                        c.moveTo(p.x, p.y);
                        hasBack = true;
                    } else {
                        c.lineTo(p.x, p.y);
                    }
                } else if (hasBack) {
                    // Start new path segment when transitioning front/back
                    c.stroke();
                    c.beginPath();
                    hasBack = false;
                }
            }
            if (hasBack) c.stroke();
        }
        c.restore();
        
        // FRONT HEMISPHERE - bright lines
        c.save();
        c.lineWidth = 0.02 * radius;
        c.strokeStyle = `hsl(${hue}, ${Math.round(saturation)}%, ${Math.round(lightness)}%)`;
        for (let li = 0; li < latDegrees.length; li++) {
            const phi = latDegrees[li] * Math.PI / 180;
            const rLat = radius * Math.cos(phi);
            const z0 = radius * Math.sin(phi);
            const steps = 96;
            c.beginPath();
            let hasFront = false;
            for (let s = 0; s <= steps; s++) {
                const theta = (s / steps) * 2 * Math.PI + spin;
                const x0 = rLat * Math.cos(theta);
                const y0 = rLat * Math.sin(theta);
                const rot = rotatePoint(x0, y0, z0);
                const p = project(rot.x, rot.y, rot.z);
                
                // Only draw if facing forward (z >= 0)
                if (rot.z >= 0) {
                    if (!hasFront) {
                        c.moveTo(p.x, p.y);
                        hasFront = true;
                    } else {
                        c.lineTo(p.x, p.y);
                    }
                } else if (hasFront) {
                    c.stroke();
                    c.beginPath();
                    hasFront = false;
                }
            }
            if (hasFront) c.stroke();
        }
        c.restore();

        // Longitudes: Draw back-facing first (faint), then front-facing (bright)  ----------
        const numLong = 12;
        const phiSteps = 80;
        
        // BACK HEMISPHERE - faint lines
        c.save();
        c.lineWidth = 0.015 * radius;
        c.strokeStyle = `hsla(${hue}, ${Math.round(saturation)}%, ${Math.round(Math.max(20, lightness - 10))}%, 0.6)`;
        for (let k = 0; k < numLong; k++) {
            const lambda = (k / numLong) * 2 * Math.PI + spin;
            c.beginPath();
            let hasBack = false;
            for (let pi = 0; pi <= phiSteps; pi++) {
                const phi = (-0.5 + pi / phiSteps) * Math.PI;
                const x0 = radius * Math.cos(phi) * Math.cos(lambda);
                const y0 = radius * Math.cos(phi) * Math.sin(lambda);
                const z0 = radius * Math.sin(phi);
                const rot = rotatePoint(x0, y0, z0);
                const p = project(rot.x, rot.y, rot.z);
                
                // Only draw if facing away (z < 0)
                if (rot.z < 0) {
                    if (!hasBack) {
                        c.moveTo(p.x, p.y);
                        hasBack = true;
                    } else {
                        c.lineTo(p.x, p.y);
                    }
                } else if (hasBack) {
                    c.stroke();
                    c.beginPath();
                    hasBack = false;
                }
            }
            if (hasBack) c.stroke();
        }
        c.restore();
        
        // FRONT HEMISPHERE - bright lines
        c.save();
        c.lineWidth = 0.02 * radius;
        c.strokeStyle = `hsl(${hue}, ${Math.round(saturation)}%, ${Math.round(lightness)}%)`;
        for (let k = 0; k < numLong; k++) {
            const lambda = (k / numLong) * 2 * Math.PI + spin;
            c.beginPath();
            let hasFront = false;
            for (let pi = 0; pi <= phiSteps; pi++) {
                const phi = (-0.5 + pi / phiSteps) * Math.PI;
                const x0 = radius * Math.cos(phi) * Math.cos(lambda);
                const y0 = radius * Math.cos(phi) * Math.sin(lambda);
                const z0 = radius * Math.sin(phi);
                const rot = rotatePoint(x0, y0, z0);
                const p = project(rot.x, rot.y, rot.z);
                
                // Only draw if facing forward (z >= 0)
                if (rot.z >= 0) {
                    if (!hasFront) {
                        c.moveTo(p.x, p.y);
                        hasFront = true;
                    } else {
                        c.lineTo(p.x, p.y);
                    }
                } else if (hasFront) {
                    c.stroke();
                    c.beginPath();
                    hasFront = false;
                }
            }
            if (hasFront) c.stroke();
        }
        c.restore();

        // Draw outer circle mask to hide arc ends at the edge
        c.save();
        c.lineWidth = 0.03 * radius;
        c.strokeStyle = `hsl(${hue}, ${Math.round(saturation)}%, ${Math.round(lightness)}%)`;
        c.beginPath();
        c.arc(cx, cy, radius, 0, 2 * Math.PI);
        c.stroke();
        c.restore();

        /*// Apply 3D shading overlay - radial gradient lit from upper left
        c.save();
        const lightOffsetX = -radius * 0.35;
        const lightOffsetY = -radius * 0.55;
        const gradient = c.createRadialGradient(
            cx + lightOffsetX, cy + lightOffsetY, radius * 0.1,
            cx, cy, radius
        );
        // Use the sphere's own color for shading (lighter on top-left, darker on bottom-right)
        const brightL = Math.min(95, lightness + 35);
        const darkL = Math.max(10, lightness - 35);
        gradient.addColorStop(0, `hsla(${hue}, ${Math.round(saturation)}%, ${brightL}%, 0.4)`); // Bright highlight
        gradient.addColorStop(0.4, `hsla(${hue}, ${Math.round(saturation)}%, ${lightness}%, 0)`); // Fade to transparent
        gradient.addColorStop(0.7, `hsla(${hue}, ${Math.round(saturation)}%, ${lightness}%, 0)`); // Transparent midtone
        gradient.addColorStop(1, `hsla(${hue}, ${Math.round(saturation)}%, ${darkL}%, 0.5)`); // Dark shadow at edge
        
        c.fillStyle = gradient;
        c.beginPath();
        c.arc(cx, cy, radius, 0, 2 * Math.PI);
        c.fill();
        c.restore();*/
    }

    function drawOrbiter(radius, centerPos, orientation, orbitAngle) {
        // Draw orbiting ball around equator
        const orbitRadius = radius * 2.5; // Slightly outside the globe
        const baseBallRadius = radius * 0.35; // Base ball size
        
        // Calculate 3D position on equator (z=0 plane)
        const ballX0 = orbitRadius * Math.cos(orbitAngle);
        const ballY0 = orbitRadius * Math.sin(orbitAngle);
        const ballZ0 = 0; // On equator
        
        // Rotate the ball position with the globe's orientation
        const rotBall = quatRotateVec(orientation, ballX0, ballY0, ballZ0);
        
        // Scale based on z-position (perspective effect)
        // When z > 0 (toward viewer), scale up; when z < 0 (away from viewer), scale down
        // Normalize z by orbit radius to get a reasonable scale factor
        const zNormalized = rotBall.z / orbitRadius; // Range approximately -1 to 1
        const scaleFactor = 1.0 + zNormalized * 0.3; // Scale from 0.7x to 1.3x
        const ballRadius = baseBallRadius * scaleFactor;
        
        // Project to 2D screen space
        const ballScreenX = (centerPos.x + rotBall.x) * cScale;
        const ballScreenY = (centerPos.y - rotBall.y) * cScale; // Invert Y
        
        // Draw the orbiting ball with spherical shading
        const ballPixelRadius = ballRadius * cScale;
        
        // Return position info for shadow calculation
        return { screenX: ballScreenX, screenY: ballScreenY, pixelRadius: ballPixelRadius, worldPos: rotBall, scaleFactor: scaleFactor };
    }
    
    function drawOrbiterBall(ballScreenX, ballScreenY, ballPixelRadius) {
        // Sphere gradient for the ball
        const ballGradient = c.createRadialGradient(
            ballScreenX - ballPixelRadius * 0.3,
            ballScreenY - ballPixelRadius * 0.4,
            0,
            ballScreenX,
            ballScreenY,
            1.1 * ballPixelRadius
        );

        ballGradient.addColorStop(0, 'hsl(320, 80%, 80%)');
        ballGradient.addColorStop(0.3, 'hsl(320, 80%, 60%)');
        ballGradient.addColorStop(0.7, 'hsl(320, 80%, 30%)');
        ballGradient.addColorStop(1, 'hsl(320, 60%, 10%)');
        
        c.beginPath();
        c.arc(ballScreenX, ballScreenY, ballPixelRadius, 0, 2 * Math.PI);
        c.fillStyle = ballGradient;
        c.fill();
    }
    
    function drawSubOrbiterShadow(mainOrbiterScreenX, mainOrbiterScreenY, mainOrbiterPixelRadius, 
                                   subOrbiterScreenX, subOrbiterScreenY, subOrbiterPixelRadius,
                                   subOrbiterWorldZ, mainOrbiterWorldZ) {
        // Only draw shadow if sub-orbiter is behind main orbiter
        if (subOrbiterWorldZ >= mainOrbiterWorldZ) return;
        
        // Calculate shadow position on main orbiter surface
        const dx = subOrbiterScreenX - mainOrbiterScreenX;
        const dy = subOrbiterScreenY - mainOrbiterScreenY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Only draw shadow if sub-orbiter is reasonably close
        if (distance > mainOrbiterPixelRadius * 4) return;
        
        // Shadow is centered on the main orbiter, not offset
        const shadowCenterX = mainOrbiterScreenX;
        const shadowCenterY = mainOrbiterScreenY;
        
        // Calculate shadow size - larger and softer the farther away
        const depthFactor = Math.abs(subOrbiterWorldZ - mainOrbiterWorldZ) * 0.02;
        const shadowRadius = subOrbiterPixelRadius * (1.5 + depthFactor);
        
        // Draw shadow as a simple dark circular gradient at the center
        c.save();
        c.globalCompositeOperation = 'multiply';
        
        const shadowGradient = c.createRadialGradient(
            shadowCenterX, shadowCenterY, 0,
            shadowCenterX, shadowCenterY, shadowRadius
        );
        shadowGradient.addColorStop(0, 'rgba(0, 0, 0, 0.85)');
        shadowGradient.addColorStop(0.4, 'rgba(0, 0, 0, 0.6)');
        shadowGradient.addColorStop(0.7, 'rgba(0, 0, 0, 0.3)');
        shadowGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        
        c.fillStyle = shadowGradient;
        c.beginPath();
        c.arc(shadowCenterX, shadowCenterY, shadowRadius, 0, 2 * Math.PI);
        c.fill();
        c.restore();
    }

    function drawSubOrbiter(radius, centerPos, orientation, orbitAngle, subOrbitAngle, subOrbitDistanceMultiplier, orbiterScaleFactor) {
        const info = getSubOrbiterPosition(radius, centerPos, orientation, orbitAngle, subOrbitAngle, subOrbitDistanceMultiplier, orbiterScaleFactor);
        drawSubOrbiterBall(info.screenX, info.screenY, info.pixelRadius);
    }
    
    function getSubOrbiterPosition(radius, centerPos, orientation, orbitAngle, subOrbitAngle, subOrbitDistanceMultiplier, orbiterScaleFactor) {
        // Calculate smaller orbiter that orbits around the main orbiter
        const orbitRadius = radius * 2.5;
        const subOrbitRadius = radius * 0.15 * subOrbitDistanceMultiplier * orbiterScaleFactor; // Orbit radius scales with main orbiter
        const baseBallRadius = radius * 0.12 * orbiterScaleFactor; // Size scales with main orbiter
        
        // Calculate main orbiter position (this is the radial vector from globe center)
        const ballX0 = orbitRadius * Math.cos(orbitAngle);
        const ballY0 = orbitRadius * Math.sin(orbitAngle);
        const ballZ0 = 0;
        
        // Normalize the radial vector to get the direction from globe center to orbiter
        const radialLength = Math.sqrt(ballX0 * ballX0 + ballY0 * ballY0 + ballZ0 * ballZ0);
        const radialX = ballX0 / radialLength;
        const radialY = ballY0 / radialLength;
        const radialZ = ballZ0 / radialLength;
        
        // Create orbital plane perpendicular to radial vector
        // Use Z-axis as reference to find perpendicular vectors
        // First perpendicular vector (in the plane perpendicular to radial)
        let perp1X, perp1Y, perp1Z;
        if (Math.abs(radialZ) < 0.9) {
            // Cross product with Z axis
            perp1X = -radialY;
            perp1Y = radialX;
            perp1Z = 0;
        } else {
            // Cross product with X axis if radial is too close to Z
            perp1X = 0;
            perp1Y = -radialZ;
            perp1Z = radialY;
        }
        const perp1Length = Math.sqrt(perp1X * perp1X + perp1Y * perp1Y + perp1Z * perp1Z);
        perp1X /= perp1Length;
        perp1Y /= perp1Length;
        perp1Z /= perp1Length;
        
        // Second perpendicular vector (cross product of radial and perp1)
        const perp2X = radialY * perp1Z - radialZ * perp1Y;
        const perp2Y = radialZ * perp1X - radialX * perp1Z;
        const perp2Z = radialX * perp1Y - radialY * perp1X;
        
        // Calculate sub-orbiter position in the plane perpendicular to radial vector
        const cosAngle = Math.cos(subOrbitAngle);
        const sinAngle = Math.sin(subOrbitAngle);
        const subX0 = subOrbitRadius * (perp1X * cosAngle + perp2X * sinAngle);
        const subY0 = subOrbitRadius * (perp1Y * cosAngle + perp2Y * sinAngle);
        const subZ0 = subOrbitRadius * (perp1Z * cosAngle + perp2Z * sinAngle);
        
        // Position relative to main orbiter
        const subBallX = ballX0 + subX0;
        const subBallY = ballY0 + subY0;
        const subBallZ = ballZ0 + subZ0;
        
        // Rotate the sub-orbiter position with the globe's orientation
        const rotSubBall = quatRotateVec(orientation, subBallX, subBallY, subBallZ);
        
        // Scale based on z-position (perspective effect)
        const totalOrbitRadius = orbitRadius + subOrbitRadius;
        const zNormalized = rotSubBall.z / totalOrbitRadius;
        const scaleFactor = 1.0 + zNormalized * 0.3;
        const ballRadius = baseBallRadius * scaleFactor;
        
        // Project to 2D screen space
        const ballScreenX = (centerPos.x + rotSubBall.x) * cScale;
        const ballScreenY = (centerPos.y - rotSubBall.y) * cScale;
        
        // Return position info
        const ballPixelRadius = ballRadius * cScale;
        return { screenX: ballScreenX, screenY: ballScreenY, pixelRadius: ballPixelRadius, worldPos: rotSubBall };
    }
    
    function getSubOrbiterPosition2(radius, centerPos, orientation, orbitAngle, subOrbitAngle, subOrbitDistanceMultiplier, orbiterScaleFactor) {
        // Calculate smaller orbiter on perpendicular orbital plane (parallel to radial vector)
        const orbitRadius = radius * 2.5;
        const subOrbitRadius = radius * 0.15 * subOrbitDistanceMultiplier * orbiterScaleFactor; // Orbit radius scales with main orbiter
        const baseBallRadius = radius * 0.12 * orbiterScaleFactor; // Size scales with main orbiter
        
        // Calculate main orbiter position (radial vector from globe center)
        const ballX0 = orbitRadius * Math.cos(orbitAngle);
        const ballY0 = orbitRadius * Math.sin(orbitAngle);
        const ballZ0 = 0;
        
        // Normalize the radial vector
        const radialLength = Math.sqrt(ballX0 * ballX0 + ballY0 * ballY0 + ballZ0 * ballZ0);
        const radialX = ballX0 / radialLength;
        const radialY = ballY0 / radialLength;
        const radialZ = ballZ0 / radialLength;
        
        // Create orbital plane parallel to radial vector (perpendicular to first ring)
        // This plane contains the radial vector as one axis
        // Use Z-axis as reference to find perpendicular vector
        let perpX, perpY, perpZ;
        if (Math.abs(radialZ) < 0.9) {
            // Cross product with Z axis
            perpX = -radialY;
            perpY = radialX;
            perpZ = 0;
        } else {
            // Cross product with X axis if radial is too close to Z
            perpX = 0;
            perpY = -radialZ;
            perpZ = radialY;
        }
        const perpLength = Math.sqrt(perpX * perpX + perpY * perpY + perpZ * perpZ);
        perpX /= perpLength;
        perpY /= perpLength;
        perpZ /= perpLength;
        
        // Phase offset to avoid collisions with first set
        const phaseOffset = Math.PI / 5; // 36 degrees phase shift
        
        // Calculate sub-orbiter position using radial and perpendicular vectors
        const cosAngle = Math.cos(subOrbitAngle + phaseOffset);
        const sinAngle = Math.sin(subOrbitAngle + phaseOffset);
        const subX0 = subOrbitRadius * (radialX * cosAngle + perpX * sinAngle);
        const subY0 = subOrbitRadius * (radialY * cosAngle + perpY * sinAngle);
        const subZ0 = subOrbitRadius * (radialZ * cosAngle + perpZ * sinAngle);
        
        // Position relative to main orbiter
        const subBallX = ballX0 + subX0;
        const subBallY = ballY0 + subY0;
        const subBallZ = ballZ0 + subZ0;
        
        // Rotate the sub-orbiter position with the globe's orientation
        const rotSubBall = quatRotateVec(orientation, subBallX, subBallY, subBallZ);
        
        // Scale based on z-position (perspective effect)
        const totalOrbitRadius = orbitRadius + subOrbitRadius;
        const zNormalized = rotSubBall.z / totalOrbitRadius;
        const scaleFactor = 1.0 + zNormalized * 0.3;
        const ballRadius = baseBallRadius * scaleFactor;
        
        // Project to 2D screen space
        const ballScreenX = (centerPos.x + rotSubBall.x) * cScale;
        const ballScreenY = (centerPos.y - rotSubBall.y) * cScale;
        
        // Return position info
        const ballPixelRadius = ballRadius * cScale;
        return { screenX: ballScreenX, screenY: ballScreenY, pixelRadius: ballPixelRadius, worldPos: rotSubBall };
    }
    
    function drawSubOrbiterBall(ballScreenX, ballScreenY, ballPixelRadius, hue = 200) {
        // Sphere gradient for the sub-orbiter with variable hue
        const ballGradient = c.createRadialGradient(
            ballScreenX - ballPixelRadius * 0.3,
            ballScreenY - ballPixelRadius * 0.4,
            0,
            ballScreenX,
            ballScreenY,
            1.1 * ballPixelRadius
        );
        ballGradient.addColorStop(0, `hsl(${hue}, 80%, 80%)`);
        ballGradient.addColorStop(0.3, `hsl(${hue}, 80%, 70%)`);
        ballGradient.addColorStop(0.7, `hsl(${hue}, 80%, 40%)`);
        ballGradient.addColorStop(1, `hsl(${hue}, 60%, 15%)`);
        
        c.beginPath();
        c.arc(ballScreenX, ballScreenY, ballPixelRadius, 0, 2 * Math.PI);
        c.fillStyle = ballGradient;
        c.fill();
    }

    //  SPAWN ROIDS  ------------------------------------------------------------
    function spawnRoid() {
        var radius = 0.4;
        var pos = new Vector2(0.8 * simWidth, 0.3 * simHeight);
        //var pos = new Vector2(0.7 * simWidth, 0.5 * simHeight);
        var vel = new Vector2(0, 0);
        //var hue = Math.floor(Math.random() * 360);
        var hue = 70;
        var saturation = 60 + 30 * Math.random(); // 60-90% for vibrant colors
        var lightness = 40; // 45-60% to avoid white/pale colors
        let seed = Math.floor(Math.random() * 0xFFFFFFFF);
        let randomNo = Math.random();
        let yaw = Math.random() * 2 * Math.PI;
        let pitch = Math.random() * 2 * Math.PI; // -pi/2 .. +pi/2
        let roll = Math.random() * 2 * Math.PI;
                
        Roid.push(new ROID(pos, vel, radius, hue, saturation, lightness, randomNo, yaw, pitch, roll));   
    }

    //  SPAWN CUBE  ------------------------------------------------------------
    function spawnCube() {
        var size = 0.2; // Half-size of cube
        var pos = new Vector2(0.6 * simWidth, 0.75 * simHeight); // Center of screen
        Cube = new CUBE(pos, size);
    }

    //  SPAWN PONG GAME  ------------------------------------------------------------
    function spawnPong() {
        PongGame = new PONG();
    }

    //  NODE CLASS  -------------------
    class NODE { 
        constructor(pos, angle, color, speed, direction) {
            this.pos = pos.clone();
            this.angle = angle;
            this.color = color;
            this.speed = speed;
            this.direction = direction;
            this.trail = [];
            this.maxTrailLength = 40;
            this.trailMinDistance = 0.001;
        }
        simulate() {
            this.angle += .05 * this.direction * this.speed;
            if (this.direction > 0 && this.angle > 2 * Math.PI) {
                this.angle -= 2 * Math.PI;
            }
            if (this.direction < 0 && this.angle < 0) {
                this.angle += 2 * Math.PI;
            }

            var lobeId = 5;
            f += 0.000001 * this.speed * this.direction;
            
            // Pre-calculate trig values to avoid redundant calculations
            const angleDirection = this.angle * this.direction;
            const fPlusAngle = f + this.angle;
            const lobeFPlusAngle = lobeId * fPlusAngle;
            
            const cosAngleDirection = Math.cos(angleDirection);
            const sinAngle = Math.sin(this.angle);
            const cosLobeFPlusAngle = Math.cos(lobeFPlusAngle);
            const cosFPlusAngle = Math.cos(fPlusAngle);
            const sinFPlusAngle = Math.sin(fPlusAngle);
            
            const lobeEffect = 0.008 * cosLobeFPlusAngle;
            
            this.pos.x += 0.002 * cosAngleDirection + lobeEffect * cosFPlusAngle;
            this.pos.y += 0.001 * sinAngle + lobeEffect * sinFPlusAngle;
            
            // Add current position to trail
            this.addToTrail();
        }
        addToTrail() {
            // Only add if moved enough distance from last trail point
            if (this.trail.length === 0) {
                this.trail.push(this.pos.clone());
            } else {
                const lastPos = this.trail[this.trail.length - 1];
                const dx = this.pos.x - lastPos.x;
                const dy = this.pos.y - lastPos.y;
                const distSquared = dx * dx + dy * dy;
                
                if (distSquared > this.trailMinDistance * this.trailMinDistance) {
                    this.trail.push(this.pos.clone());
                    
                    // Keep trail at max length
                    if (this.trail.length > this.maxTrailLength) {
                        this.trail.shift();
                    }
                }
            }
        }
    }

    //  GENERATE NODE ARRAY ------------------
    function spawnNodes() {
        // right side
        for (i = 0; i < 20; i++) {
            var radius = 0.1 * simHeight + 0.5 * simHeight * Math.random();
            var angle = 2 * Math.PI * Math.random();
            var color = `hsl(${Math.random() * 360}, 30%, 50%)`;
            var speed = 0.4 * Math.random();
            if (Math.random() < 0.50) {
                var direction = 1;
            } else {
                var direction = -1;
            }
            PrimaryNodes.push(new NODE(
                new Vector2(
                    0.7 * simWidth + radius * Math.cos(angle), 
                    0.5 * simHeight + radius * Math.sin(angle)), 
                2 * Math.PI * Math.random(),
                color,
                speed,
                direction));
        }

        //  left side
        for (i = 0; i < 20; i++) {
            var radius = 0.1 * simHeight + 0.5 * simHeight * Math.random();
            var angle = 2 * Math.PI * Math.random();
            var color = `hsl(${Math.random() * 360}, 30%, 50%)`;
            var speed = .1 + .4 * Math.random();
            if (Math.random() < 0.50) {
                direction = 1;
            } else {
                direction = -1;
            }
            SecondaryNodes.push(new NODE(
                new Vector2(
                    0.1 * simWidth + radius * Math.cos(angle), 
                    0.5 * simHeight + radius * Math.sin(angle)), 
                2 * Math.PI * Math.random(),
                color,
                speed,
                direction));
        }
    }

    function drawNodes() {
        // Draw trails for primary nodes
        for (i = 0; i < PrimaryNodes.length; i++) {
            const node = PrimaryNodes[i];
            if (node.trail.length > 1) {
                c.lineCap = 'round';
                c.lineJoin = 'round';
                
                for (let j = 1; j < node.trail.length; j++) {
                    const alpha = j / node.trail.length;
                    c.strokeStyle = `hsla(210, 70%, 60%, ${alpha * 0.1})`;
                    c.lineWidth = 2 + 25 * alpha;
                    
                    c.beginPath();
                    c.moveTo(node.trail[j - 1].x * cScale, node.trail[j - 1].y * cScale);
                    c.lineTo(node.trail[j].x * cScale, node.trail[j].y * cScale);
                    c.stroke();
                }
            }
        }
            
        // Draw trails for secondary nodes
        for (i = 0; i < SecondaryNodes.length; i++) {
            const node = SecondaryNodes[i];
            if (node.trail.length > 1) {
                c.lineCap = 'round';
                c.lineJoin = 'round';
                for (let j = 1; j < node.trail.length; j++) {
                    const alpha = j / node.trail.length;
                    c.strokeStyle = `hsla(320, 70%, 50%, ${alpha * 0.15})`;
                    c.lineWidth = 2 + 25 * alpha;
                    
                    c.beginPath();
                    c.moveTo(node.trail[j - 1].x * cScale, node.trail[j - 1].y * cScale);
                    c.lineTo(node.trail[j].x * cScale, node.trail[j].y * cScale);
                    c.stroke();
                }
            }
        }
        
        // Collect all connections with their distances for sorting
        let secondaryConnections = [];
        let primaryConnections = [];
        
        // Collect connections between secondary nodes (left side)
        for (i = 0; i < SecondaryNodes.length; i++) {
            node1 = SecondaryNodes[i];
            for (j = i + 1; j < SecondaryNodes.length; j++) {
                node2 = SecondaryNodes[j];
                const invDistance = measureDistAndShade(node1, node2);
                secondaryConnections.push({
                    node1: node1,
                    node2: node2,
                    invDistance: invDistance
                });
            }   
        }

        // Collect connections between primary nodes (right side)
        for (i = 0; i < PrimaryNodes.length; i++) {
            node1 = PrimaryNodes[i];
            for (j = i + 1; j < PrimaryNodes.length; j++) {
                node2 = PrimaryNodes[j];
                const invDistance = measureDistAndShade(node1, node2);
                primaryConnections.push({
                    node1: node1,
                    node2: node2,
                    invDistance: invDistance
                });
            }  
        }
        
        // Sort connections: large invDistance (close) = draw last, small invDistance (far) = draw first
        secondaryConnections.sort((a, b) => a.invDistance - b.invDistance);
        primaryConnections.sort((a, b) => a.invDistance - b.invDistance);
        
        // Draw secondary connections from farthest to closest
        for (let conn of secondaryConnections) {
            c.beginPath();
            c.moveTo(conn.node1.pos.x * cScale, conn.node1.pos.y * cScale);
            c.lineTo(conn.node2.pos.x * cScale, conn.node2.pos.y * cScale);
            if (conn.invDistance * 20 < 60) {
                var lineLite = conn.invDistance * 20;
            } else {
                var lineLite = 60;
            }
            c.strokeStyle = `hsla(130, 50%, ${lineLite}%, ${lineLite + 20}%)`;
            c.lineWidth = Math.min(2 * conn.invDistance, 4);
            c.stroke();
        }
        
        // Draw primary connections from farthest to closest
        for (let conn of primaryConnections) {
            c.beginPath();
            c.moveTo(conn.node1.pos.x * cScale, conn.node1.pos.y * cScale);
            c.lineTo(conn.node2.pos.x * cScale, conn.node2.pos.y * cScale);
            if (conn.invDistance * 20 < 60) {
                var lineLite = conn.invDistance * 20;
            } else {
                var lineLite = 60;
            }
            c.strokeStyle = `hsla(${180 + 3 * lineLite}, 50%, ${lineLite}%, ${lineLite + 20}%)`;
            c.lineWidth = Math.min(4 * conn.invDistance, 4);
            c.stroke();
        }
            
        // Draw primary nodes with spherical shading
        for (i = 0; i < PrimaryNodes.length; i++) {
            node1 = PrimaryNodes[i];
            const x = node1.pos.x * cScale;
            const y = node1.pos.y * cScale;
            const radius = 0.03 * cScale;
            
            // Create radial gradient for 3D sphere effect
            const gradient = c.createRadialGradient(
                x - radius * 0.3, y - radius * 0.3, radius * 0.1,
                x, y, radius
            );
            gradient.addColorStop(0, 'hsl(210, 70%, 85%)');
            gradient.addColorStop(0.3, 'hsl(210, 70%, 60%)');
            gradient.addColorStop(0.7, 'hsl(210, 70%, 40%)');
            gradient.addColorStop(1, 'hsl(210, 70%, 20%)');
            
            drawCircle(x, y, radius);
            c.fillStyle = gradient;
            c.fill();   
        }
            
        // Draw secondary nodes with spherical shading
        for (i = 0; i < SecondaryNodes.length; i++) {
            node1 = SecondaryNodes[i];
            const x = node1.pos.x * cScale;
            const y = node1.pos.y * cScale;
            const radius = 0.03 * cScale;
            
            // Create radial gradient for 3D sphere effect
            const gradient = c.createRadialGradient(
                x - radius * 0.3, y - radius * 0.3, radius * 0.1,
                x, y, radius
            );
            gradient.addColorStop(0, 'hsl(320, 70%, 85%)');
            gradient.addColorStop(0.3, 'hsl(320, 70%, 60%)');
            gradient.addColorStop(0.7, 'hsl(320, 70%, 40%)');
            gradient.addColorStop(1, 'hsl(320, 70%, 20%)');
            
            drawCircle(x, y, radius);
            c.fillStyle = gradient;
            c.fill();   
        }

        /*// Draw connections between primary and secondary nodes
        for (i = 0; i < PrimaryNodes.length; i++) {
            node1 = PrimaryNodes[i];
            for (j = 0; j < SecondaryNodes.length; j++) {
                node2 = SecondaryNodes[i];
                c.moveTo(node1.pos.x * cScale, node1.pos.y * cScale);
                c.lineTo(node2.pos.x * cScale, node2.pos.y * cScale);
                if (measureDistAndShade(node1, node2) * 20 < 60) {
                    var lineLite = measureDistAndShade(node1, node2) * 20
                } else {
                    var lineLite = 60;
                }
                c.strokeStyle = `hsla(0, 70%, 20%, 10%)`;
                c.lineWidth = Math.min(2 * measureDistAndShade(node1, node2), 2);
                
            }
            c.stroke();
        }*/
    }

    //  SIMULATION --------------------------------------------------------------------------
	function simulate() {
        for (n = 0; n < PrimaryNodes.length; n++) {
            PrimaryNodes[n].simulate();
            SecondaryNodes[n].simulate();
        }

        for (var r = 0; r < Roid.length; r++) {
            if (Roid[r] != null) {
                var roid = Roid[r]
                roid.simulate();
            }
        }
        
        // Simulate cube
        if (Cube != null) {
            Cube.simulate();
        }
        
        // Simulate pong game
        if (PongGame != null) {
            PongGame.simulate();
        }
    }
    
    //  DRAW EVERYTHING ==============================================================
	function drawEverything() {
        // Clear the canvas
        c.fillStyle = 'hsl(0, 0%, 0%)';
        c.fillRect(0, 0, canvas.width, canvas.height);

        // Draw nodes and their connections
        drawNodes();
        
        // Draw side fades
        const sideFade = c.createLinearGradient(0, 0, canvas.width, 0);
        sideFade.addColorStop(0.00, 'hsla(0, 0%, 5%, 1)');
        sideFade.addColorStop(0.30, 'hsla(0, 0%, 3%, 1.0)');
        sideFade.addColorStop(0.50, 'hsla(0, 0%, 0%, 0)');
        sideFade.addColorStop(0.90, 'hsla(0, 0%, 0%, 0)');
        sideFade.addColorStop(0.97, 'hsla(0, 0%, 0%, 0.8)');
        sideFade.addColorStop(1, 'hsla(0, 0%, 0%, 0.9)');
        c.fillStyle = sideFade;
        c.fillRect(0, 0, canvas.width, canvas.height);

        // Draw semi-transparent black overlay
        c.fillStyle = 'hsla(0, 0%, 0%, 0.5)';
        c.fillRect(0, 0, canvas.width, canvas.height); 

        // Draw cube
        if (Cube != null) {
            Cube.draw();
        }

        // Draw roid
        for (var r = 0; r < Roid.length; r++) {
            if (Roid[r] != null) {
                var roid = Roid[r]
                roid.draw();
            }
        }
        
        // Draw pong game
        if (PongGame != null) {
            PongGame.draw();
        }
	}

    //  MAIN SEQUENCE ----------------------------------------------------------------------------
	setupScene();
    
    function update() {
        simulate();
        
		drawEverything();
		requestAnimationFrame(update);
	}
    
	update();

</script> 

</body>
</html>
