<!-- Frank Maiello -->

<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=500, initial-scale=1.0">
<!-- <meta name="viewport" content="width=device-width, initial-scale=1.0"> -->
<style>

    .title {font-family: verdana; 
        font-size: 38px;
        font-weight: bold;
        color: hsl(30, 87%, 50%);
        text-align: left;
        text-shadow: 5px 7px 10px hsl(0, 0%, 0%);
        margin-left: 0px;
        margin-right: 0px;
        padding-left: 10px;
        padding-right: 5px;
    }

    .appTitle {font-family: monospace; 
        font-size: 20px;
        font-weight: bold;
        color : #C93226;
        text-align: left;
        text-shadow: 5px 7px 10px hsl(0, 0%, 0%);
        margin: 0;
        padding: 0;
        font-weight: bold;
    }

    .description {font-family: monospace; 
        font-size: 20px;
        color: hsl(0, 0%, 89%);
        text-align: left;
        text-shadow: 5px 7px 10px hsl(0, 0%, 0%);
        margin: 0;
        padding: 0;
    }

    h4 {
        color: hsl(0, 90%, 59%);
    }

    h3 {font-family: verdana; 
        font-size: 2px;
        color: hsl(0, 0%, 89%);
        text-align: left;
        text-shadow: 5px 7px 10px hsl(0, 0%, 0%);
        margin-left: 0px;
        margin-right: 0px;
        padding-left: 10px;
        padding-right: 5px;
    }

    .verbiage1 {font-family: verdana; 
        font-size: 14px;
        color: hsl(0, 0%, 89%);
        text-align: left;
        text-shadow: 5px 7px 10px hsl(0, 0%, 0%);
        margin-left: 5px;
        margin-right: 0px;
        padding-left: 10px;
        padding-right: 5px;
    }

    .verbiage1b {font-family: verdana; 
        font-style: italic;
        font-size: 14px;
       
        text-align: left;
        text-shadow: 5px 7px 10px hsl(0, 0%, 0%);
        margin-left: 5px;
        margin-right: 0px;
        padding-left: 10px;
        padding-right: 5px;
    }

    .verbiage1b a {
        color: hsl(37, 100%, 58%);
        text-decoration: none;
    }
    
    .verbiage1b a:hover {
        color: #C93226;
        text-decoration: underline;
    }

    .verbiage2a {font-family: verdana; 
        font-size: 13px;
        font-style: italic;
        color: hsl(0, 0%, 89%);
        text-align: left;
        text-shadow: 5px 7px 10px hsl(0, 0%, 0%);
        margin-left: 5px;
        margin-right: 0px;
        padding-left: 10px;
        padding-right: 5px;
    }
    
    .verbiage2 {font-family: verdana; 
        font-size: 13px;
        font-style: italic;
        color: hsl(0, 0%, 89%);
        text-align: left;
        text-shadow: 5px 7px 10px hsl(0, 0%, 0%);
        margin-left: 0px;
        margin-right: 0px;
        padding-left: 10px;
        padding-right: 5px;
    }
    
    

    table#pubTable {
        text-align: left;
        width: 100%;
        font-size: 18px;
        vertical-align: bottom;
    }
    td {
    vertical-align: top;
    white-space: nowrap;
    padding : 10px 20px;
    }

    

    thead tr th:first-child,
    tbody tr td:first-child {
    width: 400px;
    min-width: 400px;
    max-width: 400px;
    }

    .paperButton:hover {
    background-color: #777777; 
    color: white;
    }

    .button {
    font-family: verdana; 
    background-color: #555555;
    border: none;
    color: white;
    padding: 5px 5px;
    margin: 2px 0px 2px 0px;  
    border-radius: 5px;
    
    text-align: center;
    text-decoration: none;
    display: inline-block;
    font-size: 14px;
    box-shadow: 5px 7px 10px hsl(0, 0%, 0%);
    }
    
    .paperImage {
    width: 400px;
    box-shadow: 5px 7px 10px hsl(0, 0%, 0%);
    }
</style>

</head>
<body>

<canvas id="myCanvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0;"></canvas>

<div style="position: relative; z-index: 1; padding: 10px;">
<title>FM Home</title>

<div class = "title">I Like to üíÉüèº Move it üï∫üèª Move it üêí </div>

<div class = "verbiage1"><br>A small collection of physics and animation exercises with JavaScript</div>
<div class = "verbiage1b"><a href="mailto:maiello.frank@gmail.com">maiello.frank@gmail.com</a></div>
<div class = "verbiage2a"><br>Please use Chrome or Edge for best performance</div>
<table id = "pubTable">

<tr>
  <td>
    <a href = "https://frank-maiello.github.io//slosh.html"><img class = "paperImage" src = "https://frank-maiello.github.io/screen_slosh.png"></a>
  </td>
  <td>
    <div class = "appTitle">3 - SL0SH (CHEF'S CHOICE)</div>
    <h3><br></h3>
    <div class = "description">Particle Physics Sandbox</div>
    <div class = "verbiage2"><br>Fluid-like "sloshy" particle simulation with </div>
    <div class = "verbiage2">interactive toys and a menu-driven user interface. </div>
    <div class = "verbiage2">Created with the help of Claude. Go Claude!</div>
    <br>
    <a href = "https://frank-maiello.github.io/slosh.html" target="_blank" class="button">Play</a>
    <a href = "https://github.com/frank-maiello/frank-maiello.github.io/blob/main/slosh.html" target="_blank" class="button">Code</a>
    &nbsp; &nbsp; &nbsp;
  </td>
</tr>

<tr>
  <td>
    <a href = "https://frank-maiello.github.io//roids.html"><img class = "paperImage" src = "https://frank-maiello.github.io/screen_roids.png"></a>
  </td>
  <td>
    <div class = "appTitle">2 - R0IDS (STAFF PICK!)</div>
    <h3><br></h3>
    <div class = "description">A Take on Asteroids</div>
    <div class = "verbiage2"><br>First there was Space Invaders, then came Asteroids.</div>
    <div class = "verbiage2">Unique obstacles, cranky enemy, weapon power-ups,</div>
    <div class = "verbiage2">floaty physics, increasing difficulty... and cheats.</div>
    <br>
    <a href = "https://frank-maiello.github.io/roids.html" target="_blank" class="button">Play</a>
    <a href = "https://github.com/frank-maiello/frank-maiello.github.io/blob/main/roids.html" target="_blank" class="button">Code</a>
    &nbsp; &nbsp; &nbsp;
  </td>
</tr>
  
<tr>
  <td>
    <a href = "https://frank-maiello.github.io/droplets.html"><img class = "paperImage" src = "https://frank-maiello.github.io/screen_droplets.png"></a>
  </td>
  <td>
    <div class = "appTitle">1 - DR0PLETS</div>
    <h3><br></h3>
    <div class = "description">Abstract Algorithmic Line 'Art'</div>
    <div class = "verbiage2"><br>Repetetive line-drawing the slow way, using</div>
    <div class = "verbiage2">trigonometry and polar coordinates.</div>
    <div class = "verbiage2"><br>Click the Auto button for instant gratification.</div>
    <br>
    <a href = "https://frank-maiello.github.io/droplets.html" target="_blank" class="button">Play</a>
    <a href = "https://github.com/frank-maiello/frank-maiello.github.io/blob/6404a30fcd3e544bf28b16d2a8adea4be639b728/droplets.html" target="_blank" class="button">Code</a>
    &nbsp; &nbsp; &nbsp;
  </td>
</tr>
              
<tr>
  <td>
    <a href = "https://frank-maiello.github.io/plinkolab.html"><img class = "paperImage" src = "https://frank-maiello.github.io/screen_plinkolab.png"></a>
  </td>
  <td>
  <div class = "appTitle">0 - PLINK0 LAB</div>
  <h3><br></h3>
  <div class = "description">Intro to Particle Physics Simulation</div>
  <div class = "verbiage2"><br>If you dare. My first undertaking. Consult a child</div>
  <div class = "verbiage2">to best navigate the Playskool user interface.</div>

  <br>
  <a href = "https://frank-maiello.github.io/plinkolab.html" target="_blank" class="button">Play</a>
  <a href = "https://github.com/frank-maiello/frank-maiello.github.io/blob/6404a30fcd3e544bf28b16d2a8adea4be639b728/plinkolab.html" target="_blank" class="button">Code</a>
  &nbsp; &nbsp; &nbsp;  
  </td>
</tr>      
</table>
</div>
</body>
    
<script>

    //  CANVAS SETUP AND SCALING --------------------------------------------------------------
    canvas = document.getElementById("myCanvas");
	    c = canvas.getContext("2d");
        canvas.style.cursor = "pointer";
       
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

        simMinWidth = 2.0;
        cScale = Math.min(canvas.width, canvas.height) / simMinWidth;
        simWidth = canvas.width / cScale;
        simHeight = canvas.height / cScale;
        topMargin = 0;
        bottomMargin = 0;
    
    function resizeCanvas() {
        canvas = document.getElementById("myCanvas");
	    c = canvas.getContext("2d");
        canvas.style.cursor = "pointer";
       
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;        simMinWidth = 2.0;
        cScale = Math.min(canvas.width, canvas.height) / simMinWidth;
        simWidth = canvas.width / cScale;
        simHeight = canvas.height / cScale;
    }

    window.addEventListener("resize", resizeCanvas);

    function drawCircle(x, y, radius) {
        c.beginPath();			
		c.arc(x, y, radius, 0.0, 2.0 * Math.PI) 
		c.closePath();
	}
    function drawEllipse(x, y, radiusX, radiusY) {
        c.beginPath();			
		c.ellipse(x * cScale, y * cScale, radiusX * cScale, radiusY * cScale, 0, 0, 2 * Math.PI) 
		c.closePath();
	}

    //  SETUP SCENE ======================================================
	function setupScene() {
        PrimaryNodes = [];
        SecondaryNodes = [];
        spawnNodes();
        spinner = 0;
        f = 0;

        //  INITIALIZE ARRAYS  
        Roid = [];

        //  INITIALIZE BOOLEANS 
        dT = 1/60;

        //  SPAWN INITIAL OBJECTS  
        spawnRoid()
    }
    
	//  VECTOR OPERATIONS ---------------------------------------------------------------------
	class Vector2 {
		constructor(x = 0.0, y = 0.0) {
			this.x = x; 
			this.y = y;
		}
		set(v) {
			this.x = v.x; 
            this.y = v.y;
		}
		clone() {
			return new Vector2(this.x, this.y);
		}
		add(v, s=1) {
			this.x += v.x * s;
			this.y += v.y * s;
			return this;
		}
		addVectors(a, b) {
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			return this;
		}
		subtract(v, s = 1.0) {
			this.x -= v.x * s;
			this.y -= v.y * s;
			return this;
		}
		subtractVectors(a, b) {
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			return this;			
		}
		length() {
			return Math.sqrt(this.x * this.x + this.y * this.y);
		}
		scale(s) {
			this.x *= s;
			this.y *= s;
		}
		dot(v) {
			return this.x * v.x + this.y * v.y;
		}
        perp() {
			return new Vector2(-this.y, this.x);
		}
	}

    function cX(pos) {
        return pos.x * cScale;
    }
	function cY(pos) {
        return canvas.height - pos.y * cScale;
    }

    //  NORMALIZE DISTANCE  -------------------
    function measureDistAndShade(node1, node2) {
		var dir = new Vector2();
		dir.subtractVectors(node1.pos, node2.pos);
		d = dir.length();
		
		return 1 / d;
	}

    // Quaternion helpers to avoid gimbal lock when integrating orientation
        function quatFromEuler(yaw, pitch, roll) {
            // yaw (Z), pitch (X), roll (Y) ‚Äî same convention as earlier Euler usage
            const cy = Math.cos(yaw * 0.5);
            const sy = Math.sin(yaw * 0.5);
            const cp = Math.cos(pitch * 0.5);
            const sp = Math.sin(pitch * 0.5);
            const cr = Math.cos(roll * 0.5);
            const sr = Math.sin(roll * 0.5);
            // q = q_yaw * q_pitch * q_roll
            const w = cy * cp * cr + sy * sp * sr;
            const x = cy * sp * cr + sy * cp * sr;
            const y = cy * cp * sr - sy * sp * cr;
            const z = sy * cp * cr - cy * sp * sr;
            return { w: w, x: x, y: y, z: z };
        }

        function quatMultiply(a, b) {
            return {
                w: a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z,
                x: a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y,
                y: a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x,
                z: a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w
            };
        }

        function quatNormalize(q) {
            const len = Math.sqrt(q.w*q.w + q.x*q.x + q.y*q.y + q.z*q.z) || 1.0;
            q.w /= len; q.x /= len; q.y /= len; q.z /= len;
            return q;
        }

        function quatRotateVec(q, vx, vy, vz) {
            // Standard, stable quaternion-vector rotation using cross products:
            // t = 2 * cross(q.xyz, v)
            // v' = v + q.w * t + cross(q.xyz, t)
            const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
            // cross(q.xyz, v)
            const cx = qy * vz - qz * vy;
            const cy = qz * vx - qx * vz;
            const cz = qx * vy - qy * vx;
            const tx = 2 * cx;
            const ty = 2 * cy;
            const tz = 2 * cz;
            // cross(q.xyz, t)
            const c2x = qy * tz - qz * ty;
            const c2y = qz * tx - qx * tz;
            const c2z = qx * ty - qy * tx;
            return {
                x: vx + qw * tx + c2x,
                y: vy + qw * ty + c2y,
                z: vz + qw * tz + c2z
            };
        }

    //  DEFINE ROIDS  -----------------
    class ROID {
        constructor (pos, vel, radius, hue, saturation, lightness, 
        randomNo, yaw, pitch, roll) {
            this.pos = pos.clone();
            this.vel = vel.clone();
            this.radius = radius;
            this.originalRadius = radius;
            this.mass = radius * radius * radius; // volume proportional to r^3, density constant
            this.hue = hue;
            this.saturation = saturation;
            this.lightness = lightness;
            this.randomNo = randomNo;
            this.spinAngle = 0;
            // pole spin state for globe roids (controls longitudes rotation)
            this.poleSpinAngle = Math.random() * 2 * Math.PI;
            this.poleSpinSpeed = (Math.random() - 0.5) * 0.1;
            // orientation: store as a quaternion to avoid gimbal lock; also keep Euler cache for code compatibility
            this.yaw = Math.random() * 2 * Math.PI; // initial Euler cache
            this.pitch = (Math.random() - 0.5) * Math.PI; // initial Euler cache
            this.roll = Math.random() * 2 * Math.PI; // initial Euler cache
            // quaternion orientation initialized from euler cache
            this.orientation = quatFromEuler(this.yaw, this.pitch, this.roll);
            // 3D angular velocity vector (rad/frame). Keep scalar angularVelocity in sync with omega.z
            this.omega = {
                x: (Math.random() - 0.5) * 0.2, // pitch rate (tumbling)
                y: (Math.random() - 0.5) * 0.2, // roll rate (tumbling)
                z: (Math.random() - 0.5) * 0.08  // yaw rate (main axis spin)
            };
            // also mirror z into scalar for compatibility
            this.angularVelocity = this.omega.z;
        }
        get left() {
            return this.pos.x - this.radius;
        }
        get right() {
            return this.pos.x + this.radius;
        }
        get top() {
            return this.pos.y - this.radius;
        }
        get bottom() {
            return this.pos.y + this.radius;
        }
        simulate() {
            this.pos.add(this.vel, dT);

            const maxSpeed = 0.5;
            if (this.vel.length() > maxSpeed) {
                this.vel.x *= maxSpeed / this.vel.length();
                this.vel.y *= maxSpeed / this.vel.length();
            }

            // angular control constants (declared early so non-globe code can use them)
            const omegaDamping = 1.0; // no automatic damping: tumbling persists until another force acts
            // maximum angular rate (radians/frame) allowed per-axis to avoid runaway
            const maxOmega = 0.5;
            // maximum spin about axis (scalar spin rate applied to spinAngle/poleSpinAngle)
            const maxSpin = 0.01;

            // Integrate 3D omega into visible orientation for globe roids
            // and keep scalar angularVelocity roughly in sync with omega.z
            // pole spin continues to include poleSpinSpeed
            // include yaw rate (omega.z) in poleSpinAngle so visible longitude rotation follows yaw
            // clamp the resulting axial spin so roids don't spin faster than maxSpin
            let spinInc = 60 * dT * (this.poleSpinSpeed + this.omega.z);
            spinInc = Math.max(-maxSpin, Math.min(maxSpin, spinInc));
            this.poleSpinAngle += spinInc;
            if (this.poleSpinAngle > 2 * Math.PI) this.poleSpinAngle -= 2 * Math.PI;
            if (this.poleSpinAngle < -2 * Math.PI) this.poleSpinAngle += 2 * Math.PI;
            // Integrate angular velocity vector (this.omega) into quaternion orientation using small-angle quaternion
            // delta_q ~ [1, 0.5*omega*dt]
            const half_dt = 0.5 * dT;
            const dq = {
                w: 1.0,
                x: this.omega.x * half_dt,
                y: this.omega.y * half_dt,
                z: this.omega.z * half_dt
            };
            // new orientation = orientation * dq  (apply small-body-frame rotation)
            this.orientation = quatMultiply(this.orientation, dq);
            quatNormalize(this.orientation);
            // update Euler cache from quaternion for any code that still reads yaw/pitch/roll
            // conversion: yaw (Z), pitch (X), roll (Y) inverse of quatFromEuler
            const qw = this.orientation.w, qx = this.orientation.x, qy = this.orientation.y, qz = this.orientation.z;
            // yaw (Z)
            this.yaw = Math.atan2(2*(qw*qz + qx*qy), 1 - 2*(qy*qy + qz*qz));
            // pitch (X)
            const sinp = 2*(qw*qx - qy*qz);
            this.pitch = Math.abs(sinp) >= 1 ? Math.sign(sinp) * Math.PI/2 : Math.asin(sinp);
            // roll (Y)
            this.roll = Math.atan2(2*(qw*qy + qz*qx), 1 - 2*(qx*qx + qy*qy));
            // apply damping (may be 1.0 for no damping) and then clamp to max allowed rates
            this.omega.x *= omegaDamping;
            this.omega.y *= omegaDamping;
            this.omega.z *= omegaDamping;
            // clamp per-axis angular rates
            this.omega.x = Math.max(-maxOmega, Math.min(maxOmega, this.omega.x));
            this.omega.y = Math.max(-maxOmega, Math.min(maxOmega, this.omega.y));
            this.omega.z = Math.max(-maxOmega, Math.min(maxOmega, this.omega.z));
            // keep scalar angularVelocity in sync with clamped z
            this.angularVelocity = this.omega.z;
            // clamp scalar axial spin used for visual spin/pole spin
            this.angularVelocity = Math.max(-maxSpin, Math.min(maxSpin, this.angularVelocity));
         
            if (this.spinAngle > 2 * Math.PI) {
                this.spinAngle -= 2 * Math.PI;
            }
        }
        draw() {
            drawGlobeRoid(
                this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale, 
                this.originalRadius * cScale, this.hue, this.saturation, this.lightness, 
                this.poleSpinAngle, this.orientation);

            //  HIGHLIGHT SHADING ----------
            drawCircle(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale);
            var sphereGradient = c.createRadialGradient(
                (this.pos.x - (0.3 * this.radius)) * cScale, 
                (this.pos.y - (0.5 * this.radius)) * cScale, 
                0, 
                (this.pos.x - (0.3 * this.radius)) * cScale, 
                (this.pos.y - (0.5 * this.radius)) * cScale, 
                2 * this.radius * cScale);
            var highlight = `hsla(${this.hue + 60}, 50%, 50%, 0.6)`;
            var shadow = `hsla(0, 0%, 0%, 0)`;
            sphereGradient.addColorStop(0.0, highlight);
            sphereGradient.addColorStop(1.0, shadow);
            c.fillStyle = sphereGradient;
            c.fill();

            //  OVERALL BUBBLE SHADING  ----------
            var sphereGradient = c.createRadialGradient(
                    this.pos.x * cScale, 
                    this.pos.y * cScale, 
                    0, 
                    this.pos.x * cScale, 
                    this.pos.y * cScale, 
                    this.radius * cScale);
            var highlight = `hsla(${this.hue + 60}, 50%, 40%, 0.5)`;
            var midtone = `hsla(${this.hue + 60}, 50%, 20%, 0.4)`;
            var shadow = `hsla(${this.hue + 60}, 50%, 10%, 0.2)`;
            sphereGradient.addColorStop(0.0, shadow);
            sphereGradient.addColorStop(0.8, midtone);
            sphereGradient.addColorStop(1.0, highlight);
            c.fillStyle = sphereGradient;
            c.fill();
        }
    }

    //  DRAW GLOBE ROIDS  --------------------
    function drawGlobeRoid(cx, cy, radius, originalRadius, hue, saturation, lightness, spinAngle = 0, orientation = {w:1,x:0,y:0,z:0}) {
        // Parametric globe-style globe (latitude & longitude) with front-hemisphere clipping
        c.save();
        
        // line width scales with roid size (radius is in pixels already)
        c.lineWidth = 0.02 * radius;
        c.strokeStyle = `hsl(${hue}, ${Math.round(saturation)}%, ${Math.round(lightness)}%)`;
        c.lineCap = 'round';

        // Use orthographic projection with equal X/Y scale so circles remain circular
        const verticalSquash = 1.0;
        // Helper: project 3D point (x,y,z) to screen (no non-uniform squash)
        function project(x, y, z) {
            const sx = cx + x;
            const sy = cy - y; // invert Y to canvas coords
            return { x: sx, y: sy, z: z };
        }

        // rotate by yaw (around Z), pitch (around X), roll (around Y)
        const spin = spinAngle || 0;

        function rotatePoint(x, y, z) {
            return quatRotateVec(orientation, x, y, z);
        }

        // Latitudes: Draw back-facing first (faint), then front-facing (bright)  ----------
        const latStep = 20; 
        const maxLat = 60;  
        const latDegrees = [0];
        for (let d = latStep; d <= maxLat; d += latStep) {
            latDegrees.push(d, -d);
        }
        
        // BACK HEMISPHERE - faint lines
        c.save();
        c.lineWidth = 0.015 * radius;
        c.strokeStyle = `hsla(${hue}, ${Math.round(saturation)}%, ${Math.round(Math.max(20, lightness - 10))}%, 0.6)`;
        for (let li = 0; li < latDegrees.length; li++) {
            const phi = latDegrees[li] * Math.PI / 180;
            const rLat = radius * Math.cos(phi);
            const z0 = radius * Math.sin(phi);
            const steps = 96;
            c.beginPath();
            let hasBack = false;
            for (let s = 0; s <= steps; s++) {
                const theta = (s / steps) * 2 * Math.PI + spin;
                const x0 = rLat * Math.cos(theta);
                const y0 = rLat * Math.sin(theta);
                const rot = rotatePoint(x0, y0, z0);
                const p = project(rot.x, rot.y, rot.z);
                
                // Only draw if facing away (z < 0)
                if (rot.z < 0) {
                    if (!hasBack) {
                        c.moveTo(p.x, p.y);
                        hasBack = true;
                    } else {
                        c.lineTo(p.x, p.y);
                    }
                } else if (hasBack) {
                    // Start new path segment when transitioning front/back
                    c.stroke();
                    c.beginPath();
                    hasBack = false;
                }
            }
            if (hasBack) c.stroke();
        }
        c.restore();
        
        // FRONT HEMISPHERE - bright lines
        c.save();
        c.lineWidth = 0.02 * radius;
        c.strokeStyle = `hsl(${hue}, ${Math.round(saturation)}%, ${Math.round(lightness)}%)`;
        for (let li = 0; li < latDegrees.length; li++) {
            const phi = latDegrees[li] * Math.PI / 180;
            const rLat = radius * Math.cos(phi);
            const z0 = radius * Math.sin(phi);
            const steps = 96;
            c.beginPath();
            let hasFront = false;
            for (let s = 0; s <= steps; s++) {
                const theta = (s / steps) * 2 * Math.PI + spin;
                const x0 = rLat * Math.cos(theta);
                const y0 = rLat * Math.sin(theta);
                const rot = rotatePoint(x0, y0, z0);
                const p = project(rot.x, rot.y, rot.z);
                
                // Only draw if facing forward (z >= 0)
                if (rot.z >= 0) {
                    if (!hasFront) {
                        c.moveTo(p.x, p.y);
                        hasFront = true;
                    } else {
                        c.lineTo(p.x, p.y);
                    }
                } else if (hasFront) {
                    c.stroke();
                    c.beginPath();
                    hasFront = false;
                }
            }
            if (hasFront) c.stroke();
        }
        c.restore();

        // Longitudes: Draw back-facing first (faint), then front-facing (bright)  ----------
        const numLong = 12;
        const phiSteps = 80;
        
        // BACK HEMISPHERE - faint lines
        c.save();
        c.lineWidth = 0.015 * radius;
        c.strokeStyle = `hsla(${hue}, ${Math.round(saturation)}%, ${Math.round(Math.max(20, lightness - 10))}%, 0.6)`;
        for (let k = 0; k < numLong; k++) {
            const lambda = (k / numLong) * 2 * Math.PI + spin;
            c.beginPath();
            let hasBack = false;
            for (let pi = 0; pi <= phiSteps; pi++) {
                const phi = (-0.5 + pi / phiSteps) * Math.PI;
                const x0 = radius * Math.cos(phi) * Math.cos(lambda);
                const y0 = radius * Math.cos(phi) * Math.sin(lambda);
                const z0 = radius * Math.sin(phi);
                const rot = rotatePoint(x0, y0, z0);
                const p = project(rot.x, rot.y, rot.z);
                
                // Only draw if facing away (z < 0)
                if (rot.z < 0) {
                    if (!hasBack) {
                        c.moveTo(p.x, p.y);
                        hasBack = true;
                    } else {
                        c.lineTo(p.x, p.y);
                    }
                } else if (hasBack) {
                    c.stroke();
                    c.beginPath();
                    hasBack = false;
                }
            }
            if (hasBack) c.stroke();
        }
        c.restore();
        
        // FRONT HEMISPHERE - bright lines
        c.save();
        c.lineWidth = 0.02 * radius;
        c.strokeStyle = `hsl(${hue}, ${Math.round(saturation)}%, ${Math.round(lightness)}%)`;
        for (let k = 0; k < numLong; k++) {
            const lambda = (k / numLong) * 2 * Math.PI + spin;
            c.beginPath();
            let hasFront = false;
            for (let pi = 0; pi <= phiSteps; pi++) {
                const phi = (-0.5 + pi / phiSteps) * Math.PI;
                const x0 = radius * Math.cos(phi) * Math.cos(lambda);
                const y0 = radius * Math.cos(phi) * Math.sin(lambda);
                const z0 = radius * Math.sin(phi);
                const rot = rotatePoint(x0, y0, z0);
                const p = project(rot.x, rot.y, rot.z);
                
                // Only draw if facing forward (z >= 0)
                if (rot.z >= 0) {
                    if (!hasFront) {
                        c.moveTo(p.x, p.y);
                        hasFront = true;
                    } else {
                        c.lineTo(p.x, p.y);
                    }
                } else if (hasFront) {
                    c.stroke();
                    c.beginPath();
                    hasFront = false;
                }
            }
            if (hasFront) c.stroke();
        }
        c.restore();

        // Draw outer circle mask to hide arc ends at the edge
        c.save();
        c.lineWidth = 0.03 * radius;
        c.strokeStyle = `hsl(${hue}, ${Math.round(saturation)}%, ${Math.round(lightness)}%)`;
        c.beginPath();
        c.arc(cx, cy, radius, 0, 2 * Math.PI);
        c.stroke();
        c.restore();

        /*// Apply 3D shading overlay - radial gradient lit from upper left
        c.save();
        const lightOffsetX = -radius * 0.35;
        const lightOffsetY = -radius * 0.55;
        const gradient = c.createRadialGradient(
            cx + lightOffsetX, cy + lightOffsetY, radius * 0.1,
            cx, cy, radius
        );
        // Use the sphere's own color for shading (lighter on top-left, darker on bottom-right)
        const brightL = Math.min(95, lightness + 35);
        const darkL = Math.max(10, lightness - 35);
        gradient.addColorStop(0, `hsla(${hue}, ${Math.round(saturation)}%, ${brightL}%, 0.4)`); // Bright highlight
        gradient.addColorStop(0.4, `hsla(${hue}, ${Math.round(saturation)}%, ${lightness}%, 0)`); // Fade to transparent
        gradient.addColorStop(0.7, `hsla(${hue}, ${Math.round(saturation)}%, ${lightness}%, 0)`); // Transparent midtone
        gradient.addColorStop(1, `hsla(${hue}, ${Math.round(saturation)}%, ${darkL}%, 0.5)`); // Dark shadow at edge
        
        c.fillStyle = gradient;
        c.beginPath();
        c.arc(cx, cy, radius, 0, 2 * Math.PI);
        c.fill();
        c.restore();*/
    }

    //  SPAWN ROIDS  ------------------------------------------------------------
    function spawnRoid() {
        var radius = 0.4;
        var pos = new Vector2(simWidth - 0.8 * radius, 1.5 * radius);
        var vel = new Vector2(0, 0);
        //var hue = Math.floor(Math.random() * 360);
        var hue = 70;
        var saturation = 60 + 30 * Math.random(); // 60-90% for vibrant colors
        var lightness = 45 + 15 * Math.random(); // 45-60% to avoid white/pale colors
        let seed = Math.floor(Math.random() * 0xFFFFFFFF);
        let randomNo = Math.random();
        let yaw = Math.random() * 2 * Math.PI;
        let pitch = Math.random() * 2 * Math.PI; // -pi/2 .. +pi/2
        let roll = Math.random() * 2 * Math.PI;
                
        Roid.push(new ROID(pos, vel, radius, hue, saturation, lightness, randomNo, yaw, pitch, roll));   
    }

    //  NODE CLASS  -------------------
    class NODE { 
        constructor(pos, angle, color, speed, direction) {
            this.pos = pos.clone();
            this.angle = angle;
            this.color = color;
            this.speed = speed;
            this.direction = direction;
            this.trail = [];
            this.maxTrailLength = 40;
            this.trailMinDistance = 0.001;
        }
        simulate() {
            this.angle += .05 * this.direction * this.speed;
            if (this.direction > 0 && this.angle > 2 * Math.PI) {
                this.angle -= 2 * Math.PI;
            }
            if (this.direction < 0 && this.angle < 0) {
                this.angle += 2 * Math.PI;
            }

            var lobeId = 5;
            f += 0.000001 * this.speed * this.direction;
            
            // Pre-calculate trig values to avoid redundant calculations
            const angleDirection = this.angle * this.direction;
            const fPlusAngle = f + this.angle;
            const lobeFPlusAngle = lobeId * fPlusAngle;
            
            const cosAngleDirection = Math.cos(angleDirection);
            const sinAngle = Math.sin(this.angle);
            const cosLobeFPlusAngle = Math.cos(lobeFPlusAngle);
            const cosFPlusAngle = Math.cos(fPlusAngle);
            const sinFPlusAngle = Math.sin(fPlusAngle);
            
            const lobeEffect = 0.008 * cosLobeFPlusAngle;
            
            this.pos.x += 0.002 * cosAngleDirection + lobeEffect * cosFPlusAngle;
            this.pos.y += 0.001 * sinAngle + lobeEffect * sinFPlusAngle;
            
            // Add current position to trail
            this.addToTrail();
        }
        addToTrail() {
            // Only add if moved enough distance from last trail point
            if (this.trail.length === 0) {
                this.trail.push(this.pos.clone());
            } else {
                const lastPos = this.trail[this.trail.length - 1];
                const dx = this.pos.x - lastPos.x;
                const dy = this.pos.y - lastPos.y;
                const distSquared = dx * dx + dy * dy;
                
                if (distSquared > this.trailMinDistance * this.trailMinDistance) {
                    this.trail.push(this.pos.clone());
                    
                    // Keep trail at max length
                    if (this.trail.length > this.maxTrailLength) {
                        this.trail.shift();
                    }
                }
            }
        }
    }

    //  GENERATE NODE ARRAY ------------------
    function spawnNodes() {
        // right side
        for (i = 0; i < 20; i++) {
            var radius = 0.1 * simHeight + 0.5 * simHeight * Math.random();
            var angle = 2 * Math.PI * Math.random();
            var color = `hsl(${Math.random() * 360}, 30%, 50%)`;
            var speed = 0.4 * Math.random();
            if (Math.random() < 0.50) {
                var direction = 1;
            } else {
                var direction = -1;
            }
            PrimaryNodes.push(new NODE(
                new Vector2(
                    0.7 * simWidth + radius * Math.cos(angle), 
                    0.5 * simHeight + radius * Math.sin(angle)), 
                2 * Math.PI * Math.random(),
                color,
                speed,
                direction));
        }

        //  left side
        for (i = 0; i < 20; i++) {
            var radius = 0.1 * simHeight + 0.5 * simHeight * Math.random();
            var angle = 2 * Math.PI * Math.random();
            var color = `hsl(${Math.random() * 360}, 30%, 50%)`;
            var speed = .1 + .4 * Math.random();
            if (Math.random() < 0.50) {
                direction = 1;
            } else {
                direction = -1;
            }
            SecondaryNodes.push(new NODE(
                new Vector2(
                    0.1 * simWidth + radius * Math.cos(angle), 
                    0.5 * simHeight + radius * Math.sin(angle)), 
                2 * Math.PI * Math.random(),
                color,
                speed,
                direction));
        }
    }

    //  SIMULATION --------------------------------------------------------------------------
	function simulate() {
        for (n = 0; n < PrimaryNodes.length; n++) {
            PrimaryNodes[n].simulate();
            SecondaryNodes[n].simulate();
        }

        for (var r = 0; r < Roid.length; r++) {
            if (Roid[r] != null) {
                var roid = Roid[r]
                roid.simulate();
            }
        }
    }
    
    //  DRAW EVERYTHING ==============================================================
	function drawEverything() {
        c.fillStyle = 'hsl(0, 0%, 0%)';
        c.fillRect(0, 0, canvas.width, canvas.height);

        /*
        // Draw connections between primary and secondary nodes
        for (i = 0; i < PrimaryNodes.length; i++) {
            node1 = PrimaryNodes[i];
            for (j = 0; j < SecondaryNodes.length; j++) {
                node2 = SecondaryNodes[i];
                c.moveTo(node1.pos.x * cScale, node1.pos.y * cScale);
                c.lineTo(node2.pos.x * cScale, node2.pos.y * cScale);
                if (measureDistAndShade(node1, node2) * 20 < 60) {
                    var lineLite = measureDistAndShade(node1, node2) * 20
                } else {
                    var lineLite = 60;
                }
                c.strokeStyle = `hsla(0, 70%, 20%, 10%)`;
                c.lineWidth = Math.min(2 * measureDistAndShade(node1, node2), 2);
                
            }
            c.stroke();
        }
        */

        // Draw connections between secondary nodes (left side)
        for (i = 0; i < SecondaryNodes.length; i++) {
            node1 = SecondaryNodes[i];
            for (j = i + 1; j < PrimaryNodes.length; j++) {
                node2 = SecondaryNodes[j];
                c.beginPath();
                c.moveTo(node1.pos.x * cScale, node1.pos.y * cScale);
                c.lineTo(node2.pos.x * cScale, node2.pos.y * cScale);
                if (measureDistAndShade(node1, node2) * 20 < 60) {
                    var lineLite = measureDistAndShade(node1, node2) * 20
                } else {
                    var lineLite = 60;
                }
                c.strokeStyle = `hsla(130, 50%, ${lineLite}%, ${lineLite + 20}%)`;
                c.lineWidth = Math.min(2 * measureDistAndShade(node1, node2), 4);
                c.stroke();
            }   
        }

        // Draw connections between primary nodes (right side)
        for (i = 0; i < PrimaryNodes.length; i++) {
            node1 = PrimaryNodes[i];
            for (j = i + 1; j < PrimaryNodes.length; j++) {
                node2 = PrimaryNodes[j];
                c.beginPath();
                c.moveTo(node1.pos.x * cScale, node1.pos.y * cScale);
                c.lineTo(node2.pos.x * cScale, node2.pos.y * cScale);
                if (measureDistAndShade(node1, node2) * 20 < 60) {
                    var lineLite = measureDistAndShade(node1, node2) * 20
                } else {
                    var lineLite = 60;
                }
                c.strokeStyle = `hsla(${180 + 3 * lineLite}, 50%, ${lineLite}%, ${lineLite + 20}%)`;
                c.lineWidth = Math.min(4 * measureDistAndShade(node1, node2), 4);
                c.stroke();
            }  
        }

        // Draw trails for primary nodes
        for (i = 0; i < PrimaryNodes.length; i++) {
            const node = PrimaryNodes[i];
            if (node.trail.length > 1) {
                c.lineCap = 'round';
                c.lineJoin = 'round';
                
                for (let j = 1; j < node.trail.length; j++) {
                    const alpha = j / node.trail.length;
                    c.strokeStyle = `hsla(210, 70%, 60%, ${alpha * 0.1})`;
                    c.lineWidth = 2 + 25 * alpha;
                    
                    c.beginPath();
                    c.moveTo(node.trail[j - 1].x * cScale, node.trail[j - 1].y * cScale);
                    c.lineTo(node.trail[j].x * cScale, node.trail[j].y * cScale);
                    c.stroke();
                }
            }
        }
            
        // Draw trails for secondary nodes
        for (i = 0; i < SecondaryNodes.length; i++) {
            const node = SecondaryNodes[i];
            if (node.trail.length > 1) {
                c.lineCap = 'round';
                c.lineJoin = 'round';
                for (let j = 1; j < node.trail.length; j++) {
                    const alpha = j / node.trail.length;
                    c.strokeStyle = `hsla(320, 70%, 50%, ${alpha * 0.15})`;
                    c.lineWidth = 2 + 25 * alpha;
                    
                    c.beginPath();
                    c.moveTo(node.trail[j - 1].x * cScale, node.trail[j - 1].y * cScale);
                    c.lineTo(node.trail[j].x * cScale, node.trail[j].y * cScale);
                    c.stroke();
                }
            }
        }
            
        // Draw primary nodes with spherical shading
        for (i = 0; i < PrimaryNodes.length; i++) {
            node1 = PrimaryNodes[i];
            const x = node1.pos.x * cScale;
            const y = node1.pos.y * cScale;
            const radius = 0.03 * cScale;
            
            // Create radial gradient for 3D sphere effect
            const gradient = c.createRadialGradient(
                x - radius * 0.3, y - radius * 0.3, radius * 0.1,
                x, y, radius
            );
            gradient.addColorStop(0, 'hsl(210, 70%, 85%)');
            gradient.addColorStop(0.3, 'hsl(210, 70%, 60%)');
            gradient.addColorStop(0.7, 'hsl(210, 70%, 40%)');
            gradient.addColorStop(1, 'hsl(210, 70%, 20%)');
            
            drawCircle(x, y, radius);
            c.fillStyle = gradient;
            c.fill();   
        }
            
        // Draw secondary nodes with spherical shading
        for (i = 0; i < SecondaryNodes.length; i++) {
            node1 = SecondaryNodes[i];
            const x = node1.pos.x * cScale;
            const y = node1.pos.y * cScale;
            const radius = 0.03 * cScale;
            
            // Create radial gradient for 3D sphere effect
            const gradient = c.createRadialGradient(
                x - radius * 0.3, y - radius * 0.3, radius * 0.1,
                x, y, radius
            );
            gradient.addColorStop(0, 'hsl(320, 70%, 85%)');
            gradient.addColorStop(0.3, 'hsl(320, 70%, 60%)');
            gradient.addColorStop(0.7, 'hsl(320, 70%, 40%)');
            gradient.addColorStop(1, 'hsl(320, 70%, 20%)');
            
            drawCircle(x, y, radius);
            c.fillStyle = gradient;
            c.fill();   
        }

        for (var r = 0; r < Roid.length; r++) {
            if (Roid[r] != null) {
                var roid = Roid[r]
                roid.draw();
            }
        }
        
        // Draw side fades
        const sideFade = c.createLinearGradient(0, 0, canvas.width, 0);
        sideFade.addColorStop(0.00, 'hsla(0, 0%, 5%, 1)');
        sideFade.addColorStop(0.30, 'hsla(0, 0%, 3%, 1.0)');
        sideFade.addColorStop(0.50, 'hsla(0, 0%, 0%, 0)');
        sideFade.addColorStop(0.90, 'hsla(0, 0%, 0%, 0)');
        sideFade.addColorStop(0.97, 'hsla(0, 0%, 0%, 0.8)');
        sideFade.addColorStop(1, 'hsla(0, 0%, 0%, 0.9)');
        c.fillStyle = sideFade;
        c.fillRect(0, 0, canvas.width, canvas.height);
        c.fillStyle = 'hsla(0, 0%, 0%, 0.2)';
        c.fillRect(0, 0, canvas.width, canvas.height); 
	}

    //  MAIN SEQUENCE ----------------------------------------------------------------------------
	setupScene();
    
    function update() {
        simulate();
        
		drawEverything();
		requestAnimationFrame(update);
	}
    
	update();

</script> 

</body>
</html>
