<!-- Frank Maiello -->

<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=500, initial-scale=1.0">
<!-- <meta name="viewport" content="width=device-width, initial-scale=1.0"> -->
<style>

    body {
        background-color: black;
        animation: pageLoadFadeIn 1.5s ease-in forwards;
    }

    @keyframes pageLoadFadeIn {
        from {
            opacity: 0;
        }
        to {
            opacity: 1;
        }
    }

    .title {font-family: verdana; 
        font-size: 38px;
        font-weight: bold;
        color: hsl(30, 60%, 50%);
        text-align: left;
        text-shadow: 5px 7px 10px hsl(0, 0%, 0%);
        margin-left: 0px;
        margin-right: 0px;
        padding-left: 10px;
        padding-right: 5px;
        height: 60px;
        line-height: 60px;
    }

    .title-word {
        display: inline-block;
        margin-right: 8px;
        transition: all 0.1s ease-out;
        transform-origin: center center;
    }

    .title-word.pulse {
        font-size: 44px;
        text-shadow: 0px 0px 25px hsl(30, 100%, 60%), 5px 7px 10px hsl(0, 0%, 0%);
        color: hsl(30, 80%, 60%);
    }

    .appTitle {font-family: monospace; 
        font-size: 26px;
        font-weight: bold;
        color : #C93226;
        text-align: left;
        text-shadow: 5px 7px 10px hsl(0, 0%, 0%);
        margin: 0;
        padding: 0;
        font-weight: bold;
    }

    .description {font-family: monospace; 
        font-size: 20px;
        color: hsl(0, 0%, 89%);
        text-align: left;
        text-shadow: 5px 7px 10px hsl(0, 0%, 0%);
        margin: 0;
        padding: 0;
    }

    h4 {
        color: hsl(0, 90%, 59%);
    }

    h3 {font-family: verdana; 
        font-size: 2px;
        color: hsl(0, 0%, 89%);
        text-align: left;
        text-shadow: 5px 7px 10px hsl(0, 0%, 0%);
        margin-left: 0px;
        margin-right: 0px;
        padding-left: 10px;
        padding-right: 5px;
    }

    .verbiage1 {font-family: verdana; 
        font-size: 14px;
        color: hsl(0, 0%, 89%);
        text-align: left;
        text-shadow: 5px 7px 10px hsl(0, 0%, 0%);
        margin-left: 5px;
        margin-right: 0px;
        padding-left: 10px;
        padding-right: 5px;
    }

    .verbiage1b {font-family: verdana; 
        font-style: italic;
        font-size: 14px;
        text-align: left;
        text-shadow: 5px 7px 10px hsl(0, 0%, 0%);
        margin-left: 5px;
        margin-right: 0px;
        padding-left: 10px;
        padding-right: 5px;
    }

    .verbiage1b a {
        color: hsl(37, 100%, 58%);
        text-decoration: none;
    }
    
    .verbiage1b a:hover {
        color: #C93226;
        text-decoration: underline;
    }

    .verbiage2a {font-family: verdana; 
        font-size: 13px;
        font-style: italic;
        color: hsl(0, 0%, 89%);
        text-align: left;
        text-shadow: 5px 7px 10px hsl(0, 0%, 0%);
        margin-left: 5px;
        margin-right: 0px;
        padding-left: 10px;
        padding-right: 5px;
    }

    .title-blocker {
        position: fixed;
        top: -50px;
        left: 0;
        width: 600px;
        height: 100px;
        background: rgba(0, 0, 0, 0.85);
        z-index: 99;
        pointer-events: none;
        filter: blur(15px);
    }

    .fixed-header {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 100;
        padding: 10px;
    }

    .fixed-header > * {
        position: relative;
        z-index: 1;
    }

    @keyframes fadeIn {
        from {
            opacity: 0;
            background-color: rgba(0, 0, 0, 1);
        }
        to {
            opacity: 1;
            background-color: rgba(0, 0, 0, 0);
        }
    }

    .scrollable-content {
        display: none; /* Hide the old scrollable content */
    }
    
    #fan-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100vh;
        pointer-events: none;
        z-index: 50;
    }
    
    .fan-blade {
        position: absolute;
        right: 0;
        left: 30px;
        top: 30%;
        transform-origin: 80%;
        height: 400px;
        margin-top: -200px;
        pointer-events: auto;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        background: none;
        border: none;
        padding: 40px 60px 40px 40px;
        overflow: visible;
        display: flex;
        align-items: center;
    }
    
    .fan-blade::before {
        content: '';
        position: absolute;
        left: 0;
        top: 50%;
        transform: translateY(-50%);
        width: 750px;
        height: 700px;
        background: linear-gradient(135deg, 
            hsla(24, 15%, 30%, 1.0) 0%,
            hsla(24, 15%, 20%, 0.9) 50%,
            hsla(24, 15%, 5%, 0.7) 100%);
            
        clip-path: url(#rounded-trapezoid);
        z-index: -1;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .fan-blade::after {
        content: '';
        position: absolute;
        left: 0;
        top: 50%;
        transform: translateY(-50%);
        width: 750px;
        height: 700px;
        z-index: 0;
        pointer-events: none;
    }
    
    .fan-blade:hover::before {
        background: linear-gradient(135deg, 
            hsla(24, 15%, 30%, 1.0) 0%,
            hsla(24, 15%, 20%, 0.9) 50%,
            hsla(24, 15%, 5%, 0.7) 100%); 
    }
    
    .blade-content {
        display: flex;
        align-items: center;
        gap: 30px;
        opacity: 1;
        transition: opacity 0.3s;
        width: 100%;
    }
    
    .blade-image {
        flex-shrink: 0;
        width: 280px;
        height: auto;
    }
    
    .blade-image img {
        width: 100%;
        height: auto;
        display: block;
        box-shadow: 5px 7px 15px rgba(0, 0, 0, 0.8);
    }
    
    .blade-text {
        flex: 1;
        min-width: 0;
    }
    
    .blade-buttons {
        margin-top: 15px;
    }
    
    .verbiage2 {font-family: verdana; 
        font-size: 13px;
        font-style: italic;
        color: hsl(0, 0%, 89%);
        text-align: left;
        text-shadow: 5px 7px 10px hsl(0, 0%, 0%);
        margin-left: 0px;
        margin-right: 0px;
        padding-left: 10px;
        padding-right: 5px;
    }

    table#pubTable {
        text-align: left;
        width: 100%;
        font-size: 18px;
        vertical-align: bottom;
    }
    td {
    vertical-align: top;
    white-space: nowrap;
    padding : 10px 20px;
    }

    thead tr th:first-child,
    tbody tr td:first-child {
    width: 400px;
    min-width: 400px;
    max-width: 400px;
    }

    .paperButton:hover {
    background-color: #777777; 
    color: white;
    }

    .button {
    font-family: verdana; 
    background-color: #555555;
    border: none;
    color: white;
    padding: 5px 5px;
    margin: 2px 0px 2px 0px;  
    border-radius: 5px;
    
    text-align: center;
    text-decoration: none;
    display: inline-block;
    font-size: 14px;
    box-shadow: 5px 7px 10px hsl(0, 0%, 0%);
    }
    
    .paperImage {
    width: 400px;
    box-shadow: 5px 7px 10px hsl(0, 0%, 0%);
    }
</style>

</head>
<body style="background-color: #000000;">

<svg style="position: absolute; width: 0; height: 0;">
    <defs>
        <clipPath id="rounded-trapezoid" clipPathUnits="objectBoundingBox">
            <path d="M 0.053,0.3 Q 0,0.3 0,0.34 L 0,0.74 Q 0,0.78 0.053,0.78 L 0.947,0.62 Q 1,0.62 1,0.58 L 1,0.42 Q 1,0.38 0.947,0.38 Z"/>
        </clipPath>
    </defs>
</svg>

<canvas id="myCanvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 2;"></canvas>

<div class="title-blocker"></div>

<title>FM Home</title>

<div class="fixed-header">
<div class="title">
    <span class="title-word" id="word1">I</span>
    <span class="title-word" id="word2">Like</span>
    <span class="title-word" id="word3">to</span>
    <span class="title-word" id="word4">Move it</span>
    <span class="title-word" id="word5">Move it</span>
</div>

<!--<div class = "verbiage1"><br>A small collection of realtime physics and animation exercises with JavaScript</div>-->
<div class = "verbiage1b"><a href="mailto:maiello.frank@gmail.com">maiello.frank@gmail.com</a></div>
<div class = "verbiage2a"><br>Please use Chrome or Edge for best performance<br><br></div>
</div>

<div class="scrollable-content">
<table id = "pubTable">
<!-- Old content kept for reference but hidden -->
</table>
</div>

<div id="fan-container">
    <div class="fan-blade" data-blade="0">
        <div class="blade-content">
            <div class="blade-image">
                <a href="https://frank-maiello.github.io/slosh.html" target="_blank">
                    <img src="https://frank-maiello.github.io/screen_slosh.png" alt="Slosh">
                </a>
            </div>
            <div class="blade-text">
                <div class="appTitle">SL0SH</div>
                <h3><br></h3>
                <div class="description">Particle Physics Sandbox</div>
                <div class="verbiage2"><br>Fluid-like "sloshy" particle simulation with</div>
                <div class="verbiage2">interactive toys and a menu-driven user interface.</div>
                <div class="verbiage2">Created with the help of Claude. Go Claude!</div>
                <div class="blade-buttons">
                    <br>
                    <a href="https://github.com/frank-maiello/frank-maiello.github.io/blob/main/slosh.html" target="_blank" class="button">Code</a>
                </div>
            </div>
        </div>
    </div>
    
    <div class="fan-blade" data-blade="1">
        <div class="blade-content">
            <div class="blade-image">
                <a href="https://frank-maiello.github.io/roids.html" target="_blank">
                    <img src="https://frank-maiello.github.io/screen_roids.png" alt="Roids">
                </a>
            </div>
            <div class="blade-text">
                <div class="appTitle">R0IDS</div>
                <h3><br></h3>
                <div class="description">A Take on Asteroids</div>
                <div class="verbiage2"><br>First there was Space Invaders, then came Asteroids.</div>
                <div class="verbiage2">Unique obstacles, cranky enemy, weapon power-ups,</div>
                <div class="verbiage2">floaty physics, increasing difficulty... and cheats.</div>
                <div class="blade-buttons">
                    <br>
                    <a href="https://github.com/frank-maiello/frank-maiello.github.io/blob/main/roids.html" target="_blank" class="button">Code</a>
                </div>
            </div>
        </div>
    </div>
    
    <div class="fan-blade" data-blade="2">
        <div class="blade-content">
            <div class="blade-image">
                <a href="https://frank-maiello.github.io/droplets.html" target="_blank">
                    <img src="https://frank-maiello.github.io/screen_droplets.png" alt="Droplets">
                </a>
            </div>
            <div class="blade-text">
                <div class="appTitle">DR0PLETS</div>
                <h3><br></h3>
                <div class="description">Abstract Algorithmic Line 'Art'</div>
                <div class="verbiage2"><br>Repetetive line-drawing the slow way, using</div>
                <div class="verbiage2">trigonometry and polar coordinates.</div>
                <div class="verbiage2"><br>Click the Auto button for instant gratification.</div>
                <div class="blade-buttons">
                    <br>
                    <a href="https://github.com/frank-maiello/frank-maiello.github.io/blob/6404a30fcd3e544bf28b16d2a8adea4be639b728/droplets.html" target="_blank" class="button">Code</a>
                </div>
            </div>
        </div>
    </div>
    
    <div class="fan-blade" data-blade="3">
        <div class="blade-content">
            <div class="blade-image">
                <a href="https://frank-maiello.github.io/plinkolab.html" target="_blank">
                    <img src="https://frank-maiello.github.io/screen_plinkolab.png" alt="Plinko Lab">
                </a>
            </div>
            <div class="blade-text">
                <div class="appTitle">PLINK0 LAB</div>
                <h3><br></h3>
                <div class="description">Intro to Particle Simulation</div>
                <div class="verbiage2"><br>If you dare. My first undertaking. Consult a child</div>
                <div class="verbiage2">to best navigate the Playskool user interface.</div>
                <div class="blade-buttons">
                    <br>
                    <a href="https://github.com/frank-maiello/frank-maiello.github.io/blob/6404a30fcd3e544bf28b16d2a8adea4be639b728/plinkolab.html" target="_blank" class="button">Code</a>
                </div>
            </div>
        </div>
    </div>
</div>

</body>
    
<script>

    //  CANVAS SETUP AND SCALING --------------------------------------------------------------
    canvas = document.getElementById("myCanvas");
	    c = canvas.getContext("2d");
        canvas.style.cursor = "pointer";
        canvas.style.opacity = "0";
        canvas.style.animation = "fadeIn 1.5s ease-in forwards";
       
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

        simMinWidth = 2.0;
        cScale = Math.min(canvas.width, canvas.height) / simMinWidth;
        simWidth = canvas.width / cScale;
        simHeight = canvas.height / cScale;
        topMargin = 0;
        bottomMargin = 0;
    
    //  FAN MENU ROTATION SYSTEM --------------------------------------------------------------
    let currentBladeIndex = 0;
    const totalBlades = 4;
    const bladeAngleSpacing = -20; // Degrees between blades (negative to open downward)
    let fanDragging = false;
    let startX = 0;
    let startY = 0;
    let lastX = 0;
    let lastY = 0;
    let velocityX = 0;
    let velocityY = 0;
    
    function updateFanRotation() {
        const blades = document.querySelectorAll('.fan-blade');
        
        blades.forEach((blade, index) => {
            const relativeIndex = index - currentBladeIndex;
            const angle = relativeIndex * bladeAngleSpacing;
            
            // Calculate z-index based on angle (more negative = further back)
            const zIndex = 100 - Math.abs(relativeIndex);
            blade.style.zIndex = zIndex;
            
            // Apply rotation and scaling
            if (relativeIndex === 0) {
                // Active blade - front and center
                blade.style.transform = `rotate(${angle}deg) scale(1)`;
                blade.style.opacity = '1';
                blade.style.pointerEvents = 'auto';
            } else {
                // Inactive blades - rotated and slightly scaled down
                const scale = 0.9 - Math.abs(relativeIndex) * 0.05;
                const opacity = Math.max(0.4, 1 - Math.abs(relativeIndex) * 0.2);
                blade.style.transform = `rotate(${angle}deg) scale(${scale})`;
                blade.style.opacity = opacity;
                // Allow pointer events on all blades
                blade.style.pointerEvents = 'auto';
            }
        });
    }
    
    function rotateFan(direction) {
        const oldIndex = currentBladeIndex;
        currentBladeIndex = currentBladeIndex + direction;
        if (currentBladeIndex < 0) {
            currentBladeIndex = totalBlades - 1;
        } else if (currentBladeIndex >= totalBlades) {
            currentBladeIndex = 0;
        }
        updateFanRotation();
    }
    
    // Mouse drag to rotate fan
    document.addEventListener('mousedown', (e) => {
        if (e.target.closest('.fan-blade')) {
            fanDragging = true;
            startX = e.clientX;
            startY = e.clientY;
            lastX = e.clientX;
            lastY = e.clientY;
            velocityX = 0;
            velocityY = 0;
        }
    });
    
    document.addEventListener('mousemove', (e) => {
        if (fanDragging) {
            velocityX = e.clientX - lastX;
            velocityY = e.clientY - lastY;
            lastX = e.clientX;
            lastY = e.clientY;
        }
    });
    
    document.addEventListener('mouseup', () => {
        if (fanDragging) {
            fanDragging = false;
            
            // Determine direction based on velocity - check both X and Y
            const flickThreshold = 5; // Lower threshold = more sensitive
            
            // Map gestures: flick up/right = next, flick down/left = previous
            if (Math.abs(velocityX) > flickThreshold || Math.abs(velocityY) > flickThreshold) {
                if (Math.abs(velocityX) > Math.abs(velocityY)) {
                    // Horizontal flick dominates
                    if (velocityX > 0) {
                        rotateFan(1);
                    } else {
                        rotateFan(-1);
                    }
                } else {
                    // Vertical flick dominates - negative Y is up, positive Y is down
                    if (velocityY < 0) {
                        rotateFan(1);
                    } else {
                        rotateFan(-1);
                    }
                }
            }
        }
    });
    
    // Initialize fan on page load
    document.addEventListener('DOMContentLoaded', () => {
        updateFanRotation();
    });
    
    // Initialize immediately
    updateFanRotation();
    
    function resizeCanvas() {
        canvas = document.getElementById("myCanvas");
	    c = canvas.getContext("2d");
        canvas.style.cursor = "pointer";
       
        // Store old dimensions
        const oldSimWidth = simWidth;
        const oldSimHeight = simHeight;
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;        simMinWidth = 2.0;
        cScale = Math.min(canvas.width, canvas.height) / simMinWidth;
        simWidth = canvas.width / cScale;
        simHeight = canvas.height / cScale;
        
        // Calculate scale factors
        const scaleX = simWidth / oldSimWidth;
        const scaleY = simHeight / oldSimHeight;
        
        // Scale all node positions
        if (typeof PrimaryNodes !== 'undefined') {
            for (let i = 0; i < PrimaryNodes.length; i++) {
                PrimaryNodes[i].pos.x *= scaleX;
                PrimaryNodes[i].pos.y *= scaleY;
                // Scale trail positions
                for (let j = 0; j < PrimaryNodes[i].trail.length; j++) {
                    PrimaryNodes[i].trail[j].x *= scaleX;
                    PrimaryNodes[i].trail[j].y *= scaleY;
                }
            }
        }
        
        if (typeof SecondaryNodes !== 'undefined') {
            for (let i = 0; i < SecondaryNodes.length; i++) {
                SecondaryNodes[i].pos.x *= scaleX;
                SecondaryNodes[i].pos.y *= scaleY;
                // Scale trail positions
                for (let j = 0; j < SecondaryNodes[i].trail.length; j++) {
                    SecondaryNodes[i].trail[j].x *= scaleX;
                    SecondaryNodes[i].trail[j].y *= scaleY;
                }
            }
        }
        
        // Scale roid positions
        if (typeof Roid !== 'undefined') {
            for (let i = 0; i < Roid.length; i++) {
                Roid[i].pos.x *= scaleX;
                Roid[i].pos.y *= scaleY;
            }
        }
        
        // Scale cube position
        if (typeof Cube !== 'undefined' && Cube != null) {
            Cube.pos.x *= scaleX;
            Cube.pos.y *= scaleY;
        }
    }

    window.addEventListener("resize", resizeCanvas);

    function drawCircle(x, y, radius) {
        c.beginPath();			
		c.arc(x, y, radius, 0.0, 2.0 * Math.PI) 
		c.closePath();
	}
    function drawEllipse(x, y, radiusX, radiusY) {
        c.beginPath();			
		c.ellipse(x * cScale, y * cScale, radiusX * cScale, radiusY * cScale, 0, 0, 2 * Math.PI) 
		c.closePath();
	}

    //  SETUP SCENE ======================================================
	function setupScene() {
        PrimaryNodes = [];
        SecondaryNodes = [];
        spawnNodes();
        spinner = 0;
        f = 0;

        //  INITIALIZE ARRAYS  
        Roid = [];
        Cube = null; // Single cube instance
        PongGame = null; // Pong game instance

        //  INITIALIZE BOOLEANS 
        dT = 1/60;

        //  SPAWN INITIAL OBJECTS  
        spawnRoid();
        spawnCube();
        spawnPong();
    }
    
    //  MOUSE TRACKBALL INTERACTION -----------------------------------------------------------
    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;
    let draggedRoid = null;
    
    function setupMouseInteraction() {
        // Helper function to check if mouse is over any roid
        function getRoidAtPosition(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = (clientX - rect.left) / cScale;
            const mouseY = (clientY - rect.top) / cScale;
            
            for (let i = 0; i < Roid.length; i++) {
                const roid = Roid[i];
                const dx = mouseX - roid.pos.x;
                const dy = mouseY - roid.pos.y;
                const distSq = dx * dx + dy * dy;
                
                if (distSq < roid.radius * roid.radius) {
                    return { roid, mouseX, mouseY };
                }
            }
            return null;
        }
        
        // Use document-level events to capture everything
        document.addEventListener('mousedown', (e) => {
            const result = getRoidAtPosition(e.clientX, e.clientY);
            
            if (result) {
                e.preventDefault();
                e.stopPropagation();
                
                isDragging = true;
                draggedRoid = result.roid;
                lastMouseX = result.mouseX;
                lastMouseY = result.mouseY;
                document.body.style.cursor = 'grabbing';
                
                // Stop the roid's automatic tumbling and prevent automatic updates
                result.roid.omega.x = 0;
                result.roid.omega.y = 0;
                result.roid.omega.z = 0;
                result.roid.isDragging = true;
            }
        });
        
        document.addEventListener('mousemove', (e) => {
            if (isDragging && draggedRoid) {
                e.preventDefault();
                
                // Calculate delta in PIXEL space for proper sensitivity
                const pixelDx = e.clientX - (lastMouseX * cScale + canvas.getBoundingClientRect().left);
                const pixelDy = e.clientY - (lastMouseY * cScale + canvas.getBoundingClientRect().top);
                
                // Convert to rotation - working in pixel space for proper sensitivity
                const rotationSpeed = 0.005;  // Lower value since we're in pixel space now
                const deltaYaw = pixelDx * rotationSpeed;
                const deltaPitch = pixelDy * rotationSpeed;
                
                // Create rotation quaternions for the drag
                const qYaw = quatFromAxisAngle(0, 1, 0, deltaYaw);
                const qPitch = quatFromAxisAngle(1, 0, 0, deltaPitch);
                
                // Combine rotations
                const qDelta = quatMultiply(qYaw, qPitch);
                
                // Apply to globe orientation
                draggedRoid.orientation = quatMultiply(qDelta, draggedRoid.orientation);
                
                // Normalize to prevent drift
                draggedRoid.orientation = quatNormalize(draggedRoid.orientation);
                
                // Update last position in simulation space for next frame
                const rect = canvas.getBoundingClientRect();
                lastMouseX = (e.clientX - rect.left) / cScale;
                lastMouseY = (e.clientY - rect.top) / cScale;
            } else {
                // Update cursor when hovering
                const result = getRoidAtPosition(e.clientX, e.clientY);
                document.body.style.cursor = result ? 'grab' : 'default';
            }
        });
        
        document.addEventListener('mouseup', (e) => {
            if (isDragging && draggedRoid) {
                draggedRoid.isDragging = false;
                const result = getRoidAtPosition(e.clientX, e.clientY);
                document.body.style.cursor = result ? 'grab' : 'default';
            }
            isDragging = false;
            draggedRoid = null;
        });
        
        // Prevent text selection while dragging
        document.body.style.userSelect = 'none';
        document.body.style.webkitUserSelect = 'none';
        document.body.style.mozUserSelect = 'none';
    }
    
	//  VECTOR OPERATIONS ---------------------------------------------------------------------
	class Vector2 {
		constructor(x = 0.0, y = 0.0) {
			this.x = x; 
			this.y = y;
		}
		set(v) {
			this.x = v.x; 
            this.y = v.y;
		}
		clone() {
			return new Vector2(this.x, this.y);
		}
		add(v, s=1) {
			this.x += v.x * s;
			this.y += v.y * s;
			return this;
		}
		addVectors(a, b) {
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			return this;
		}
		subtract(v, s = 1.0) {
			this.x -= v.x * s;
			this.y -= v.y * s;
			return this;
		}
		subtractVectors(a, b) {
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			return this;			
		}
		length() {
			return Math.sqrt(this.x * this.x + this.y * this.y);
		}
		scale(s) {
			this.x *= s;
			this.y *= s;
		}
		dot(v) {
			return this.x * v.x + this.y * v.y;
		}
        perp() {
			return new Vector2(-this.y, this.x);
		}
	}

    function cX(pos) {
        return pos.x * cScale;
    }
	function cY(pos) {
        return canvas.height - pos.y * cScale;
    }

    //  NORMALIZE DISTANCE  -------------------
    function measureDistAndShade(node1, node2) {
		var dir = new Vector2();
		dir.subtractVectors(node1.pos, node2.pos);
		d = dir.length();
		
		return 1 / d;
	}

    // Quaternion helpers to avoid gimbal lock when integrating orientation
        function quatFromEuler(yaw, pitch, roll) {
            // yaw (Z), pitch (X), roll (Y) â€” same convention as earlier Euler usage
            const cy = Math.cos(yaw * 0.5);
            const sy = Math.sin(yaw * 0.5);
            const cp = Math.cos(pitch * 0.5);
            const sp = Math.sin(pitch * 0.5);
            const cr = Math.cos(roll * 0.5);
            const sr = Math.sin(roll * 0.5);
            // q = q_yaw * q_pitch * q_roll
            const w = cy * cp * cr + sy * sp * sr;
            const x = cy * sp * cr + sy * cp * sr;
            const y = cy * cp * sr - sy * sp * cr;
            const z = sy * cp * cr - cy * sp * sr;
            return { w: w, x: x, y: y, z: z };
        }

        function quatMultiply(a, b) {
            return {
                w: a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z,
                x: a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y,
                y: a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x,
                z: a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w
            };
        }

        function quatNormalize(q) {
            const len = Math.sqrt(q.w*q.w + q.x*q.x + q.y*q.y + q.z*q.z) || 1.0;
            q.w /= len; q.x /= len; q.y /= len; q.z /= len;
            return q;
        }
        
        function quatFromAxisAngle(ax, ay, az, angle) {
            // Create a quaternion from axis-angle representation
            const halfAngle = angle * 0.5;
            const s = Math.sin(halfAngle);
            return {
                w: Math.cos(halfAngle),
                x: ax * s,
                y: ay * s,
                z: az * s
            };
        }

        function quatRotateVec(q, vx, vy, vz) {
            // Standard, stable quaternion-vector rotation using cross products:
            // t = 2 * cross(q.xyz, v)
            // v' = v + q.w * t + cross(q.xyz, t)
            const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
            // cross(q.xyz, v)
            const cx = qy * vz - qz * vy;
            const cy = qz * vx - qx * vz;
            const cz = qx * vy - qy * vx;
            const tx = 2 * cx;
            const ty = 2 * cy;
            const tz = 2 * cz;
            // cross(q.xyz, t)
            const c2x = qy * tz - qz * ty;
            const c2y = qz * tx - qx * tz;
            const c2z = qx * ty - qy * tx;
            return {
                x: vx + qw * tx + c2x,
                y: vy + qw * ty + c2y,
                z: vz + qw * tz + c2z
            };
        }

    //  DEFINE ROIDS  -----------------
    class ROID {
        constructor (pos, vel, radius, hue, saturation, lightness, 
        randomNo, yaw, pitch, roll) {
            this.pos = pos.clone();
            this.vel = vel.clone();
            this.radius = radius;
            this.originalRadius = radius;
            this.mass = radius * radius * radius; // volume proportional to r^3, density constant
            this.hue = hue;
            this.saturation = saturation;
            this.lightness = lightness;
            this.randomNo = randomNo;
            this.spinAngle = 0;
            // pole spin state for globe roids (controls longitudes rotation)
            this.poleSpinAngle = Math.random() * 2 * Math.PI;
            this.poleSpinSpeed = (Math.random() - 0.5) * 0.1;
            // orientation: store as a quaternion to avoid gimbal lock; also keep Euler cache for code compatibility
            this.yaw = Math.random() * 2 * Math.PI; // initial Euler cache
            this.pitch = (Math.random() - 0.5) * Math.PI; // initial Euler cache
            this.roll = Math.random() * 2 * Math.PI; // initial Euler cache
            // quaternion orientation initialized from euler cache
            this.orientation = quatFromEuler(this.yaw, this.pitch, this.roll);
            // 3D angular velocity vector (rad/frame). Keep scalar angularVelocity in sync with omega.z
            this.omega = {
                x: (Math.random() - 0.5) * 0.2, // pitch rate (tumbling)
                y: (Math.random() - 0.5) * 0.2, // roll rate (tumbling)
                z: (Math.random() - 0.5) * 0.08  // yaw rate (main axis spin)
            };
            // also mirror z into scalar for compatibility
            this.angularVelocity = this.omega.z;
            // Flag to prevent automatic rotation during user drag
            this.isDragging = false;
            // Orbiting ball around equator
            this.orbitAngle = Math.random() * 2 * Math.PI;
            this.orbitSpeed = 0.02; // radians per frame (reduced by 20% from 0.03)
            // Three sub-orbiters that orbit the first orbiter, evenly spaced
            this.subOrbitAngle = Math.random() * 2 * Math.PI;
            this.subOrbitSpeed = 0.05; // radians per frame (restored to previous speed)
            this.subOrbitDistanceMultiplier = 4.0; // Distance from main orbiter to sub-orbiter
            // Polar orbiter - fast north-south orbit near surface
            this.polarOrbitAngle = Math.random() * 2 * Math.PI;
            this.polarOrbitSpeed = 0.08; // faster orbit speed
            this.polarOrbitRadius = 1.30; // two orbiter radii away from surface
            // Polar orbiter trail
            this.polarOrbitTrail = [];
            this.maxPolarTrailLength = 60;
        }
        get left() {
            return this.pos.x - this.radius;
        }
        get right() {
            return this.pos.x + this.radius;
        }
        get top() {
            return this.pos.y - this.radius;
        }
        get bottom() {
            return this.pos.y + this.radius;
        }
        simulate() {
            this.pos.add(this.vel, dT);

            const maxSpeed = 0.5;
            if (this.vel.length() > maxSpeed) {
                this.vel.x *= maxSpeed / this.vel.length();
                this.vel.y *= maxSpeed / this.vel.length();
            }

            // angular control constants (declared early so non-globe code can use them)
            const omegaDamping = 1.0; // no automatic damping: tumbling persists until another force acts
            // maximum angular rate (radians/frame) allowed per-axis to avoid runaway
            const maxOmega = 0.5;
            // maximum spin about axis (scalar spin rate applied to spinAngle/poleSpinAngle)
            const maxSpin = 0.01;

            // Integrate 3D omega into visible orientation for globe roids
            // and keep scalar angularVelocity roughly in sync with omega.z
            // pole spin continues to include poleSpinSpeed
            // include yaw rate (omega.z) in poleSpinAngle so visible longitude rotation follows yaw
            // clamp the resulting axial spin so roids don't spin faster than maxSpin
            let spinInc = 60 * dT * (this.poleSpinSpeed + this.omega.z);
            spinInc = Math.max(-maxSpin, Math.min(maxSpin, spinInc));
            this.poleSpinAngle += spinInc;
            if (this.poleSpinAngle > 2 * Math.PI) this.poleSpinAngle -= 2 * Math.PI;
            if (this.poleSpinAngle < -2 * Math.PI) this.poleSpinAngle += 2 * Math.PI;
            // Integrate angular velocity vector (this.omega) into quaternion orientation using small-angle quaternion
            // delta_q ~ [1, 0.5*omega*dt]
            // Skip automatic rotation if user is dragging
            if (!this.isDragging) {
                const half_dt = 0.5 * dT;
                const dq = {
                    w: 1.0,
                    x: this.omega.x * half_dt,
                    y: this.omega.y * half_dt,
                    z: this.omega.z * half_dt
                };
                // new orientation = orientation * dq  (apply small-body-frame rotation)
                this.orientation = quatMultiply(this.orientation, dq);
                this.orientation = quatNormalize(this.orientation);
            }
            // update Euler cache from quaternion for any code that still reads yaw/pitch/roll
            // conversion: yaw (Z), pitch (X), roll (Y) inverse of quatFromEuler
            const qw = this.orientation.w, qx = this.orientation.x, qy = this.orientation.y, qz = this.orientation.z;
            // yaw (Z)
            this.yaw = Math.atan2(2*(qw*qz + qx*qy), 1 - 2*(qy*qy + qz*qz));
            // pitch (X)
            const sinp = 2*(qw*qx - qy*qz);
            this.pitch = Math.abs(sinp) >= 1 ? Math.sign(sinp) * Math.PI/2 : Math.asin(sinp);
            // roll (Y)
            this.roll = Math.atan2(2*(qw*qy + qz*qx), 1 - 2*(qx*qx + qy*qy));
            // apply damping (may be 1.0 for no damping) and then clamp to max allowed rates
            this.omega.x *= omegaDamping;
            this.omega.y *= omegaDamping;
            this.omega.z *= omegaDamping;
            // clamp per-axis angular rates
            this.omega.x = Math.max(-maxOmega, Math.min(maxOmega, this.omega.x));
            this.omega.y = Math.max(-maxOmega, Math.min(maxOmega, this.omega.y));
            this.omega.z = Math.max(-maxOmega, Math.min(maxOmega, this.omega.z));
            // keep scalar angularVelocity in sync with clamped z
            this.angularVelocity = this.omega.z;
            // clamp scalar axial spin used for visual spin/pole spin
            this.angularVelocity = Math.max(-maxSpin, Math.min(maxSpin, this.angularVelocity));
            
            // Update orbiting ball angle
            this.orbitAngle += this.orbitSpeed;
            if (this.orbitAngle > 2 * Math.PI) {
                this.orbitAngle -= 2 * Math.PI;
            }
            
            // Update second orbiter angle
            this.subOrbitAngle += this.subOrbitSpeed;
            if (this.subOrbitAngle > 2 * Math.PI) {
                this.subOrbitAngle -= 2 * Math.PI;
            }
            
            // Update polar orbiter angle
            this.polarOrbitAngle += this.polarOrbitSpeed;
            if (this.polarOrbitAngle > 2 * Math.PI) {
                this.polarOrbitAngle -= 2 * Math.PI;
            }
            
            // Add polar orbiter position to trail
            this.addPolarOrbiterToTrail();
         
            if (this.spinAngle > 2 * Math.PI) {
                this.spinAngle -= 2 * Math.PI;
            }
        }
        
        addPolarOrbiterToTrail() {
            // Calculate polar orbiter's world position
            const polarOrbitDist = this.radius * this.polarOrbitRadius;
            const polarLocalX = 0;
            const polarLocalY = polarOrbitDist * Math.sin(this.polarOrbitAngle);
            const polarLocalZ = polarOrbitDist * Math.cos(this.polarOrbitAngle);
            const polarRotated = quatRotateVec(this.orientation, polarLocalX, polarLocalY, polarLocalZ);
            
            // World position
            const worldX = polarRotated.x + this.pos.x;
            const worldY = polarRotated.y + this.pos.y;
            const worldZ = polarRotated.z;
            
            // Add to trail
            this.polarOrbitTrail.push({ x: worldX, y: worldY, z: worldZ });
            
            // Keep trail at max length
            if (this.polarOrbitTrail.length > this.maxPolarTrailLength) {
                this.polarOrbitTrail.shift();
            }
        }
        
        draw() {
            // Calculate orbiter's 3D position to determine if it's behind or in front
            const orbitRadius = this.radius * 2.5;
            const ballX0 = orbitRadius * Math.cos(this.orbitAngle);
            const ballY0 = orbitRadius * Math.sin(this.orbitAngle);
            const ballZ0 = 0;
            const rotBall = quatRotateVec(this.orientation, ballX0, ballY0, ballZ0);
            
            // Calculate sub-orbiter's 3D position relative to main orbiter
            const subOrbitRadius = this.radius * 0.15 * this.subOrbitDistanceMultiplier; // Orbit around the main orbiter
            const axisOffset = 30 * Math.PI / 180; // 30-degree offset
            const subX0 = subOrbitRadius * Math.cos(this.subOrbitAngle);
            const subY0 = subOrbitRadius * Math.sin(this.subOrbitAngle) * Math.cos(axisOffset);
            const subZ0 = subOrbitRadius * Math.sin(this.subOrbitAngle) * Math.sin(axisOffset);
            // Position relative to main orbiter
            const subBallX = ballX0 + subX0;
            const subBallY = ballY0 + subY0;
            const subBallZ = ballZ0 + subZ0;
            const rotSubBall = quatRotateVec(this.orientation, subBallX, subBallY, subBallZ);
            
            // Draw orbiters BEHIND globe if z < 0 (facing away from camera)
            if (rotBall.z < 0) {
                // Get orbiter positions
                const mainOrbiterInfo = drawOrbiter(this.radius, this.pos, this.orientation, this.orbitAngle);
                
                // Get four sub-orbiters spaced 90 degrees apart (first plane)
                const angleOffset = (2 * Math.PI) / 4; // 90 degrees
                const orbiterScaleFactor = mainOrbiterInfo.scaleFactor;
                const subOrbiterInfos = [
                    getSubOrbiterPosition(this.radius, this.pos, this.orientation, this.orbitAngle, this.subOrbitAngle, this.subOrbitDistanceMultiplier, orbiterScaleFactor),
                    getSubOrbiterPosition(this.radius, this.pos, this.orientation, this.orbitAngle, this.subOrbitAngle + angleOffset, this.subOrbitDistanceMultiplier, orbiterScaleFactor),
                    getSubOrbiterPosition(this.radius, this.pos, this.orientation, this.orbitAngle, this.subOrbitAngle + angleOffset * 2, this.subOrbitDistanceMultiplier, orbiterScaleFactor),
                    getSubOrbiterPosition(this.radius, this.pos, this.orientation, this.orbitAngle, this.subOrbitAngle + angleOffset * 3, this.subOrbitDistanceMultiplier, orbiterScaleFactor)
                ];
                
                // Get four sub-orbiters on perpendicular plane (second plane)
                const subOrbiterInfos2 = [
                    getSubOrbiterPosition2(this.radius, this.pos, this.orientation, this.orbitAngle, this.subOrbitAngle, this.subOrbitDistanceMultiplier, orbiterScaleFactor),
                    getSubOrbiterPosition2(this.radius, this.pos, this.orientation, this.orbitAngle, this.subOrbitAngle + angleOffset, this.subOrbitDistanceMultiplier, orbiterScaleFactor),
                    getSubOrbiterPosition2(this.radius, this.pos, this.orientation, this.orbitAngle, this.subOrbitAngle + angleOffset * 2, this.subOrbitDistanceMultiplier, orbiterScaleFactor),
                    getSubOrbiterPosition2(this.radius, this.pos, this.orientation, this.orbitAngle, this.subOrbitAngle + angleOffset * 3, this.subOrbitDistanceMultiplier, orbiterScaleFactor)
                ];
                
                const subOrbiterHues = [15, 25, 35, 20];
                const subOrbiterHues2 = [170, 185, 195, 180];
                
                // Draw sub-orbiters that are behind the globe
                for (let i = 0; i < 4; i++) {
                    const subInfo = subOrbiterInfos[i];
                    if (subInfo.worldPos.z < 0) {
                        drawSubOrbiterBall(subInfo.screenX, subInfo.screenY, subInfo.pixelRadius, subOrbiterHues[i]);
                    }
                }
                
                for (let i = 0; i < 4; i++) {
                    const subInfo = subOrbiterInfos2[i];
                    if (subInfo.worldPos.z < 0) {
                        drawSubOrbiterBall(subInfo.screenX, subInfo.screenY, subInfo.pixelRadius, subOrbiterHues2[i]);
                    }
                }
                
                // Draw main orbiter ball (it's behind the globe)
                drawOrbiterBall(mainOrbiterInfo.screenX, mainOrbiterInfo.screenY, mainOrbiterInfo.pixelRadius);
            }
            
            // Calculate polar orbiter position for occlusion checking
            const polarOrbitDist = this.radius * this.polarOrbitRadius;
            const polarLocalX = 0;
            const polarLocalY = polarOrbitDist * Math.sin(this.polarOrbitAngle);
            const polarLocalZ = polarOrbitDist * Math.cos(this.polarOrbitAngle);
            const polarRotated = quatRotateVec(this.orientation, polarLocalX, polarLocalY, polarLocalZ);
            
            // Check if polar orbiter is behind globe surface
            const polarDistFromAxis = Math.sqrt(polarRotated.x * polarRotated.x + polarRotated.y * polarRotated.y);
            const isPolarBehindGlobe = polarRotated.z < 0 && polarDistFromAxis < this.radius;
            
            // Draw polar orbiter trail segments that are behind the globe
            if (this.polarOrbitTrail.length > 1) {
                c.lineCap = 'butt';
                c.lineJoin = 'butt';
                
                for (let j = 1; j < this.polarOrbitTrail.length; j++) {
                    const p1 = this.polarOrbitTrail[j - 1];
                    const p2 = this.polarOrbitTrail[j];
                    
                    // Convert world positions to globe-relative positions
                    const rel1X = p1.x - this.pos.x;
                    const rel1Y = p1.y - this.pos.y;
                    const rel1Z = p1.z;
                    const rel2X = p2.x - this.pos.x;
                    const rel2Y = p2.y - this.pos.y;
                    const rel2Z = p2.z;
                    
                    // Check if both points are behind the globe
                    const dist1FromAxis = Math.sqrt(rel1X * rel1X + rel1Y * rel1Y);
                    const dist2FromAxis = Math.sqrt(rel2X * rel2X + rel2Y * rel2Y);
                    const isBehind1 = rel1Z < 0 && dist1FromAxis < this.radius;
                    const isBehind2 = rel2Z < 0 && dist2FromAxis < this.radius;
                    
                    // Only draw if both endpoints are behind the globe
                    if (isBehind1 && isBehind2) {
                        const alpha = j / this.polarOrbitTrail.length;
                        c.strokeStyle = `hsla(50, 90%, 70%, ${alpha * 0.3})`;
                        c.lineWidth = 1 + 3 * alpha;
                        
                        const perspective1 = 800 / (800 + p1.z);
                        const perspective2 = 800 / (800 + p2.z);
                        
                        const screenX1 = p1.x * cScale * perspective1;
                        const screenY1 = p1.y * cScale * perspective1;
                        const screenX2 = p2.x * cScale * perspective2;
                        const screenY2 = p2.y * cScale * perspective2;
                        
                        c.beginPath();
                        c.moveTo(screenX1, screenY1);
                        c.lineTo(screenX2, screenY2);
                        c.stroke();
                    }
                }
            }
            
            // Draw polar orbiter if behind globe
            if (isPolarBehindGlobe) {
                drawPolarOrbiter(this.radius, this.pos, this.orientation, this.polarOrbitAngle, this.polarOrbitRadius);
            }
            
            drawGlobeRoid(
                this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale, 
                this.originalRadius * cScale, this.hue, this.saturation, this.lightness, 
                this.poleSpinAngle, this.orientation);

            //  HIGHLIGHT SHADING ----------
            drawCircle(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale);
            var sphereGradient = c.createRadialGradient(
                (this.pos.x - (0.3 * this.radius)) * cScale, 
                (this.pos.y - (0.5 * this.radius)) * cScale, 
                0, 
                (this.pos.x - (0.3 * this.radius)) * cScale, 
                (this.pos.y - (0.5 * this.radius)) * cScale, 
                2 * this.radius * cScale);
            var highlight = `hsla(${this.hue + 60}, 50%, 50%, 0.6)`;
            var shadow = `hsla(0, 0%, 0%, 0)`;
            sphereGradient.addColorStop(0.0, highlight);
            sphereGradient.addColorStop(1.0, shadow);
            c.fillStyle = sphereGradient;
            c.fill();

            //  OVERALL BUBBLE SHADING  ----------
            var sphereGradient = c.createRadialGradient(
                    this.pos.x * cScale, 
                    this.pos.y * cScale, 
                    0, 
                    this.pos.x * cScale, 
                    this.pos.y * cScale, 
                    this.radius * cScale);
            var highlight = `hsla(${this.hue + 60}, 50%, 40%, 0.5)`;
            var midtone = `hsla(${this.hue + 60}, 50%, 20%, 0.4)`;
            var shadow = `hsla(${this.hue + 60}, 50%, 10%, 0.2)`;
            sphereGradient.addColorStop(0.0, shadow);
            sphereGradient.addColorStop(0.8, midtone);
            sphereGradient.addColorStop(1.0, highlight);
            c.fillStyle = sphereGradient;
            c.fill();

            // Always draw orbiters that are in front of the globe (z >= 0), after all shading
            // Get orbiter positions
            const mainOrbiterInfo = drawOrbiter(this.radius, this.pos, this.orientation, this.orbitAngle);
            
            // Get four sub-orbiters spaced 90 degrees apart (first plane)
            const angleOffset = (2 * Math.PI) / 4; // 90 degrees
            const orbiterScaleFactor = mainOrbiterInfo.scaleFactor; // Use main orbiter's scale
            const subOrbiterInfos = [
                getSubOrbiterPosition(this.radius, this.pos, this.orientation, this.orbitAngle, this.subOrbitAngle, this.subOrbitDistanceMultiplier, orbiterScaleFactor),
                getSubOrbiterPosition(this.radius, this.pos, this.orientation, this.orbitAngle, this.subOrbitAngle + angleOffset, this.subOrbitDistanceMultiplier, orbiterScaleFactor),
                getSubOrbiterPosition(this.radius, this.pos, this.orientation, this.orbitAngle, this.subOrbitAngle + angleOffset * 2, this.subOrbitDistanceMultiplier, orbiterScaleFactor),
                getSubOrbiterPosition(this.radius, this.pos, this.orientation, this.orbitAngle, this.subOrbitAngle + angleOffset * 3, this.subOrbitDistanceMultiplier, orbiterScaleFactor)
            ];
            
            // Get four sub-orbiters on perpendicular plane (second plane)
            const subOrbiterInfos2 = [
                getSubOrbiterPosition2(this.radius, this.pos, this.orientation, this.orbitAngle, this.subOrbitAngle, this.subOrbitDistanceMultiplier, orbiterScaleFactor),
                getSubOrbiterPosition2(this.radius, this.pos, this.orientation, this.orbitAngle, this.subOrbitAngle + angleOffset, this.subOrbitDistanceMultiplier, orbiterScaleFactor),
                getSubOrbiterPosition2(this.radius, this.pos, this.orientation, this.orbitAngle, this.subOrbitAngle + angleOffset * 2, this.subOrbitDistanceMultiplier, orbiterScaleFactor),
                getSubOrbiterPosition2(this.radius, this.pos, this.orientation, this.orbitAngle, this.subOrbitAngle + angleOffset * 3, this.subOrbitDistanceMultiplier, orbiterScaleFactor)
            ];
            
            const mainOrbiterRadius = this.radius * 0.15;
            const subOrbiterHues = [15, 25, 35, 20]; // Moderate variation: red-orange to orange
            const subOrbiterHues2 = [170, 185, 195, 180]; // Moderate variation: cyan to light cyan
            
            // Draw main orbiter if in front of globe
            if (rotBall.z >= 0) {
                drawOrbiterBall(mainOrbiterInfo.screenX, mainOrbiterInfo.screenY, mainOrbiterInfo.pixelRadius);
            }
            
            // Draw sub-orbiters that are in front of the globe (first plane)
            for (let i = 0; i < 4; i++) {
                const subInfo = subOrbiterInfos[i];
                if (subInfo.worldPos.z >= 0) {
                    drawSubOrbiterBall(subInfo.screenX, subInfo.screenY, subInfo.pixelRadius, subOrbiterHues[i]);
                }
            }
            
            // Draw sub-orbiters that are in front of the globe (second plane)
            for (let i = 0; i < 4; i++) {
                const subInfo = subOrbiterInfos2[i];
                if (subInfo.worldPos.z >= 0) {
                    drawSubOrbiterBall(subInfo.screenX, subInfo.screenY, subInfo.pixelRadius, subOrbiterHues2[i]);
                }
            }
            
            // Draw polar orbiter trail segments that are in front of the globe
            if (this.polarOrbitTrail.length > 1) {
                c.lineCap = 'butt';
                c.lineJoin = 'butt';
                
                for (let j = 1; j < this.polarOrbitTrail.length; j++) {
                    const p1 = this.polarOrbitTrail[j - 1];
                    const p2 = this.polarOrbitTrail[j];
                    
                    // Convert world positions to globe-relative positions
                    const rel1X = p1.x - this.pos.x;
                    const rel1Y = p1.y - this.pos.y;
                    const rel1Z = p1.z;
                    const rel2X = p2.x - this.pos.x;
                    const rel2Y = p2.y - this.pos.y;
                    const rel2Z = p2.z;
                    
                    // Check if points are behind the globe
                    const dist1FromAxis = Math.sqrt(rel1X * rel1X + rel1Y * rel1Y);
                    const dist2FromAxis = Math.sqrt(rel2X * rel2X + rel2Y * rel2Y);
                    const isBehind1 = rel1Z < 0 && dist1FromAxis < this.radius;
                    const isBehind2 = rel2Z < 0 && dist2FromAxis < this.radius;
                    
                    // Only draw if at least one endpoint is in front
                    if (!isBehind1 || !isBehind2) {
                        const alpha = j / this.polarOrbitTrail.length;
                        c.strokeStyle = `hsla(50, 90%, 70%, ${alpha * 0.3})`;
                        c.lineWidth = 1 + 3 * alpha;
                        
                        const perspective1 = 800 / (800 + p1.z);
                        const perspective2 = 800 / (800 + p2.z);
                        
                        const screenX1 = p1.x * cScale * perspective1;
                        const screenY1 = p1.y * cScale * perspective1;
                        const screenX2 = p2.x * cScale * perspective2;
                        const screenY2 = p2.y * cScale * perspective2;
                        
                        c.beginPath();
                        c.moveTo(screenX1, screenY1);
                        c.lineTo(screenX2, screenY2);
                        c.stroke();
                    }
                }
            }

            // Draw polar orbiter if in front of globe
            if (!isPolarBehindGlobe) {
                drawPolarOrbiter(this.radius, this.pos, this.orientation, this.polarOrbitAngle, this.polarOrbitRadius);
            }
        }
    }

    //  DEFINE CUBE  -----------------
    class CUBE {
        constructor(pos, size) {
            this.pos = pos.clone();
            this.size = size; // Half-size of cube (distance from center to face)
            
            // Quaternion orientation
            this.orientation = quatFromEuler(
                Math.random() * 2 * Math.PI,
                Math.random() * 2 * Math.PI,
                Math.random() * 2 * Math.PI
            );

             // Quaternion orientation
            this.orientation = quatFromEuler(
                0.25 * Math.PI,
                0.25 * Math.PI,
                0.25 * Math.PI
            );
            
            // 3D angular velocity (tumbling in all dimensions)
            this.omega = {
                x: 0.2, // slow pitch
                y: -1, // slow roll
                z: 1.5  // slow yaw
            };
        }
        
        simulate() {
            // Update orientation by integrating angular velocity
            const half_dt = dT * 0.5;
            const dq = {
                w: 1,
                x: this.omega.x * half_dt,
                y: this.omega.y * half_dt,
                z: this.omega.z * half_dt
            };
            // new orientation = orientation * dq  (apply small-body-frame rotation)
            this.orientation = quatMultiply(this.orientation, dq);
            this.orientation = quatNormalize(this.orientation);
        }
        
        draw() {
            // Define 8 vertices of the cube in local space
            const s = this.size * cScale;
            const vertices = [
                { x: -s, y: -s, z: -s }, // 0: back-bottom-left
                { x:  s, y: -s, z: -s }, // 1: back-bottom-right
                { x:  s, y:  s, z: -s }, // 2: back-top-right
                { x: -s, y:  s, z: -s }, // 3: back-top-left
                { x: -s, y: -s, z:  s }, // 4: front-bottom-left
                { x:  s, y: -s, z:  s }, // 5: front-bottom-right
                { x:  s, y:  s, z:  s }, // 6: front-top-right
                { x: -s, y:  s, z:  s }  // 7: front-top-left
            ];
            
            // Rotate all vertices by current orientation
            const rotated = vertices.map(v => quatRotateVec(this.orientation, v.x, v.y, v.z));
            
            // Project to screen space
            const screenVerts = rotated.map(v => ({
                x: this.pos.x * cScale + v.x,
                y: this.pos.y * cScale - v.y, // flip Y for canvas
                z: v.z
            }));
            
            // Define 6 faces (each face as array of 4 vertex indices)
            const faces = [
                { indices: [0, 1, 2, 3], normal: { x: 0, y: 0, z: -1 }, baseHue: 170 }, // back
                { indices: [4, 5, 6, 7], normal: { x: 0, y: 0, z: 1 }, baseHue: 170 },  // front
                { indices: [0, 1, 5, 4], normal: { x: 0, y: -1, z: 0 }, baseHue: 170 }, // bottom
                { indices: [3, 2, 6, 7], normal: { x: 0, y: 1, z: 0 }, baseHue: 170 },  // top
                { indices: [0, 3, 7, 4], normal: { x: -1, y: 0, z: 0 }, baseHue: 170 }, // left
                { indices: [1, 2, 6, 5], normal: { x: 1, y: 0, z: 0 }, baseHue: 170 }   // right
            ];
            
            // Calculate each face's average Z and rotated normal for depth sorting and shading
            const facesWithDepth = faces.map(face => {
                // Average Z of face vertices
                const avgZ = face.indices.reduce((sum, idx) => sum + screenVerts[idx].z, 0) / 4;
                
                // Rotate the face normal
                const rotNormal = quatRotateVec(this.orientation, face.normal.x, face.normal.y, face.normal.z);
                
                // Simple lighting: assume light from front-top-right (normalized)
                const lightDir = { x: 0.3, y: 0.5, z: 0.8 };
                const lightMag = Math.sqrt(lightDir.x * lightDir.x + lightDir.y * lightDir.y + lightDir.z * lightDir.z);
                const lightDot = (rotNormal.x * lightDir.x + rotNormal.y * lightDir.y + rotNormal.z * lightDir.z) / lightMag;
                
                // Map dot product to brightness (0.3 to 1.0 range)
                const brightness = 0.3 + 0.7 * Math.max(0, lightDot);
                
                return {
                    face: face,
                    avgZ: avgZ,
                    brightness: brightness,
                    rotNormal: rotNormal
                };
            });
            
            // Sort faces by depth (back to front)
            facesWithDepth.sort((a, b) => a.avgZ - b.avgZ);
            
            // Draw rear faces (facing away) with faint lines first
            facesWithDepth.forEach(({ face, brightness, rotNormal }) => {
                if (rotNormal.z >= 0) { // Facing away from camera
                    c.beginPath();
                    face.indices.forEach((idx, i) => {
                        const v = screenVerts[idx];
                        if (i === 0) {
                            c.moveTo(v.x, v.y);
                        } else {
                            c.lineTo(v.x, v.y);
                        }
                    });
                    c.closePath();
                    
                    // Faint rear edges
                    c.strokeStyle = `hsla(${face.baseHue}, 40%, 30%, 0.8)`;
                    c.lineWidth = 2;
                    c.stroke();
                }
            });
            
            // Draw front faces (facing toward camera)
            facesWithDepth.forEach(({ face, brightness, rotNormal }) => {
                if (rotNormal.z < 0) { // Facing toward camera
                    c.beginPath();
                    face.indices.forEach((idx, i) => {
                        const v = screenVerts[idx];
                        if (i === 0) {
                            c.moveTo(v.x, v.y);
                        } else {
                            c.lineTo(v.x, v.y);
                        }
                    });
                    c.closePath();
                    
                    // Use transparency and shading based on lighting
                    const lightness = 10 + brightness * 30;
                    c.fillStyle = `hsla(${face.baseHue}, 70%, ${lightness}%, 0.4)`;
                    c.fill();
                    
                    // Edge outline
                    c.strokeStyle = `hsla(${face.baseHue}, 70%, ${lightness + 10}%, 0.9)`;
                    c.lineWidth = 3;
                    c.stroke();
                }
            });
        }
    }

    //  PONG GAME  -----------------
    class PONG {
        constructor() {
            // Game area in simulation coordinates (bottom right corner)
            this.width = 0.7; // Game width in sim units (doubled from 0.35)
            this.height = 0.375; // Game height in sim units (50% taller: 0.25 * 1.5)
            this.padding = 0.05; // Fixed padding from edges
            this.updatePosition(); // Calculate initial position
            
            // Paddles
            this.paddleWidth = 0.0075;
            this.paddleHeight = 0.04;
            
            // Goal area (half height, centered)
            this.goalHeight = this.height * 0.5;
            this.goalTop = this.height * 0.25;
            this.goalBottom = this.goalTop + this.goalHeight;
            this.goalCenter = this.goalTop + this.goalHeight / 2;
            
            this.leftPaddleY = this.goalCenter;
            this.rightPaddleY = this.goalCenter;
            this.paddleSpeed = 0.004;
            
            // Ball
            this.ballSize = 0.012;
            this.ballX = this.width / 2;
            this.ballY = this.height / 2;
            this.ballVelX = 0.006;
            this.ballVelY = 0.004;
            
            // AI tracking
            this.leftPaddleTarget = this.ballY;
            this.rightPaddleTarget = this.ballY;
            
            // Scores
            this.leftScore = 0;
            this.rightScore = 0;
        }
        
        updatePosition() {
            // Recalculate position based on current simWidth/simHeight
            this.x = simWidth - this.width - this.padding;
            this.y = simHeight - this.height - this.padding;
        }
        
        simulate() {
            // Update position in case window was resized
            this.updatePosition();
            // Move ball
            this.ballX += this.ballVelX;
            this.ballY += this.ballVelY;
            
            // Bounce off top/bottom walls
            if (this.ballY - this.ballSize / 2 <= 0) {
                this.ballY = this.ballSize / 2;
                this.ballVelY = Math.abs(this.ballVelY);
            }
            if (this.ballY + this.ballSize / 2 >= this.height) {
                this.ballY = this.height - this.ballSize / 2;
                this.ballVelY = -Math.abs(this.ballVelY);
            }
            
            // Check paddle collisions
            const paddlePadding = 0.02;
            
            // Left paddle
            const leftPaddleX = paddlePadding;
            if (this.ballX - this.ballSize / 2 <= leftPaddleX + this.paddleWidth &&
                this.ballX - this.ballSize / 2 >= leftPaddleX &&
                this.ballY >= this.leftPaddleY - this.paddleHeight / 2 &&
                this.ballY <= this.leftPaddleY + this.paddleHeight / 2) {
                this.ballX = leftPaddleX + this.paddleWidth + this.ballSize / 2;
                this.ballVelX = Math.abs(this.ballVelX);
                // Add some variation to Y velocity based on where it hit the paddle
                const hitPos = (this.ballY - this.leftPaddleY) / (this.paddleHeight / 2);
                this.ballVelY += hitPos * 0.002;
            }
            
            // Right paddle
            const rightPaddleX = this.width - this.paddleWidth - paddlePadding;
            if (this.ballX + this.ballSize / 2 >= rightPaddleX &&
                this.ballX + this.ballSize / 2 <= rightPaddleX + this.paddleWidth &&
                this.ballY >= this.rightPaddleY - this.paddleHeight / 2 &&
                this.ballY <= this.rightPaddleY + this.paddleHeight / 2) {
                this.ballX = rightPaddleX - this.ballSize / 2;
                this.ballVelX = -Math.abs(this.ballVelX);
                // Add some variation to Y velocity
                const hitPos = (this.ballY - this.rightPaddleY) / (this.paddleHeight / 2);
                this.ballVelY += hitPos * 0.002;
            }
            
            // Check if ball goes out of bounds - only score if through goal area
            if (this.ballX < 0) {
                // Check if ball went through goal area
                if (this.ballY >= this.goalTop && this.ballY <= this.goalBottom) {
                    // Right player scores
                    this.rightScore++;
                    // Reset scores if either player passes 9
                    if (this.rightScore > 9) {
                        this.rightScore = 0;
                        this.leftScore = 0;
                    }
                } else {
                    // Ball hit wall outside goal - just bounce back
                    this.ballX = 0;
                    this.ballVelX = Math.abs(this.ballVelX);
                }
                // Reset ball position if scored
                if (this.ballX < 0) {
                    this.ballX = this.width / 2;
                    this.ballY = this.height / 2;
                    this.ballVelX = (Math.random() > 0.5 ? 1 : -1) * 0.006;
                    this.ballVelY = (Math.random() - 0.5) * 0.008;
                }
            } else if (this.ballX > this.width) {
                // Check if ball went through goal area
                if (this.ballY >= this.goalTop && this.ballY <= this.goalBottom) {
                    // Left player scores
                    this.leftScore++;
                    // Reset scores if either player passes 9
                    if (this.leftScore > 9) {
                        this.rightScore = 0;
                        this.leftScore = 0;
                    }
                } else {
                    // Ball hit wall outside goal - just bounce back
                    this.ballX = this.width;
                    this.ballVelX = -Math.abs(this.ballVelX);
                }
                // Reset ball position if scored
                if (this.ballX > this.width) {
                    this.ballX = this.width / 2;
                    this.ballY = this.height / 2;
                    this.ballVelX = (Math.random() > 0.5 ? 1 : -1) * 0.006;
                    this.ballVelY = (Math.random() - 0.5) * 0.008;
                }
            }
            
            // AI: paddles only track when ball is moving toward them
            const trackingSpeed = this.paddleSpeed * 1.2;
            const deadZone = 0.005; // Don't move if within this range
            
            // Left paddle AI - only track when ball is moving left
            if (this.ballVelX < 0) {
                if (this.leftPaddleY < this.ballY - deadZone) {
                    this.leftPaddleY += trackingSpeed;
                } else if (this.leftPaddleY > this.ballY + deadZone) {
                    this.leftPaddleY -= trackingSpeed;
                }
            }
            
            // Right paddle AI - only track when ball is moving right
            if (this.ballVelX > 0) {
                if (this.rightPaddleY < this.ballY - deadZone) {
                    this.rightPaddleY += trackingSpeed;
                } else if (this.rightPaddleY > this.ballY + deadZone) {
                    this.rightPaddleY -= trackingSpeed;
                }
            }
            
            // Keep paddles in bounds (allow half paddle length beyond goal opening)
            const paddleExtension = this.paddleHeight / 2;
            this.leftPaddleY = Math.max(this.goalTop - paddleExtension + this.paddleHeight / 2, 
                                        Math.min(this.goalBottom + paddleExtension - this.paddleHeight / 2, this.leftPaddleY));
            this.rightPaddleY = Math.max(this.goalTop - paddleExtension + this.paddleHeight / 2, 
                                         Math.min(this.goalBottom + paddleExtension - this.paddleHeight / 2, this.rightPaddleY));
        }
        
        // Draw seven-segment style digit (classic Pong look)
        drawDigit(digit, x, y, segWidth, segHeight) {
            // Seven segments: top, top-right, bottom-right, bottom, bottom-left, top-left, middle
            const segments = {
                0: [1,1,1,1,1,1,0],
                1: [0,1,1,0,0,0,0],
                2: [1,1,0,1,1,0,1],
                3: [1,1,1,1,0,0,1],
                4: [0,1,1,0,0,1,1],
                5: [1,0,1,1,0,1,1],
                6: [1,0,1,1,1,1,1],
                7: [1,1,1,0,0,0,0],
                8: [1,1,1,1,1,1,1],
                9: [1,1,1,1,0,1,1]
            };
            
            const segs = segments[digit] || [0,0,0,0,0,0,0];
            const gap = segWidth * 0.15;
            
            c.fillStyle = 'hsla(0, 0%, 90%, 0.9)';
            
            // Top
            if (segs[0]) c.fillRect(x + gap, y, segHeight, segWidth);
            // Top-right
            if (segs[1]) c.fillRect(x + gap + segHeight, y + gap, segWidth, segHeight);
            // Bottom-right
            if (segs[2]) c.fillRect(x + gap + segHeight, y + gap + segHeight + gap, segWidth, segHeight);
            // Bottom
            if (segs[3]) c.fillRect(x + gap, y + 2*gap + 2*segHeight, segHeight, segWidth);
            // Bottom-left
            if (segs[4]) c.fillRect(x, y + gap + segHeight + gap, segWidth, segHeight);
            // Top-left
            if (segs[5]) c.fillRect(x, y + gap, segWidth, segHeight);
            // Middle
            if (segs[6]) c.fillRect(x + gap, y + gap + segHeight, segHeight, segWidth);
        }
        
        draw() {
            c.save();

            // fill game border
            c.fillStyle = 'hsla(0, 0%, 0%, 0.8)';
            c.fillRect(
                (this.x) * cScale,
                (this.y) * cScale,
                this.width * cScale,
                this.height * cScale
            );
            
            // Draw game border with goal gaps (half height, centered vertically) 
            c.strokeStyle = 'hsla(0, 0%, 100%, 0.6)';
            c.lineWidth = 2;
            
            const goalHeight = this.height * 0.5; // Goal is half the height
            const goalTop = this.height * 0.25; // Centered vertically
            const goalBottom = goalTop + goalHeight;
            
            c.beginPath();
            // Top border (full width)
            c.moveTo(this.x * cScale, this.y * cScale);
            c.lineTo((this.x + this.width) * cScale, this.y * cScale);
            
            // Bottom border (full width)
            c.moveTo(this.x * cScale, (this.y + this.height) * cScale);
            c.lineTo((this.x + this.width) * cScale, (this.y + this.height) * cScale);
            
            // Left border segments (top and bottom, with gap in middle)
            c.moveTo(this.x * cScale, this.y * cScale);
            c.lineTo(this.x * cScale, (this.y + goalTop) * cScale);
            c.moveTo(this.x * cScale, (this.y + goalBottom) * cScale);
            c.lineTo(this.x * cScale, (this.y + this.height) * cScale);
            
            // Right border segments (top and bottom, with gap in middle)
            c.moveTo((this.x + this.width) * cScale, this.y * cScale);
            c.lineTo((this.x + this.width) * cScale, (this.y + goalTop) * cScale);
            c.moveTo((this.x + this.width) * cScale, (this.y + goalBottom) * cScale);
            c.lineTo((this.x + this.width) * cScale, (this.y + this.height) * cScale);
            c.stroke();
            
            // Draw center line (dashed)
            c.setLineDash([5, 5]);
            c.strokeStyle = 'hsla(0, 0%, 100%, 0.5)';
            c.lineWidth = 1;
            c.beginPath();
            c.moveTo((this.x + this.width / 2) * cScale, this.y * cScale);
            c.lineTo((this.x + this.width / 2) * cScale, (this.y + this.height) * cScale);
            c.stroke();
            c.setLineDash([]);
            
            // Draw left paddle
            c.fillStyle = 'hsla(0, 0%, 100%, 0.9)';
            const paddlePadding = 0.02; // Distance from edge
            c.fillRect(
                (this.x + paddlePadding) * cScale,
                (this.y + this.leftPaddleY - this.paddleHeight / 2) * cScale,
                this.paddleWidth * cScale,
                this.paddleHeight * cScale
            );
            
            // Draw right paddle
            c.fillStyle = 'hsla(0, 0%, 100%, 0.9)';
            c.fillRect(
                (this.x + this.width - this.paddleWidth - paddlePadding) * cScale,
                (this.y + this.rightPaddleY - this.paddleHeight / 2) * cScale,
                this.paddleWidth * cScale,
                this.paddleHeight * cScale
            );
            
            // Draw ball (square)
            c.fillStyle = 'hsla(0, 0%, 100%, 0.95)';
            c.fillRect(
                (this.x + this.ballX - this.ballSize / 2) * cScale,
                (this.y + this.ballY - this.ballSize / 2) * cScale,
                this.ballSize * cScale,
                this.ballSize * cScale
            );
            
            // Draw scores with seven-segment display style
            const digitSegWidth = 3.0;
            const digitSegHeight = 10.8;
            const digitWidth = digitSegHeight + digitSegWidth * 2;
            
            // Left score (closer to center)
            const leftX = (this.x + this.width * 0.4) * cScale - digitWidth / 2;
            const leftY = (this.y + 0.015) * cScale;
            this.drawDigit(this.leftScore, leftX, leftY, digitSegWidth, digitSegHeight);
            
            // Right score (closer to center)
            const rightX = (this.x + this.width * 0.6) * cScale - digitWidth / 2;
            const rightY = (this.y + 0.015) * cScale;
            this.drawDigit(this.rightScore, rightX, rightY, digitSegWidth, digitSegHeight);
            
            c.restore();
        }
    }

    //  DRAW GLOBE ROIDS  --------------------
    function drawGlobeRoid(cx, cy, radius, originalRadius, hue, saturation, lightness, spinAngle = 0, orientation = {w:1,x:0,y:0,z:0}) {
        // Parametric globe-style globe (latitude & longitude) with front-hemisphere clipping
        c.save();
        
        // line width scales with roid size (radius is in pixels already)
        c.lineWidth = 0.02 * radius;
        c.strokeStyle = `hsl(${hue}, ${Math.round(saturation)}%, ${Math.round(lightness)}%)`;
        c.lineCap = 'round';

        // Use orthographic projection with equal X/Y scale so circles remain circular
        const verticalSquash = 1.0;
        // Helper: project 3D point (x,y,z) to screen (no non-uniform squash)
        function project(x, y, z) {
            const sx = cx + x;
            const sy = cy - y; // invert Y to canvas coords
            return { x: sx, y: sy, z: z };
        }

        // rotate by yaw (around Z), pitch (around X), roll (around Y)
        const spin = spinAngle || 0;

        function rotatePoint(x, y, z) {
            return quatRotateVec(orientation, x, y, z);
        }

        // Latitudes: Draw back-facing first (faint), then front-facing (bright)  ----------
        const latStep = 20; 
        const maxLat = 60;  
        const latDegrees = [0];
        for (let d = latStep; d <= maxLat; d += latStep) {
            latDegrees.push(d, -d);
        }
        
        // BACK HEMISPHERE - faint lines
        c.save();
        c.lineWidth = 0.015 * radius;
        c.strokeStyle = `hsla(${hue}, ${Math.round(saturation)}%, ${Math.round(Math.max(20, lightness - 10))}%, 0.6)`;
        for (let li = 0; li < latDegrees.length; li++) {
            const phi = latDegrees[li] * Math.PI / 180;
            const rLat = radius * Math.cos(phi);
            const z0 = radius * Math.sin(phi);
            const steps = 96;
            c.beginPath();
            let hasBack = false;
            for (let s = 0; s <= steps; s++) {
                const theta = (s / steps) * 2 * Math.PI + spin;
                const x0 = rLat * Math.cos(theta);
                const y0 = rLat * Math.sin(theta);
                const rot = rotatePoint(x0, y0, z0);
                const p = project(rot.x, rot.y, rot.z);
                
                // Only draw if facing away (z < 0)
                if (rot.z < 0) {
                    if (!hasBack) {
                        c.moveTo(p.x, p.y);
                        hasBack = true;
                    } else {
                        c.lineTo(p.x, p.y);
                    }
                } else if (hasBack) {
                    // Start new path segment when transitioning front/back
                    c.stroke();
                    c.beginPath();
                    hasBack = false;
                }
            }
            if (hasBack) c.stroke();
        }
        c.restore();
        
        // FRONT HEMISPHERE - bright lines
        c.save();
        c.lineWidth = 0.02 * radius;
        c.strokeStyle = `hsl(${hue}, ${Math.round(saturation)}%, ${Math.round(lightness)}%)`;
        for (let li = 0; li < latDegrees.length; li++) {
            const phi = latDegrees[li] * Math.PI / 180;
            const rLat = radius * Math.cos(phi);
            const z0 = radius * Math.sin(phi);
            const steps = 96;
            c.beginPath();
            let hasFront = false;
            for (let s = 0; s <= steps; s++) {
                const theta = (s / steps) * 2 * Math.PI + spin;
                const x0 = rLat * Math.cos(theta);
                const y0 = rLat * Math.sin(theta);
                const rot = rotatePoint(x0, y0, z0);
                const p = project(rot.x, rot.y, rot.z);
                
                // Only draw if facing forward (z >= 0)
                if (rot.z >= 0) {
                    if (!hasFront) {
                        c.moveTo(p.x, p.y);
                        hasFront = true;
                    } else {
                        c.lineTo(p.x, p.y);
                    }
                } else if (hasFront) {
                    c.stroke();
                    c.beginPath();
                    hasFront = false;
                }
            }
            if (hasFront) c.stroke();
        }
        c.restore();

        // Longitudes: Draw back-facing first (faint), then front-facing (bright)  ----------
        const numLong = 12;
        const phiSteps = 80;
        
        // BACK HEMISPHERE - faint lines
        c.save();
        c.lineWidth = 0.015 * radius;
        c.strokeStyle = `hsla(${hue}, ${Math.round(saturation)}%, ${Math.round(Math.max(20, lightness - 10))}%, 0.6)`;
        for (let k = 0; k < numLong; k++) {
            const lambda = (k / numLong) * 2 * Math.PI + spin;
            c.beginPath();
            let hasBack = false;
            for (let pi = 0; pi <= phiSteps; pi++) {
                const phi = (-0.5 + pi / phiSteps) * Math.PI;
                const x0 = radius * Math.cos(phi) * Math.cos(lambda);
                const y0 = radius * Math.cos(phi) * Math.sin(lambda);
                const z0 = radius * Math.sin(phi);
                const rot = rotatePoint(x0, y0, z0);
                const p = project(rot.x, rot.y, rot.z);
                
                // Only draw if facing away (z < 0)
                if (rot.z < 0) {
                    if (!hasBack) {
                        c.moveTo(p.x, p.y);
                        hasBack = true;
                    } else {
                        c.lineTo(p.x, p.y);
                    }
                } else if (hasBack) {
                    c.stroke();
                    c.beginPath();
                    hasBack = false;
                }
            }
            if (hasBack) c.stroke();
        }
        c.restore();
        
        // FRONT HEMISPHERE - bright lines
        c.save();
        c.lineWidth = 0.02 * radius;
        c.strokeStyle = `hsl(${hue}, ${Math.round(saturation)}%, ${Math.round(lightness)}%)`;
        for (let k = 0; k < numLong; k++) {
            const lambda = (k / numLong) * 2 * Math.PI + spin;
            c.beginPath();
            let hasFront = false;
            for (let pi = 0; pi <= phiSteps; pi++) {
                const phi = (-0.5 + pi / phiSteps) * Math.PI;
                const x0 = radius * Math.cos(phi) * Math.cos(lambda);
                const y0 = radius * Math.cos(phi) * Math.sin(lambda);
                const z0 = radius * Math.sin(phi);
                const rot = rotatePoint(x0, y0, z0);
                const p = project(rot.x, rot.y, rot.z);
                
                // Only draw if facing forward (z >= 0)
                if (rot.z >= 0) {
                    if (!hasFront) {
                        c.moveTo(p.x, p.y);
                        hasFront = true;
                    } else {
                        c.lineTo(p.x, p.y);
                    }
                } else if (hasFront) {
                    c.stroke();
                    c.beginPath();
                    hasFront = false;
                }
            }
            if (hasFront) c.stroke();
        }
        c.restore();

        // Draw outer circle mask to hide arc ends at the edge
        c.save();
        c.lineWidth = 0.03 * radius;
        c.strokeStyle = `hsl(${hue}, ${Math.round(saturation)}%, ${Math.round(lightness)}%)`;
        c.beginPath();
        c.arc(cx, cy, radius, 0, 2 * Math.PI);
        c.stroke();
        c.restore();

        /*// Apply 3D shading overlay - radial gradient lit from upper left
        c.save();
        const lightOffsetX = -radius * 0.35;
        const lightOffsetY = -radius * 0.55;
        const gradient = c.createRadialGradient(
            cx + lightOffsetX, cy + lightOffsetY, radius * 0.1,
            cx, cy, radius
        );
        // Use the sphere's own color for shading (lighter on top-left, darker on bottom-right)
        const brightL = Math.min(95, lightness + 35);
        const darkL = Math.max(10, lightness - 35);
        gradient.addColorStop(0, `hsla(${hue}, ${Math.round(saturation)}%, ${brightL}%, 0.4)`); // Bright highlight
        gradient.addColorStop(0.4, `hsla(${hue}, ${Math.round(saturation)}%, ${lightness}%, 0)`); // Fade to transparent
        gradient.addColorStop(0.7, `hsla(${hue}, ${Math.round(saturation)}%, ${lightness}%, 0)`); // Transparent midtone
        gradient.addColorStop(1, `hsla(${hue}, ${Math.round(saturation)}%, ${darkL}%, 0.5)`); // Dark shadow at edge
        
        c.fillStyle = gradient;
        c.beginPath();
        c.arc(cx, cy, radius, 0, 2 * Math.PI);
        c.fill();
        c.restore();*/
    }

    function drawOrbiter(radius, centerPos, orientation, orbitAngle) {
        // Draw orbiting ball around equator
        const orbitRadius = radius * 2.5; // Slightly outside the globe
        const baseBallRadius = radius * 0.35; // Base ball size
        
        // Calculate 3D position on equator (z=0 plane)
        const ballX0 = orbitRadius * Math.cos(orbitAngle);
        const ballY0 = orbitRadius * Math.sin(orbitAngle);
        const ballZ0 = 0; // On equator
        
        // Rotate the ball position with the globe's orientation
        const rotBall = quatRotateVec(orientation, ballX0, ballY0, ballZ0);
        
        // Scale based on z-position (perspective effect)
        // When z > 0 (toward viewer), scale up; when z < 0 (away from viewer), scale down
        // Normalize z by orbit radius to get a reasonable scale factor
        const zNormalized = rotBall.z / orbitRadius; // Range approximately -1 to 1
        const scaleFactor = 1.0 + zNormalized * 0.3; // Scale from 0.7x to 1.3x
        const ballRadius = baseBallRadius * scaleFactor;
        
        // Project to 2D screen space
        const ballScreenX = (centerPos.x + rotBall.x) * cScale;
        const ballScreenY = (centerPos.y - rotBall.y) * cScale; // Invert Y
        
        // Draw the orbiting ball with spherical shading
        const ballPixelRadius = ballRadius * cScale;
        
        // Return position info for shadow calculation
        return { screenX: ballScreenX, screenY: ballScreenY, pixelRadius: ballPixelRadius, worldPos: rotBall, scaleFactor: scaleFactor };
    }
    
    function drawOrbiterBall(ballScreenX, ballScreenY, ballPixelRadius) {
        // Sphere gradient for the ball
        const ballGradient = c.createRadialGradient(
            ballScreenX - ballPixelRadius * 0.3,
            ballScreenY - ballPixelRadius * 0.4,
            0,
            ballScreenX,
            ballScreenY,
            1.1 * ballPixelRadius
        );

        /*ballGradient.addColorStop(0, 'hsl(320, 80%, 80%)');
        ballGradient.addColorStop(0.3, 'hsl(320, 80%, 60%)');
        ballGradient.addColorStop(0.7, 'hsl(320, 80%, 30%)');
        ballGradient.addColorStop(1, 'hsl(320, 60%, 10%)');*/

        ballGradient.addColorStop(0, 'hsl(320, 80%, 70%)');
        ballGradient.addColorStop(0.3, 'hsl(320, 80%, 40%)');
        ballGradient.addColorStop(0.7, 'hsl(320, 80%, 15%)');
        ballGradient.addColorStop(1, 'hsl(320, 60%, 5%)');
        
        c.beginPath();
        c.arc(ballScreenX, ballScreenY, ballPixelRadius, 0, 2 * Math.PI);
        c.fillStyle = ballGradient;
        c.fill();
    }
    
    function drawPolarOrbiter(radius, centerPos, orientation, polarOrbitAngle, polarOrbitRadius) {
        // Polar orbit: a great circle passing through both poles
        // Testing: use Y as polar axis (since sy = cy - y suggests -Y is up on screen)
        // Orbit in Y-Z plane
        const orbitDist = radius * polarOrbitRadius;
        
        // Circular orbit in Y-Z plane
        const localX = 0;
        const localY = orbitDist * Math.sin(polarOrbitAngle);  // polar axis
        const localZ = orbitDist * Math.cos(polarOrbitAngle);
        // When angle=0Â°: (0, 0, orbitDist)
        // When angle=90Â°: (0, orbitDist, 0) - at NORTH POLE
        // When angle=180Â°: (0, 0, -orbitDist)
        // When angle=270Â°: (0, -orbitDist, 0) - at SOUTH POLE
        
        // Rotate by globe orientation
        const rotated = quatRotateVec(orientation, localX, localY, localZ);
        
        // Translate to globe position
        const worldX = rotated.x + centerPos.x;
        const worldY = rotated.y + centerPos.y;
        const worldZ = rotated.z;
        
        // Project to screen
        const perspective = 800 / (800 + worldZ);
        const screenX = worldX * cScale * perspective;
        const screenY = worldY * cScale * perspective;
        
        // Small orbiter size
        const baseSize = radius * 0.1;
        const pixelRadius = baseSize * cScale * perspective;
        
        // Draw small spherically-shaded ball
        const ballGradient = c.createRadialGradient(
            screenX - pixelRadius * 0.3,
            screenY - pixelRadius * 0.4,
            0,
            screenX,
            screenY,
            1.1 * pixelRadius
        );
        
        ballGradient.addColorStop(0, 'hsl(275, 0%, 100%)');
        ballGradient.addColorStop(0.3, 'hsl(275, 0%, 65%)');
        ballGradient.addColorStop(0.7, 'hsl(275, 0%, 25%)');
        ballGradient.addColorStop(1, 'hsl(275, 0%, 10%)');
        
        c.beginPath();
        c.arc(screenX, screenY, pixelRadius, 0, 2 * Math.PI);
        c.fillStyle = ballGradient;
        c.fill();
    }
    
    function drawSubOrbiterShadow(mainOrbiterScreenX, mainOrbiterScreenY, mainOrbiterPixelRadius, 
                                   subOrbiterScreenX, subOrbiterScreenY, subOrbiterPixelRadius,
                                   subOrbiterWorldZ, mainOrbiterWorldZ) {
        // Only draw shadow if sub-orbiter is behind main orbiter
        if (subOrbiterWorldZ >= mainOrbiterWorldZ) return;
        
        // Calculate shadow position on main orbiter surface
        const dx = subOrbiterScreenX - mainOrbiterScreenX;
        const dy = subOrbiterScreenY - mainOrbiterScreenY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Only draw shadow if sub-orbiter is reasonably close
        if (distance > mainOrbiterPixelRadius * 4) return;
        
        // Shadow is centered on the main orbiter, not offset
        const shadowCenterX = mainOrbiterScreenX;
        const shadowCenterY = mainOrbiterScreenY;
        
        // Calculate shadow size - larger and softer the farther away
        const depthFactor = Math.abs(subOrbiterWorldZ - mainOrbiterWorldZ) * 0.02;
        const shadowRadius = subOrbiterPixelRadius * (1.5 + depthFactor);
        
        // Draw shadow as a simple dark circular gradient at the center
        c.save();
        c.globalCompositeOperation = 'multiply';
        
        const shadowGradient = c.createRadialGradient(
            shadowCenterX, shadowCenterY, 0,
            shadowCenterX, shadowCenterY, shadowRadius
        );
        shadowGradient.addColorStop(0, 'rgba(0, 0, 0, 0.85)');
        shadowGradient.addColorStop(0.4, 'rgba(0, 0, 0, 0.6)');
        shadowGradient.addColorStop(0.7, 'rgba(0, 0, 0, 0.3)');
        shadowGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        
        c.fillStyle = shadowGradient;
        c.beginPath();
        c.arc(shadowCenterX, shadowCenterY, shadowRadius, 0, 2 * Math.PI);
        c.fill();
        c.restore();
    }

    function drawSubOrbiter(radius, centerPos, orientation, orbitAngle, subOrbitAngle, subOrbitDistanceMultiplier, orbiterScaleFactor) {
        const info = getSubOrbiterPosition(radius, centerPos, orientation, orbitAngle, subOrbitAngle, subOrbitDistanceMultiplier, orbiterScaleFactor);
        drawSubOrbiterBall(info.screenX, info.screenY, info.pixelRadius);
    }
    
    function getSubOrbiterPosition(radius, centerPos, orientation, orbitAngle, subOrbitAngle, subOrbitDistanceMultiplier, orbiterScaleFactor) {
        // Calculate smaller orbiter that orbits around the main orbiter
        const orbitRadius = radius * 2.5;
        const subOrbitRadius = radius * 0.15 * subOrbitDistanceMultiplier * orbiterScaleFactor; // Orbit radius scales with main orbiter
        const baseBallRadius = radius * 0.12 * orbiterScaleFactor; // Size scales with main orbiter
        
        // Calculate main orbiter position (this is the radial vector from globe center)
        const ballX0 = orbitRadius * Math.cos(orbitAngle);
        const ballY0 = orbitRadius * Math.sin(orbitAngle);
        const ballZ0 = 0;
        
        // Normalize the radial vector to get the direction from globe center to orbiter
        const radialLength = Math.sqrt(ballX0 * ballX0 + ballY0 * ballY0 + ballZ0 * ballZ0);
        const radialX = ballX0 / radialLength;
        const radialY = ballY0 / radialLength;
        const radialZ = ballZ0 / radialLength;
        
        // Create orbital plane perpendicular to radial vector
        // Use Z-axis as reference to find perpendicular vectors
        // First perpendicular vector (in the plane perpendicular to radial)
        let perp1X, perp1Y, perp1Z;
        if (Math.abs(radialZ) < 0.9) {
            // Cross product with Z axis
            perp1X = -radialY;
            perp1Y = radialX;
            perp1Z = 0;
        } else {
            // Cross product with X axis if radial is too close to Z
            perp1X = 0;
            perp1Y = -radialZ;
            perp1Z = radialY;
        }
        const perp1Length = Math.sqrt(perp1X * perp1X + perp1Y * perp1Y + perp1Z * perp1Z);
        perp1X /= perp1Length;
        perp1Y /= perp1Length;
        perp1Z /= perp1Length;
        
        // Second perpendicular vector (cross product of radial and perp1)
        const perp2X = radialY * perp1Z - radialZ * perp1Y;
        const perp2Y = radialZ * perp1X - radialX * perp1Z;
        const perp2Z = radialX * perp1Y - radialY * perp1X;
        
        // Calculate sub-orbiter position in the plane perpendicular to radial vector
        const cosAngle = Math.cos(subOrbitAngle);
        const sinAngle = Math.sin(subOrbitAngle);
        const subX0 = subOrbitRadius * (perp1X * cosAngle + perp2X * sinAngle);
        const subY0 = subOrbitRadius * (perp1Y * cosAngle + perp2Y * sinAngle);
        const subZ0 = subOrbitRadius * (perp1Z * cosAngle + perp2Z * sinAngle);
        
        // Position relative to main orbiter
        const subBallX = ballX0 + subX0;
        const subBallY = ballY0 + subY0;
        const subBallZ = ballZ0 + subZ0;
        
        // Rotate the sub-orbiter position with the globe's orientation
        const rotSubBall = quatRotateVec(orientation, subBallX, subBallY, subBallZ);
        
        // Scale based on z-position (perspective effect)
        const totalOrbitRadius = orbitRadius + subOrbitRadius;
        const zNormalized = rotSubBall.z / totalOrbitRadius;
        const scaleFactor = 1.0 + zNormalized * 0.3;
        const ballRadius = baseBallRadius * scaleFactor;
        
        // Project to 2D screen space
        const ballScreenX = (centerPos.x + rotSubBall.x) * cScale;
        const ballScreenY = (centerPos.y - rotSubBall.y) * cScale;
        
        // Return position info
        const ballPixelRadius = ballRadius * cScale;
        return { screenX: ballScreenX, screenY: ballScreenY, pixelRadius: ballPixelRadius, worldPos: rotSubBall };
    }
    
    function getSubOrbiterPosition2(radius, centerPos, orientation, orbitAngle, subOrbitAngle, subOrbitDistanceMultiplier, orbiterScaleFactor) {
        // Calculate smaller orbiter on perpendicular orbital plane (parallel to radial vector)
        const orbitRadius = radius * 2.5;
        const subOrbitRadius = radius * 0.15 * subOrbitDistanceMultiplier * orbiterScaleFactor; // Orbit radius scales with main orbiter
        const baseBallRadius = radius * 0.12 * orbiterScaleFactor; // Size scales with main orbiter
        
        // Calculate main orbiter position (radial vector from globe center)
        const ballX0 = orbitRadius * Math.cos(orbitAngle);
        const ballY0 = orbitRadius * Math.sin(orbitAngle);
        const ballZ0 = 0;
        
        // Normalize the radial vector
        const radialLength = Math.sqrt(ballX0 * ballX0 + ballY0 * ballY0 + ballZ0 * ballZ0);
        const radialX = ballX0 / radialLength;
        const radialY = ballY0 / radialLength;
        const radialZ = ballZ0 / radialLength;
        
        // Create orbital plane parallel to radial vector (perpendicular to first ring)
        // This plane contains the radial vector as one axis
        // Use Z-axis as reference to find perpendicular vector
        let perpX, perpY, perpZ;
        if (Math.abs(radialZ) < 0.9) {
            // Cross product with Z axis
            perpX = -radialY;
            perpY = radialX;
            perpZ = 0;
        } else {
            // Cross product with X axis if radial is too close to Z
            perpX = 0;
            perpY = -radialZ;
            perpZ = radialY;
        }
        const perpLength = Math.sqrt(perpX * perpX + perpY * perpY + perpZ * perpZ);
        perpX /= perpLength;
        perpY /= perpLength;
        perpZ /= perpLength;
        
        // Phase offset to prevent orbital intersections - 45 degrees places balls between first ring's positions
        const phaseOffset = Math.PI / 4; // 45 degrees offset for 4-ball configuration (halfway between 90-degree spacing)
        
        // Calculate sub-orbiter position using radial and perpendicular vectors
        const cosAngle = Math.cos(subOrbitAngle + phaseOffset);
        const sinAngle = Math.sin(subOrbitAngle + phaseOffset);
        const subX0 = subOrbitRadius * (radialX * cosAngle + perpX * sinAngle);
        const subY0 = subOrbitRadius * (radialY * cosAngle + perpY * sinAngle);
        const subZ0 = subOrbitRadius * (radialZ * cosAngle + perpZ * sinAngle);
        
        // Position relative to main orbiter
        const subBallX = ballX0 + subX0;
        const subBallY = ballY0 + subY0;
        const subBallZ = ballZ0 + subZ0;
        
        // Rotate the sub-orbiter position with the globe's orientation
        const rotSubBall = quatRotateVec(orientation, subBallX, subBallY, subBallZ);
        
        // Scale based on z-position (perspective effect)
        const totalOrbitRadius = orbitRadius + subOrbitRadius;
        const zNormalized = rotSubBall.z / totalOrbitRadius;
        const scaleFactor = 1.0 + zNormalized * 0.3;
        const ballRadius = baseBallRadius * scaleFactor;
        
        // Project to 2D screen space
        const ballScreenX = (centerPos.x + rotSubBall.x) * cScale;
        const ballScreenY = (centerPos.y - rotSubBall.y) * cScale;
        
        // Return position info
        const ballPixelRadius = ballRadius * cScale;
        return { screenX: ballScreenX, screenY: ballScreenY, pixelRadius: ballPixelRadius, worldPos: rotSubBall };
    }
    
    function drawSubOrbiterBall(ballScreenX, ballScreenY, ballPixelRadius, hue = 200) {
        // Sphere gradient for the sub-orbiter with variable hue
        const ballGradient = c.createRadialGradient(
            ballScreenX - ballPixelRadius * 0.3,
            ballScreenY - ballPixelRadius * 0.4,
            0,
            ballScreenX,
            ballScreenY,
            1.1 * ballPixelRadius
        );
        ballGradient.addColorStop(0, `hsl(${hue}, 80%, 60%)`);
        ballGradient.addColorStop(0.3, `hsl(${hue}, 80%, 50%)`);
        ballGradient.addColorStop(0.7, `hsl(${hue}, 80%, 20%)`);
        ballGradient.addColorStop(1, `hsl(${hue}, 60%, 5%)`);
        
        c.beginPath();
        c.arc(ballScreenX, ballScreenY, ballPixelRadius, 0, 2 * Math.PI);
        c.fillStyle = ballGradient;
        c.fill();
    }

    //  SPAWN ROIDS  ------------------------------------------------------------
    function spawnRoid() {
        var radius = 0.4;
        var pos = new Vector2(0.85 * simWidth, 0.3 * simHeight);
        //var pos = new Vector2(0.7 * simWidth, 0.5 * simHeight);
        var vel = new Vector2(0, 0);
        //var hue = Math.floor(Math.random() * 360);
        var hue = 70;
        var saturation = 60 + 30 * Math.random(); // 60-90% for vibrant colors
        var lightness = 40; // 45-60% to avoid white/pale colors
        let seed = Math.floor(Math.random() * 0xFFFFFFFF);
        let randomNo = Math.random();
        let yaw = Math.random() * 2 * Math.PI;
        let pitch = Math.random() * 2 * Math.PI; // -pi/2 .. +pi/2
        let roll = Math.random() * 2 * Math.PI;
                
        Roid.push(new ROID(pos, vel, radius, hue, saturation, lightness, randomNo, yaw, pitch, roll));   
    }

    //  SPAWN CUBE  ------------------------------------------------------------
    function spawnCube() {
        var size = 0.15; // Half-size of cube
        var pos = new Vector2(0.15 * simWidth, 0.85 * simHeight); // Center of screen
        Cube = new CUBE(pos, size);
    }

    //  SPAWN PONG GAME  ------------------------------------------------------------
    function spawnPong() {
        PongGame = new PONG();
    }

    //  NODE CLASS  -------------------
    class NODE { 
        constructor(pos, angle, color, speed, direction) {
            this.pos = pos.clone();
            this.angle = angle;
            this.color = color;
            this.speed = speed;
            this.direction = direction;
            this.trail = [];
            this.maxTrailLength = 30;
            this.trailMinDistance = 0.001;
        }
        simulate() {
            this.angle += .05 * this.direction * this.speed;
            if (this.direction > 0 && this.angle > 2 * Math.PI) {
                this.angle -= 2 * Math.PI;
            }
            if (this.direction < 0 && this.angle < 0) {
                this.angle += 2 * Math.PI;
            }

            var lobeId = 5;
            f += 0.000001 * this.speed * this.direction;
            
            // Pre-calculate trig values to avoid redundant calculations
            const angleDirection = this.angle * this.direction;
            const fPlusAngle = f + this.angle;
            const lobeFPlusAngle = lobeId * fPlusAngle;
            
            const cosAngleDirection = Math.cos(angleDirection);
            const sinAngle = Math.sin(this.angle);
            const cosLobeFPlusAngle = Math.cos(lobeFPlusAngle);
            const cosFPlusAngle = Math.cos(fPlusAngle);
            const sinFPlusAngle = Math.sin(fPlusAngle);
            
            const lobeEffect = 0.008 * cosLobeFPlusAngle;
            
            this.pos.x += 0.002 * cosAngleDirection + lobeEffect * cosFPlusAngle;
            this.pos.y += 0.001 * sinAngle + lobeEffect * sinFPlusAngle;
            
            // Add current position to trail
            this.addToTrail();
        }
        addToTrail() {
            // Only add if moved enough distance from last trail point
            if (this.trail.length === 0) {
                this.trail.push(this.pos.clone());
            } else {
                const lastPos = this.trail[this.trail.length - 1];
                const dx = this.pos.x - lastPos.x;
                const dy = this.pos.y - lastPos.y;
                const distSquared = dx * dx + dy * dy;
                
                if (distSquared > this.trailMinDistance * this.trailMinDistance) {
                    this.trail.push(this.pos.clone());
                    
                    // Keep trail at max length
                    if (this.trail.length > this.maxTrailLength) {
                        this.trail.shift();
                    }
                }
            }
        }
    }

    //  GENERATE NODE ARRAY ------------------
    function spawnNodes() {
        // right side
        for (i = 0; i < 20; i++) {
            var radius = 0.1 * simHeight + 0.5 * simHeight * Math.random();
            var angle = 2 * Math.PI * Math.random();
            var color = `hsl(${Math.random() * 360}, 30%, 50%)`;
            var speed = 0.4 * Math.random();
            if (Math.random() < 0.50) {
                var direction = 1;
            } else {
                var direction = -1;
            }
            PrimaryNodes.push(new NODE(
                new Vector2(
                    0.7 * simWidth + radius * Math.cos(angle), 
                    0.5 * simHeight + radius * Math.sin(angle)), 
                2 * Math.PI * Math.random(),
                color,
                speed,
                direction));
        }

        //  left side
        for (i = 0; i < 20; i++) {
            var radius = 0.1 * simHeight + 0.5 * simHeight * Math.random();
            var angle = 2 * Math.PI * Math.random();
            var color = `hsl(${Math.random() * 360}, 30%, 50%)`;
            var speed = .1 + .4 * Math.random();
            if (Math.random() < 0.50) {
                direction = 1;
            } else {
                direction = -1;
            }
            SecondaryNodes.push(new NODE(
                new Vector2(
                    0.1 * simWidth + radius * Math.cos(angle), 
                    0.5 * simHeight + radius * Math.sin(angle)), 
                2 * Math.PI * Math.random(),
                color,
                speed,
                direction));
        }
    }

    function drawPrimaryNodes() {
        // Draw trails for primary nodes
        for (i = 0; i < PrimaryNodes.length; i++) {
            const node = PrimaryNodes[i];
            if (node.trail.length > 1) {
                c.lineCap = 'round';
                c.lineJoin = 'round';
                
                for (let j = 1; j < node.trail.length; j++) {
                    const alpha = j / node.trail.length;
                    c.strokeStyle = `hsla(210, 70%, 60%, ${alpha * 0.1})`;
                    c.lineWidth = 2 + 25 * alpha;
                    
                    c.beginPath();
                    c.moveTo(node.trail[j - 1].x * cScale, node.trail[j - 1].y * cScale);
                    c.lineTo(node.trail[j].x * cScale, node.trail[j].y * cScale);
                    c.stroke();
                }
            }
        }

        // Collect all connections with their distances for sorting
        let primaryConnections = [];

        // Collect connections between primary nodes (right side)
        for (i = 0; i < PrimaryNodes.length; i++) {
            node1 = PrimaryNodes[i];
            for (j = i + 1; j < PrimaryNodes.length; j++) {
                node2 = PrimaryNodes[j];
                const invDistance = measureDistAndShade(node1, node2);
                primaryConnections.push({
                    node1: node1,
                    node2: node2,
                    invDistance: invDistance
                });
            }  
        }

        // Sort connections: large invDistance (close) = draw last, small invDistance (far) = draw first
        primaryConnections.sort((a, b) => a.invDistance - b.invDistance);
        
        // Draw primary connections from farthest to closest
        for (let conn of primaryConnections) {
            c.beginPath();
            c.moveTo(conn.node1.pos.x * cScale, conn.node1.pos.y * cScale);
            c.lineTo(conn.node2.pos.x * cScale, conn.node2.pos.y * cScale);
            if (conn.invDistance * 20 < 60) {
                var lineLite = conn.invDistance * 20;
            } else {
                var lineLite = 60;
            }
            c.strokeStyle = `hsla(${180 + 3 * lineLite}, 50%, ${lineLite}%, ${lineLite + 20}%)`;
            c.lineWidth = Math.min(4 * conn.invDistance, 4);
            c.stroke();
        }
            
        // Draw primary nodes with spherical shading
        for (i = 0; i < PrimaryNodes.length; i++) {
            node1 = PrimaryNodes[i];
            const x = node1.pos.x * cScale;
            const y = node1.pos.y * cScale;
            const radius = 0.03 * cScale;
            
            // Create radial gradient for 3D sphere effect
            const gradient = c.createRadialGradient(
                x - radius * 0.3, y - radius * 0.3, radius * 0.1,
                x, y, radius
            );
            gradient.addColorStop(0, 'hsl(210, 70%, 85%)');
            gradient.addColorStop(0.3, 'hsl(210, 70%, 60%)');
            gradient.addColorStop(0.7, 'hsl(210, 70%, 40%)');
            gradient.addColorStop(1, 'hsl(210, 70%, 20%)');
            
            drawCircle(x, y, radius);
            c.fillStyle = gradient;
            c.fill();   
        }
    }

    function drawSecondaryNodes() { 
        // Draw trails for secondary nodes
        for (i = 0; i < SecondaryNodes.length; i++) {
            const node = SecondaryNodes[i];
            if (node.trail.length > 1) {
                c.lineCap = 'round';
                c.lineJoin = 'round';
                for (let j = 1; j < node.trail.length; j++) {
                    const alpha = j / node.trail.length;
                    c.strokeStyle = `hsla(320, 70%, 50%, ${alpha * 0.15})`;
                    c.lineWidth = 2 + 25 * alpha;
                    
                    c.beginPath();
                    c.moveTo(node.trail[j - 1].x * cScale, node.trail[j - 1].y * cScale);
                    c.lineTo(node.trail[j].x * cScale, node.trail[j].y * cScale);
                    c.stroke();
                }
            }
        }
        
        // Collect all connections with their distances for sorting
        let secondaryConnections = [];
        
        // Collect connections between secondary nodes (left side)
        for (i = 0; i < SecondaryNodes.length; i++) {
            node1 = SecondaryNodes[i];
            for (j = i + 1; j < SecondaryNodes.length; j++) {
                node2 = SecondaryNodes[j];
                const invDistance = measureDistAndShade(node1, node2);
                secondaryConnections.push({
                    node1: node1,
                    node2: node2,
                    invDistance: invDistance
                });
            }   
        }
        
        // Sort connections: large invDistance (close) = draw last, small invDistance (far) = draw first
        secondaryConnections.sort((a, b) => a.invDistance - b.invDistance);
         
        // Draw secondary connections from farthest to closest
        for (let conn of secondaryConnections) {
            c.beginPath();
            c.moveTo(conn.node1.pos.x * cScale, conn.node1.pos.y * cScale);
            c.lineTo(conn.node2.pos.x * cScale, conn.node2.pos.y * cScale);
            if (conn.invDistance * 20 < 60) {
                var lineLite = conn.invDistance * 20;
            } else {
                var lineLite = 60;
            }
            c.strokeStyle = `hsla(130, 50%, ${lineLite}%, ${lineLite + 20}%)`;
            c.lineWidth = Math.min(2 * conn.invDistance, 4);
            c.stroke();
        }
         
        // Draw secondary nodes with spherical shading
        for (i = 0; i < SecondaryNodes.length; i++) {
            node1 = SecondaryNodes[i];
            const x = node1.pos.x * cScale;
            const y = node1.pos.y * cScale;
            const radius = 0.03 * cScale;
            
            // Create radial gradient for 3D sphere effect
            const gradient = c.createRadialGradient(
                x - radius * 0.3, y - radius * 0.3, radius * 0.1,
                x, y, radius
            );
            gradient.addColorStop(0, 'hsl(320, 70%, 85%)');
            gradient.addColorStop(0.3, 'hsl(320, 70%, 60%)');
            gradient.addColorStop(0.7, 'hsl(320, 70%, 40%)');
            gradient.addColorStop(1, 'hsl(320, 70%, 20%)');
            
            drawCircle(x, y, radius);
            c.fillStyle = gradient;
            c.fill();   
        }

        /*// Draw connections between primary and secondary nodes
        for (i = 0; i < PrimaryNodes.length; i++) {
            node1 = PrimaryNodes[i];
            for (j = 0; j < SecondaryNodes.length; j++) {
                node2 = SecondaryNodes[i];
                c.moveTo(node1.pos.x * cScale, node1.pos.y * cScale);
                c.lineTo(node2.pos.x * cScale, node2.pos.y * cScale);
                if (measureDistAndShade(node1, node2) * 20 < 60) {
                    var lineLite = measureDistAndShade(node1, node2) * 20
                } else {
                    var lineLite = 60;
                }
                c.strokeStyle = `hsla(0, 70%, 20%, 10%)`;
                c.lineWidth = Math.min(2 * measureDistAndShade(node1, node2), 2);
                
            }
            c.stroke();
        }*/
    }

    //  SIMULATION --------------------------------------------------------------------------
	function simulate() {
        for (n = 0; n < PrimaryNodes.length; n++) {
            PrimaryNodes[n].simulate();
            SecondaryNodes[n].simulate();
        }

        for (var r = 0; r < Roid.length; r++) {
            if (Roid[r] != null) {
                var roid = Roid[r]
                roid.simulate();
            }
        }
        
        // Simulate cube
        if (Cube != null) {
            Cube.simulate();
        }
        
        // Simulate pong game
        if (PongGame != null) {
            PongGame.simulate();
        }
    }
    
    //  DRAW EVERYTHING ==============================================================
	function drawEverything() {
        // Clear the canvas
        c.fillStyle = 'hsl(0, 0%, 0%)';
        c.fillRect(0, 0, canvas.width, canvas.height);

        // Draw nodes and their connections
        drawPrimaryNodes();
        //drawSecondaryNodes();
        
        // Draw side fades
        const sideFade = c.createLinearGradient(0, 0, canvas.width, 0);
        sideFade.addColorStop(0.00, 'hsla(0, 0%, 5%, 0.9)');
        sideFade.addColorStop(0.05, 'hsla(0, 0%, 3%, 0.8)');
        sideFade.addColorStop(0.50, 'hsla(0, 0%, 0%, 0)');
        sideFade.addColorStop(0.90, 'hsla(0, 0%, 0%, 0)');
        sideFade.addColorStop(0.97, 'hsla(0, 0%, 0%, 0.8)');
        sideFade.addColorStop(1, 'hsla(0, 0%, 0%, 0.9)');
        c.fillStyle = sideFade;
        c.fillRect(0, 0, canvas.width, canvas.height);

        // Draw semi-transparent black overlay
        c.fillStyle = 'hsla(0, 0%, 0%, 0.5)';
        c.fillRect(0, 0, canvas.width, canvas.height); 

        // Draw cube
        if (Cube != null) {
            Cube.draw();
        }

        // Draw roid
        for (var r = 0; r < Roid.length; r++) {
            if (Roid[r] != null) {
                var roid = Roid[r]
                roid.draw();
            }
        }
        
        // Draw pong game
        if (PongGame != null) {
            PongGame.draw();
        }
	}

    //  MAIN SEQUENCE ----------------------------------------------------------------------------
	setupScene();
    setupMouseInteraction();
    
    function update() {
        simulate();
        
		drawEverything();
		requestAnimationFrame(update);
	}
    
	update();

    // Title pulse timing system
    const tapTimings = [];
    const wordGroups = [
        ['word1'],  // I
        ['word2'],  // Like
        ['word3'],  // to
        ['word4'],  // Move it
        ['word5']   // Move it
    ];
    let currentTapIndex = 0;
    
    // Saved timings from tapping to "I Like to Move It"
    // Each timing corresponds to one word group
    const savedTimings = [0, 233, 433, 743, 1194]; // Based on your actual tapping
    const loopDuration = 1965; // Total cycle duration before repeat (ms) - average of your cycles
    const pressDurations = [80, 68, 79, 168, 151]; // Hold durations for emphasis (one cycle)
    let playbackInterval = null;

    function pulseWord(wordId, duration = 150, emphasis = 1.0) {
        const word = document.getElementById(wordId);
        if (word) {
            // Scale the pulse based on emphasis (duration of key press)
            const scaleAmount = 1.0 + (emphasis * 0.32); // More emphasis = bigger pulse (max ~1.32x)
            const glowIntensity = 25 + (emphasis * 15); // More emphasis = brighter glow
            
            word.style.transform = `scale(${scaleAmount})`;
            word.style.textShadow = `0px 0px ${glowIntensity}px hsl(0, 0%, 100%), 5px 7px 10px hsl(0, 0%, 0%)`;
            word.style.color = `hsl(0, 0%, 100%)`; // White during pulse
            
            // After pulse duration, transition to red cooldown
            setTimeout(() => {
                word.style.transform = '';
                word.style.textShadow = '5px 7px 10px hsl(0, 0%, 0%)';
                word.style.color = 'hsl(0, 90%, 59%)'; // Red during cooldown
                
                // After cooldown, return to original color
                setTimeout(() => {
                    word.style.textShadow = '';
                    word.style.color = '';
                }, 400); // 300ms red cooldown period
            }, duration);
        }
    }

    function pulseGroup(groupIndex, emphasis = 1.0) {
        const group = wordGroups[groupIndex];
        if (!group) return;
        
        // First three words (I, Like, to) get short staccato pulses
        // Last two (Move it) get longer pulses
        const pulseDuration = groupIndex < 3 ? 100 : 150;
        pulseWord(group[0], pulseDuration, emphasis);
    }

    function startPlayback() {
        // Stop any existing playback
        if (playbackInterval) {
            clearTimeout(playbackInterval);
        }
        
        // Play each group according to recorded timings with emphasis
        savedTimings.forEach((timing, index) => {
            setTimeout(() => {
                // Calculate emphasis based on press duration (normalize to 0-1 scale)
                // Short press ~90ms = 0.5, long press ~290ms = 1.5
                const pressDuration = pressDurations[index % pressDurations.length];
                const emphasis = Math.max(0.5, Math.min(2.0, pressDuration / 150));
                pulseGroup(index % 5, emphasis);
            }, timing);
        });
        
        // Loop the animation
        const totalDuration = loopDuration;
        playbackInterval = setTimeout(() => startPlayback(), totalDuration);
    }

    // Auto-start with saved timings
    setTimeout(() => startPlayback(), 500);


</script> 

</body>
</html>
