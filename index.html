<!-- 
:: R0IDS :: copyright 2025 :: Frank Maiello :: maiello.frank@gmail.com ::

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. In no event shall the author or copyright holders be liable for any claim, damages, or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in, connection with the software or the use of other dealings in the Software.
-->

<!DOCTYPE html>
<html>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<head>
    <title>R0IDS 1.72</title>
    <style>
        body {font-family: monospace; 
            font-size: 14px;
            color: hsl(0, 0%, 89%);
            text-align: center;
            text-shadow: 3px 4px 10px hsl(0, 0%, 0%);
            margin-left: 0px;
            margin-right: 0px;
            padding-left: 5px;
            padding-right: 5px;

        }
        h1 {font-family: monospace; 
            font-size: 12px;
            color: hsl(0, 0%, 65%);
            text-align: center;
            text-shadow: 3px 4px 10px hsl(0, 0%, 0%);
            margin-left: 0px;
            margin-right: 0px;
            padding-left: 0px;
            padding-right: 0px;
            padding-top: 10px;
            display: inline;
        }
        h2 {font-family: monospace; 
            font-size: 0px;
            color: hsl(0, 0%, 65%);
            float: left;
            text-shadow: 3px 4px 10px hsl(0, 0%, 0%);
            margin-left: 0px;
            margin-right: 0px;
            padding-left: 0px;
            padding-right: 0px;
            display: inline;
        }
        .radio:hover {opacity: 1}
        .radio {-webkit-appearance: none;
            appearance: none;
            padding: 0px;
            border: 0px;
            vertical-align: middle;
            margin-top: 0px;
            margin-bottom: 0px;
            margin-left: 0px;
            margin-right: 5px;
            width: 15px;
            height: 15px;
            border-radius: 10px;
            background-color: hsl(0, 98%, 33%);
            opacity: 0.7;
            border: 2px solid hsl(0, 0%, 83%);
            cursor: pointer;
            box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
        .radio:checked {
            background-color: hsl(118, 100%, 33%);
        }
        .radio2:hover {opacity: 1}
        .radio2 {-webkit-appearance: none;
            appearance: none;
            padding: 0px;
            border: 0px;
            vertical-align: middle;
            margin-top: 0px;
            margin-bottom: 0px;
            margin-left: 0px;
            margin-right: 5px;
            width: 15px;
            height: 15px;
            border-radius: 10px;
            background-color: hsl(205, 100%, 40%);
            opacity: 0.7;
            border: 2px solid hsl(0, 0%, 83%);
            cursor: pointer;
            box-shadow: 3px 4px 10px hsl(0, 0%, 0%)}
        .radio2:checked {
            background-color: hsl(118, 100%, 33%);
        }
        </style>
</head>

<body style="background: linear-gradient(to bottom, hsl(0, 0%, 8%) 0%, hsl(0, 0%, 15%) 50%); background-attachment: fixed; margin-left: 0px; margin-right: 0px">
    <div style="display:none;">
        <img id="spaceStuff" src="andromeda.png">
        <img id="earth" src="planet_disc.png">
    </div>
        <canvas id="myCanvas" style="border:1px solid hsl(0, 0%, 30%); margin-bottom: 3px; padding-left: 1px; padding-right: 1px; margin-left: 1px; margin-right: 1px">
    </canvas>

    <h2><input type="checkbox" title="Roid Fill ON/OFF" name="roidFill" id="roidFill" class="radio" checked>
    <input type="checkbox" title="Polkadots ON/OFF" name="polkadots" id="polkadots" class="radio" checked>>
    <input type="checkbox" title="Princess Mode ON/OFF" name="athena" id="athena" class="radio" unchecked></h2>
    <h1>:: R0IDS ::</h1>
    <script>

    //  CANVAS SETUP AND SCALING --------------------------------------------------------------   
    function resizeCanvas() {
        canvas = document.getElementById("myCanvas");
        c = canvas.getContext("2d");

        galaxy = document.getElementById('spaceStuff');
        earthImage = document.getElementById('earth');

        canvas.style.cursor = "pointer";
        canvas.width = window.innerWidth - 15;
        canvas.height = window.innerHeight - 50;
        simMinWidth = 2;
        cScale = Math.min(canvas.width, canvas.height) / simMinWidth;
        simWidth = canvas.width / cScale;
        simHeight = canvas.height / cScale;

        offscreenFlashCanvas = document.createElement('canvas');
        offscreenFlashCtx = offscreenFlashCanvas.getContext('2d');
        offscreenFlashCanvas.width = 0.4 * cScale; 
        offscreenFlashCanvas.height = 0.4 * cScale; 

        offscreenStarfieldCanvas = document.createElement('canvas');
        offscreenStarfieldCtx = offscreenStarfieldCanvas.getContext('2d');
        offscreenStarfieldCanvas.width = canvas.width; 
        offscreenStarfieldCanvas.height = canvas.height; 

    }
    resizeCanvas();
    window.addEventListener("resize", resizeCanvas);
    window.addEventListener("resize", makeStars);
    window.addEventListener("resize", defineStarfield);

    //  KEYBOARD CONTROL  ---------------------
    document.addEventListener("keydown", keyDownHandler, false);
    document.addEventListener("keyup", keyUpHandler, false);

    function keyDownHandler(u) {
        if (u.key == "a" || u.key == "A" || u.key == "ArrowLeft") {
            leftPressed = true;
        } else if (u.key == "d" || u.key == "D" || u.key == "ArrowRight") {
            rightPressed = true;
        }  

        if (u.key == "ArrowUp" || u.key == "w" || u.key == "W") {
            thrustKey = true;
        }

        if (u.key == " " || u.key == 's' || u.key == 'S' || u.key == "ArrowDown") { 
            spawnTorpedoKey = true;
        }

        if (u.key == "p" || u.key == "P") {
            userPause = !userPause;
        }

        if (gameIdle == true && (leftPressed || rightPressed || thrustKey || spawnTorpedoKey)) {
            gameIdle = false;
            gameOn = true;
            gameStarting = true;
            gameStartTime = Date.now();
            torpedoFired = 0;
            torpedoHit = 0;
        }
        
        //if (u.key == "q" || u.key == "Q") {
        //    spawnSoloAlien(new Vector2(0.5 * simWidth, 0.2 * simHeight));
        //}

        if (u.key == "x" || u.key == "X") {
            spawnSpawnlets(0.5 * simWidth, 0.5 * simHeight, 4, 0.35, 1000);
        }

        if (gameOn != true && lives < 1 && (u.key == "R" || u.key == 'r')) {
            window.clearInterval(fallingStars);
            setupScene();
        }

        if (u.key == "z" || u.key == "Z") {
            timeWarp = true;  
        }
    }
    
    function keyUpHandler(u) {
        if (u.key == "a" || u.key == "A" || u.key == "ArrowLeft") {
            leftPressed = false;
        } else if (u.key == "d" || u.key == "D" || u.key == "ArrowRight") {
            rightPressed = false;
        } 

        if (u.key == "ArrowUp"  || u.key == "w" || u.key == "W") {
            thrustKey = false;
        }
        if (u.key == " " || u.key == 's' || u.key == 'S' || u.key == "ArrowDown") {
            spawnTorpedoKey = false;
        }

        if (u.key == "z" || u.key == "Z") {
            timeWarp = false;
        }
    }

    //  VECTOR OPERATIONS ---------------------------------------------------------------------
    class Vector2 {
        constructor(x = 0.0, y = 0.0) {
            this.x = x; 
            this.y = y;
        }
        clone() {
            return new Vector2(this.x, this.y);
        }
        add(v, s=1) {
            this.x += v.x * s;
            this.y += v.y * s;
            return this;
        }
        subtract(a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            return this;			
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        scale(s) {
            this.x *= s;
            this.y *= s;
        }
        dot(v) {
            return this.x * v.x + this.y * v.y;
        }
        normalize() {
            let len = Math.sqrt(this.x * this.x + this.y * this.y);
            if (len === 0) {
                this.x = 0; this.y = 0; return this;
            }
            this.x /= len;
            this.y /= len;
            return this;
        }
    }

    // Quaternion helpers to avoid gimbal lock when integrating orientation
    function quatFromEuler(yaw, pitch, roll) {
        // yaw (Z), pitch (X), roll (Y) â€” same convention as earlier Euler usage
        const cy = Math.cos(yaw * 0.5);
        const sy = Math.sin(yaw * 0.5);
        const cp = Math.cos(pitch * 0.5);
        const sp = Math.sin(pitch * 0.5);
        const cr = Math.cos(roll * 0.5);
        const sr = Math.sin(roll * 0.5);
        // q = q_yaw * q_pitch * q_roll
        const w = cy * cp * cr + sy * sp * sr;
        const x = cy * sp * cr + sy * cp * sr;
        const y = cy * cp * sr - sy * sp * cr;
        const z = sy * cp * cr - cy * sp * sr;
        return { w: w, x: x, y: y, z: z };
    }

    function quatMultiply(a, b) {
        return {
            w: a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z,
            x: a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y,
            y: a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x,
            z: a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w
        };
    }

    function quatNormalize(q) {
        const len = Math.sqrt(q.w*q.w + q.x*q.x + q.y*q.y + q.z*q.z) || 1.0;
        q.w /= len; q.x /= len; q.y /= len; q.z /= len;
        return q;
    }

    function quatRotateVec(q, vx, vy, vz) {
        // Standard, stable quaternion-vector rotation using cross products:
        // t = 2 * cross(q.xyz, v)
        // v' = v + q.w * t + cross(q.xyz, t)
        const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
        // cross(q.xyz, v)
        const cx = qy * vz - qz * vy;
        const cy = qz * vx - qx * vz;
        const cz = qx * vy - qy * vx;
        const tx = 2 * cx;
        const ty = 2 * cy;
        const tz = 2 * cz;
        // cross(q.xyz, t)
        const c2x = qy * tz - qz * ty;
        const c2y = qz * tx - qx * tz;
        const c2z = qx * ty - qy * tx;
        return {
            x: vx + qw * tx + c2x,
            y: vy + qw * ty + c2y,
            z: vz + qw * tz + c2z
        };
    }

    //  BASIC FUNCTIONS --------------------
    function drawCircle(posX, posY, radius) {
        c.beginPath();			
        c.arc(posX, posY, radius, 0, 2 * Math.PI) 
        c.closePath();
    }
    function offscreenDrawCircle(posX, posY, radius) {
        offscreenFlashCtx.beginPath();			
        offscreenFlashCtx.arc(posX, posY, radius, 0, 2 * Math.PI) 
        offscreenFlashCtx.closePath();
    }
    function drawHorizEllipse(x, y, radius) {
        c.beginPath();			
        c.ellipse(x, y, radius, 0.35 * radius, 0, 0, 2 * Math.PI) 
        c.closePath();
    }
    function drawCustomEllipse(x, y, radius, scaleY) {
        c.beginPath();			
        c.ellipse(x, y, radius, scaleY * radius, 0, 0, 2 * Math.PI) 
        c.closePath();
    }
    function drawCustomEllipse2(x, y, radiusX, radiusY) {
        c.beginPath();			
        c.ellipse(x, y, radiusX, radiusY, 0, 0, 2 * Math.PI) 
        c.closePath();
    }
    function drawHorizEllipse2(x, y, radius) {
        c.beginPath();			
        c.ellipse(x, y, radius, 0.35 * Enemy[0].radius * cScale, 0, 0, 2 * Math.PI) 
        c.closePath();
    }
    function drawVertEllipse(x, y, radius) {
        c.beginPath();			
        c.ellipse(x, y, 0.7 * radius, radius, 0, 0, 2 * Math.PI) 
        c.closePath();
    }
    function rads(theta) {
        return theta * Math.PI/180;
    }
    function drawArrow(posX, posY, angle, radius) {
        var arrow = {
            radius: radius,
            // 1 bottom right
            a1cos: Math.cos(rads(281.86) + angle),
            a1sin: Math.sin(rads(281.86) + angle),
            r1: 0.5109,
            // 2 right inside corner
            a2cos: Math.cos(rads(43.6) + angle),
            a2sin: Math.sin(rads(43.6) + angle),
            r2: 0.1450,
            // 3 right tip
            a3cos: Math.cos(rads(16.86) + angle),
            a3sin: Math.sin(rads(16.86) + angle),
            r3: 0.3448,
            // 4 top
            a4cos: Math.cos(rads(90) + angle),
            a4sin: Math.sin(rads(90) + angle),
            r4: 0.5,
            // 5 left tip
            a5cos: Math.cos(rads(163.14) + angle),
            a5sin: Math.sin(rads(163.14) + angle),
            r5: 0.3448,
            // 6 left inside corner
            a6cos: Math.cos(rads(136.4) + angle),
            a6sin: Math.sin(rads(136.4) + angle),
            r6: 0.1450,
            // 7 bottom left
            a7cos: Math.cos(rads(258.14) + angle),
            a7sin: Math.sin(rads(258.14) + angle),
            r7: 0.5109,
            // 8 bottom center
            a8cos: Math.cos(rads(270) + angle),
            a8sin: Math.sin(rads(270) + angle),
            r8: 0.5
        }

        c.beginPath();
        c.moveTo((posX + arrow.radius * arrow.r1 * arrow.a1cos) * cScale,
            (posY - arrow.radius * arrow.r1 * arrow.a1sin) * cScale);
        c.lineTo((posX + arrow.radius * arrow.r2 * arrow.a2cos) * cScale,
            (posY - arrow.radius * arrow.r2 * arrow.a2sin) * cScale);
        c.lineTo((posX + arrow.radius * arrow.r3 * arrow.a3cos) * cScale,
            (posY - arrow.radius * arrow.r3 * arrow.a3sin) * cScale);
        c.lineTo((posX + arrow.radius * arrow.r4 * arrow.a4cos) * cScale,
            (posY - arrow.radius * arrow.r4 * arrow.a4sin) * cScale);
        c.lineTo((posX + arrow.radius * arrow.r5 * arrow.a5cos) * cScale,
            (posY - arrow.radius * arrow.r5 * arrow.a5sin) * cScale);
        c.lineTo((posX + arrow.radius * arrow.r6 * arrow.a6cos) * cScale,
            (posY - arrow.radius * arrow.r6 * arrow.a6sin) * cScale);
        c.lineTo((posX + arrow.radius * arrow.r7 * arrow.a7cos) * cScale,
            (posY - arrow.radius * arrow.r7 * arrow.a7sin) * cScale);
        c.lineTo((posX + arrow.radius * arrow.r8 * arrow.a8cos) * cScale,
            (posY - arrow.radius * arrow.r8 * arrow.a8sin) * cScale);
        c.closePath();
    }

    //  DRAW STAR  ------------------
    function drawStar(pos, radius, angle) {
        var drawX = pos.x * cScale;
        var drawY = pos.y * cScale;
        var starWedges = Math.PI / 5;
        var innerRadius = 0.3 * radius * cScale;
        var outerRadius = 0.6 * radius * cScale;
        c.beginPath();
        for (var v = 0; v < 10; v++) {
            let theta = angle + v * starWedges;
            let r = (v % 2 == 0) ? innerRadius : outerRadius;
            let x = drawX + r * Math.cos(theta);
            let y = drawY + r * Math.sin(theta);
            if (v == 0) {
                c.moveTo(x, y);
            } else {
                c.lineTo(x, y);
            }
        }
        c.closePath();
    }

    //  GET THE DANGLE FROM THE ANGLE ------------------
    function getDangle(enemyX, enemyY, roketX, roketY) {
        // top left ---------- sector #3
        if (roketX < enemyX && roketY > enemyY) {
            var dangle = Math.PI + (Math.atan(Math.abs(roketY - enemyY) / (roketX - enemyX)));
        } 
        // top right ---------- sector #2
        if (roketX < enemyX && roketY < enemyY) {
            var dangle = Math.PI - (Math.atan(Math.abs(roketY - enemyY) / (roketX - enemyX)));
        }
        // bottom left ---------- sector #4
        if (roketX > enemyX && roketY > enemyY) {
            var dangle = (Math.atan(Math.abs(roketY - enemyY) / (roketX - enemyX)));
        } 
        // bottom right ---------- sector #1
        if (roketX > enemyX && roketY < enemyY) {  
            var dangle = -(Math.atan(Math.abs(roketY - enemyY) / (roketX - enemyX)));
        }
        return dangle; 
    }

    //  Catmull-Rom Spline helper
    function catmullRomSpline(points, tension = 0.5, numSegments = 16) {
        let splinePoints = [];
        for (let i = 0; i < points.length - 1; i++) {
            let p0 = points[i === 0 ? i : i - 1];
            let p1 = points[i];
            let p2 = points[i + 1];
            let p3 = points[i + 2 < points.length ? i + 2 : i + 1];
            for (let t = 0; t < numSegments; t++) {
                let s = t / numSegments;
                let s2 = s * s;
                let s3 = s2 * s;
                let x = 0.5 * ((2 * p1.x) +
                    (-p0.x + p2.x) * s +
                    (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * s2 +
                    (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * s3);
                let y = 0.5 * ((2 * p1.y) +
                    (-p0.y + p2.y) * s +
                    (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * s2 +
                    (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * s3);
                splinePoints.push({ x, y });
            }
        }
        splinePoints.push(points[points.length - 1]);
        return splinePoints;
}

    function mouthEdgeY(x) {
        const dx = (x - mouthCenterX) / mouthRadiusX;
        if (Math.abs(dx) > 1) return mouthCenterY; // outside ellipse
        return mouthCenterY - Math.sqrt(1 - dx * dx) * mouthRadiusY;
    }

    function minImageDistance(ax, ay, bx, by, simWidth, simHeight) {
        let dx = ax - bx;
        let dy = ay - by;
        // Wrap distances to minimum image
        if (dx > simWidth / 2) dx -= simWidth;
        if (dx < -simWidth / 2) dx += simWidth;
        if (dy > simHeight / 2) dy -= simHeight;
        if (dy < -simHeight / 2) dy += simHeight;
        return { dx, dy, dist: Math.sqrt(dx*dx + dy*dy) };
    }

    //  DRAW POLKADOTS ON ROIDS  ------------------
    function drawPolkadots(cx, cy, radius, maxDots, dotRadiusFrac, roidHue, 
    roidSaturation, polkaPulseLightness, roidLightness, seed, randomNo, spinAngle = 0, flashPolkadots) {
        let dotHue;
        let flashAmount = 0;
        if (flashAmount > 0) {
            dotHue = 0;
        } else if (randomNo < 0.5) {
            dotHue = (roidHue + 90) % 360;
        } else {
            dotHue = (roidHue - 90) % 360;
        }

        if (typeof flashPolkadots === 'number') {
            flashAmount = Math.max(0, Math.min(1, flashPolkadots / 0.5));
        } else if (flashPolkadots === true) {
            flashAmount = 1;
        }
        
        const goldenAngle = Math.PI * (3 - Math.sqrt(5));
        const dotAngularRadius = Math.asin(dotRadiusFrac);

        function seededRand(seed) {
            let s = seed || 1;
            return function() {
                s = Math.imul(48271, s) & 0x7fffffff;
                return s / 0x7fffffff;
            };
        }

        let phase = ((seed || 1) % 10000) / 10000 * 2 * Math.PI;

        // Try from maxDots down to 1, return the first successful non-overlapping set
        for (let dotCount = maxDots; dotCount > 0; dotCount--) {
            let rand = seededRand(seed || 1); // re-seed for each attempt
            // Shuffle indices
            let indices = Array.from({length: dotCount}, (_, i) => i);
            for (let i = dotCount - 1; i > 0; i--) {
                let j = Math.floor(rand() * (i + 1));
                [indices[i], indices[j]] = [indices[j], indices[i]];
            }
            let placed = [];
            let success = true;
            for (let n = 0; n < dotCount; n++) {
                let i = indices[n];
                let y = 1 - (i + 0.5) / dotCount * 2;
                let rxy = Math.sqrt(1 - y * y);
                let theta = goldenAngle * i + phase;
                let x = Math.cos(theta) * rxy;
                let z = Math.sin(theta) * rxy;
                // Rotate (x, y) about z-axis by spinAngle (group rotation)
                let xRot = x * Math.cos(spinAngle) - y * Math.sin(spinAngle);
                let yRot = x * Math.sin(spinAngle) + y * Math.cos(spinAngle);
                x = xRot;
                y = yRot;
                // Strict overlap check
                let ok = true;
                for (let j = 0; j < placed.length; j++) {
                    let p = placed[j];
                    let dot = x * p.x + y * p.y + z * p.z;
                    let angDist = Math.acos(Math.max(-1, Math.min(1, dot)));
                    if (angDist < 2 * dotAngularRadius) {
                        ok = false;
                        break;
                    }
                }
                if (!ok) {
                    success = false;
                    break;
                }
                placed.push({x, y, z});
            }
            if (success) {
                // Draw all placed dots
                for (let k = 0; k < placed.length; k++) {
                    let {x, y, z} = placed[k];
                    let px = cx + x * radius;
                    let py = cy + y * radius;
                    // Tangent vectors for rim
                    let upx = 0, upy = 1, upz = 0;
                    if (Math.abs(y) > 0.99) { upx = 1; upy = 0; upz = 0; }
                    let t1x = upy * z - upz * y;
                    let t1y = upz * x - upx * z;
                    let t1z = upx * y - upy * x;
                    let t1len = Math.sqrt(t1x * t1x + t1y * t1y + t1z * t1z);
                    t1x /= t1len; t1y /= t1len; t1z /= t1len;
                    let t2x = y * t1z - z * t1y;
                    let t2y = z * t1x - x * t1z;
                    let t2z = x * t1y - y * t1x;
                    let t2len = Math.sqrt(t2x * t2x + t2y * t2y + t2z * t2z);
                    t2x /= t2len; t2y /= t2len; t2z /= t2len;

                    // Only draw dots whose centers are on the front hemisphere
                    if (z > 0) {
                        let rim3D = [];
                        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                        for (let j = 0; j < 32; j++) {  // 32 rimSteps
                            let psi = (2 * Math.PI * j) / 32;
                            let rimX = x * Math.cos(dotAngularRadius) + t1x * Math.sin(dotAngularRadius) * Math.cos(psi) + t2x * Math.sin(dotAngularRadius) * Math.sin(psi);
                            let rimY = y * Math.cos(dotAngularRadius) + t1y * Math.sin(dotAngularRadius) * Math.cos(psi) + t2y * Math.sin(dotAngularRadius) * Math.sin(psi);
                            let rimZ = z * Math.cos(dotAngularRadius) + t1z * Math.sin(dotAngularRadius) * Math.cos(psi) + t2z * Math.sin(dotAngularRadius) * Math.sin(psi);
                            // Normalize to sphere surface
                            let len = Math.sqrt(rimX * rimX + rimY * rimY + rimZ * rimZ);
                            rimX /= len; rimY /= len; rimZ /= len;
                            var pxr = cx + rimX * radius;
                            var pyr = cy + rimY * radius;
                            rim3D.push([pxr, pyr]);
                            if (pxr < minX) minX = pxr;
                            if (pxr > maxX) maxX = pxr;
                            if (pyr < minY) minY = pyr;
                            if (pyr > maxY) maxY = pyr;
                        }

                        // Improved filtering: Use PCA to measure major/minor axes of the rim ellipse
                        // Compute centroid
                        let sumX = 0, sumY = 0;
                        for (let j = 0; j < rim3D.length; j++) {
                            sumX += rim3D[j][0];
                            sumY += rim3D[j][1];
                        }
                        let meanX = sumX / rim3D.length;
                        let meanY = sumY / rim3D.length;
                        // Compute covariance matrix
                        let covXX = 0, covYY = 0, covXY = 0;
                        for (let j = 0; j < rim3D.length; j++) {
                            let dx = rim3D[j][0] - meanX;
                            let dy = rim3D[j][1] - meanY;
                            covXX += dx * dx;
                            covYY += dy * dy;
                            covXY += dx * dy;
                        }
                        covXX /= rim3D.length;
                        covYY /= rim3D.length;
                        covXY /= rim3D.length;
                        // Eigenvalues of 2x2 covariance matrix give squared axis lengths
                        let trace = covXX + covYY;
                        let det = covXX * covYY - covXY * covXY;
                        let lambda1 = trace / 2 + Math.sqrt((trace * trace) / 4 - det);
                        let lambda2 = trace / 2 - Math.sqrt((trace * trace) / 4 - det);
                        let majorAxis = 2 * Math.sqrt(Math.max(lambda1, lambda2));
                        let minorAxis = 2 * Math.sqrt(Math.min(lambda1, lambda2));
                        if (majorAxis === 0 || minorAxis / majorAxis < 0.2) {
                            continue; // Skip this dot
                        }

                        c.save();
                        c.beginPath();
                        c.moveTo(rim3D[0][0], rim3D[0][1]);
                        for (let j = 1; j < rim3D.length; j++) {
                            c.lineTo(rim3D[j][0], rim3D[j][1]);
                        }
                        c.closePath();
                        let distFromCenter = Math.sqrt((pxr - cx) ** 2 + (pyr - cy) ** 2);
                        let normDist = distFromCenter / radius;
                        if (roidFill.checked == true) {
                            let minWidth = 0.00001 * radius * cScale;
                            let maxWidth = 0.00004 * radius * cScale;
                            c.lineWidth = maxWidth - (maxWidth - minWidth) * normDist;
                            c.strokeStyle = `hsl(${roidHue}, 100%, ${roidLightness - 45}%, ${roidLightness - 20}%)`;
                            if (flashAmount > 0) {
                                let l = (1 - flashAmount) * (polkaPulseLightness - 20) + flashAmount * 100;
                                let a = (1 - flashAmount) * 0.7 + flashAmount * 1.0;
                                c.fillStyle = `hsla(${dotHue}, ${roidSaturation}%, ${l}%, ${a})`;
                                c.strokeStyle = `hsla(${dotHue}, ${roidSaturation}%, ${l}%, ${a})`;
                            } else {
                                c.fillStyle = `hsla(${dotHue}, ${roidSaturation + 10}%, ${polkaPulseLightness - 20}%, 70%)`;
                                c.strokeStyle = `hsl(${dotHue}, ${roidSaturation + 20}%, ${roidLightness - 20}%)`;
                            }
                            c.fill();
                        } else {
                            let minWidth = 0.00003 * radius * cScale;
                            let maxWidth = 0.0001 * radius * cScale;
                            c.lineWidth = maxWidth - (maxWidth - minWidth) * normDist;
                        }
                        c.stroke()
                        c.restore();
                    }
                }
                break; // Stop after the first successful (maximal) set
            }
        }
    }

    //  DRAW WIREFRAME ROIDS  --------------------
    function drawWireframeRoid(cx, cy, radius, originalRadius, hue, saturation, lightness, spinAngle = 0, orientation = {w:1,x:0,y:0,z:0}, flashPolkadots) {
        // Parametric globe-style wireframe (latitude & longitude) with front-hemisphere clipping
        c.save();
        // line width scales with roid size (radius is in pixels already)
        c.lineWidth = 0.02 * radius;
        c.strokeStyle = `hsl(${hue}, ${Math.max(30, Math.round(saturation))}%, ${Math.max(20, Math.round(lightness))}%)`;
        c.lineCap = 'round';

        // Use orthographic projection with equal X/Y scale so circles remain circular
        const verticalSquash = 1.0;
        // Helper: project 3D point (x,y,z) to screen (no non-uniform squash)
        function project(x, y, z) {
            const sx = cx + x;
            const sy = cy - y; // invert Y to canvas coords
            return { x: sx, y: sy, z: z };
        }

        // rotate by yaw (around Z), pitch (around X), roll (around Y)
        const spin = spinAngle || 0;

        function rotatePoint(x, y, z) {
            return quatRotateVec(orientation, x, y, z);
        }

        // Latitudes: FAINT background curves  ----------
        // generate symmetric latitudes about the equator so spacing is equal to poles
        const latStep = 20; 
        const maxLat = 60;  
        const latDegrees = [0];
        for (let d = latStep; d <= maxLat; d += latStep) {
            latDegrees.push(d, -d);
        }
        c.save();
        c.lineWidth = 0.015 * radius;
        c.strokeStyle = `hsla(${hue}, ${Math.max(30, Math.round(saturation))}%, ${Math.max(20, Math.round(lightness - 20))}%, 0.6)`;
        for (let li = 0; li < latDegrees.length; li++) {
            const phi = latDegrees[li] * Math.PI / 180;
            const rLat = radius * Math.cos(phi);
            const z0 = radius * Math.sin(phi);
            const steps = 96;
            let any = false;
            c.beginPath();
            for (let s = 0; s <= steps; s++) {
                const theta = (s / steps) * 2 * Math.PI + spin;
                const x0 = rLat * Math.cos(theta);
                const y0 = rLat * Math.sin(theta);
                const rot = rotatePoint(x0, y0, z0);
                const p = project(rot.x, rot.y, rot.z);
                if (s === 0) c.moveTo(p.x, p.y); else c.lineTo(p.x, p.y);
                any = true;
            }
            if (any) c.stroke();
        }

        // Longitudes: FAINT background  ----------
        const numLongBg = 12;
        const phiStepsBg = 80;
        for (let k = 0; k < numLongBg; k++) {
            const lambda = (k / numLongBg) * 2 * Math.PI + spin;
            c.beginPath();
            for (let pi = 0; pi <= phiStepsBg; pi++) {
                const phi = (-0.5 + pi / phiStepsBg) * Math.PI;
                const x0 = radius * Math.cos(phi) * Math.cos(lambda);
                const y0 = radius * Math.cos(phi) * Math.sin(lambda);
                const z0 = radius * Math.sin(phi);
                const rot = rotatePoint(x0, y0, z0);
                const p = project(rot.x, rot.y, rot.z);
                if (pi === 0) c.moveTo(p.x, p.y); else c.lineTo(p.x, p.y);
            }
            c.stroke();
        }
        c.restore();

        //  DRAW INNER ROID  ----------
        // Use the incoming hue/saturation/lightness parameters (avoid referencing
        // undefined variables from the polkadot routine). Compute a dotHue for
        // flash tinting and respect flashPolkadots argument.
        let flashAmount = 0;
        drawCircle(cx, cy, 0.0001 * cScale * cScale);
        if (typeof flashPolkadots === 'number') {
            flashAmount = Math.max(0, Math.min(1, flashPolkadots / 0.5));
        } else if (flashPolkadots === true) {
            flashAmount = 1;
        }

        // Map local names used by the polkadot code to the parameters passed in
        const roidHue = hue;
        const roidSaturation = saturation;
        const roidLightness = lightness;
        // Default dot hue (unused when flashing red)
        const dotHue = (roidHue + 90) % 360;

        if (flashAmount > 0) {
            // Blink pattern: 3 quick red blinks over the standard flash duration.
            const BLINK_COUNT = 3;
            const BLINK_TOTAL = 0.5; // default per-code assignments use 0.5
            // remaining timer is provided as flashPolkadots (or derived numeric)
            let tRemaining = (typeof flashPolkadots === 'number') ? flashPolkadots : (flashAmount > 0 ? BLINK_TOTAL * flashAmount : 0);
            let elapsed = Math.max(0, BLINK_TOTAL - tRemaining);
            let blinkPeriod = BLINK_TOTAL / BLINK_COUNT;
            let within = elapsed % blinkPeriod;
            // show flash for first half of each blinkPeriod
            let showFlashThisFrame = (within / blinkPeriod) < 0.5;

            // When showing, use a strong red highlight; otherwise use normal shading.
            if (showFlashThisFrame) {
                const redHue = 60;
                const redSat = 100;
                // make the flash bright and opaque
                let l = 90;
                let a = 1.0;
                c.fillStyle = `hsla(${redHue}, ${redSat}%, ${l}%, ${a})`;
                var highlight = `hsla(${redHue}, ${redSat}%, ${l}%, ${a})`;
                var midtone = `hsla(${redHue}, ${Math.max(30, redSat - 40)}%, ${Math.max(0, l - 40)}%, ${a})`;
                var shadow = `hsl(0, 0%, 10%)`;
            } else {
                var highlight = `hsla(0, 0%, 100%)`;
                var midtone = `hsla(0, 0%, 50%)`;
                var shadow = `hsl(0, 0%, 10%)`;
            }
        } else {
            var highlight = `hsla(0, 0%, 100%)`;
            var midtone = `hsla(0, 0%, 50%)`;
            var shadow = `hsl(0, 0%, 10%)`;
        }
        var sphereGradient = c.createRadialGradient(
                (cx - 0.2 * (0.3 * originalRadius)),
                (cy - 0.2 * (0.5 * originalRadius)),
                0,
                (cx - 0.2 * (0.3 * originalRadius)),
                (cy - 0.2 * (0.5 * originalRadius)),
                0.3 * originalRadius);
        sphereGradient.addColorStop(0.0, highlight);
        sphereGradient.addColorStop(0.5, midtone);
        sphereGradient.addColorStop(1.0, shadow);
        c.fillStyle = sphereGradient;
        c.fill();

        // Now draw BRIGHT front-facing arcs on top
        for (let li = 0; li < latDegrees.length; li++) {
            const phi = latDegrees[li] * Math.PI / 180; // latitude angle
            const rLat = radius * Math.cos(phi);
            const z0 = radius * Math.sin(phi);
            const steps = 96;
            let started = false;
            let any = false;
            c.beginPath();
            for (let s = 0; s <= steps; s++) {
                const theta = (s / steps) * 2 * Math.PI + spin;
                const x0 = rLat * Math.cos(theta);
                const y0 = rLat * Math.sin(theta);
                const rot = rotatePoint(x0, y0, z0);
                if (rot.z > 0.0001) {
                    const p = project(rot.x, rot.y, rot.z);
                    if (!started) {
                        c.moveTo(p.x, p.y);
                        started = true;
                    } else {
                        c.lineTo(p.x, p.y);
                    }
                    any = true;
                } else {
                    // allow future re-entry: finish current subpath and continue
                    started = false;
                }
            }
            if (any) {
                c.lineWidth = 0.02 * radius;
                c.strokeStyle = `hsl(${hue}, ${Math.max(30, Math.round(saturation))}%, ${Math.max(20, Math.round(lightness))}%)`;
                c.stroke();
            }
        }

        // Longitudes (meridians): draw arcs that are on the front hemisphere (z>0). These vary in z with latitude.
        const numLong = 12;
        const phiSteps = 80;
        for (let k = 0; k < numLong; k++) {
            const lambda = (k / numLong) * 2 * Math.PI + spin; // longitude
            let started = false;
            let any = false;
            c.beginPath();
            for (let pi = 0; pi <= phiSteps; pi++) {
                // phi: -pi/2 .. +pi/2
                const phi = (-0.5 + pi / phiSteps) * Math.PI;
                const x0 = radius * Math.cos(phi) * Math.cos(lambda);
                const y0 = radius * Math.cos(phi) * Math.sin(lambda);
                const z0 = radius * Math.sin(phi);
                const rot = rotatePoint(x0, y0, z0);
                if (rot.z > 0.0001) {
                    const p = project(rot.x, rot.y, rot.z);
                    if (!started) {
                        c.moveTo(p.x, p.y);
                        started = true;
                    } else {
                        c.lineTo(p.x, p.y);
                    }
                    any = true;
                } else {
                    // allow re-entry later: finish current subpath
                    started = false;
                }
            }
            if (any) {
                c.lineWidth = 0.02 * radius;
                c.strokeStyle = `hsl(${hue}, ${Math.max(30, Math.round(saturation))}%, ${Math.max(20, Math.round(lightness))}%)`;
                c.stroke();
            }
        }
        c.restore();

        // Draw outer silhouette (rim) as a circle so the roid reads round
        c.lineWidth = 0.02 * radius;
        c.strokeStyle = `hsl(${hue}, ${Math.max(30, Math.round(saturation))}%, ${Math.max(20, Math.round(lightness))}%)`;
        c.lineCap = 'round';  
        c.beginPath();
        c.arc(cx, cy, radius, 0, 2 * Math.PI);
        c.stroke();
    }

    //  DEFINE CLASSES -----------------------------------------------------------------
    
    //  DEFINE STARS FOR BACKGROUND  -----------------
    class STAR {
        constructor(pos, radius, hue, lightness, velY, falling) {
            this.pos = pos.clone();
            this.radius = radius;
            this.hue = hue;
            this.lightness = lightness;
            this.velY = velY;
            this.falling = falling;
        }
        simulate() {
            this.velY += 0.005;
            this.pos.y += this.velY * this.velY * dT;
        }     
        draw(n) {
            offscreenStarfieldCtx.beginPath();
            offscreenStarfieldCtx.arc(this.pos.x * cScale, this.pos.y * cScale,
            this.radius, 0, 2*Math.PI)
            offscreenStarfieldCtx.fillStyle = `hsl(${this.hue}, 10%, ${this.lightness*100}%)`
            offscreenStarfieldCtx.closePath();
            offscreenStarfieldCtx.fill();
        }
        drawForReal(n) {
            c.beginPath();
            c.arc(this.pos.x * cScale, this.pos.y * cScale,
            this.radius, 0, 2*Math.PI)
            c.fillStyle = `hsl(${this.hue}, 10%, ${this.lightness*100}%)`
            c.closePath();
            c.fill();
        }
    }

    //  SPAWN SOLO ALIEN  ----------
    function spawnSoloAlien(pos) {
        // spawn alien
        var pos = pos.clone();
        var radius = 0.1;
        var flyTo = new Vector2(
            0.2 * simWidth + 0.6 * simWidth * Math.random(),
            1.0 * simHeight);
        var vel = new Vector2(); 
        vel.subtract(flyTo, pos);
        vel.scale(0.002);
        var lol = true;
        var birthday = Date.now();
        trash = SmackTalk[Math.floor(Math.random() * SmackTalk.length)];

        Alien.push(new ALIEN(pos, vel, radius, lol, birthday));
    }

    //  DEFINE SOLO ALIEN  ---------------------
    class ALIEN {
        constructor(pos, vel, radius, lol, birthday) {
            this.pos = pos.clone();
            this.vel = vel.clone();
            this.radius = radius;
            this.lol = lol;
            this.birthday = birthday;
        }
        simulate() {
            this.pos.add(this.vel, dT);
            this.age = (Date.now() - this.birthday) / 1000;
            this.vel.scale(1.05);

            this.radius += 0.005;
            if (this.pos.x > simWidth + this.radius ||
                this.pos.x < 0 - this.radius ||
                this.pos.y > simHeight + this.radius ||
                this.pos.y < 0 - this.radius) {
                    Alien = [];
            }
        }
        draw() {
            // START OF SOLO ALIEN--------------------
            //  LAUGH  -----------
            if (this.lol == true) {
                lol += 0.8 * Math.random();
                lolX += 0.2 * Math.random();
                lolAdjY = 2.5 * Math.abs(Math.cos(lol));
                lolAdjX = 5.0 * Math.abs(Math.sin(lolX));
                
                toothAdj = 0.02 * this.radius + 0.05 * this.radius * Math.abs(Math.cos(lol));
            } else {
                lolAdjX = 1;
                lolAdjY = 1;
                toothAdj = 0;
                lolTime = 1.0 + 3.0 * Math.random();
            }
            //  left arm ----------
            if (leftArmAngle >= 1.1 * Math.PI) {
                leftArmAngle -= 0.07 * Math.random();
                wavingForward = false;
            } else
            if (leftArmAngle <= 1.0 * Math.PI) {
                leftArmAngle += 0.07 * Math.random();;
                wavingForward = true;
            } else
            if (leftArmAngle > 0.95  * Math.PI && leftArmAngle < 1.3  * Math.PI && wavingForward == true) {
                leftArmAngle += 0.07 * Math.random();;
            } else {
                leftArmAngle -= 0.07 * Math.random();;
            } 
            var armCos = Math.cos(leftArmAngle);
            var armSin = Math.sin(leftArmAngle);

            c.strokeStyle = 'hsl(110, 50%, 40%)';
            c.lineWidth = 0.04 * this.radius * cScale;
            c.beginPath();
            c.moveTo(this.pos.x * cScale, (this.pos.y - 0.1 * this.radius) * cScale);
            c.lineTo((this.pos.x + 0.4 * this.radius * armCos) * cScale, ((this.pos.y - 0.1 * this.radius) + 0.4 * this.radius * armSin) * cScale);
            c.closePath();
            c.stroke();

            drawHand(
                (this.pos.x + 0.9*0.4 * this.radius * armCos) * cScale, 
                ((this.pos.y - 0.9*0.1 * this.radius) + 0.4 * this.radius * armSin) * cScale, 
                leftArmAngle,
                this.radius * cScale,
                [1.3, 0.3, -0.5]);

            //  right arm ----------
            if (rightArmAngle >= 0 * Math.PI) {
                rightArmAngle -= 0.07 * Math.random();
                wavingForward = false;
            } else
            if (rightArmAngle <= -0.2 * Math.PI) {
                rightArmAngle += 0.07 * Math.random();;
                wavingForward = true;
            } else
            if (rightArmAngle > -0.2 * Math.PI && rightArmAngle < 0 * Math.PI && wavingForward == true) {
                rightArmAngle += 0.07 * Math.random();;
            } else {
                rightArmAngle -= 0.07 * Math.random();;
            } 
            var armCos = Math.cos(rightArmAngle);
            var armSin = Math.sin(rightArmAngle);

            c.beginPath();
            c.moveTo(this.pos.x * cScale, (this.pos.y - 0.1 * this.radius) * cScale);
            c.lineTo((this.pos.x + 0.4 * this.radius * armCos) * cScale, ((this.pos.y - 0.1 * this.radius) + 0.4 * this.radius * armSin) * cScale);
            c.closePath();
            c.stroke();

            drawHand(
                (this.pos.x + 0.9*0.4 * this.radius * armCos) * cScale, 
                ((this.pos.y - 0.9*0.1 * this.radius) + 0.4 * this.radius * armSin) * cScale, 
                rightArmAngle,
                this.radius * cScale,
                [-1.2, -0.4, 0.4]);   

            function drawHand(x, y, angle, radius, fingerAngles) {
                c.save();
                c.translate(x, y);
                c.rotate(angle);

                var fingerLength;
                var tipRadius;
                for (let i = 0; i < 3; i++) {
                    if (i == 0) {
                        c.lineWidth = 0.000081 * radius * cScale;
                        fingerLength = .1 * radius; 
                        tipRadius = .025 * radius; // Thumb
                    } else {
                        c.lineWidth = 0.00005 * radius * cScale;
                        fingerLength = .15 * radius;
                        tipRadius = .02 * radius;  // Other fingers
                    }
                    
                c.save();
                c.rotate(fingerAngles[i]);

                // First segment
                c.beginPath();
                c.moveTo(0, 0);
                c.lineTo(fingerLength, 0);
                c.stroke();

                // Fingertip
                c.beginPath();
                c.arc(fingerLength, 0, tipRadius, 0, 2 * Math.PI);
                c.fillStyle = 'yellow';
                c.fill();

                c.restore();
                }

                c.restore();
            }

            //  left leg ----------
            if (leftLegAngle >= 0.9 * Math.PI) {
                leftLegAngle -= 0.1;
                wavingForward = false;
            } else
            if (leftLegAngle <= 0.7 * Math.PI) {
                leftLegAngle += 0.1;
                wavingForward = true;
            } else
            if (leftLegAngle > 0.7 * Math.PI && leftLegAngle < 0.9 * Math.PI && wavingForward == true) {
                leftLegAngle += 0.1;
            } else {
                leftLegAngle -= 0.1;
            } 
            var armCos = Math.cos(leftLegAngle);
            var armSin = Math.sin(leftLegAngle);

            /*//  left sole  ----------
            c.strokeStyle = 'hsl(0, 0%, 70%)';
            c.lineWidth = 0.13 * this.radius * cScale;
            c.beginPath();
            c.moveTo((this.pos.x + 0.30 * this.radius * armCos) * cScale, ((this.pos.y + 0.3 * this.radius) + 0.30 * this.radius * armSin) * cScale);
            c.lineTo((this.pos.x + 0.32 * this.radius * armCos) * cScale, ((this.pos.y + 0.3 * this.radius) + 0.32 * this.radius * armSin) * cScale);
            c.closePath();
            c.stroke();*/

            //  left leg  ----------
            c.strokeStyle = 'hsl(110, 50%, 15%)';
            c.lineWidth = 0.08 * this.radius * cScale;
            c.beginPath();
            c.moveTo((this.pos.x - 0.1 * this.radius) * cScale, (this.pos.y + 0.3 * this.radius) * cScale);
            c.lineTo((this.pos.x + 0.3 * this.radius * armCos) * cScale, ((this.pos.y + 0.3 * this.radius) + 0.3 * this.radius * armSin) * cScale);
            c.closePath();
            c.stroke();
  
            // Curly jester's left shoe (smaller)
            const leftLegEndX = this.pos.x + 0.3 * this.radius * armCos;
            const leftLegEndY = (this.pos.y + 0.3 * this.radius) + 0.3 * this.radius * armSin;
            const leftAnkleLen = 0.035 * this.radius;
            // Offset ankle to back of leg by half leg thickness
            const legThickness = 0.08 * this.radius; // matches c.lineWidth for leg
            const perpX = Math.cos(leftLegAngle + Math.PI / 2);
            const perpY = Math.sin(leftLegAngle + Math.PI / 2);
            const leftAnkleX = leftLegEndX - leftAnkleLen * Math.sin(leftLegAngle) - 0.5 * legThickness * perpX;
            const leftAnkleY = leftLegEndY + leftAnkleLen * Math.cos(leftLegAngle) - 0.5 * legThickness * perpY;
            const curlLen = 0.09 * this.radius;
            // Rotate left shoe 30 degrees (Ï€/6) away from the leg
            const shoeOffset = Math.PI / 6;
            // Move left shoe inward by 20% of curlLen
            function lerp(a, b, t) { return a + (b - a) * t; }
            const ctrlX_raw = leftAnkleX - curlLen * Math.sin(leftLegAngle - 0.7 + shoeOffset);
            const ctrlY_raw = leftAnkleY + curlLen * Math.cos(leftLegAngle - 0.7 + shoeOffset);
            const tipX_raw = leftAnkleX - curlLen * Math.sin(leftLegAngle - 1.2 + shoeOffset);
            const tipY_raw = leftAnkleY + curlLen * Math.cos(leftLegAngle - 1.2 + shoeOffset);
            const inwardT = 0.2;
            const curlCtrlX = lerp(ctrlX_raw, leftAnkleX, inwardT);
            const curlCtrlY = lerp(ctrlY_raw, leftAnkleY, inwardT);
            const curlTipX = lerp(tipX_raw, leftAnkleX, inwardT);
            const curlTipY = lerp(tipY_raw, leftAnkleY, inwardT);
            c.save();
            c.beginPath();
            c.moveTo(leftLegEndX * cScale, leftLegEndY * cScale);
            c.lineTo(leftAnkleX * cScale, leftAnkleY * cScale);
            c.quadraticCurveTo(curlCtrlX * cScale, curlCtrlY * cScale, curlTipX * cScale, curlTipY * cScale);
            c.lineWidth = 0.065 * this.radius * cScale;
            c.strokeStyle = 'hsl(0, 50%, 50%)'
            c.stroke();
            /*// Bell at tip
            c.beginPath();
            c.arc(curlTipX * cScale, curlTipY * cScale, 0.0125 * this.radius * cScale, 0, 2 * Math.PI);
            c.fillStyle = 'hsl(0, 0%, 20%)';
            c.fill();
            c.restore();*/

            //  right leg ----------
            if (rightLegAngle >= 0.3 * Math.PI) {
                rightLegAngle -= 0.1;
                wavingForward = false;
            } else
            if (rightLegAngle <= 0.1 * Math.PI) {
                rightLegAngle += 0.1;
                wavingForward = true;
            } else
            if (rightLegAngle > 0.1 * Math.PI && rightLegAngle < 0.3 * Math.PI && wavingForward == true) {
                rightLegAngle += 0.1;
            } else {
                rightLegAngle -= 0.1;
            } 
            armCos = Math.cos(rightLegAngle);
            armSin = Math.sin(rightLegAngle);

            /*//  right sole  ----------
            c.lineWidth = 0.13 * this.radius * cScale;
            c.strokeStyle = 'hsl(0, 0%, 70%)';
            c.beginPath();
            c.moveTo((this.pos.x + 0.30 * this.radius * armCos) * cScale, ((this.pos.y + 0.3 * this.radius) + 0.30 * this.radius * armSin) * cScale);
            c.lineTo((this.pos.x + 0.32 * this.radius * armCos) * cScale, ((this.pos.y + 0.3 * this.radius) + 0.32 * this.radius * armSin) * cScale);
            c.closePath();
            c.stroke();*/

            //  right leg  ----------
            c.lineWidth = 0.08 * this.radius * cScale;
            c.strokeStyle = 'hsl(110, 50%, 15%)';
            c.beginPath();
            c.moveTo((this.pos.x + 0.1 * this.radius) * cScale, (this.pos.y + 0.3 * this.radius) * cScale);
            c.lineTo((this.pos.x + 0.3 * this.radius * armCos) * cScale, ((this.pos.y + 0.3 * this.radius) + 0.3 * this.radius * armSin) * cScale);
            c.closePath();
            c.stroke();

            // Curly jester's right shoe (smaller)
            const rightLegEndX = this.pos.x + 0.3 * this.radius * armCos;
            const rightLegEndY = (this.pos.y + 0.3 * this.radius) + 0.3 * this.radius * armSin;
            const rightAnkleLen = 0.035 * this.radius;
            // Offset ankle to back of leg by half leg thickness
            const rlegThickness = 0.08 * this.radius; // matches c.lineWidth for leg
            const rperpX = Math.cos(rightLegAngle - Math.PI / 2);
            const rperpY = Math.sin(rightLegAngle - Math.PI / 2);
            const rightAnkleX = rightLegEndX + rightAnkleLen * Math.sin(rightLegAngle) - 0.5 * rlegThickness * rperpX;
            const rightAnkleY = rightLegEndY - rightAnkleLen * Math.cos(rightLegAngle) - 0.5 * rlegThickness * rperpY;
            const rcurlLen = 0.09 * this.radius;
            // Rotate right shoe 30 degrees (Ï€/6) away from the leg
            // Move right shoe inward by 20% of rcurlLen
            const rctrlX_raw = rightAnkleX + rcurlLen * Math.sin(rightLegAngle + 0.7 - shoeOffset);
            const rctrlY_raw = rightAnkleY - rcurlLen * Math.cos(rightLegAngle + 0.7 - shoeOffset);
            const rtipX_raw = rightAnkleX + rcurlLen * Math.sin(rightLegAngle + 1.2 - shoeOffset);
            const rtipY_raw = rightAnkleY - rcurlLen * Math.cos(rightLegAngle + 1.2 - shoeOffset);
            const rcurlCtrlX = lerp(rctrlX_raw, rightAnkleX, inwardT);
            const rcurlCtrlY = lerp(rctrlY_raw, rightAnkleY, inwardT);
            const rcurlTipX = lerp(rtipX_raw, rightAnkleX, inwardT);
            const rcurlTipY = lerp(rtipY_raw, rightAnkleY, inwardT);
            c.save();
            c.beginPath();
            c.moveTo(rightLegEndX * cScale, rightLegEndY * cScale);
            c.lineTo(rightAnkleX * cScale, rightAnkleY * cScale);
            c.quadraticCurveTo(rcurlCtrlX * cScale, rcurlCtrlY * cScale, rcurlTipX * cScale, rcurlTipY * cScale);
            c.lineWidth = 0.065 * this.radius * cScale;
            c.strokeStyle = 'hsl(0, 50%, 50%)'
            c.stroke();
            /*// Bell at tip
            c.beginPath();
            c.arc(rcurlTipX * cScale, rcurlTipY * cScale, 0.0125 * this.radius * cScale, 0, 2 * Math.PI);
            c.fillStyle = 'hsl(0, 0%, 20%)';
            //c.fill();
            c.restore();*/

            //  RAISE EYEBROWS  ----------
            if (this.vel.x >= 0) {
                eyeLiftL = 0;
                eyeLiftR = -0.03 * this.radius;
            } else {
                eyeLiftL = -0.03 * this.radius;
                eyeLiftR = 0;
            }
            
            // antennas  ----------
            c.fillStyle = 'green';
            c.strokeStyle = 'cyan';
            c.lineWidth = 0.015 * this.radius * cScale;
            c.beginPath();
            //  left  ----------
            c.moveTo((this.pos.x - 0.04 * this.radius) * cScale, (this.pos.y - 0.2 * this.radius) * cScale);
            c.lineTo((this.pos.x - 0.13 * this.radius) * cScale, (this.pos.y - 0.44 * this.radius) * cScale);
            c.lineTo((this.pos.x - 0.22 * this.radius) * cScale, (this.pos.y - 0.4 * this.radius) * cScale);
            //  middle  ----------
            c.moveTo(this.pos.x * cScale, (this.pos.y - 0.2 * this.radius) * cScale);
            c.lineTo(this.pos.x * cScale, (this.pos.y - 0.5 * this.radius) * cScale);
            //  right  ----------
            c.moveTo((this.pos.x + 0.04 * this.radius) * cScale, (this.pos.y - 0.2 * this.radius) * cScale);
            c.lineTo((this.pos.x + 0.18 * this.radius) * cScale, (this.pos.y - 0.5 * this.radius) * cScale);
            c.stroke();

            //  antenna knobs  ----------
            c.strokeStyle = 'green';
            knobLight += 0.01;
            var knobHue = 360 * Math.cos(knobLight);
            //  right
            c.fillStyle = `hsl(${90 + knobHue}, 90%, 50%)`;
            drawCircle((this.pos.x + 0.18 * this.radius) * cScale, (this.pos.y - 0.5 * this.radius) * cScale, 0.045 * this.radius * cScale);
            c.fill();
            drawCircle((this.pos.x + 0.18 * this.radius) * cScale, (this.pos.y - 0.5 * this.radius) * cScale, 0.045 * this.radius * cScale);
            c.stroke();
            //  middle
            c.fillStyle = `hsl(${180 + knobHue}, 90%, 50%)`;
            drawCircle(this.pos.x * cScale, (this.pos.y - 0.5 * this.radius) * cScale, 0.045 * this.radius * cScale);
            c.fill();
            drawCircle(this.pos.x * cScale, (this.pos.y - 0.5 * this.radius) * cScale, 0.045 * this.radius * cScale);
            c.stroke();
            //  left
            drawCircle((this.pos.x - 0.22 * this.radius) * cScale, (this.pos.y - 0.4 * this.radius) * cScale, 0.045 * this.radius * cScale);
            if (knobOn == true) {
                knobCounter += 1;
                if (knobCounter <= knobOffCycles) {
                    c.fillStyle = `hsl(${270 + knobHue}, 30%, 40%)`;
                    c.fill();
                } else {
                    c.fillStyle = `black`;
                    c.fill();
                    knobOn = false;
                    needNewCycleCounter = true;
                    knobCounter = 0;
                }
            } 
            if (needNewCycleCounter == true) {
                knobOn = true;
                knobOffCycles = Math.floor(2 * Math.random());
                needNewCycleCounter = false;
            }
            drawCircle((this.pos.x - 0.22 * this.radius) * cScale, (this.pos.y - 0.4 * this.radius) * cScale, 0.045 * this.radius * cScale);
            c.stroke();
            
            //  head/body  ----------
            drawVertEllipse(this.pos.x * cScale, (this.pos.y) * cScale, 0.4 * this.radius * cScale);
            var sphereGradient = c.createRadialGradient(
                (this.pos.x - (0.0 * this.radius)) * cScale, 
                (this.pos.y - (0.45 * this.radius)) * cScale, 
                0.1 * this.radius * cScale, 
                (this.pos.x - (0.0 * this.radius)) * cScale, 
                (this.pos.y - (0.45 * this.radius)) * cScale, 
                0.5 * this.radius * cScale);
                
            var highlight = `hsl(110, 100%, 50%)`;
            var midtone = `hsl(110, 50%, 30%)`;
            var shadow = `hsl(110, 50%, 15%)`;
            sphereGradient.addColorStop(0.0, highlight);
            sphereGradient.addColorStop(0.5, midtone);
            sphereGradient.addColorStop(1.0, shadow);
            c.fillStyle = sphereGradient;
            c.fill();

            //  underpants  ----------
            /*
            //c.fillStyle = 'hsl(0, 0%, 90%)';
            //c.strokeStyle = 'hsl(0, 0%, 90%)';
            //c.lineWidth = 0.01 * this.radius * cScale;

            drawCircle( // left
                (this.pos.x - 0.26 * this.radius) * cScale,
                (this.pos.y + 0.15 * this.radius) * cScale,
                0.02 * this.radius * cScale);
            c.fill();

            drawCircle(  // right
                (this.pos.x + 0.26 * this.radius) * cScale,
                (this.pos.y + 0.15 * this.radius) * cScale,
                0.02 * this.radius * cScale);
            c.fill();

            drawCircle(  // top of right leg hole
                (this.pos.x + 0.20 * this.radius) * cScale,
                (this.pos.y + 0.27 * this.radius) * cScale,
                0.02 * this.radius * cScale);
            c.fill();

            drawCircle(  // bottom of right leg hole
                (this.pos.x + 0.10 * this.radius) * cScale,
                (this.pos.y + 0.37 * this.radius) * cScale,
                0.02 * this.radius * cScale);
            c.fill();

            drawCircle(  // bottom of left leg hole
                (this.pos.x - 0.10 * this.radius) * cScale,
                (this.pos.y + 0.37 * this.radius) * cScale,
                0.02 * this.radius * cScale);
            c.fill();

            drawCircle(  // top of left leg hole
                (this.pos.x - 0.20 * this.radius) * cScale,
                (this.pos.y + 0.27 * this.radius) * cScale,
                0.02 * this.radius * cScale);
            c.fill();

             drawCircle(  // top of left leg hole
                this.pos.x * cScale,
                (this.pos.y - 0.05 * this.radius) * cScale,
                0.02 * this.radius * cScale);
            c.fill();
            */

            c.beginPath();
            c.moveTo(
                (this.pos.x - 0.26 * this.radius) * cScale,
                (this.pos.y + 0.15 * this.radius) * cScale)
            c.arcTo(  // top of right waistband
                this.pos.x * cScale,
                (this.pos.y + 0.25 * this.radius) * cScale,
                (this.pos.x + 0.26 * this.radius) * cScale,
                (this.pos.y + 0.15 * this.radius) * cScale,
                0.7 * this.radius * cScale);
            c.arcTo(  // right waist
                (this.pos.x + 0.27 * this.radius) * cScale,
                (this.pos.y + 0.24 * this.radius) * cScale,
                (this.pos.x + 0.20 * this.radius) * cScale,
                (this.pos.y + 0.27 * this.radius) * cScale,
                0.1 * this.radius * cScale);
            c.arcTo(  // right leg
                (this.pos.x + 0.06 * this.radius) * cScale,
                (this.pos.y + 0.25 * this.radius) * cScale,
                (this.pos.x + 0.10 * this.radius) * cScale,
                (this.pos.y + 0.37 * this.radius) * cScale,
                0.08 * this.radius * cScale);
            c.arcTo(  // crotch
                this.pos.x * cScale,
                (this.pos.y + 0.45 * this.radius) * cScale,
                (this.pos.x - 0.10 * this.radius) * cScale,
                (this.pos.y + 0.37 * this.radius) * cScale,
                0.15 * this.radius * cScale);
            c.arcTo(  // left leg
                (this.pos.x - 0.09 * this.radius) * cScale,
                (this.pos.y + 0.22 * this.radius) * cScale, 
                (this.pos.x - 0.20 * this.radius) * cScale,
                (this.pos.y + 0.27 * this.radius) * cScale,
                0.08 * this.radius * cScale);
            c.arcTo(  // left waist
                (this.pos.x - 0.28 * this.radius) * cScale,
                (this.pos.y + 0.25 * this.radius) * cScale,
                (this.pos.x - 0.26 * this.radius) * cScale,
                (this.pos.y + 0.15 * this.radius) * cScale,
                0.1 * this.radius * cScale);
            c.closePath();

            var rainbowpants = c.createLinearGradient((
                this.pos.x - 0.2 * this.radius) * cScale, 
                0, 
                (this.pos.x + 0.4 * this.radius) * cScale, 
                0);
            for (col = 0; col <= 360; col += 30) {
                rainbowpants.addColorStop(col / 360, `hsl(${col}, 100%, 50%)`);
                if (col + 15 <= 360) {
                    rainbowpants.addColorStop((col + 15) / 360, `hsl(${col}, 100%, 50%)`);
                }
            }
            c.lineWidth = .01 * this.radius * cScale;
            if (weaponLevel < 7) {
                c.fillStyle = 'hsl(0, 0%, 40%)';
            } else {
                c.fillStyle = rainbowpants;
            }
            
            c.strokeStyle = 'hsl(0, 0%, 10%)';
            c.fill();
            c.stroke();

            c.beginPath();
            c.moveTo(
                (this.pos.x - 0.26 * this.radius) * cScale,
                (this.pos.y + 0.15 * this.radius) * cScale)
            c.arcTo(  // top of right waistband
                this.pos.x * cScale,
                (this.pos.y + 0.25 * this.radius) * cScale,
                (this.pos.x + 0.26 * this.radius) * cScale,
                (this.pos.y + 0.15 * this.radius) * cScale,
                0.7 * this.radius * cScale);
            c.lineWidth = .03 * this.radius * cScale;
            c.strokeStyle = 'hsl(0, 0%, 80%)';
            c.stroke();
            c.beginPath();
            
            c.lineWidth = .01 * this.radius * cScale;
            c.strokeStyle = 'hsl(0, 0%, 10%)';
            c.beginPath();
            c.arc((this.pos.x - 0.49 * this.radius) * cScale, (this.pos.y + 0.3 * this.radius) * cScale, 0.5 * this.radius * cScale, -0.18, 0.21);
            c.stroke();
            
            c.beginPath();
            c.arc((this.pos.x + 0.01 * this.radius) * cScale, (this.pos.y + 0.32 * this.radius) * cScale, 0.03 * this.radius * cScale, -4.7, -1.5, true);
            c.stroke();
            
            //  mouth  ----------
            c.fillStyle = 'black';
            drawCustomEllipse2(
                this.pos.x * cScale, 
                (this.pos.y + 0.01 * this.radius) * cScale, 
                (0.12 * this.radius + lolAdjX * 0.02 * this.radius) * cScale, 
                (0.12 * this.radius + lolAdjY * 0.02 * this.radius) * cScale);
            c.fill();

            //  toofs  ----------
            c.fillStyle = 'hsl(0, 0%, 90%)';
            
            // Mouth parameters (should match your drawCustomEllipse2 call)
            const mouthCenterX = this.pos.x;
            const mouthCenterY = this.pos.y + 0.01 * this.radius;
            const mouthRadiusX = 0.12 * this.radius + lolAdjX * 0.02 * this.radius;
            const mouthRadiusY = 0.12 * this.radius + lolAdjY * 0.02 * this.radius;

            // Helper to get Y on the ellipse for a given X
            function mouthEdgeY(x) {
                const dx = (x - mouthCenterX) / mouthRadiusX;
                if (Math.abs(dx) > 1) return mouthCenterY; // outside ellipse
                return mouthCenterY - Math.sqrt(1 - dx * dx) * mouthRadiusY;
            }

            // right toof
            const toofX = this.pos.x + 0.06 * this.radius;
            const toofY = mouthEdgeY(toofX) + 0.02 * this.radius; // 0.02 for tooth height offset
            c.beginPath();
            c.moveTo(
                toofX * cScale, (toofY + 0.08 * this.radius) * cScale);
            c.lineTo(
                (toofX + 0.04 * this.radius) * cScale, (toofY + 0.0 * this.radius) * cScale);
            c.lineTo(
                (toofX - 0.04 * this.radius) * cScale, (toofY + 0.0 * this.radius) * cScale);
            c.closePath();
            c.fill();

            //  tongue  ----------
            c.fillStyle = 'darkred';
            drawCustomEllipse2(
                this.pos.x * cScale, 
                (this.pos.y + 0.03 * this.radius + lolAdjY * 0.02 * this.radius) * cScale, 
                (0.08 * this.radius + lolAdjX * 0.01 * this.radius) * cScale, 
                (0.03 * this.radius + lolAdjX * 0.003 * this.radius)* cScale);
            c.fill();

            //  lips  ----------
            c.lineWidth = .03 * this.radius * cScale;
            //c.strokeStyle = 'hsl(0, 100%, 50%)';
            c.strokeStyle = 'hsl(330, 75%, 35%)';
            drawCustomEllipse2(
                this.pos.x * cScale, 
                (this.pos.y + 0.01 * this.radius) * cScale, 
                (0.11 * this.radius + lolAdjX * 0.02 * this.radius) * cScale, 
                (0.11 * this.radius + lolAdjY * 0.02 * this.radius) * cScale);
            c.shadowBlur = 10 * this.radius;
            c.stroke();
            
            //  lips inner shadow ----------
            c.lineWidth = .01 * this.radius * cScale;
            //c.strokeStyle = 'hsl(0, 100%, 50%)';
            c.strokeStyle = 'hsla(0, 0%, 0%, 0%)';
            drawCustomEllipse2(
                this.pos.x * cScale, 
                (this.pos.y + 0.01 * this.radius) * cScale, 
                (0.10 * this.radius + lolAdjX * 0.02 * this.radius) * cScale, 
                (0.10 * this.radius + lolAdjY * 0.02 * this.radius) * cScale);
                c.shadowBlur = 5 * this.radius;
                c.stroke();
                c.shadowBlur = 0;
            
            //  eyebrows  ----------
            c.lineWidth = .03 * this.radius * cScale;
            c.strokeStyle = 'black'
            c.beginPath();
            c.moveTo((this.pos.x + 0.04 * this.radius) * cScale, (this.pos.y - 0.22*(1.02) * this.radius) * cScale);
            c.lineTo((this.pos.x + 0.13 * this.radius) * cScale, (this.pos.y - 0.26*(1.07) * this.radius + eyeLiftR) * cScale);
            c.moveTo((this.pos.x - 0.04 * this.radius) * cScale, (this.pos.y - 0.22*(1.02) * this.radius) * cScale);
            c.lineTo((this.pos.x - 0.13 * this.radius) * cScale, (this.pos.y - 0.26*(1.07) * this.radius + eyeLiftL) * cScale);
            c.closePath();
            c.stroke();

            //  eyes  ----------
            c.lineWidth = .04 * this.radius * cScale;
            c.strokeStyle = 'white'
            c.beginPath();
            c.moveTo((this.pos.x + 0.04 * this.radius) * cScale, (this.pos.y - 0.22 * this.radius) * cScale);
            c.lineTo((this.pos.x + 0.13 * this.radius) * cScale, (this.pos.y - 0.25 * this.radius + eyeLiftR) * cScale);
            c.moveTo((this.pos.x - 0.04 * this.radius) * cScale, (this.pos.y - 0.22 * this.radius) * cScale);
            c.lineTo((this.pos.x - 0.13 * this.radius) * cScale, (this.pos.y - 0.25 * this.radius + eyeLiftL) * cScale);
            c.closePath();
            c.stroke();

            //  pupils  ----------
            eyeRoll += 0.3;
            //  left eye ----------
            var xCos = this.pos.x + 0.005 * Math.cos(eyeRoll);
            var ySin = this.pos.y + 0.005 * Math.sin(eyeRoll);
            drawCircle((xCos + 0.07 * this.radius) * cScale, (ySin - 0.23 * this.radius) * cScale, (0.035 * this.radius + 0.4 * Math.abs(eyeLiftR) * this.radius) * cScale);
            c.shadowColor = 'black';
            c.shadowBlur = 10;
            c.shadowOffsetX = 2 * this.radius;
            c.shadowOffsetY = 5 * this.radius;
            c.fillStyle = 'hsl(0, 0%, 90%)';
            c.fill();
            c.shadowBlur = 0;
            c.shadowOffsetX = 0;
            c.shadowOffsetY = 0;

            drawCircle((xCos + 0.07 * this.radius) * cScale, (ySin - 0.23 * this.radius) * cScale, (0.025 * this.radius + 0.4 * Math.abs(eyeLiftR) * this.radius) * cScale);
            c.fillStyle = 'red';
            c.fill();

            drawCircle((xCos + 0.07 * this.radius) * cScale, (ySin - 0.23 * this.radius) * cScale, (0.01 * this.radius + 0.4 * Math.abs(eyeLiftR) * this.radius) * cScale);
            c.fillStyle = 'black';
            c.fill();

            //  right eye ----------
            var xCos = this.pos.x + 0.005 * Math.sin(eyeRoll);
            var ySin = this.pos.y + 0.005 * Math.cos(eyeRoll);
            drawCircle((xCos - 0.07 * this.radius) * cScale, (ySin - 0.23 * this.radius) * cScale, (0.035 * this.radius + 0.4 * Math.abs(eyeLiftL) * this.radius) * cScale);
            c.shadowColor = 'black';
            c.shadowBlur = 10;
            c.shadowOffsetX = 2 * this.radius;
            c.shadowOffsetY = 5 * this.radius;
            c.fillStyle = 'hsl(0, 0%, 80%)';
            c.fill();
            c.shadowBlur = 0;
            c.shadowOffsetX = 0;
            c.shadowOffsetY = 0;

            drawCircle((xCos - 0.07 * this.radius) * cScale, (ySin - 0.23 * this.radius) * cScale, (0.025 * this.radius + 0.4 * Math.abs(eyeLiftL) * this.radius) * cScale);
            c.fillStyle = 'red';
            c.fill();

            drawCircle((xCos - 0.07 * this.radius) * cScale, (ySin - 0.23 * this.radius) * cScale, (0.01 * this.radius + 0.4 * Math.abs(eyeLiftL) * this.radius) * cScale);
            c.fillStyle = 'black';
            c.fill();
            
            // SUNGLASSES  ----------
            if (weaponLevel >= 6) {
                // bridge
                c.beginPath();
                c.lineWidth = 0.01 * this.radius * cScale;
                c.strokeStyle = 'red';
                c.arc((this.pos.x) * cScale, (this.pos.y - 0.2 * this.radius) * cScale, 0.04 * this.radius * cScale, 1.2 * Math.PI, 1.8 * Math.PI);
                c.stroke();

                // lenses
                drawStar(new Vector2(this.pos.x - 0.07 * this.radius, this.pos.y - 0.23 * this.radius), 0.14 * this.radius, 0);
                c.fillStyle = 'hsla(310, 100%, 50%, 40%)';
                c.strokeStyle = 'orange';
                c.lineWidth = 0.006 * Alien[0].radius * cScale;
                c.fill();
                c.stroke();
                drawStar(new Vector2(this.pos.x + 0.07 * this.radius, this.pos.y - 0.23 * this.radius), 0.14 * this.radius, Math.PI);
                c.fill();
                c.stroke();

                // temples
                c.beginPath();
                c.moveTo((this.pos.x - 0.14 * this.radius) * cScale, (this.pos.y - 0.23 * this.radius) * cScale);
                c.lineTo((this.pos.x - 0.23 * this.radius) * cScale, (this.pos.y - 0.24 * this.radius) * cScale);
                c.lineWidth = 0.015 * this.radius * cScale;
                c.strokeStyle = 'red';
                c.stroke();

                c.beginPath();
                c.moveTo((this.pos.x + 0.14 * this.radius) * cScale, (this.pos.y - 0.23 * this.radius) * cScale);
                c.lineTo((this.pos.x + 0.23 * this.radius) * cScale, (this.pos.y - 0.24 * this.radius) * cScale);
                c.stroke();
            }

            // 'stache  ----------
            c.lineWidth = .025 * this.radius * cScale;
            c.strokeStyle = 'black';
            c.beginPath();
            c.moveTo((this.pos.x - 0.02 * this.radius) * cScale, (this.pos.y - 0.18 * this.radius) * cScale);
            c.lineTo((this.pos.x + 0.02 * this.radius) * cScale, (this.pos.y - 0.18 * this.radius) * cScale);
            c.closePath();
            c.stroke();

            //  SPEECH BUBBLE  ----------
            if (this.lol == true) {
                c.fillStyle = 'hsl(0, 0%, 80%)';
                c.strokeStyle = 'hsl(0, 0%, 80%)';
                c.lineWidth = 2;

                var eX = 0.8 * this.radius * cScale;
                var eY = 0.5 * this.radius * cScale;
                var posX = (this.pos.x + 0.1 * this.radius) * cScale;
                var posY = (this.pos.y - 1.1 * this.radius) * cScale;
                c.beginPath();
                c.moveTo(posX + eX * .75, posY + eY * .25);
                c.quadraticCurveTo(posX + eX * 0.25, posY + eY * 0.25, posX + eX * 0.25, posY + eY * 0.625);
                c.quadraticCurveTo(posX + eX * 0.25, posY + eY * 1.00, posX + eX * 0.50, posY + eY * 1.00);
                c.quadraticCurveTo(posX + eX * 0.50, posY + eY * 1.20, posX + eX * 0.30, posY + eY * 1.25);
                c.quadraticCurveTo(posX + eX * 0.60, posY + eY * 1.20, posX + eX * 0.65, posY + eY * 1.00);
                c.quadraticCurveTo(posX + eX * 1.25, posY + eY * 1.00, posX + eX * 1.25, posY + eY * 0.625);
                c.quadraticCurveTo(posX + eX * 1.25, posY + eY * 0.25, posX + eX * 0.75, posY + eY * 0.25);
                c.closePath();
                c.stroke();

                c.fillStyle = 'yellow';
                c.textBaseline = 'middle';
                c.textAlign = "center";
                c.font = `${0.1 * this.radius * cScale}px monospace`;
                c.fillText(trash, (this.pos.x + 0.7 * this.radius) * cScale, (this.pos.y - 0.77 * this.radius) * cScale);
            }

            /*//  SWILRLING STAR  -------------------
                // ellipse track  ----------
                this.angle = 0;
                f += 0.1;
                var drawX = this.pos.x +                    Math.cos(f + this.angle) * ( 0.15 * this.radius / Math.sqrt( 0.15 * this.radius * Math.pow(Math.cos(f), 2) + 1.0 * this.radius * Math.pow(Math.sin(f), 2)) );
                var drawY = this.pos.y - 1.1 * this.radius +  Math.sin(f + this.angle) * ( 0.05 * this.radius / Math.sqrt( 0.05 * this.radius * Math.pow(Math.cos(f), 2) + 1.0 * this.radius * Math.pow(Math.sin(f), 2)) );
                // star
                var starWedges = Math.PI / 5;
                var innerRadius = 0.05 * this.radius;
                var outerRadius = 0.1 * this.radius;
                c.beginPath();
                for (var v = 0; v < 10; v++) {
                    if (v == 0) {
                        c.moveTo((drawX + innerRadius * Math.cos(this.angle + v * starWedges)) * cScale, (drawY + innerRadius * Math.sin(this.angle + v * starWedges)) * cScale);
                    } else 
                    if (v % 2 == 0) {  //inner
                        c.lineTo((drawX + innerRadius * Math.cos(this.angle + v * starWedges)) * cScale, (drawY + innerRadius * Math.sin(this.angle + v * starWedges)) * cScale);
                    } else {  //outer
                        c.lineTo((drawX + outerRadius * Math.cos(this.angle + v * starWedges)) * cScale, (drawY + outerRadius * Math.sin(this.angle + v * starWedges)) * cScale);
                    }
                }
                c.closePath();
                c.strokeStyle = 'white';
                //drawCircle(drawX * cScale, drawY * cScale, 0.1 * this.radius * cScale);
                c.stroke();*/
            
            //  END OF SOLO ALIEN----------
        }
    }

    //  DEFINE UFO  ---------------------
    class UFO {
        constructor(pos, vel, radius, gunAngle, start, lol, birthday) {
            this.pos = pos.clone();
            this.vel = vel.clone();
            this.radius = radius;
            this.gunAngle = gunAngle;
            this.start = start;
            this.lol = lol;
            this.birthday = birthday;
        }
        simulate() {
            this.pos.add(this.vel, dT);
            if (this.start == true) {
                if (this.pos.x > this.radius && this.pos.x < simWidth - this.radius) {
                    this.start = false;
                }
            } else {
                if (this.pos.x < this.radius) {
                    //this.pos.x = simWidth;
                    //this.vel.x *= -1;
                }
                    if (this.pos.x > simWidth - this.radius) {
                    //this.pos.x = 0;
                    //this.vel.x *= -1;
                }
            }
            if (this.pos.y < 0.8 * this.radius) {
                //this.pos.y = simHeight;
                //this.vel.y *= -1;
            }
            if (this.pos.y > simHeight - 0.8 * this.radius) {
                //this.pos.y = 0;
                //this.vel.y *= -1;
            }

            //  TARGETING  ----------
            var torpSpeed = 1;
            var enemyTimeout = 20;
            //  ENEMY TIMEOUT  ----------
            if ((Date.now() - this.birthday) / 1000 < enemyTimeout && Roket[0].collision != 2) {
                this.gunAngle = getInterceptAngle(
                    this.pos,
                    Roket[0].pos,
                    Roket[0].vel,
                    torpSpeed
                );
            } else {
                if (this.gunAngle > 0) {
                    this.gunAngle -= 0.1;
                } else {
                    //  LEAVE A BOMB BEHINS WHEN ENEMY LEAVES ----------

                    //  POINT GUN TO THE RIGHT  ----------
                    this.gunAngle = 0;
                    window.clearInterval(gonnaGetcha);
                    if (this.pos.x > simWidth + this.radius) {
                        Enemy = [];
                    }
                }
                
            }

            //  LEAVE AFTER HIT ON PLAYER  ----------
            if (sayByeBye == true && Enemy[0] != null) {
                this.gunAngle = 0;
                window.clearInterval(gonnaGetcha);
                if (this.pos.x > simWidth + this.radius) {
                    Enemy = [];
                    sayByeBye = false;
                }
            }

            //  STEER IN GUN DIRECTION  ----------
            var speedLimit = 0.6;
            var aimVector = new Vector2(Math.cos(this.gunAngle), Math.sin(this.gunAngle))
            aimVector.scale(0.5);
            this.vel.add(aimVector, dT) 
            if (this.vel.length() > speedLimit) {  
                this.vel.scale(0.99);
            }

            //  RAISE EYEBROWS  ----------
            if (this.vel.x >= 0) {
                eyeLiftL = 0;
                eyeLiftR = -0.03 * this.radius;
            } else {
                eyeLiftL = -0.03 * this.radius;
                eyeLiftR = 0;
            }

            //  LAUGH  -----------
            if (this.lol == true) {
                if ((Date.now() - lolStart) / 1000 > lolTime) {
                    this.lol = false;
                } else {
                    lol += 0.2;
                    lolAdjY = 1.5 * Math.abs(Math.sin(lol));
                    toothAdj = 0.05 * Math.abs(Math.sin(lol)) - 0.1 * this.radius;
                }
            } else {
                lolAdjY = 1;
                toothAdj = 0;
                lolTime = 1.0 + 3.0 * Math.random();
            }

            //  SPAWN IDLE Exhaustlets  ----------
            spawnIdleExhaustlets(this.pos.x, this.pos.y, 0, 'foe');
        }
        draw() {
            // START OF ALIEN--------------------
            // antennas  ----------
            c.fillStyle = 'green';
            c.strokeStyle = 'green';
            c.lineWidth = 0.005 * cScale;
            c.beginPath();
            c.moveTo((this.pos.x + 0.04 * this.radius) * cScale, (this.pos.y - 0.5 * this.radius) * cScale);
            c.lineTo((this.pos.x + 0.18 * this.radius) * cScale, (this.pos.y - 0.8 * this.radius) * cScale);

            c.moveTo(this.pos.x * cScale, (this.pos.y - 0.5 * this.radius) * cScale);
            c.lineTo(this.pos.x * cScale, (this.pos.y - 0.8 * this.radius) * cScale);

            c.moveTo((this.pos.x - 0.04 * this.radius) * cScale, (this.pos.y - 0.5 * this.radius) * cScale);
            c.lineTo((this.pos.x - 0.18 * this.radius) * cScale, (this.pos.y - 0.8 * this.radius) * cScale);
            c.closePath();
            c.stroke();

            //  antenna knobs  ----------
            knobLight += 0.01;
            var knobHue = 360 * Math.cos(knobLight);
            //c.fillStyle = 'deeppink';
            c.fillStyle = `hsl(${90 + knobHue}, 90%, 50%)`;
            drawCircle((this.pos.x + 0.18 * this.radius) * cScale, (this.pos.y - 0.8 * this.radius) * cScale, 0.045 * this.radius * cScale);
            c.fill();
            //c.fillStyle = 'gold';
            c.fillStyle = `hsl(${180 + knobHue}, 90%, 50%)`;
            drawCircle(this.pos.x * cScale, (this.pos.y - 0.8 * this.radius) * cScale, 0.045 * this.radius * cScale);
            c.fill();
            //c.fillStyle = 'orangered';
            c.fillStyle = `hsl(${270 + knobHue}, 90%, 50%)`;
            drawCircle((this.pos.x - 0.18 * this.radius) * cScale, (this.pos.y - 0.8 * this.radius) * cScale, 0.045 * this.radius * cScale);
            c.fill();
            
            //  head/body  ----------
            c.fillStyle = 'hsl(110, 100%, 50%)';
            drawVertEllipse(this.pos.x * cScale, (this.pos.y - 0.3 * this.radius) * cScale, 0.4 * this.radius * cScale);
            c.fill();

            //  mouth  ----------
            c.fillStyle = 'black';
            drawCustomEllipse(this.pos.x * cScale, (this.pos.y - 0.4 * this.radius) * cScale, 0.21 * this.radius * cScale, lolAdjY * 0.35);
            c.fill();

            //  toofs  ----------
            c.fillStyle = 'hsl(0, 0%, 90%)';
            c.beginPath();
            c.moveTo(
                (this.pos.x + 0.07 * this.radius) * cScale, (this.pos.y - (0.1 - toothAdj + lolAdjY * 0.03) * this.radius) * cScale);
            c.lineTo(
                (this.pos.x + 0.11 * this.radius) * cScale, (this.pos.y - (0.18 - toothAdj + lolAdjY * 0.03) * this.radius) * cScale);
            c.lineTo(
                (this.pos.x + 0.03 * this.radius) * cScale, (this.pos.y - (0.18 - toothAdj + lolAdjY * 0.03) * this.radius) * cScale);
            c.closePath();
            c.fill();

            c.beginPath();
            c.moveTo(
                (this.pos.x - 0.07 * this.radius) * cScale, (this.pos.y - (0.1 - toothAdj + lolAdjY * 0.03) * this.radius) * cScale);
            c.lineTo(
                (this.pos.x - 0.11 * this.radius) * cScale, (this.pos.y - (0.18 - toothAdj + lolAdjY * 0.03) * this.radius) * cScale);
            c.lineTo(
                (this.pos.x - 0.03 * this.radius) * cScale, (this.pos.y - (0.18 - toothAdj + lolAdjY * 0.03) * this.radius) * cScale);
            c.closePath();
            c.fill();

            //  lips  ----------
            /*c.lineWidth = .005 * cScale;
            c.strokeStyle = 'hsl(110, 100%, 50%)';
            //c.strokeStyle = 'gray';
            drawHorizEllipse(this.pos.x * cScale, (this.pos.y - 0.4 * this.radius) * cScale, 0.21 * this.radius * cScale);
            c.stroke();
            */

            //  eyebrows  ----------
            c.lineWidth = .008 * cScale;
            c.strokeStyle = 'black'
            c.beginPath();
            c.moveTo((this.pos.x + 0.04 * this.radius) * cScale, (this.pos.y - 0.52*(1.02) * this.radius) * cScale);
            c.lineTo((this.pos.x + 0.13 * this.radius) * cScale, (this.pos.y - 0.55*(1.07) * this.radius + eyeLiftR) * cScale);
            c.moveTo((this.pos.x - 0.04 * this.radius) * cScale, (this.pos.y - 0.52*(1.02) * this.radius) * cScale);
            c.lineTo((this.pos.x - 0.13 * this.radius) * cScale, (this.pos.y - 0.55*(1.07) * this.radius + eyeLiftL) * cScale);
            c.closePath();
            c.stroke();

            //  eyes  ----------
            c.lineWidth = .006 * cScale;
            c.strokeStyle = 'white'
            c.beginPath();
            c.moveTo((this.pos.x + 0.04 * this.radius) * cScale, (this.pos.y - 0.52 * this.radius) * cScale);
            c.lineTo((this.pos.x + 0.13 * this.radius) * cScale, (this.pos.y - 0.55 * this.radius + eyeLiftR) * cScale);
            c.moveTo((this.pos.x - 0.04 * this.radius) * cScale, (this.pos.y - 0.52 * this.radius) * cScale);
            c.lineTo((this.pos.x - 0.13 * this.radius) * cScale, (this.pos.y - 0.55 * this.radius + eyeLiftL) * cScale);
            c.closePath();
            c.stroke();

            //  pupils  ----------
            c.fillStyle = 'red';
            drawCircle((this.pos.x + 0.065 * this.radius + eyeLiftL) * cScale, (this.pos.y - 0.53 * this.radius) * cScale, 0.004 * cScale);
            c.fill();
            drawCircle((this.pos.x - 0.065 * this.radius - eyeLiftR) * cScale, (this.pos.y - 0.53 * this.radius) * cScale, 0.004 * cScale);
            c.fill();

            // 'stache  ----------
            c.lineWidth = .003 * cScale;
            c.strokeStyle = 'black';
            c.beginPath();
            c.moveTo((this.pos.x - 0.03 * this.radius) * cScale, (this.pos.y - 0.48 * this.radius) * cScale);
            c.lineTo((this.pos.x + 0.03 * this.radius) * cScale, (this.pos.y - 0.48 * this.radius) * cScale);
            c.closePath();
            c.stroke();

            //  SPEECH BUBBLE  ----------
            if (this.lol == true && gameIdle != true) {
                c.fillStyle = 'hsl(0, 0%, 80%)';
                c.strokeStyle = 'hsl(0, 0%, 80%)';
                c.lineWidth = 2;

                var eX = 0.2 * cScale;
                var eY = 0.125 * cScale;
                var posX = this.pos.x * cScale;
                var posY = (this.pos.y - 2.5 * this.radius) * cScale;
                c.beginPath();
                c.moveTo(posX + eX * .75, posY + eY * .25);
                c.quadraticCurveTo(posX + eX * .25, posY + eY * .25, posX + eX * .25, posY + eY * .625);
                c.quadraticCurveTo(posX + eX * .25, posY + eY * 1.00, posX + eX * .50, posY + eY * 1.00);
                c.quadraticCurveTo(posX + eX * .50, posY + eY * 1.20, posX + eX * .30, posY + eY * 1.25);
                c.quadraticCurveTo(posX + eX * .60, posY + eY * 1.20, posX + eX * .65, posY + eY * 1.00);
                c.quadraticCurveTo(posX + eX * 1.25, posY + eY * 1.00, posX + eX * 1.25, posY + eY * .625);
                c.quadraticCurveTo(posX + eX * 1.25, posY + eY * .25, posX + eX * .75, posY + eY * .25);
                c.closePath();
                c.stroke();

                c.fillStyle = 'yellow';
                c.textBaseline = 'middle';
                c.textAlign = "center";
                c.font = `${0.3 * this.radius * cScale}px monospace`;
                c.fillText(trash, (this.pos.x + 1.5*this.radius) * cScale, (this.pos.y - 1.65 * this.radius) * cScale);
            }
            //  END OF ALIEN----------

            // dome  ----------
            var domeGradient = c.createRadialGradient(
                this.pos.x * cScale, 
                (this.pos.y - 0.3 * this.radius) * cScale,
                0, 
                this.pos.x * cScale, 
                (this.pos.y - 0.3 * this.radius) * cScale,
                0.65 * this.radius * cScale);
            var shadow = `hsla(0, 0%, 50%, 20%)`;
            var highlight = `hsla(230, 50%, 80%, 70%)`;
            domeGradient.addColorStop(0.6, shadow);
            domeGradient.addColorStop(1.0, highlight);
            c.fillStyle = domeGradient;
            
            c.strokeStyle = 'hsl(0, 0%, 80%)';
            c.lineWidth = 2;
            drawCircle(this.pos.x * cScale, (this.pos.y - 0.3 * this.radius) * cScale, 0.65 * this.radius * cScale);
            c.fill();
            //c.stroke();

            // left leg support  ----------
            c.strokeStyle = `hsl(60, 20%, 40%)`;
            c.lineWidth = .025 * cScale;
            c.beginPath();
            c.moveTo((this.pos.x - 0.3 * this.radius) * cScale, this.pos.y * cScale);
            c.lineTo((this.pos.x - 0.52 * this.radius) * cScale, (this.pos.y + 0.440 * this.radius) * cScale);
            c.closePath();
            c.stroke();

            // right leg support  ----------
            c.beginPath();
            c.moveTo((this.pos.x + 0.3 * this.radius) * cScale, this.pos.y * cScale);
            c.lineTo((this.pos.x + 0.52 * this.radius) * cScale, (this.pos.y + 0.440 * this.radius) * cScale);
            c.closePath();
            c.stroke();

            // left leg  ----------
            c.strokeStyle = `hsl(0, 0%, 80%)`;
            c.lineWidth = .007 * cScale;
            c.beginPath();
            c.moveTo((this.pos.x - 0.3 * this.radius) * cScale, this.pos.y * cScale);
            c.lineTo((this.pos.x - 0.7 * this.radius) * cScale, (this.pos.y + 0.8 * this.radius) * cScale);
            c.closePath();
            c.stroke();

            // right leg  ----------
            c.beginPath();
            c.moveTo((this.pos.x + 0.3 * this.radius) * cScale, this.pos.y * cScale);
            c.lineTo((this.pos.x + 0.7 * this.radius) * cScale, (this.pos.y + 0.8 * this.radius) * cScale);
            c.closePath();
            c.stroke();

            // left foot  ----------
            c.strokeStyle = `hsl(0, 0%, 80%)`;
            c.fillStyle = 'hsl(0, 30%, 30%)';
            c.lineWidth = .003 * cScale;
            c.beginPath();
            c.ellipse(
                (this.pos.x - 0.7 * this.radius) * cScale, 
                (this.pos.y + 0.8 * this.radius) * cScale, 
                0.15 * this.radius * cScale, 
                0.1 * this.radius * cScale, 
                0, 
                0,
                3.14,
                false);
            c.closePath();
            c.fill();
            c.stroke();

            // right foot  ----------
            c.beginPath();
            c.ellipse(
            (this.pos.x + 0.7 * this.radius) * cScale, 
            (this.pos.y + 0.8 * this.radius) * cScale, 
            0.15 * this.radius * cScale, 
            0.1 * this.radius * cScale, 
            0, 
            0,
            3.14,
            false);
            c.closePath();
            c.fill();
            c.stroke();

            // fuselage  ----------
            var bodyGradient = c.createRadialGradient(
                this.pos.x * cScale, 
                (this.pos.y - 0.85 * this.radius) * cScale,
                0, 
                this.pos.x * cScale, 
                (this.pos.y - 0.85 * this.radius) * cScale,
                1 * this.radius * cScale);
            
            var highlight = `hsl(335, 100%, 100%)`;
            var midtone = `hsl(335, 80%, 50%)`;
            var shadow = `hsl(335, 50%, 20%)`;
            bodyGradient.addColorStop(0.0, highlight);
            bodyGradient.addColorStop(0.7, midtone);
            bodyGradient.addColorStop(1.0, shadow);
            c.fillStyle = bodyGradient;

            // fuselage fill  -----------
            c.lineWidth = .004 * cScale;
            c.strokeStyle = `hsl(0, 0%, 80%)`;
            drawHorizEllipse(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale);
            c.fill();

            //  small latitudes  ----------
            c.lineWidth = .002 * cScale;
            c.strokeStyle = `hsl(0, 0%, 20%)`;
            c.beginPath();
            c.ellipse(
                this.pos.x * cScale, 
                (this.pos.y - 0.33 * this.radius) * cScale, 
                0.4 * this.radius * cScale, 
                0.05 * this.radius * cScale, 
                0, 
                0,
                3.1,
                false);
            c.stroke();
            
            c.beginPath();
            c.ellipse(
                this.pos.x * cScale, 
                (this.pos.y + 0.33 * this.radius) * cScale, 
                0.4 * this.radius * cScale, 
                0.05 * this.radius * cScale, 
                0, 
                0,
                3.1,
                true);
            //c.closePath();
            c.stroke();

            //  mid latitudes  ----------
            //c.lineWidth = .006 * cScale;
            c.beginPath();
            c.ellipse(
                this.pos.x * cScale, 
                (this.pos.y - 0.29 * this.radius) * cScale, 
                0.67 * this.radius * cScale, 
                0.09 * this.radius * cScale, 
                0, 
                0.35,
                2.85,
                false);
            c.stroke();

            c.beginPath();
            c.ellipse(
                this.pos.x * cScale, 
                (this.pos.y + 0.3 * this.radius) * cScale, 
                0.67 * this.radius * cScale, 
                0.09 * this.radius * cScale, 
                0, 
                -0.35,
                -2.85,
                true);
            c.stroke();

            //  big latitudes, top  ----------
            //c.lineWidth = .004 * cScale;
            c.beginPath();
            c.ellipse(
                this.pos.x * cScale, 
                (this.pos.y - 0.2 * this.radius) * cScale, 
                0.8 * this.radius * cScale, 
                0.09 * this.radius * cScale, 
                0, 
                -.2,
                3.3,
                false);
            c.stroke();

            c.beginPath();
            c.ellipse(
                this.pos.x * cScale, 
                (this.pos.y + 0.2 * this.radius) * cScale, 
                0.8 * this.radius * cScale, 
                0.09 * this.radius * cScale, 
                0,  
                0.2,
                -3.3,
                true);
            c.stroke();

            //  equator  ----------
            //c.lineWidth = .003 * cScale;
            c.beginPath();
            c.moveTo((this.pos.x - this.radius) * cScale, this.pos.y * cScale);
            c.lineTo((this.pos.x + this.radius) * cScale, this.pos.y * cScale);
            c.closePath();
            c.stroke();

            //  sectors  ----------
            //c.strokeStyle = `hsl(0, 0%, 80%)`;
            drawHorizEllipse2(this.pos.x * cScale, this.pos.y * cScale, 0.9 * this.radius * cScale);
            c.stroke();
            drawHorizEllipse2(this.pos.x * cScale, this.pos.y * cScale, 0.6 * this.radius * cScale);
            c.stroke();
            drawHorizEllipse2(this.pos.x * cScale, this.pos.y * cScale, 0.23 * this.radius * cScale);
            c.stroke();

            // fuselage outline  -----------
            c.lineWidth = .003 * cScale;
            c.strokeStyle = `hsl(0, 20%, 70%)`;
            drawHorizEllipse(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale);
            c.stroke();
            
            // portholes  ----------
            c.strokeStyle = 'white';
            c.fillStyle = 'hsl(0, 0%, 20%)';
            c.lineWidth = .007 * cScale;
            drawVertEllipse((this.pos.x - 0.72 * this.radius) * cScale, this.pos.y * cScale, 0.07 * this.radius * cScale);
            c.stroke();
            c.fill();
            drawVertEllipse((this.pos.x - 0.38 * this.radius) * cScale, this.pos.y * cScale, 0.12 * this.radius * cScale);
            c.stroke();
            c.fill();
            drawCircle((this.pos.x - 0.00 * this.radius) * cScale, this.pos.y * cScale, 0.14 * this.radius * cScale);
            c.stroke();
            c.fill();
            drawVertEllipse((this.pos.x + 0.38 * this.radius) * cScale, this.pos.y * cScale, 0.12 * this.radius * cScale);
            c.stroke();
            c.fill();
            drawVertEllipse((this.pos.x + 0.72 * this.radius) * cScale, this.pos.y * cScale, 0.07 * this.radius * cScale);
            c.stroke();
            c.fill();

            // blinky lights  ----------
            c.fillStyle = `orange`;
            var secFrac = new Date().getMilliseconds()/1000;
            if (secFrac < 1/12) {
                // no lights'
            } else 
            if (secFrac < 2/12) {
                // light up #1
                drawVertEllipse((this.pos.x - 0.72 * this.radius) * cScale, this.pos.y * cScale, 0.07 * this.radius * cScale);
                c.fill();
            } else 
            if (secFrac < 3/12) {
                // light up #2
                drawVertEllipse((this.pos.x - 0.38 * this.radius) * cScale, this.pos.y * cScale, 0.12 * this.radius * cScale);
                c.fill();
            } else 
            if (secFrac < 4/12) {
                // light up #3
                drawCircle((this.pos.x - 0.00 * this.radius) * cScale, this.pos.y * cScale, 0.14 * this.radius * cScale);
                c.fill();
            } else 
            if (secFrac < 5/12) {
                // light up #4
                drawVertEllipse((this.pos.x + 0.38 * this.radius) * cScale, this.pos.y * cScale, 0.12 * this.radius * cScale);
                c.fill();
            } else
            if (secFrac < 6/12) {
                // light up #5
                drawVertEllipse((this.pos.x + 0.72 * this.radius) * cScale, this.pos.y * cScale, 0.07 * this.radius * cScale);
                c.fill();
            } else
            if (secFrac < 7/12) {
                // no lights
            } else 
            if (secFrac < 8/12) {
                // light up #5
                c.fillStyle = `hsl(320, 90%, 50%)`;
                drawVertEllipse((this.pos.x + 0.72 * this.radius) * cScale, this.pos.y * cScale, 0.07 * this.radius * cScale);
                c.fill();
            } else 
            if (secFrac < 9/12) {
                // light up #4
                c.fillStyle = `hsl(320, 90%, 50%)`;
                drawVertEllipse((this.pos.x + 0.38 * this.radius) * cScale, this.pos.y * cScale, 0.12 * this.radius * cScale);
                c.fill();
            } else 
            if (secFrac < 10/12) {
                // light up #3
                c.fillStyle = `hsl(320, 90%, 50%)`;
                drawCircle((this.pos.x - 0.00 * this.radius) * cScale, this.pos.y * cScale, 0.14 * this.radius * cScale);
                c.fill();
            } else 
            if (secFrac < 11/12) {
                // light up #2
                c.fillStyle = `hsl(320, 90%, 50%)`;
                drawVertEllipse((this.pos.x - 0.38 * this.radius) * cScale, this.pos.y * cScale, 0.12 * this.radius * cScale);
                c.fill();
            } else
            if (secFrac < 12/12) {
                // light up #1
                c.fillStyle = `hsl(320, 90%, 50%)`;
                drawVertEllipse((this.pos.x - 0.72 * this.radius) * cScale, this.pos.y * cScale, 0.07 * this.radius * cScale);
                c.fill();
            } 

            //  gun  ----------
            bbl = 0.7 * this.radius + 0.5 * this.radius * (Date.now() - enemyShotBirthday) / 1000;
            if (bbl >= 1.2 * this.radius) {
                bbl = 1.2 * this.radius;
            }

            //  muzzle  ----------
            var offset = 0.15 * this.radius;
            c.strokeStyle = 'yellow';
            c.lineWidth = 0.025 * cScale;
            c.beginPath();
            c.moveTo((this.pos.x + offset * Math.cos(this.gunAngle)) * cScale, (this.pos.y + offset * Math.sin(this.gunAngle)) * cScale);
            c.lineTo((this.pos.x + bbl*(1.0) * Math.cos(this.gunAngle)) * cScale, (this.pos.y + bbl*(1.0) * Math.sin(this.gunAngle)) * cScale);
            c.closePath();
            c.stroke();

            // bbl  ---------
            c.strokeStyle = `hsl(0, 0%, 30%)`;
            c.lineWidth = 0.025 * cScale;
            c.beginPath();
            c.moveTo((this.pos.x + offset * Math.cos(this.gunAngle)) * cScale, (this.pos.y + offset * Math.sin(this.gunAngle)) * cScale);
            c.lineTo((this.pos.x + bbl*(.85) * Math.cos(this.gunAngle)) * cScale, (this.pos.y + bbl*(.85) * Math.sin(this.gunAngle)) * cScale);
            c.closePath();
            c.stroke();

            c.strokeStyle = 'cyan';
            c.lineWidth = 0.020 * cScale;
            c.beginPath();
            c.moveTo((this.pos.x + offset * Math.cos(this.gunAngle)) * cScale, (this.pos.y + offset * Math.sin(this.gunAngle)) * cScale);
            c.lineTo((this.pos.x + bbl*(0.85) * Math.cos(this.gunAngle)) * cScale, (this.pos.y + bbl*(0.85) * Math.sin(this.gunAngle)) * cScale);
            c.closePath();
            c.stroke();

            //  butt  ----------
            c.strokeStyle = `hsl(0, 0%, 30%)`;
            c.lineWidth = 0.04 * cScale;
            c.beginPath();
            c.moveTo((this.pos.x + offset * Math.cos(this.gunAngle)) * cScale, (this.pos.y + offset * Math.sin(this.gunAngle)) * cScale);
            c.lineTo((this.pos.x + 1.2*this.radius*(.4) * Math.cos(this.gunAngle)) * cScale, (this.pos.y + 1.2*this.radius*(.4) * Math.sin(this.gunAngle)) * cScale);
            c.closePath();
            c.stroke();

            c.strokeStyle = 'cyan';
            c.lineWidth = 0.03 * cScale;
            c.beginPath();
            c.moveTo((this.pos.x + offset * Math.cos(this.gunAngle)) * cScale, (this.pos.y + offset * Math.sin(this.gunAngle)) * cScale);
            c.lineTo((this.pos.x + 1.2*this.radius*(0.4) * Math.cos(this.gunAngle)) * cScale, (this.pos.y + 1.2*this.radius*(0.4) * Math.sin(this.gunAngle)) * cScale);
            c.closePath();
            c.stroke();
            
            //  bore  ----------
            c.strokeStyle = 'hsl(0, 0%, 15%)';
            c.lineWidth = 0.005 * cScale;
            c.beginPath();
            c.moveTo((this.pos.x + offset * Math.cos(this.gunAngle)) * cScale, (this.pos.y + offset * Math.sin(this.gunAngle)) * cScale);
            c.lineTo((this.pos.x + bbl*(1.0) * Math.cos(this.gunAngle)) * cScale, (this.pos.y + bbl*(1.0) * Math.sin(this.gunAngle)) * cScale);
            c.closePath();
            c.stroke();

            //  gun mount  ----------
            c.strokeStyle = 'cyan';
            c.lineWidth = 0.01 * cScale;
            drawCircle(this.pos.x * cScale, this.pos.y * cScale, offset * cScale);
            c.stroke();

            c.strokeStyle = 'black';
            c.lineWidth = 0.005 * cScale;
            drawCircle(this.pos.x * cScale, this.pos.y * cScale, 0.17 * this.radius * cScale);
            c.stroke();

            /*//  draw enemy aiming target point  -----------
            c.strokeStyle = `white`;
            c.beginPath();
            c.moveTo((targetImage.x - 0.1 * this.radius)* cScale, targetImage.y * cScale);
            c.lineTo((targetImage.x + 0.1 * this.radius)* cScale, targetImage.y * cScale);
            c.moveTo(targetImage.x * cScale, (targetImage.y - 0.1 * this.radius) * cScale);
            c.lineTo(targetImage.x * cScale, (targetImage.y + 0.1 * this.radius) * cScale);
            c.stroke();*/
        }
    }

    //  DEFINE TORPEDO  -----------------
    class TORPEDO {
        constructor(pos, vel, squangle, radius, hue, friendOrFoe) {
            this.pos = pos.clone();
            this.vel = vel.clone();
            this.squangle = squangle;
            this.radius = radius;
            this.hue = hue;
            this.friendOrFoe = friendOrFoe;
        }
        get left() {
            return this.pos.x - this.radius;
        }
        get right() {
            return this.pos.x + this.radius;
        }
        simulate() {
            this.pos.add(this.vel, dT);
            if (this.friendOrFoe == 'foe') {
                if (this.vel.x > 0) {
                    this.squangle += 1;
                } else {
                    this.squangle -= 1;
                }
            }
        }
        draw() {
            if (this.friendOrFoe == 'foe') {
                const points = 4;
                const starWedges = Math.PI / points;
                var radius = 1.5 * this.radius; // + 0.5 * this.radius * Math.cos(2*this.squangle);
                var innerRadius = 0.4 * radius;
                var outerRadius = 1.4 * radius;
                //function spawnRoidDebris(origin, radius, hue1, hue2, sat, debrisQuant, debrisVel, type)
                spawnRoidDebris(this.pos, 0.003, 60, 60, 100, 20, 0.4, 'torpedo');
                c.beginPath();
                for (var v = 0; v < 2 * points; v++) {
                    if (v == 0) {
                        c.moveTo((this.pos.x + innerRadius * Math.cos(this.squangle + v * starWedges)) * cScale, (this.pos.y + innerRadius * Math.sin(this.squangle + v * starWedges)) * cScale);
                    } else 
                    if (v % 2 == 0) {  //inner
                        c.lineTo((this.pos.x + innerRadius * Math.cos(this.squangle + v * starWedges)) * cScale, (this.pos.y + innerRadius * Math.sin(this.squangle + v * starWedges)) * cScale);
                    } else {  //outer
                        c.lineTo((this.pos.x + outerRadius * Math.cos(this.squangle + v * starWedges)) * cScale, (this.pos.y + outerRadius * Math.sin(this.squangle + v * starWedges)) * cScale);
                    }
                }
                c.closePath();
                c.fillStyle = `yellow`;
                c.fill();
                c.lineWidth = 0.15 * this.radius * cScale;
                c.strokeStyle = `cyan`;
                c.stroke();
            } else {
                spawnRoidDebris(this.pos, 0.003, this.hue, this.hue, 100, 1, 0.4, 'torpedo');
                drawCircle(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale);
                c.fillStyle = `hsl(${this.hue}, ${40 + 60 * Math.random()}%, ${40 + 20 * Math.random()}%)`;
                c.fill();
            }
            
        }
    }

    //  DEFINE ROIDS  -----------------
    class ROID {
        constructor (pos, vel, radius, mass, hue, saturation, lightness, polkaSeed, randomNo, isWireframe = false, yaw, pitch, roll) {
            this.pos = pos.clone();
            this.vel = vel.clone();
            this.radius = radius;
            this.originalRadius = radius;
            this.mass = mass;
            this.hue = hue;
            this.saturation = saturation;
            this.lightness = lightness;
            this.polkaSeed = polkaSeed;
            this.randomNo = randomNo;
            this.spinAngle = 0;
            this.polkadotFlashTimer = 0;
            this.isWireframe = isWireframe; // new flag: draw as pseudo-3D wireframe
            // enable rotation only for non-wireframe roids (spin for polkadots)
            this.angularVelocity = this.isWireframe ? 0.0 : 0.01 * (Math.random() - 0.5);
            // pole spin state for wireframe roids (controls longitudes rotation)
            this.poleSpinAngle = Math.random() * 2 * Math.PI;
            this.poleSpinSpeed = this.isWireframe ? (Math.random() - 0.5) * 0.1 : 0.0;
            // orientation: store as a quaternion to avoid gimbal lock; also keep Euler cache for code compatibility
            if (this.isWireframe) {
                this.yaw = Math.random() * 2 * Math.PI; // initial Euler cache
                this.pitch = (Math.random() - 0.5) * Math.PI; // initial Euler cache
                this.roll = Math.random() * 2 * Math.PI; // initial Euler cache
            } else {
                this.yaw = (typeof yaw === 'number') ? yaw : Math.random() * 2 * Math.PI;
                this.pitch = (typeof pitch === 'number') ? pitch : (Math.random() * Math.PI - Math.PI/2);
                this.roll = (typeof roll === 'number') ? roll : Math.random() * 2 * Math.PI;
            }
            // quaternion orientation initialized from euler cache
            this.orientation = quatFromEuler(this.yaw, this.pitch, this.roll);
            // 3D angular velocity vector (rad/frame). Keep scalar angularVelocity in sync with omega.z
            if (this.isWireframe) {
                this.omega = {
                    x: (Math.random() - 0.5) * 0.02, // pitch rate
                    y: (Math.random() - 0.5) * 0.02, // roll rate
                    z: (Math.random() - 0.5) * 0.02  // yaw rate
                };
                // also mirror z into scalar for compatibility
                this.angularVelocity = this.omega.z;
            } else {
                this.omega = { x: 0, y: 0, z: this.angularVelocity };
            }
    }
        get left() {
            return this.pos.x - this.radius;
        }
        get right() {
            return this.pos.x + this.radius;
        }
        get top() {
            return this.pos.y - this.radius;
        }
        get bottom() {
            return this.pos.y + this.radius;
        }
        simulate() {
            this.pos.add(this.vel, dT);

            const maxSpeed = 0.5 + wave / 20;
            if (this.vel.length() > maxSpeed) {
                this.vel.x *= maxSpeed / this.vel.length();
                this.vel.y *= maxSpeed / this.vel.length();
            }

            // angular control constants (declared early so non-wireframe code can use them)
            const omegaDamping = 1.0; // no automatic damping: tumbling persists until another force acts
            // maximum angular rate (radians/frame) allowed per-axis to avoid runaway
            const maxOmega = 0.5;
            // maximum spin about axis (scalar spin rate applied to spinAngle/poleSpinAngle)
            const maxSpin = 0.05;

            //if (this.vel.length() < 0.05) {
            //    this.vel.scale(1.01);
            //}

            // update spin only for non-wireframe roids (polkadot spin)
            if (!this.isWireframe && polkadots.checked == true) {
                // clamp scalar spin to same maxSpin used for wireframes
                this.angularVelocity = Math.max(-maxSpin, Math.min(maxSpin, this.angularVelocity));
                this.spinAngle += this.angularVelocity;
            }
            // Integrate 3D omega into visible orientation for wireframe roids
            // and keep scalar angularVelocity roughly in sync with omega.z
            if (this.isWireframe) {
                // pole spin continues to include poleSpinSpeed
                // include yaw rate (omega.z) in poleSpinAngle so visible longitude rotation follows yaw
                // clamp the resulting axial spin so roids don't spin faster than maxSpin
                let spinInc = 60 * dT * (this.poleSpinSpeed + this.omega.z);
                spinInc = Math.max(-maxSpin, Math.min(maxSpin, spinInc));
                this.poleSpinAngle += spinInc;
                if (this.poleSpinAngle > 2 * Math.PI) this.poleSpinAngle -= 2 * Math.PI;
                if (this.poleSpinAngle < -2 * Math.PI) this.poleSpinAngle += 2 * Math.PI;
                // Integrate angular velocity vector (this.omega) into quaternion orientation using small-angle quaternion
                // delta_q ~ [1, 0.5*omega*dt]
                const half_dt = 0.5 * dT;
                const dq = {
                    w: 1.0,
                    x: this.omega.x * half_dt,
                    y: this.omega.y * half_dt,
                    z: this.omega.z * half_dt
                };
                // new orientation = orientation * dq  (apply small-body-frame rotation)
                this.orientation = quatMultiply(this.orientation, dq);
                quatNormalize(this.orientation);
                // update Euler cache from quaternion for any code that still reads yaw/pitch/roll
                // conversion: yaw (Z), pitch (X), roll (Y) inverse of quatFromEuler
                const qw = this.orientation.w, qx = this.orientation.x, qy = this.orientation.y, qz = this.orientation.z;
                // yaw (Z)
                this.yaw = Math.atan2(2*(qw*qz + qx*qy), 1 - 2*(qy*qy + qz*qz));
                // pitch (X)
                const sinp = 2*(qw*qx - qy*qz);
                this.pitch = Math.abs(sinp) >= 1 ? Math.sign(sinp) * Math.PI/2 : Math.asin(sinp);
                // roll (Y)
                this.roll = Math.atan2(2*(qw*qy + qz*qx), 1 - 2*(qx*qx + qy*qy));
                // apply damping (may be 1.0 for no damping) and then clamp to max allowed rates
                this.omega.x *= omegaDamping;
                this.omega.y *= omegaDamping;
                this.omega.z *= omegaDamping;
                // clamp per-axis angular rates
                this.omega.x = Math.max(-maxOmega, Math.min(maxOmega, this.omega.x));
                this.omega.y = Math.max(-maxOmega, Math.min(maxOmega, this.omega.y));
                this.omega.z = Math.max(-maxOmega, Math.min(maxOmega, this.omega.z));
                // keep scalar angularVelocity in sync with clamped z
                this.angularVelocity = this.omega.z;
                // clamp scalar axial spin used for visual spin/pole spin
                this.angularVelocity = Math.max(-maxSpin, Math.min(maxSpin, this.angularVelocity));
            }
            
            if (this.spinAngle > 2 * Math.PI) {
                this.spinAngle -= 2 * Math.PI;
            }

            //  WRAP TO OTHER SIDE OF SCREEN  -------------------
            let isOffScreen = false;
            if (this.pos.x < -this.radius) {
                this.pos.x = simWidth + this.radius;
                isOffScreen = true;
            } else if (this.pos.x > simWidth + this.radius) {
                this.pos.x = -this.radius;
                isOffScreen = true;
            }
            if (this.pos.y < -this.radius) {
                this.pos.y = simHeight + this.radius;
                isOffScreen = true;
            } else if (this.pos.y > simHeight + this.radius) {
                this.pos.y = -this.radius;
                isOffScreen = true;
            }

            // Boost velocity if off-screen and too slow  -------------------
            if (isOffScreen == true && this.vel.length() < 0.1) {
                this.vel.scale(2.0);
            }

            //  POLKADOT FLASH TIMER  -------------------
            if (this.polkadotFlashTimer > 0) {
                this.polkadotFlashTimer -= dT;
                if (this.polkadotFlashTimer < 0) {
                    this.polkadotFlashTimer = 0;
                }
            }
            //this.radius *= 1.001;
        }
        draw() {
            if (this.isWireframe == true) {
                //  DRAW WIREFRAME ROIDS  ---------
                drawWireframeRoid(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale, this.originalRadius * cScale, this.hue, this.saturation, this.lightness, this.poleSpinAngle, this.orientation, this.polkadotFlashTimer);

                //  HIGHLIGHT SHADING ----------
                drawCircle(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale);
                var sphereGradient = c.createRadialGradient(
                        (this.pos.x - (0.3 * this.radius)) * cScale, 
                        (this.pos.y - (0.5 * this.radius)) * cScale, 
                        0, 
                        (this.pos.x - (0.3 * this.radius)) * cScale, 
                        (this.pos.y - (0.5 * this.radius)) * cScale, 
                        2*this.radius * cScale);
                var highlight = `hsla(${this.hue + 60}, 50%, 50%, 0.6)`;
                var shadow = `hsla(0, 0%, 0%, 0)`;
                sphereGradient.addColorStop(0.0, highlight);
                sphereGradient.addColorStop(1.0, shadow);
                c.fillStyle = sphereGradient;
                c.fill();

                //  OVERALL BUBBLE SHADING  ----------
                var sphereGradient = c.createRadialGradient(
                        this.pos.x * cScale, 
                        this.pos.y * cScale, 
                        0, 
                        this.pos.x * cScale, 
                        this.pos.y * cScale, 
                        this.radius * cScale);
                var highlight = `hsla(${this.hue + 60}, 50%, 40%, 0.5)`;
                var midtone = `hsla(${this.hue + 60}, 50%, 20%, 0.4)`;
                var shadow = `hsla(${this.hue + 60}, 50%, 10%, 0.2)`;
                sphereGradient.addColorStop(0.0, shadow);
                sphereGradient.addColorStop(0.8, midtone);
                sphereGradient.addColorStop(1.0, highlight);
                c.fillStyle = sphereGradient;
                c.fill();
                return;
            }

            //  DRAW POLKADOTS HERE IF ROIDS ARE *NOT* FILLED ----------
            if (polkadots.checked == true && roidFill.checked != true) {
                var polkaPulseLightness = 50 * Math.abs(Math.cos(((this.polkaSeed + Date.now()) / 2000 / this.radius)));
                drawPolkadots(
                    this.pos.x * cScale,
                    this.pos.y * cScale,
                    this.radius * cScale,
                    6,     // quantity
                    0.3,    // fractional size of roid radius
                    this.hue,
                    this.saturation,
                    polkaPulseLightness,
                    this.lightness,
                    this.polkaSeed,
                    this.randomNo,
                    this.spinAngle || 0,
                    this.polkadotFlashTimer
                );
            }

            //  DRAW ROID OUTLINE ----------
            drawCircle(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale);

            //  FILL ROID OUTLINE ----------
            if (roidFill.checked == true) {
                var sphereGradient = c.createRadialGradient(
                    (this.pos.x - (0.2 * this.radius)) * cScale, 
                    (this.pos.y - (0.4 * this.radius)) * cScale, 
                    0, 
                    (this.pos.x - (0.2 * this.radius)) * cScale, 
                    (this.pos.y - (0.4 * this.radius)) * cScale, 
                    1.5 * this.radius * cScale
                );
                var highlight = `hsl(${this.hue}, ${this.saturation}%, ${this.lightness}%)`;
                var midtone = `hsl(${this.hue}, ${this.saturation - 20}%, ${this.lightness - 30}%)`;
                var shadow = `hsl(0, ${this.saturation - 40}%, ${this.lightness - 65}%)`;
                sphereGradient.addColorStop(0.0, highlight);
                sphereGradient.addColorStop(0.7, midtone);
                sphereGradient.addColorStop(1.0, shadow);
                c.fillStyle = sphereGradient;
                c.fill();
            } else {
                c.strokeStyle = `hsl(${this.hue}, 80%, ${this.lightness}%)`;
                c.lineWidth = Math.max(0.007 * cScale, 0.03 * this.radius * cScale);
                c.stroke();
            }

            //  DRAW POLKADOTS HERE IF ROIDS ARE FILLED ----------
            if (polkadots.checked == true && roidFill.checked == true) {
                var polkaPulseLightness = 50 * Math.abs(Math.cos(((this.polkaSeed + Date.now()) / 2000 / this.radius)));
                drawPolkadots(
                    this.pos.x * cScale,
                    this.pos.y * cScale,
                    this.radius * cScale,
                    12,     // quantity
                    0.3,    // fractional size of roid radius
                    this.hue,
                    this.saturation,
                    polkaPulseLightness,
                    this.lightness,
                    this.polkaSeed,
                    this.randomNo,
                    this.spinAngle || 0,
                    this.polkadotFlashTimer
                );
            }
        }
    }

    //  DEFINE BOMB  ----------
    class BOMB {
        constructor(pos, vel, radius) {
            this.pos = pos.clone();
            this.vel = vel.clone();
            this.radius = radius;
            this.mass = radius;
            this.birthday = Date.now();
            this.exploding = false;
            this.explosionTime = 0;
            this.firstPulse = true;
        }
        get left() {
            return this.pos.x - this.radius;
        }
        get right() {
            return this.pos.x + this.radius;
        }
        simulate() {
            if (this.exploding !== true) {
                //  COMPRESS BOMB BEFORE EXPLODING  ----------
                if (Date.now() - this.birthday > 2800) {
                    this.radius *= 0.9;
                }
                // Guard: if no player roket exists, just coast
                if (!Roket || Roket.length === 0 || !Roket[0] || !Roket[0].pos) {
                    this.pos.add(this.vel, dT);
                    return;
                }

                // Tunable parameters (adjust for feel)
                const maxSpeed = 0.20 + wave / 100;      // desired top speed for the bomb
                const maxAccel = 0.30 + wave / 100;      // max change in velocity (units/sec); lower = smoother
                const angleSmoothing = 0.22; // 0 = no smoothing, 1 = instant

                // Predict intercept heading using the bomb's max speed
                const desiredAngle = getInterceptAngle(this.pos, Roket[0].pos, Roket[0].vel, maxSpeed);

                // Smooth heading to avoid rapid flips
                if (typeof this._smoothedAngle === 'undefined') this._smoothedAngle = desiredAngle;
                const a0 = this._smoothedAngle;
                let da = desiredAngle - a0;
                while (da > Math.PI) da -= 2 * Math.PI;
                while (da < -Math.PI) da += 2 * Math.PI;
                this._smoothedAngle = a0 + da * angleSmoothing;

                const desiredDir = new Vector2(Math.cos(this._smoothedAngle), Math.sin(this._smoothedAngle));

                // desired velocity vector
                const desiredVel = desiredDir.clone();
                desiredVel.scale(maxSpeed);

                // steering = desiredVel - currentVel
                const steering = desiredVel.clone();
                // Vector2.subtract(a,b) expects two args in this codebase; do component subtract here
                steering.x -= this.vel.x;
                steering.y -= this.vel.y;

                // clamp steering to maxAccel * dT so changes are smooth and framerate-independent
                const maxStep = maxAccel * dT;
                const steerLen = steering.length();
                if (steerLen > maxStep && steerLen > 0) {
                    steering.normalize();
                    steering.scale(maxStep);
                }

                // record the actual steering direction applied (after clamping)
                if (steering.x === 0 && steering.y === 0) {
                    // if no steering, prefer the smoothed desired heading or current velocity
                    if (typeof this._smoothedAngle !== 'undefined') {
                        this._steerAngle = this._smoothedAngle;
                    } else {
                        this._steerAngle = Math.atan2(this.vel.y, this.vel.x);
                    }
                } else {
                    this._steerAngle = Math.atan2(steering.y, steering.x);
                }

                // apply steering and clamp speed
                this.vel.add(steering);
                if (this.vel.length() > maxSpeed) {
                    this.vel.normalize();
                    this.vel.scale(maxSpeed);
                }

                //  UPDATE POSITION BASED ON NEW CALCULATED VELOCITY  ----------
                this.pos.add(this.vel, dT);
            } else { 
                //  BOMB IS EXPLODING  -------------------
                var elapsed = (Date.now() - this.birthday) / 1000; // seconds
                if (typeof this._explosionOrigin === 'undefined') {
                    this._explosionOrigin = this.radius; // store radius at explosion start
                }
                // peak expansion 
                var peak = Math.max(0.15, this._explosionOrigin * 8);
                // decay rate (higher => faster onset)
                var decay = 12.0;
                // exponential ease-out: origin + peak * (1 - e^{-decay * t})
                this.radius = this._explosionOrigin + peak * (1 - Math.exp(-decay * elapsed));
            }
        }
        draw() {
            var age = Date.now() - this.birthday;
            if (this.exploding != true) {
                //  DRAW RADAR PULSE  ---------
                c.lineWidth = 0.01 * cScale;
                for (var r = 1; r < 5; r++) {
                    c.strokeStyle = `hsla(0, ${radarPulser * 100}%, ${80}%, ${100 - radarPulser * 100}%)`;
                    var radarPulseRadius = radarPulser * 0.5 * r / 10;
                    drawCircle(this.pos.x * cScale, this.pos.y * cScale, radarPulseRadius * cScale);
                    c.stroke();
                }
                
                let whiteHot = 0;
                if (age > 2800) {
                    whiteHot = 30 * (age - 2800) / 200;
                }
                
                drawCircle(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale);
                var sphereGradient = c.createRadialGradient(
                    (this.pos.x - 0.3 * this.radius) * cScale,
                    (this.pos.y - 0.5 * this.radius) * cScale,
                    0,
                    (this.pos.x - 0.3 * this.radius) * cScale,
                    (this.pos.y - 0.5 * this.radius) * cScale,
                    1.5 * this.radius * cScale);
                var highlight = `hsl(0, ${100 * age / 6000}%, ${70 + whiteHot}%)`;
                var midtone = `hsl(0, ${100 * age / 6000}%, ${50 + whiteHot}%)`;
                var shadow = `hsl(0, 0%, 10%)`;
                sphereGradient.addColorStop(0.0, highlight);
                sphereGradient.addColorStop(0.5, midtone);
                sphereGradient.addColorStop(1.0, shadow);
                c.fillStyle = sphereGradient;
                c.fill();

                //  DRAW HEADING ARROW  ----------
                if (age < 2800) {
                    let heading;
                    if (this.vel && (this.vel.x !== 0 || this.vel.y !== 0)) {
                        heading = Math.atan2(this.vel.y, this.vel.x);
                    } else if (typeof this._smoothedAngle !== 'undefined') {
                        heading = this._smoothedAngle;
                    } else {
                        heading = 0;
                    }
                    let arrowAngle;
                    arrowAngle = 0.5 * Math.PI - heading + Math.PI;
                    var bombDirPulseDisp = 2 * this.radius + 0.7 * this.radius * Math.abs(Math.sin(bombDirShake));
                    const arrowX = this.pos.x + bombDirPulseDisp * Math.cos(heading);
                    const arrowY = this.pos.y + bombDirPulseDisp * Math.sin(heading);
                    drawArrow(arrowX, arrowY, arrowAngle, Math.abs(Math.sin(bombDirShake) * 50 / cScale));
                    c.fillStyle = `hsla(60, 100%, 50%, 60%)`;
                    c.fill();
                }
            } else {
                drawCircle(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale);
                this.alpha = 100 * age / 250;
                if (this.firstPulse == true) {
                    this.firstPulse = false;
                    c.drawImage(offscreenFlashCanvas, (this.pos.x - 0.2) * cScale, (this.pos.y - 0.2) * cScale); 
                    c.drawImage(offscreenFlashCanvas, (this.pos.x - 0.2) * cScale, (this.pos.y - 0.2) * cScale); 
                    c.drawImage(offscreenFlashCanvas, (this.pos.x - 0.2) * cScale, (this.pos.y - 0.2) * cScale); 
                    spawnRoidDebris(this.pos, 0.004, 0, 0, 100, 750, 1.8, 'bomb');
                }
                //  OVERALL BUBBLE SHADING  ----------
                var sphereGradient = c.createRadialGradient(
                    this.pos.x * cScale, 
                    this.pos.y * cScale, 
                    0, 
                    this.pos.x * cScale, 
                    this.pos.y * cScale, 
                    this.radius * cScale);
                var highlight = `hsla(0, 0%, 100%, ${100 - this.alpha}%)`;
                var midtone = `hsla(50, 100%, 60%, ${100 - this.alpha}%)`;
                var shadow = `hsla(0, 0%, 0%, 0%)`;
                sphereGradient.addColorStop(0.0, highlight);
                sphereGradient.addColorStop(0.3, midtone);
                sphereGradient.addColorStop(1.0, shadow);
                c.fillStyle = sphereGradient;
                c.fill();

                //  OUTER CIRCLE
                drawCircle(this.pos.x * cScale, this.pos.y * cScale, Math.pow(this.radius * cScale, 1.3));
                c.lineWidth = 0.0001 * (100 - this.alpha) * cScale;
                c.strokeStyle = `hsla(0, 0%, ${100 - this.alpha}%, ${100 - this.alpha}%)`;
                //c.strokeStyle = `hsl(0, 0%, 100%)`;
                c.stroke();

                /*//  test circle
                drawCircle(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale);
                c.lineWidth = 0.01 * cScale;
                c.strokeStyle = `green`;
                c.stroke();*/
            }
        }
    }

    //  DEFINE PUSHER  ------------------
    class PUSHER {
        constructor(pos, radius, birthday) {
            this.pos = pos.clone();
            this.radius = radius;
            this.birthday = birthday;
        }
        simulate() {
            this.radius += 0.005;
        }
        draw() {
            c.strokeStyle = 'white';
            drawCircle(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale);
            c.strokeWidth = 3;
            //c.stroke();
            var sphereGradient = c.createRadialGradient(
                this.pos.x * cScale, 
                this.pos.y * cScale, 
                0, 
                this.pos.x * cScale, 
                this.pos.y * cScale, 
                this.radius * cScale);

            var pusherHue = 3600 * this.radius;
            var pusherAlpha = 100 - ((Date.now() - this.birthday) / 20);
            if (pusherAlpha < 0) {
                pusherAlpha = 0;
            }
            var shadow = `hsla(0, 0%, 0%, ${pusherAlpha}%)`;
            var highlight = `hsla(${pusherHue}, 50%, 80%, ${pusherAlpha}%)`;
            sphereGradient.addColorStop(1 - pusherAlpha/100, shadow);
            sphereGradient.addColorStop(1.0, highlight);
            c.fillStyle = sphereGradient;
            c.fill();
        }
    }

    //  DEFINE ROKET  -------------------
    class ROKET {
        constructor(pos, vel, radius, mass, angle, collision, thrust) {
            this.pos = pos.clone();
            this.vel = vel.clone();
            this.radius = radius;
            this.mass = mass;
            this.angle = angle;
            this.collision = collision;
            this.thrust = thrust;
        }
        get left() {
            return this.pos.x - this.radius;
        }
        get right() {
            return this.pos.x + this.radius;
        }
        startSimulate() {
            /*if (this.angle <= 0) {
                this.goCCW = true;
            } else
            if (this.angle >= 2*Math.PI) {
                this.goCCW = false;
            }
            if (this.goCCW == true) {
                this.angle += 0.02;
            } else {
                this.angle -= 0.02;
            }
            this.vel = new Vector2(
                0.5 * Math.cos(this.angle),
                -0.5 * Math.sin(this.angle)
            )*/

            this.angle += 0.017;
            this.vel = new Vector2(
                0.5 * Math.cos(this.angle),
                -0.5 * Math.sin(this.angle)
            )
            
            this.pos.add(this.vel, dT);
            spawnIdleExhaustlets(this.pos.x, this.pos.y, this.angle, 'friend');
        }
        simulate() {
            if (leftPressed == true) {
                tumbling = false;
                Roket[0].collision = 0;
                this.angle += 0.1;
                spawnRetro(this.pos.x, this.pos.y);
            }
            if (rightPressed == true) {
                tumbling = false;
                Roket[0].collision = 0
                this.angle -= 0.1;
                spawnRetro(this.pos.x, this.pos.y);
            }
            if (tumbling == true) {
                spawnRetro(this.pos.x, this.pos.y);
                if (this.vel.x > 0) {
                    this.angle -= 0.25 * this.vel.length();
                } else {
                    this.angle += 0.25 * this.vel.length();
                } 
                if (score > 0) {
                    score -= 11;
                    if (score < 1) {
                        score = 0;
                    }
                }
            }
            if (thrustKey == true) {
                spawnThrustExhaustlets(this.pos.x, this.pos.y, this.angle)
                var power = .02;
                var thrust = new Vector2(power * Math.cos(this.angle), 
                -power * Math.sin(this.angle));
                this.vel.add(thrust);
                if (this.vel.length() > 2) {
                    this.vel.scale(0.9);
                }
            } else {
                spawnIdleExhaustlets(this.pos.x, this.pos.y, this.angle, 'friend');
            }

            
            this.pos.add(this.vel, 1/60);
            totalTravelX += Roket[0].vel.x * (1/60);
            totalTravelY += Roket[0].vel.y * (1/60);

            //  HANDLE BOUNDS  -------------------
            //  TOO FAR RIGHT  ----------
            if (this.pos.x > simWidth) {
                startReentryPos = new Vector2(0, this.pos.y);
                if (Roids.length > 0) {
                    for (var r = 0; r < Roids.length; r++) {
                        var roid = Roids[r];
                        this.pos = findSafeReentry(roid, startReentryPos);
                    }
                } else {
                    this.pos = startReentryPos;
                }
            }
            //  TOO FAR LEFT  ----------
            if (this.pos.x < 0) {
                startReentryPos = new Vector2(simWidth, this.pos.y);
                if (Roids.length > 0) {
                    for (var r = 0; r < Roids.length; r++) {
                        var roid = Roids[r];
                        this.pos = findSafeReentry(roid, startReentryPos);
                    }
                } else {
                    this.pos = startReentryPos;
                }
            }
            //  TOO HIGH  ----------
            if (this.pos.y < 0) {
                startReentryPos = new Vector2(this.pos.x, simHeight);
                if (Roids.length > 0) {
                    for (var r = 0; r < Roids.length; r++) {
                        var roid = Roids[r];
                        this.pos = findSafeReentry(roid, startReentryPos);
                    }
                } else {
                    this.pos = startReentryPos;
                }
            }
            //  TOO LOW  ----------
            if (this.pos.y > simHeight) {
                startReentryPos = new Vector2(this.pos.x, 0);
                if (Roids.length > 0) {
                    for (var r = 0; r < Roids.length; r++) {
                        var roid = Roids[r];
                        this.pos = findSafeReentry(roid, startReentryPos);
                    }
                } else {
                    this.pos = startReentryPos;
                }
            }
        }
        draw() {
            //  DRAW ROKET  ------------------
            var roket = {
                radius: this.radius,
                // FUSELAGE -----
                // 1 bottom center
                a1cos: Math.cos(rads(0 - 90) + this.angle),
                a1sin: Math.sin(rads(0 - 90) + this.angle),
                r1: 0,
                // 2 bottom 
                a2cos: Math.cos(rads(0 - 90) + this.angle),
                a2sin: Math.sin(rads(0 - 90) + this.angle),
                r2: 0.07893,
                al2cos: Math.cos(rads(180 - 90) + this.angle),
                al2sin: Math.sin(rads(180 - 90) + this.angle),
                rl2: 0.07893,
                // 6 top fin attach point
                a6cos: Math.cos(rads(66.6 - 90) + this.angle),
                a6sin: Math.sin(rads(66.6 - 90) + this.angle),
                r6: 0.2859,
                al6cos: Math.cos(rads(113.4 - 90) + this.angle),
                al6sin: Math.sin(rads(113.4 - 90) + this.angle),
                rl6: 0.2859,
                // 7 mid side tip
                a7cos: Math.cos(rads(70.1 - 90) + this.angle),
                a7sin: Math.sin(rads(70.1 - 90) + this.angle),
                r7: 0.4383,
                al7cos: Math.cos(rads(109.9 - 90) + this.angle),
                al7sin: Math.sin(rads(109.9 - 90) + this.angle),
                rl7: 0.4383,
                // 8 mid top
                a8cos: Math.cos(rads(78.4 - 90) + this.angle),
                a8sin: Math.sin(rads(78.4 - 90) + this.angle),
                r8: 0.6089,
                al8cos: Math.cos(rads(101.6 - 90) + this.angle),
                al8sin: Math.sin(rads(101.6 - 90) + this.angle),
                rl8: 0.6089,
                // 9 tip
                a9cos: Math.cos(this.angle),
                a9sin: Math.sin(this.angle),
                r9: 0.7630,
                // 10 nozzle top right
                a10cos: Math.cos(rads(0 - 90) + this.angle),
                a10sin: Math.sin(rads(0 - 90) + this.angle),
                r10: 0.03508,
                //  11 nozzle bottom right
                a11cos: Math.cos(rads(-45 - 90) + this.angle),
                a11sin: Math.sin(rads(-45 - 90) + this.angle),
                r11: 0.1,
                //  12 nozzle bottom left
                a12cos: Math.cos(rads(225 - 90) + this.angle),
                a12sin: Math.sin(rads(225 - 90) + this.angle),
                r12: 0.1,
                // 13 nozzle top left
                a13cos: Math.cos(rads(180 - 90) + this.angle),
                a13sin: Math.sin(rads(180 - 90) + this.angle),
                r13: 0.03508,

                // RIGHT FIN -----
                // 3 fin tip bottom
                a3cos: Math.cos(rads(-43.9 - 90) + this.angle),
                a3sin: Math.sin(rads(-43.9 - 90) + this.angle),
                r3: 0.3287,
                // 4 fin tip top
                a4cos: Math.cos(rads(-16.7 - 90) + this.angle),
                a4sin: Math.sin(rads(-16.7 - 90) + this.angle),
                r4: 0.2747,
                // 5 fin side
                a5cos: Math.cos(rads(30.3 - 90) + this.angle),
                a5sin: Math.sin(rads(30.3 - 90) + this.angle),
                r5: 0.2426,

                // LEFT FIN
                // 3l fin tip bottom
                al3cos: Math.cos(rads(223.9 - 90) + this.angle),
                al3sin: Math.sin(rads(223.9 - 90) + this.angle),
                rl3: 0.3287,
                // 4l fin tip top
                al4cos: Math.cos(rads(196.7 - 90) + this.angle),
                al4sin: Math.sin(rads(196.7 - 90) + this.angle),
                rl4: 0.2747,
                // 5l fin side
                al5cos: Math.cos(rads(139.7 - 90) + this.angle),
                al5sin: Math.sin(rads(139.7 - 90) + this.angle),
                rl5: 0.2426,
                // portholes
                windowCos: Math.cos(this.angle),
                windowSin: Math.sin(this.angle),
                rTop: 0.6,
                rMid: 0.456,
                rBot: 0.3,
            }

            //  ANTENNA  ----------
            c.beginPath();
            c.moveTo(this.pos.x * cScale, this.pos.y * cScale);
            c.lineTo((this.pos.x + 1.15 * roket.r9 * roket.radius * Math.cos(this.angle)) * cScale, 
            (this.pos.y - 1.15 * roket.r9 * roket.radius * Math.sin(this.angle)) * cScale)
            c.strokeStyle = 'hsl(0, 0%, 90%)';
            c.lineWidth = 0.015 * roket.radius * cScale;
            c.shadowBlur = 10;
            c.shadowColor = 'black';
            c.stroke();

            //  ADVANCE RUDOLPH AND DRAW ----------
            rudolph += 0.03;
            if (rudolph > 2 * Math.PI) {
                rudolph -= 2 * Math.PI;
            }
            rudolphIntensity = 10 + 50 * Math.abs(Math.sin(rudolph));
            drawCircle((this.pos.x + 1.15 * roket.r9 * roket.radius * Math.cos(this.angle)) * cScale, 
                (this.pos.y - 1.15 * roket.r9 * roket.radius * Math.sin(this.angle)) * cScale, 
            0.05 * roket.radius * cScale);
            c.fillStyle = `hsl(0, 100%, ${rudolphIntensity}%)`
            c.shadowBlur = 0;
            c.shadowColor = 'black';
            c.fill();

            // FUSELAGE (smooth Catmull-Rom spline)
            const pts = [
                { x: (this.pos.x + roket.radius * roket.r1 * roket.a1cos) * cScale, y: (this.pos.y - roket.radius * roket.r1 * roket.a1sin) * cScale },
                { x: (this.pos.x + roket.radius * roket.r2 * roket.a2cos) * cScale, y: (this.pos.y - roket.radius * roket.r2 * roket.a2sin) * cScale },
                { x: (this.pos.x + roket.radius * roket.r6 * roket.a6cos) * cScale, y: (this.pos.y - roket.radius * roket.r6 * roket.a6sin) * cScale },
                { x: (this.pos.x + roket.radius * roket.r7 * roket.a7cos) * cScale, y: (this.pos.y - roket.radius * roket.r7 * roket.a7sin) * cScale },
                { x: (this.pos.x + roket.radius * roket.r8 * roket.a8cos) * cScale, y: (this.pos.y - roket.radius * roket.r8 * roket.a8sin) * cScale },
                { x: (this.pos.x + roket.radius * roket.r9 * roket.a9cos) * cScale, y: (this.pos.y - roket.radius * roket.r9 * roket.a9sin) * cScale },
                { x: (this.pos.x + roket.radius * roket.rl8 * roket.al8cos) * cScale, y: (this.pos.y - roket.radius * roket.rl8 * roket.al8sin) * cScale },
                { x: (this.pos.x + roket.radius * roket.rl7 * roket.al7cos) * cScale, y: (this.pos.y - roket.radius * roket.rl7 * roket.al7sin) * cScale },
                { x: (this.pos.x + roket.radius * roket.rl6 * roket.al6cos) * cScale, y: (this.pos.y - roket.radius * roket.rl6 * roket.al6sin) * cScale },
                { x: (this.pos.x + roket.radius * roket.rl2 * roket.al2cos) * cScale, y: (this.pos.y - roket.radius * roket.rl2 * roket.al2sin) * cScale }
            ];
            const smoothPts = catmullRomSpline(pts, 0.5, 12);
            c.beginPath();
            c.moveTo(smoothPts[0].x, smoothPts[0].y);
            for (let i = 1; i < smoothPts.length; i++) {
                c.lineTo(smoothPts[i].x, smoothPts[i].y);
            }
            c.closePath();
            c.fillStyle = 'hsl(120, 60%, 40%)';
            c.shadowBlur = 8;
            c.fill();
            c.strokeStyle = 'black';
            c.lineWidth = 1;
            c.stroke();

            //  NOZZLE  ---------
            c.beginPath();
            c.moveTo((this.pos.x + roket.radius * roket.r10 * roket.a10cos) * cScale,
                (this.pos.y - roket.radius * roket.r10 * roket.a10sin) * cScale);
            c.lineTo((this.pos.x + roket.radius * roket.r11 * roket.a11cos) * cScale,
                (this.pos.y - roket.radius * roket.r11 * roket.a11sin) * cScale);
            c.lineTo((this.pos.x + roket.radius * roket.r12 * roket.a12cos) * cScale,
                (this.pos.y - roket.radius * roket.r12 * roket.a12sin) * cScale);
            c.lineTo((this.pos.x + roket.radius * roket.r13 * roket.a13cos) * cScale,
                (this.pos.y - roket.radius * roket.r13 * roket.a13sin) * cScale);
            c.closePath();
            c.shadowBlur = 0;
            c.stroke();
            c.fillStyle = 'hsl(30, 70%, 60%)';
            c.fill();

            // RIGHT FIN (smooth)
            const rightFinPts = [
                { x: (this.pos.x + roket.radius * roket.r2 * roket.a2cos) * cScale, y: (this.pos.y - roket.radius * roket.r2 * roket.a2sin) * cScale },
                { x: (this.pos.x + roket.radius * roket.r3 * roket.a3cos) * cScale, y: (this.pos.y - roket.radius * roket.r3 * roket.a3sin) * cScale },
                { x: (this.pos.x + roket.radius * roket.r4 * roket.a4cos) * cScale, y: (this.pos.y - roket.radius * roket.r4 * roket.a4sin) * cScale },
                { x: (this.pos.x + roket.radius * roket.r5 * roket.a5cos) * cScale, y: (this.pos.y - roket.radius * roket.r5 * roket.a5sin) * cScale },
                { x: (this.pos.x + roket.radius * roket.r6 * roket.a6cos) * cScale, y: (this.pos.y - roket.radius * roket.r6 * roket.a6sin) * cScale },
                { x: (this.pos.x + roket.radius * roket.r2 * roket.a2cos) * cScale, y: (this.pos.y - roket.radius * roket.r2 * roket.a2sin) * cScale }
            ];
            const rightFinSmooth = catmullRomSpline(rightFinPts, 0.5, 10);
            c.beginPath();
            c.moveTo(rightFinSmooth[0].x, rightFinSmooth[0].y);
            for (let i = 1; i < rightFinSmooth.length; i++) {
                c.lineTo(rightFinSmooth[i].x, rightFinSmooth[i].y);
            }
            c.closePath();
            c.fillStyle = 'hsl(180, 90%, 44%)';
            c.shadowBlur = 5;
            c.fill();
            c.strokeStyle = 'black';
            c.lineWidth = 1;
            c.stroke();


            // LEFT FIN (smooth)
            const leftFinPts = [
                { x: (this.pos.x + roket.radius * roket.rl2 * roket.al2cos) * cScale, y: (this.pos.y - roket.radius * roket.rl2 * roket.al2sin) * cScale },
                { x: (this.pos.x + roket.radius * roket.rl3 * roket.al3cos) * cScale, y: (this.pos.y - roket.radius * roket.rl3 * roket.al3sin) * cScale },
                { x: (this.pos.x + roket.radius * roket.rl4 * roket.al4cos) * cScale, y: (this.pos.y - roket.radius * roket.rl4 * roket.al4sin) * cScale },
                { x: (this.pos.x + roket.radius * roket.rl5 * roket.al5cos) * cScale, y: (this.pos.y - roket.radius * roket.rl5 * roket.al5sin) * cScale },
                { x: (this.pos.x + roket.radius * roket.rl6 * roket.al6cos) * cScale, y: (this.pos.y - roket.radius * roket.rl6 * roket.al6sin) * cScale },
                { x: (this.pos.x + roket.radius * roket.rl2 * roket.al2cos) * cScale, y: (this.pos.y - roket.radius * roket.rl2 * roket.al2sin) * cScale }
            ];
            const leftFinSmooth = catmullRomSpline(leftFinPts, 0.5, 10);
            c.beginPath();
            c.moveTo(leftFinSmooth[0].x, leftFinSmooth[0].y);
            for (let i = 1; i < leftFinSmooth.length; i++) {
                c.lineTo(leftFinSmooth[i].x, leftFinSmooth[i].y);
            }
            c.closePath();
            c.fill();
            c.shadowBlur = 0;
            c.stroke();

            //  WINDOWS  ----------
            drawCircle((this.pos.x + roket.rTop * roket.radius * Math.cos(this.angle)) * cScale, 
                (this.pos.y - roket.rTop * roket.radius * Math.sin(this.angle)) * cScale,
            0.04 * roket.radius * cScale);
            c.strokeStyle = 'hsl(0, 0%, 90%)';
            c.lineWidth = 0.015 * roket.radius * cScale;
            c.fillStyle = 'black';
            c.fill();
            c.stroke();

            drawCircle((this.pos.x + roket.rMid * roket.radius * Math.cos(this.angle)) * cScale, 
                (this.pos.y - roket.rMid * roket.radius * Math.sin(this.angle)) * cScale,
            0.05 * roket.radius * cScale);
            c.fill();
            c.stroke();

            drawCircle((this.pos.x + roket.rBot * roket.radius * Math.cos(this.angle)) * cScale, 
                (this.pos.y - roket.rBot * roket.radius * Math.sin(this.angle)) * cScale,
            0.05 * roket.radius * cScale);
            c.fill();
            c.stroke();
        }
    }

    //  DEFINE ROKET DEBRIS -------------------
    class DEBRIS {
        constructor(pos, vel, radius, angle, hue, alpha, birthday) {
            this.pos = pos.clone();
            this.vel = vel.clone();
            this.radius = radius;
            this.angle = angle;
            this.hue = hue;
            this.alpha = alpha;
            this.birthday = birthday;
        }
        simulate() {
            this.vel.scale(0.97);
            this.pos.add(this.vel, dT)
            this.angle += 0.2;
            this.alpha = 100 - ((Date.now() - this.birthday)) * 100 / 2000;
        }
        get left() {
            return this.pos.x - this.radius;
        }
        get right() {
            return this.pos.x + this.radius;
        }
        draw() {  
            c.beginPath();
            for (var s = 0; s < 3; s++) {
                if (s == 0) {
                    c.moveTo((this.pos.x + this.radius * Math.cos((s * 2 * Math.PI / 3) + this.angle)) * cScale, 
                    (this.pos.y - this.radius * Math.sin((s * 2 * Math.PI / 3) + this.angle)) * cScale);
                } else {
                    c.lineTo((this.pos.x + this.radius * Math.cos((s * 2 * Math.PI / 3) + this.angle)) * cScale, 
                    (this.pos.y - this.radius * Math.sin((s * 2 * Math.PI / 3) + this.angle)) * cScale);
                }
            }
            c.closePath();
            c.fillStyle = `hsla(${this.hue}, 50%, 50%, ${this.alpha}%)`;
            c.fill();
        }
    }

    //  DEFINE ROID DEBRIS -------------------
    class ROIDDEBRIS {
        constructor(pos, vel, radius, hue, sat, alpha, birthday, type) {
            this.pos = pos.clone();
            this.vel = vel.clone();
            this.radius = radius;
            this.hue = hue;
            this.sat = sat;
            this.alpha = alpha;
            this.birthday = birthday;
            this.type = type;
        }
        simulate() {
            this.pos.add(this.vel, dT)
            if (this.type == 'torpedo') {
                this.alpha = 70 - ((Date.now() - this.birthday)) * 50 / 1000;
            } else {
                this.alpha = 100 - ((Date.now() - this.birthday)) * 100 / 1000;
            }
        }
        draw() {  
            drawCircle(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale)
            c.fillStyle = `hsl(${this.hue}, ${this.sat}%, ${this.alpha}%, ${this.alpha}%)`;
            c.fill();
        }
    }

    //  DEFINE RING OF FIRE -------------------
    class RINGOFFIRE {
        constructor(pos, hue, vel) {
            this.pos = pos.clone();
            this.birthday = Date.now();
            this.vel = new Vector2((-0.25 + 0.5 * Math.random()), (-0.25 + 0.5 * Math.random()));
            this.hue = hue;
        }
        simulate() {
            this.pos.add(this.vel, dT)
        }
        draw() {
            var alpha = 100 - (100 * (Date.now() - this.birthday) / 500);
            drawCircle(this.pos.x * cScale, this.pos.y * cScale, 0.004 * cScale)
            c.fillStyle = `hsl(${this.hue}, 60%, 60%, ${alpha}%)`;
            c.fill();
        }
    }

    function spawnRingOfFire(pos, radius, hue, vel) {
        for (var i = 0; i < 300; i++) {
            var angle = i * (2 * Math.PI / 300);
            var x = pos.x + radius * Math.cos(angle);
            var y = pos.y + radius * Math.sin(angle);
            var newPos = new Vector2(x, y);
            RingOfFire.push(new RINGOFFIRE(newPos, hue, vel));
        }
    }

    //  DEFINE MUZZLE FLASH  -------------------
    class MUZZLE_FLASH {
        constructor(pos, vel, radius, alpha, birthday) {
            this.pos = pos.clone();
            this.vel = vel.clone();
            this.radius = radius;
            this.alpha = alpha;
            this.birthday = birthday;
        }
        simulate() {
            this.pos.add(this.vel, dT)
            this.alpha = 100 - ((Date.now() - this.birthday)) * 100 / 500;
            if (Date.now() - this.birthday > 500) {
                MuzzleFlash.splice(0,1)
            }
            this.vel.scale(0.88);
        }
        draw() {  
            drawCircle(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale)
            c.fillStyle = `hsl(60, 100%, 40%, ${this.alpha}%)`;
            c.fill();
        }
    }

    //  DEFINE TORPEDO HIT PULSE  -------------------
    class PULSE {
        constructor(pos, radius, alpha, birthday) {
            this.pos = pos.clone();
            this.radius = radius;
            this.alpha = alpha;
            this.birthday = birthday;
        }
        simulate() {
            this.radius += 0.03;
            this.alpha = 100 - ((Date.now() - this.birthday)) * 100 / 300;
        }
        draw() {
            drawCircle(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale);
            c.lineWidth = this.alpha/10000 * cScale;
            c.strokeStyle = `hsla(0, 0%, 70%, ${this.alpha}%)`;
            c.stroke();
            if (firstPulse == true) {
                firstPulse = false;
                c.drawImage(offscreenFlashCanvas, (this.pos.x - 0.2) * cScale, (this.pos.y - 0.2) * cScale); 
            }
        }
    }

    //  DEFINE WARP IN GRAPHIC  -------------------
    class WARP {
        constructor(pos, radius, alpha, birthday) {
            this.pos = pos.clone();
            this.radius = radius;
            this.alpha = alpha;
            this.birthday = birthday;
        }
        simulate() {
            if ((Date.now() - this.birthday) / 1000 < 0.25) {
                this.radius += 0.015;
            } 
            if ((Date.now() - this.birthday) / 1000 >= 0.25 ) {
                this.radius -= 0.02;
                if (this.radius < 0.0) {
                    this.radius = 0.0;
                }
            }
            this.alpha = 100 - ((Date.now() - this.birthday)) * 0.1;
            if ((Date.now() - this.birthday) / 1000 > 1.0) {
                WarpIn = [];
            }
        }
        draw() {
            var warpArrowAngle = getDangle(0, 0, Roket[0].vel.x, -Roket[0].vel.y);
            drawArrow(this.pos.x, this.pos.y, warpArrowAngle - 0.5 * Math.PI, this.radius);
            
            c.fillStyle = `hsl(0, 0%, 70%, ${this.alpha}%)`;
            c.strokeStyle = `hsl(0, 0%, 70%, ${this.alpha}%)`;
            c.lineWidth = 0.02 * cScale * (Date.now() - this.birthday) / 1000;
            if ((Date.now() - this.birthday) / 1000 < 0.3) {  
                c.stroke();
            } 
            if ((Date.now() - this.birthday) / 1000 >= 0.25 ) {
                c.stroke();
            }
        }
    }

    //  DEFINE SCORER GRAPHIC  --------------------
    class SCORER {
        constructor(pos, vel, radius, alpha, birthday, score) {
            this.pos = pos.clone();
            this.vel = vel;
            this.radius = radius;
            this.alpha = alpha;
            this.birthday = birthday;
            this.score = score;
        }
        simulate() {
            this.radius += 0.05;
            this.alpha = 100 - ((Date.now() - this.birthday)) / 10;
            this.pos.add(this.vel, dT);
        }
        draw() {
            c.font = `${8 * this.radius}px monospace`;
            c.fillStyle = `hsl(105, 0%, 80%, ${this.alpha}%)`;
            c.fillText(Math.floor(this.score), this.pos.x * cScale, this.pos.y * cScale);
        }
    }

    //  DEFINE ENGINE THRUST PARTICLE  -------------------
    class THRUSTLET {
        constructor(pos, vel, radius, maxRadius, 
        hue, saturation, lightness, alpha, birthday, lifespan, age) {
            this.pos = pos.clone();
            this.vel = vel.clone();
            this.radius = radius;
            this.maxRadius = maxRadius;
            this.hue = hue;
            this.saturation = saturation;
            this.lightness = lightness;
            this.alpha = alpha;
            this.birthday = birthday;
            this.lifespan = lifespan;
            this.age = age;
        }
        simulate() {
            this.age = Date.now() - this.birthday;
            this.radius = this.maxRadius * (this.age) / this.lifespan;
            this.alpha = 100 - (this.age) * 100 / this.lifespan;
            this.pos.add(this.vel, dT)

            if (this.age > this.lifespan) {
                Exhaustlets.splice(0, 1);
            }
        }
        draw() {
            drawCircle(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale);
            c.lineWidth = 1;
            if (roidFill.checked == true) {
                c.fillStyle = `hsl(${this.hue}, ${this.saturation}%, ${this.lightness}%, ${this.alpha}%)`;
                c.fill();
            } else {
                c.strokeStyle = `hsla(${this.hue}, ${this.saturation}%, ${this.lightness}%, ${this.alpha}%)`;
                c.stroke();
            }
            
            
        }
    }

    //  DEFINE STEERING RETRO THRUSTLET  -------------------
    class RETROLET {
        constructor(pos, vel, radius, maxRadius, 
        hue, saturation, lightness, alpha, birthday, lifespan, age) {
            this.pos = pos.clone();
            this.vel = vel.clone();
            this.radius = radius;
            this.maxRadius = maxRadius;
            this.hue = hue;
            this.saturation = saturation;
            this.lightness = lightness;
            this.alpha = alpha;
            this.birthday = birthday;
            this.lifespan = lifespan;
            this.age = age;
        }
        simulate() {
            this.age = Date.now() - this.birthday;
            this.radius = this.maxRadius * ((Date.now() - this.birthday)) / this.lifespan;
            this.alpha = 100 - ((Date.now() - this.birthday)) * 100 / this.lifespan;
            this.pos.add(this.vel, dT)

            if (Date.now() - this.birthday > this.lifespan) {
                RetroLets.splice(0, 1);
            }
        }
        draw() {
            drawCircle(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale);
            c.lineWidth = 1;
            if (roidFill.checked == true) {
                c.fillStyle = `hsl(${this.hue}, ${this.saturation}%, ${this.lightness}%, ${this.alpha}%)`;
                c.fill();
            } else {
                c.strokeStyle = `hsla(${this.hue}, ${this.saturation}%, ${this.lightness}%, ${this.alpha}%)`;
                c.stroke();
            }
        }
    }

    //  DEFINE RESPAWN STARS AND GRAPHIC  -------------------
    class SPAWNLET {
        constructor(pos, vel, radius, maxRadius, 
        hue, saturation, lightness, alpha, birthday, lifespan, spin, angle) {
            this.pos = pos.clone();
            this.vel = vel.clone();
            this.radius = radius;
            this.maxRadius = maxRadius;
            this.hue = hue;
            this.saturation = saturation;
            this.lightness = lightness;
            this.alpha = alpha;
            this.birthday = birthday;
            this.lifespan = lifespan;
            this.spin = spin;
            this.angle = angle;
        }
        simulate() {
            this.radius = this.maxRadius * ((Date.now() - this.birthday)) / this.lifespan;
            this.alpha = 100 - ((Date.now() - this.birthday)) * 100 / this.lifespan;
            this.pos.add(this.vel, dT)
            this.angle += this.spin;
            if (Date.now() - this.birthday > this.lifespan) {
                Spawnlets.splice(0, 1);
            }
        }
        draw() {
            const starWedges = Math.PI / 5;
            var innerRadius = 0.5 * this.radius;
            var outerRadius = 1.5 * this.radius;
            c.beginPath();
            for (var v = 0; v < 10; v++) {
                if (v == 0) {
                    c.moveTo((this.pos.x + innerRadius * Math.cos(this.angle + v * starWedges)) * cScale, (this.pos.y + innerRadius * Math.sin(this.angle + v * starWedges)) * cScale);
                } else 
                if (v % 2 == 0) {  //inner
                    c.lineTo((this.pos.x + innerRadius * Math.cos(this.angle + v * starWedges)) * cScale, (this.pos.y + innerRadius * Math.sin(this.angle + v * starWedges)) * cScale);
                } else {  //outer
                    c.lineTo((this.pos.x + outerRadius * Math.cos(this.angle + v * starWedges)) * cScale, (this.pos.y + outerRadius * Math.sin(this.angle + v * starWedges)) * cScale);
                }
            }
            c.closePath();
            //drawCircle(this.pos.x * cScale, this.pos.y * cScale, this.radius * cScale);
            c.fillStyle = `hsla(${this.hue}, ${this.saturation}%, ${this.lightness}%, ${this.alpha}%)`;
            c.fill();
        }
    }

    //  DEFINE UPGRADE PRIZE  --------------------
    class PRIZE {
        constructor(pos, vel, radius, birthday) {
            this.pos = pos.clone();
            this.vel = vel.clone()
            this.radius = radius;
            this.birthday = birthday;
            this.angularposition = 0;
            this.startingRadius = radius;
        }
        simulate() {
            this.pos.add(this.vel, dT);
            this.angularposition += 0.08;
        }
        draw() {
            c.fillStyle = 'black'
            drawCircle(
                this.pos.x * cScale,
                this.pos.y * cScale,
                this.radius * cScale);
            c.fill();

            c.strokeStyle = 'yellow'
            c.lineWidth = 0.2 * this.radius * cScale;
            drawCircle(
                this.pos.x * cScale,
                this.pos.y * cScale,
                this.radius * cScale);
            c.shadowColor = 'black';
            c.shadowBlur = 10;
            c.stroke();
            c.shadowBlur = 0;
            
            textPulse += 0.2;
            var lightness = 50 * Math.abs(Math.cos(textPulse));
            c.fillStyle = `hsl(0, 90%, ${lightness}%)`
            c.textAlign = 'center';
            c.textBaseline = 'middle';
            c.font = `bold ${3 * this.radius * cScale}px monospace`;
            c.fillText('+', this.pos.x * cScale, (this.pos.y + 0.15 * this.radius) * cScale);

            //  STARS  ----------------- (drawStar function applies cScale itself)
            var starQuant = 8;
            if (poofPrize == true) {
                poofStars += 0.5;
                for (var d = 0; d < starQuant; d++) {
                    var stardist = 2 * this.startingRadius + 0.6 * poofStars * this.startingRadius;
                    var radialGrowthFade = 100 - 1.5 * (this.startingRadius - this.radius) / this.startingRadius * 100;
                    drawStar(new Vector2(
                        (this.pos.x + stardist * Math.cos(this.angularposition + d * 2 * Math.PI / starQuant)), 
                        (this.pos.y + stardist * Math.sin(this.angularposition + d * 2 * Math.PI / starQuant))), 
                        this.startingRadius + 0.2 * poofStars * this.startingRadius, 
                        Math.PI / 5 + this.angularposition + d * 2 * Math.PI / starQuant);
                    if (weaponLevel < 6 || weaponLevel > 7) {
                        if (d % 2 == 0) {
                            c.fillStyle = `hsla(0, 0%, 80%, ${radialGrowthFade}%)`;
                        } else {    
                            c.fillStyle = `hsla(0, 100%, 50%, ${radialGrowthFade}%)`;
                        }
                    } else {
                        c.fillStyle = `hsla(${360 * d / starQuant}, 80%, 50%, ${radialGrowthFade}%)`;     
                    }
                    c.lineWidth = (0.1 * this.startingRadius + 0.00005 * poofStars) * cScale;
                    c.fill();
                } 
            } else {
                poofStars = 1;
                for (var d = 0; d < starQuant; d++) {
                    var stardist = 2 * this.radius + 2 * this.radius * Math.abs(Math.cos(this.angularposition));
                    drawStar(new Vector2(
                        (this.pos.x + stardist * Math.cos(this.angularposition + d * 2 * Math.PI / starQuant)), 
                        (this.pos.y + stardist * Math.sin(this.angularposition + d * 2 * Math.PI / starQuant))), 
                        1 * this.radius + 10 * (stardist - 2 * this.radius) * this.radius, 
                        Math.PI / 5 + 1.5 * this.angularposition + d * 2 * Math.PI / starQuant);
                    if (weaponLevel < 6) {
                        if (d % 2 == 0) {
                            c.fillStyle = `hsl(0, 0%, 80%)`;
                        } else {    
                            c.fillStyle = `hsl(0, 100%, 50%)`;
                        }
                    } else {
                        c.fillStyle = `hsl(${360 * d / starQuant}, 90%, 50%)`;     
                    }
                    c.fill();
                }

            }
            
            // DISAPPEAR PRIZE  ----------------
            if (poofPrize == true) {
                this.radius *= 0.985;
                c.fillStyle = `hsl(60, 50%, 50%)`
                c.font = `${1.8 * this.radius * cScale}px monospace`;
                c.textAlign = 'center';
                //c.strokeStyle = 'green'
                c.lineWidth = 0.05 * this.radius * cScale;
                if (weaponLevel <= 6) {
                    c.fillText(`TORPEDO x ${weaponLevel + 1}`, this.pos.x * cScale, (this.pos.y - 2.3 * this.radius) * cScale);
                } else if (weaponLevel == 7) {
                    c.fillText(`TASTE THE RAINBOW!!`, this.pos.x * cScale, (this.pos.y - 2.3 * this.radius) * cScale);
                } else if (weaponLevel == 8) {
                    c.fillText(`GO NUTS!!!`, this.pos.x * cScale, (this.pos.y - 2.3 * this.radius) * cScale);
                } else if (weaponLevel == 9) {
                    c.fillText(`YOU CAN'T LOSE!!!`, this.pos.x * cScale, (this.pos.y - 2.3 * this.radius) * cScale);
                }
                if (radialGrowthFade <= 0) {
                    Prize = [];
                    poofPrize = false;
                }
            }
        }
    }

   
    //  SPAWN OBJECTS  -----------------------------------------------------------------

    //  SPAWN STARS FOR BACKGROUND  -----------------
    function makeStars() {
        StarField = [];
        for (r = 0; r < (0.003 * Math.floor(canvas.height * canvas.width)); r++) {
            var pos = new Vector2(-0.1 * simWidth + Math.random() * 1.2 * simWidth,
                -0.1 + Math.random() * 1.2 * simHeight);
            var radius = 0.3 + .8 * Math.random();
            var hue = Math.random() * 360;
            var lightness = Math.random();
            var velY = 0.01;
            var falling = false;
            StarField.push(new STAR(pos, radius, hue, lightness, velY, falling));
        }
        for (r = 0; r < (0.0001 * Math.floor(canvas.height * canvas.width)); r++) {
            var pos = new Vector2(-0.1 * simWidth + Math.random() * 1.2 * simWidth,
                -0.1 + Math.random() * 1.2 * simHeight);
            var radius = 1.0 + 1.5 * Math.random();
            var hue = Math.random() * 360;
            var lightness = 0.6 * Math.random();
            var velY = 0.01;
            var falling = false;
            StarField.push(new STAR(pos, radius, hue, lightness, velY, falling));
        }
    }

    //  PICK FALLING STARS AT GAME OVER  -------------------
    function dropStar() {
        if (pickFallingStar < StarField.length) {
            StarField[pickFallingStar].falling = true;
            pickFallingStar += 1;
        }
        if (pickFallingStar == StarField.length - 1) {
            clearInterval(fallingStars);
        }
    }

    //  SPAWN WARP-IN GRAPHIC  -----------------
    function spawnWarpIn(pos) {
        var pos = pos;
        var radius = 0.01;
        var alpha = 0;
        var birthday = Date.now();

        WarpIn.push(new WARP(pos, radius, alpha, birthday));
    }
    
    //  SPAWN ROKET  -----------------
    function makeRoket() {
        var pos = new Vector2(0.5 * simWidth, 0.7 * simHeight);
        var vel = new Vector2();
        var radius = .12;
        var mass = radius;
        var angle = 0;
        var collision = 0;
        Roket.push(new ROKET(pos, vel, radius, mass, angle, collision));
    }

    //  SPAWN UPGRADE PRIZE  --------------------
    function spawnPrize(pos) {
        var pos = new Vector2(pos.x, pos.y);
        var vel = new Vector2(0.1 * Math.random(), 0.1 * Math.random());
        var radius = 0.035;
        var birthday = Date.now();

        Prize.push(new PRIZE(pos, vel, radius, birthday));
    }

    //  SPAWN TORPEDO  -----------------
    function spawnTorpedo() {
        if (bombsAway == false) {
            var numTorpedos = weaponLevel + 1;
            if (numTorpedos > 6) {
                numTorpedos = 6;
            }
            var spread = 0.2;
        var roket = Roket[0];
        var torpSpeed = 2;
        var tipOffset = 0.9 * roket.radius;
        if (weaponLevel > 8) {
            wagTorpedoIndex += 1;
            var wagTorpedos = 0.1 * Math.PI * Math.sin(wagTorpedoIndex);
        } else {
            var wagTorpedos = 0;
        }
        
        for (var i = 0; i < numTorpedos; i++) {
            bombsAway = true;
            var t = i - (numTorpedos - 1) / 2;
            var angleOffset = (weaponLevel == 1) ? (t * spread - 0.1) : (t * spread);
            // Calculate tip position
            var tipX = roket.pos.x + tipOffset * Math.cos(roket.angle);
            var tipY = roket.pos.y - tipOffset * Math.sin(roket.angle);
            var tipPos = new Vector2(tipX, tipY);
            var torpVel = new Vector2(
                roket.vel.x + torpSpeed * Math.cos(roket.angle + angleOffset + wagTorpedos),
                roket.vel.y - torpSpeed * Math.sin(roket.angle + angleOffset + wagTorpedos)
            );
            var squangle = 0;
            var radius = 0.01;
            rainbowTorpedoIndex += 5;
            if (rainbowTorpedoIndex > 360) {
                rainbowTorpedoIndex -= 360;
            }
            var hue = (weaponLevel < 7)
                ? 0
                : rainbowTorpedoIndex;
            var friendly = 'friend';
            torpedoFired += 1;

            Torpedo.push(new TORPEDO(tipPos, torpVel, squangle, radius, hue, friendly));
        }
        //  PLAYER TORPEDO FIRE RATE  -----------
        if (weaponLevel < 8) {
            var torpedoFireRate = 100;
        } else {
            var torpedoFireRate = 33.3;
        }
        
        setTimeout(() => { bombsAway = false }, torpedoFireRate);
        } 
    }

    //  SPAWN ENEMY UFO  -------------------
    function spawnEnemy() {
        var go = 0
        if (Math.random() < 0.5) {
            var pos = new Vector2(-0.2 * simWidth, 0.1 * simHeight + 0.8 * Math.random() * simHeight);
        } else {
            var pos = new Vector2(1.2 * simWidth, 0.1 * simHeight + 0.8 * Math.random() * simHeight);
        }
        var vel = new Vector2(0, 0);
        var radius = 0.10;
        var gunAngle = 0;
        var start = true;
        var lol = false;
        var birthday = Date.now();
        trash = TrashTalk[Math.floor(Math.random() * TrashTalk.length)];

        Enemy.push(new UFO(pos, vel, radius, gunAngle, start, lol, birthday));
    }

    //  SPAWN ENEMY TORPEDO  -----------------
    // Helper: Calculate intercept angle for leading a moving target
    function getInterceptAngle(enemyPos, roketPos, roketVel, torpSpeed) {
        const dx = roketPos.x - enemyPos.x;
        const dy = roketPos.y - enemyPos.y;
        const dvx = roketVel.x;
        const dvy = roketVel.y;

        // Quadratic formula coefficients
        const a = dvx * dvx + dvy * dvy - torpSpeed * torpSpeed;
        const b = 2 * (dx * dvx + dy * dvy);
        const c = dx * dx + dy * dy;

        // Solve for t (time to intercept)
        const disc = b * b - 4 * a * c;
        if (disc < 0 || Math.abs(a) < 1e-6) {
            // No solution, aim directly at current position
            return Math.atan2(dy, dx);
        }
        const t1 = (-b + Math.sqrt(disc)) / (2 * a);
        const t2 = (-b - Math.sqrt(disc)) / (2 * a);
        const t = Math.max(t1, t2, 0.01); // pick the positive, nonzero time

        // Predicted position
        const tx = roketPos.x + roketVel.x * t;
        const ty = roketPos.y + roketVel.y * t;
        return Math.atan2(ty - enemyPos.y, tx - enemyPos.x);
    }

    function spawnEnemyTorpedo() {
        var enemy = Enemy[0];
        var roket = Roket[0];
        var torpSpeed = 1;

        // Calculate intercept angle
        var interceptAngle = getInterceptAngle(
            enemy.pos,
            roket.pos,
            roket.vel,
            torpSpeed
        );

        var pos = new Vector2(
            enemy.pos.x + 1 * enemy.radius * Math.cos(interceptAngle),
            enemy.pos.y + 1 * enemy.radius * Math.sin(interceptAngle)
        );
        var torpVel = new Vector2(
            torpSpeed * Math.cos(interceptAngle),
            torpSpeed * Math.sin(interceptAngle)
        );
        var squangle = interceptAngle;
        var radius = 0.015;
        var color = 'yellow';
        var friendly = 'foe';
        Torpedo.push(new TORPEDO(pos, torpVel, squangle, radius, color, friendly));
        bbl = 0.06;
        enemyShotBirthday = Date.now();
        spawnMuzzleFlash(interceptAngle);
    }

    //  ROID SPAWN position FUNCTIONS ---------------
    function roidSpawnTopPos(radius) {
        // top
        var pos = new Vector2(
            2 * radius + Math.random() * (simWidth - 4 * radius),
            -1.0 * radius);
        return pos;
    }

    function roidSpawnBottomPos(radius) {
        // bottom
        var pos = new Vector2(
            2 * radius + Math.random() * (simWidth - 4 * radius),
            simHeight + radius);
        return pos;
    }

    function roidSpawnLeftPos(radius) {
        // left
        var pos = new Vector2(
            -1.0 * radius,
            2 * radius + Math.random() * (simHeight - 4 * radius));
        return pos;
    }

    function roidSpawnRightPos(radius) {
        // right
        var pos = new Vector2(
            simWidth + radius,
            2 * radius + Math.random() * (simHeight - 4 * radius));
        return pos;
    }

    //  ROID SPAWN velocity FUNCTIONS ---------------
    function roidSpawnTopVel(waveIncr) {
        // top
        var vel = new Vector2(
            -0.02 + 0.04 * Math.random(), 
            waveIncr * (0.1 + 0.1 * Math.random()));
        return vel;
    }
            
    function roidSpawnBottomVel(waveIncr) {
        // bottom
        var vel = new Vector2(
            -0.2 + 0.4 * Math.random(), 
            waveIncr * (-0.1 + -0.1 * Math.random()));
        return vel;
    }

    function roidSpawnLeftVel(waveIncr) {
        // left
        var vel = new Vector2(
            waveIncr * (0.1 + 0.1 * Math.random()), 
            -0.2 + 0.4 * Math.random());
        return vel;
    }
        
    function roidSpawnRightVel(waveIncr) {
        // right
        var vel = new Vector2(
            waveIncr * (-0.1 + -0.1 * Math.random()),
            -0.2 + 0.4 * Math.random());
        return vel;
    }

    //  SPAWN ROIDS  -------------------
    function spawnRoids() {
        // Helper for safe spawn
        function isSafeRoidSpawn(x, y, radius, roids, simWidth, simHeight) {
            for (let i = 0; i < roids.length; i++) {
                let other = roids[i];
                let { dist } = minImageDistance(x, y, other.pos.x, other.pos.y, simWidth, simHeight);
                if (dist < radius + other.radius + 0.1 *radius) { // 10 is a buffer, adjust as needed
                    return false;
                }
            }
            return true;
        }

    var roidLimit = startingRoidLimit + Math.floor(wave / 3);
    if (spawnCounter >= roidLimit) {
        spawning = false;
        return;
    }

    var waveIncr = 4/5 + wave/5;
    var maxAttempts = 20;
    var attempts = 0;
    var spawned = false;
    while (!spawned && attempts < maxAttempts) {
        var radius = 0.2 + 0.2 * Math.random();
        var mass = radius;
        var maxColorAngleSep = 0.5 * 360 / roidLimit;
        var colorCloseCounter = 1;
        while (colorCloseCounter > 0) {
            colorCloseCounter = 0;
            var hue = Math.random() * 360;
            for (var r = 0; r < Roids.length; r++) {
                if (Roids[r].hue + maxColorAngleSep > hue && Roids[r].hue - maxColorAngleSep < hue ) {
                    colorCloseCounter += 1;
                }
            }
        }
        var saturation = 30 + 70 * Math.random();
        var lightness = 40 + 50 * Math.random();
        // Pick a random side and position
        var pickSide = Math.random();
        var pos, vel;
        if (pickSide <= 0.25) {
            pos = roidSpawnTopPos(radius);
            vel = roidSpawnTopVel(waveIncr);
        } else if (pickSide <= 0.50) {
            pos = roidSpawnBottomPos(radius);
            vel = roidSpawnBottomVel(waveIncr);
        } else if (pickSide <= 0.75) {
            pos = roidSpawnLeftPos(radius);
            vel = roidSpawnLeftVel(waveIncr);
        } else {
            pos = roidSpawnRightPos(radius);
            vel = roidSpawnRightVel(waveIncr);
        }
        if (isSafeRoidSpawn(pos.x, pos.y, radius, Roids, simWidth, simHeight)) {
            let seed = Math.floor(Math.random() * 0xFFFFFFFF);
            let randomNo = Math.random();

            //  CHOOSE WIREFRAME or POLKADOT ROID  ----------
            //let isWireframe = (Math.random() < 0.5);
            if (firstSpawnPass == true) {
                var isWireframe = false;
                firstSpawnPass = false;
            } else {
                var isWireframe = true;
                firstSpawnPass = true;
            }
            // random 3D orientation
            let yaw = Math.random() * 2 * Math.PI;
            let pitch = (Math.random() - 0.5) * Math.PI; // -pi/2 .. +pi/2
            let roll = Math.random() * 2 * Math.PI;
            Roids.push(new ROID(pos, vel, radius, mass, hue, saturation, lightness, seed, randomNo, isWireframe, yaw, pitch, roll, 0));
            spawnCounter += 1;
            // ...existing code...
            spawned = true;
        }
        attempts++;
    }
}
    

    //  SPAWN ROKET DEBRIS  -------------------
    function spawnRoketDebris() {
        debrisMade = true;
        lives -= 1
        for (var u = 0; u < 500; u++) {
            var pos = Roket[0].pos.clone();
            var kapow = 0.1 + 2 * Math.random();
            var huh = 2 * Math.PI * Math.random()
            if (bombBlastAngle == null) {
                var vel = new Vector2(
                0.1 + kapow * Math.cos(huh), 
                0.1 + kapow * Math.sin(huh));
            } else {
                var vel = new Vector2(
                0.1 + kapow * Math.cos(huh) - 1.5 * Math.cos(bombBlastAngle), 
                0.1 + kapow * Math.sin(huh) - 1.5 * Math.sin(bombBlastAngle));
            }
            var radius = .003 + 0.01 * Math.random();
            var angle = 0;
            var randi = Math.random();
            if (randi < 0.01) {  
                var hue = 0;
            } else
            if (randi < 0.33) {
                var hue = 180;
            } else 
            if (randi < 0.67) {
                var hue = 120;
            } else
            if (randi < 1.00) {
                var hue = 300;
            }
            var alpha = 100;
            var birthday = Date.now();
            
            RoketDebris.push(new DEBRIS(pos, vel, radius, angle, hue, alpha, birthday));
        }
        bombBlastAngle = null;
    }

    //  SPAWN ENEMY UFO DEBRIS  -------------------
    function makeEnemyDebris() {
        for (var u = 0; u < 500; u++) {
            var pos = Enemy[0].pos.clone();
            var kapow = 0.01 + Math.random();
            var huh = 2 * Math.PI * Math.random()
            var vel = new Vector2(
                0.01 + kapow * Math.cos(huh), 
                0.01 + kapow * Math.sin(huh));
            var radius = .005 + 0.01 * Math.random();
            var angle = 0;
            var randi = Math.random();
            if (randi <= 0.33) {  
                var hue = 0;
            } else
            if (randi <= 0.67) {
                var hue = 60;
            } else 
            if (randi <= 1.0) {
                var hue = 230;
            }
            var alpha = 100;
            var birthday = Date.now();
            
            EnemyDebris.push(new DEBRIS(pos, vel, radius, angle, hue, alpha, birthday));
        }
    }

    //  SPAWN MUZZLE EXHAUST  -------------------
    function spawnMuzzleFlash(interceptAngle) {
        var radius = .003;
        var alpha = 100;
        var birthday = Date.now();
        for (var u = 0; u < 100; u++) {
            var pos = new Vector2(
                Enemy[0].pos.x + Enemy[0].radius * Math.cos(interceptAngle), 
                Enemy[0].pos.y + Enemy[0].radius * Math.sin(interceptAngle));
            var kapow = 0.1 + 4*Math.random();
            var spreadAngle = 0.1 * Math.PI * (-0.5 + Math.random());
            var vel = new Vector2(
                Enemy[0].vel.x + kapow * Math.cos(interceptAngle + spreadAngle), 
                Enemy[0].vel.y + kapow * Math.sin(interceptAngle + spreadAngle));

            MuzzleFlash.push(new MUZZLE_FLASH(pos, vel, radius, alpha, birthday));
        } 
    }

    //  SPAWN ROID DEBRIS  -------------------
    function spawnRoidDebris(origin, radius, hue1, hue2, sat, debrisQuant, debrisVel, type) {
        var pos = origin.clone();
        var firstpass = true;
        var birthday = Date.now();
        for (var u = 0; u < debrisQuant; u++) {
            //var kapow = 0.8 * 0.5 * Math.random();
            var kapow = debrisVel * 0.5 * Math.random();
            var dangle = 2 * Math.PI * Math.random()
            var vel = new Vector2(
                kapow * Math.cos(dangle), 
                kapow * Math.sin(dangle));
            if (hue1 == hue2) {
                var hue = hue1;
            } 
            if (type == 'roid') {
                var alpha = 100;
                if (firstpass == true) {
                    var hue = hue1;
                    firstpass = false;
                } else {
                    var hue = hue2;
                    firstpass = true;
                }
            } else if (type == 'torpedo') {
                var alpha = 0;
                var hue = hue1;
                var sat = 100;   
            } else {
                var alpha = 100;
                if (firstpass == true) {
                    var hue = hue1;
                    var sat = 100;
                    firstpass = false;
                } else {
                    var sat = 0;
                    firstpass = true;
                }
            }
            if (hue1 == hue2) {
                var hue = hue1;
            } 
            
            RoidDebris.push(new ROIDDEBRIS(pos, vel, radius, hue, sat, alpha, birthday, type));
        } 
    }

    //  SPAWN TORPEDO PULSE  -------------------
    function makePulse(pos) {
        var pos = pos.clone();
        var radius = 0;
        var alpha = 100;
        var birthday = Date.now();

        Pulse.push(new PULSE(pos, radius, alpha, birthday))
    }
        
    //  SPAWN EXHAUST  -----------------------------------------
    function spawnThrustExhaustlets(x, y, ang) {
        for (var s = 0; s < 10; s++) {
            var exhaustScatterX = -0.2 + 0.40 * Math.random();
            var exhaustScatterY = -0.2 + 0.40 * Math.random();
            var pos = new Vector2(x,y);
            var vel = new Vector2(
                -0.35 * Math.cos(ang) + exhaustScatterX, 
                0.35 * Math.sin(ang) + exhaustScatterY);
            var radius = 0;     
            var maxRadius = 0.01 + 0.02 * Math.random();
            if (weaponLevel < 7) {
                var hue = 300;
            } else {
                var hue = 360 * Math.random();
            }
            var saturation = 30 + 50 * Math.random();
            var lightness = 30 + 50 * Math.random();
            var alpha = 0;
            var birthday = Date.now();
            var lifespan = 1000;
            var age = 0;
        
            //  SPAWN AT ROKET POSITION  -----------------
            Exhaustlets.push (new THRUSTLET(pos, vel, radius, maxRadius, 
            hue, saturation, lightness, alpha, birthday, lifespan, age));
        }
    }

    //  SPAWN ENGINE IDLE EXHAUST  -------------------
    function spawnIdleExhaustlets(x, y, ang, iff) {
        var exhaustScatter = 1;
        var pos = new Vector2(x,y);
        var vel = new Vector2 (-0.05 * Math.cos(ang), 0.05 * Math.sin(ang));
        var radius = 0;     
        var maxRadius = 0.01 + 0.03 * Math.random();
        if (iff == 'friend') {
            var hue = 0;
        } else {
            var hue = 180;
        }
        var saturation = 10 + 20 * Math.random();
        var lightness = 30 + 50 * Math.random();
        var alpha = 0;
        var birthday = Date.now();
        var lifespan = 1000;
        var age = 0;
      
        //  SPAWN AT ROKET POSITION  -----------------
        Exhaustlets.push (new THRUSTLET(pos, vel, radius, maxRadius, 
        hue, saturation, lightness, alpha, birthday, lifespan, age));
    }

    //  SPAWN RETRO EXHAUST  -----------------------------------------
    function spawnRetro(x, y) {
        roket = Roket[0];
        var pos = new Vector2(
            roket.pos.x + 0.75 * roket.radius * Math.cos(roket.angle), 
            roket.pos.y - 0.75 * roket.radius * Math.sin(roket.angle));
        var vel = new Vector2(
            0.5 * Math.cos(roket.angle),
            0.5 * Math.sin(roket.angle)
            );
        var radius = 0;
        var maxRadius = 0.01 + 0.02 * Math.random();
        var hue = 60;
        var saturation = 30 + 50 * Math.random();
        var lightness = 30 + 50 * Math.random();
        var alpha = 0;
        var birthday = Date.now();
        var lifespan = 1000;
        var age = 0;
      
        //  SPAWN AT ROKET POSITION  -----------------
        RetroLets.push (new RETROLET(pos, vel, radius, maxRadius, 
        hue, saturation, lightness, alpha, birthday, lifespan, age));
    }

    //  SPAWN SPAWNLETS  -----------------------------------------
    function spawnSpawnlets(x, y, quant, rad, life) {
        for (var s = 0; s < quant; s++) {
            var spawnletScatterX = -0.1 + 0.2 * Math.random();
            var spawnletScatterY = -0.1 + 0.2 * Math.random();
            var spawnRad = rad * Math.random();
            var spawnAng = 2 * Math.PI * Math.random();
            var spawnX = spawnRad * Math.cos(spawnAng)
            var spawnY = spawnRad * Math.sin(spawnAng)
            var pos = new Vector2(x + spawnX, y + spawnY);
            var vel = new Vector2(spawnletScatterX, spawnletScatterY);
            var radius = 0;  
            var maxRadius = 0.02 + 0.04 * Math.random();
            var hue = 360 * Math.random();
            var saturation = 50 + 50 * Math.random();
            var lightness = 30 + 30 * Math.random();
            var alpha = 0;
            var birthday = Date.now();
            var lifespan = life;
            var spin = 0.05 * (-0.5 + Math.random());
            var angle = 360 * Math.random();
        
            Spawnlets.push (new SPAWNLET(pos, vel, radius, maxRadius, 
            hue, saturation, lightness, alpha, birthday, lifespan, spin, angle));
        }
    }

    //  CHECK IF ROKET PUSHER RESPAWN POINT IS CLEAR  -------------------
    function isPointClear(pos) {
        for (let roid of Roids) {
            var dir = new Vector2();
            dir.subtract(pos, roid.pos);
            var d = dir.length();
            if (d < roid.radius) {
                return false;
            }
        }
        return true;
    }

    //  SPAWN PUSHER  -------------------
    function makePusher() {
        const centerX = 0.5 * simWidth;
        const centerY = 0.5 * simHeight;
        const maxRadius = Math.max(simWidth, simHeight) / 2;
        let foundSpot = false;
        let testPos = new Vector2();
        let pos = new Vector2();
        // Spiral search outwards from center
        for (let r = 0; r < maxRadius && foundSpot != true; r += 0.1) {
            for (let theta = 0; theta < 2 * Math.PI && foundSpot != true; theta += Math.PI / 16) {
                let x = centerX + r * Math.cos(theta);
                let y = centerY + r * Math.sin(theta);
                testPos = new Vector2(x, y);
                if (isPointClear(testPos)) {
                    foundSpot = true;
                }
            }
        }
        let radius = 0;
        let birthday = Date.now();
        Pusher.push(new PUSHER(testPos, radius, birthday));
    }

    //  SPAWN HIT SCORER GRAPHIC ------------------
    function spawnScorer(pos, score) {
        var vel = new Vector2(-0.1 + 0.2 * Math.random(), -0.1 + 0.2 * Math.random());
        Scorer.push (new SCORER(pos, vel, 0, 0, Date.now(), score));
    }


    //  COLLISION DETECTION  =========================================================
    //  HANDLE  PRIZE  COLLECTION  -------------------
    function handlePrizeCollisions(roket, prize) {
        var dir = new Vector2();
        dir.subtract(roket.pos, prize.pos);
        var d = dir.length();
        if (d < roket.radius + prize.radius && (Date.now() - prizeTimer) > 5000) {
            //  HIT  --------------------
            prizeTimer = Date.now();
            weaponLevel += 1;
            if (weaponLevel > 9) {
                weaponLevel = 9;
            }
            poofPrize = true;
            poofPrizeDate = Date.now();
        }
    }

    //  HANDLE ROKET ROID COLLISIONS  -------------------
    function handleRoketRoidCollisions(roket, roid1) {
        var dir = new Vector2();
        dir.subtract(roket.pos, roid1.pos);
        var d = dir.length();
        if (d <= 0.5 * roket.radius + roid1.radius) {
            spawnRoidDebris(roket.pos, 0.003, roid1.hue, roid1.hue2, 80, 200, 0.8, 'roid');
            //  DRAW COLLISION HIGHLIGHT  --------------------
            roid1.polkadotFlashTimer = 0.5;
            dir.scale(1.0 / d);
            var corr = (roid1.radius + roket.radius - d);
            var v1 = roid1.vel.dot(dir);
            var v2 = roket.vel.dot(dir);
            var m1 = roid1.mass;
            var m2 = 0.1;
            var newV2 = (m1 * v1 + m2 * v2 - m1 * (v2 - v1) * 1) / (m1 + m2);
            tumbling = true;
            if (!athena.checked) {
                Roket[0].collision += 1;
            }
            
            roket.pos.add(dir, corr);
            roket.vel.add(dir, newV2 - v2);
        } 
    }

    //  HANDLE ROKET BOMB COLLISIONS  -------------------
    function handleRoketBombCollisions(roket, bomb) {
        var dir = new Vector2();
        dir.subtract(roket.pos, bomb.pos);
        var d = dir.length();
        if (d < 0.5 * roket.radius + bomb.radius) {
            //  HIT  --------------------
            if (!athena.checked) {
                Roket[0].collision = 2;
                //  EXPLODE BOMB  -------------
                bomb.exploding = true;
            }
        } 
    }

    //  HANDLE ENEMY ROKET COLLISIONS  -------------------
    function handleRoketEnemyCollisions(roket, enemy) {
        var dir = new Vector2();
        dir.subtract(roket.pos, enemy.pos);
        var d = dir.length();
        if (d < 0.5 * roket.radius + enemy.radius) {
            //  HIT  --------------------
            trash = TrashTalk[Math.floor(Math.random() * TrashTalk.length)];
            Enemy[0].lol = true;
            lolStart = Date.now();
            if (gameIdle == true) {
                makePulse(Roket[0].pos);
                spawnSpawnlets(Roket[0].pos.x, Roket[0].pos.y, 50, 0.05, 2000);
            } else {
                if (!athena.checked) {
                    Roket[0].collision = 2;
                }
            }
        } 
    }

    //  HANDLE  ROKET TO ROID  REENTRY INTERFERENCCE  -------------------
    function findSafeReentry(roid, startReentryPos) {
        var entryPos = new Vector2(startReentryPos.x, startReentryPos.y);
        var dir = new Vector2();
        dir.subtract(startReentryPos, roid.pos);
        var d = dir.length();
        if (d <= roid.radius) {
            if (startReentryPos.x == 0) {
                // go right
                entryPos.x = roid.right + Roket[0].radius;
            }
            if (startReentryPos.x == simWidth) {
                // go left
                entryPos.x = roid.left - Roket[0].radius;
            }
            if (startReentryPos.y == simHeight) {
                // go up
                entryPos.y = roid.top - Roket[0].radius;
            }
            if (entryPos.y == 0) {
                // go down
                entryPos.y = roid.bottom + Roket[0].radius;
            }
            spawnWarpIn(entryPos);
        }
        return entryPos;
    }

    //  HANDLE BOMB ROKET COLLISIONS  -------------------
    function handleBombRoketCollisions(roket, bomb) {
        var dir = new Vector2();
        dir.subtract(bomb.pos, roket.pos);
        var d = dir.length();

        // safety: ensure roket collision counter exists
        if (typeof Roket[0].collision === 'undefined') Roket[0].collision = 0;

        // Cooldown (milliseconds) to prevent repeated triggers from same bomb/roket
        const COOLDOWN_MS = 700;
        var now = Date.now();
        if (typeof bomb._roketLastHit === 'undefined') bomb._roketLastHit = 0;
        if (typeof roket._lastBombHit === 'undefined') roket._lastBombHit = 0;
        if (now - bomb._roketLastHit < COOLDOWN_MS) return;
        if (now - roket._lastBombHit < COOLDOWN_MS) return;

        // radii thresholds depend on whether the bomb is exploding
        var lethalRadius, tumbleRadius;
        if (bomb.exploding) {
            lethalRadius = 8 * bomb.radius;
            tumbleRadius = 12 * bomb.radius;
        } else {
            lethalRadius = roket.radius + bomb.radius;
            tumbleRadius = 0;
        }

        if (!athena.checked) {
            if (d <= lethalRadius) {
                // lethal
                Roket[0].collision = 2;

                //  save relative rocket to bomb angle for blast ---------
                bombBlastAngle = Math.atan2(dir.y, dir.x);

                sayByeBye = true;
                bomb.exploding = true;
                bomb._roketLastHit = now;
                roket._lastBombHit = now;
                bomb._roketAffected = true;
            } else if (d <= tumbleRadius) {
                // tumble + single increment
                if (!bomb._roketAffected) {
                    tumbling = true;
                    Roket[0].collision = (Roket[0].collision || 0) + 1;
                    try {
                        var nd = dir.clone();
                        if (nd.length() > 0) {
                            nd.normalize();
                            var impulse = Math.max(0.02, (tumbleRadius - d) / tumbleRadius * 0.12);
                            // push roket away from bomb center
                            Roket[0].vel.add(nd, -impulse);
                        }
                    } catch (e) {}
                    bomb._roketLastHit = now;
                    roket._lastBombHit = now;
                    bomb._roketAffected = true;
                }
            } 
        }
    }

    //  HANDLE BOMB ROID COLLISIONS  -------------------
    function handleBombRoidCollisions(roid1, bomb) {
        var dir = new Vector2();
        dir.subtract(bomb.pos, roid1.pos);
        var d = dir.length();
        if (d == 0.0 || d > roid1.radius + bomb.radius)
            return;
        //  HIT  -------------------------------
        //  make ring of fire particles  ---------
        var velocity = roid1.vel.clone();
        velocity.normalize();
        velocity.scale(0.05);
        spawnRingOfFire(roid1.pos, roid1.radius, roid1.hue, velocity);
        roid1.radius *= 0.80;
        //  REMOVE IF TOO SMALL  ----------
        if (roid1.isWireframe == true) {
            if (roid1.radius <= 0.3 * roid1.originalRadius) {
                var ri = Roids.indexOf(roid1);
                if (ri !== -1) Roids.splice(ri, 1);
            } 
        } else {
            if (roid1.radius <= 0.05) {
                var ri = Roids.indexOf(roid1);
                if (ri !== -1) Roids.splice(ri, 1);
            }
        }
    }

    //  HANDLE ROID ROID COLLISIONS  -------------------
    function handleRoidCollisions(roid1, roid2) {
        var dir = new Vector2();
        dir.subtract(roid2.pos, roid1.pos);
        var d = dir.length();
        if (d == 0.0 || d > roid1.radius + roid2.radius)
            return;

        dir.scale(1.0 / d);
        var corr = (roid1.radius + roid2.radius - d) / 2.0;
        var v1 = roid1.vel.dot(dir);
        var v2 = roid2.vel.dot(dir);
        var m1 = roid1.mass;
        var m2 = roid2.mass;
        var newV1 = (m1 * v1 + m2 * v2 - m2 * (v1 - v2) * 1) / (m1 + m2);
        var newV2 = (m1 * v1 + m2 * v2 - m1 * (v2 - v1) * 1) / (m1 + m2);

        roid1.pos.add(dir, -corr);
        roid2.pos.add(dir, corr);
        roid1.vel.add(dir, newV1 - v1);
        roid2.vel.add(dir, newV2 - v2);

        // MAKE ROID DEBRIS  ----------
        // Calculate collision point on the surface of roid1 (dir is already normalized)
        let collisionX = roid1.pos.x + dir.x * roid1.radius;
        let collisionY = roid1.pos.y + dir.y * roid1.radius;

        // Or, equivalently, on the surface of roid2:
        let collisionX2 = roid2.pos.x - dir.x * roid2.radius;
        let collisionY2 = roid2.pos.y - dir.y * roid2.radius;

        // Scale impulseMag to a debris count (adjust the factor as needed)
        // Linear impulse (magnitude) delivered to each roid (from velocity change along normal)
        let impulseMag = Math.abs(newV1 - v1) * roid1.mass; // same as for roid2
        let debrisCount = Math.max(5, Math.min(100, Math.round(impulseMag * 3000)));

        // Use the contact point on the surface of roid1 as the debris origin
        spawnRoidDebris(new Vector2(collisionX, collisionY), 0.003, roid1.hue, roid2.hue, 80, debrisCount, 0.8, 'bomb');
        // polkadot visual flash remains optional
        //if (polkadots.checked == true) {
            roid1.polkadotFlashTimer = 0.5;
            roid2.polkadotFlashTimer = 0.5;
        //}

        // --- Always apply angular effects from collisions (torque + friction) ---
        // 1. Vector from A to B
        let dx = roid2.pos.x - roid1.pos.x;
        let dy = roid2.pos.y - roid1.pos.y;
        if (d == 0) return; // avoid division by zero
        // 2. Normal and tangent at contact
        let nx = dx / d, ny = dy / d;
        let tx = -ny, ty = nx;
        // 5. Moment of inertia for solid disk: I = 0.5 * m * r^2
        let IA = 0.5 * roid1.mass * roid1.radius * roid1.radius;
        let IB = 0.5 * roid2.mass * roid2.radius * roid2.radius;

    //  IMPULSE FROM COLLISION  ----------------
        // Contact point relative to center (assume contact at edge)
        let rA = roid1.radius;
        let rB = roid2.radius;
        // Direction of impact (tangent sign)
        let signA = Math.sign((roid1.vel.x - roid2.vel.x) * ty - (roid1.vel.y - roid2.vel.y) * tx);
        let signB = -signA;
        //  Apply angular impulse (torque = r x F, here F = impulse/dt)
        //  d(omega) = torque / I = (r * impulse) / I
    // increase torque factor so collisions produce visible 3D tumble
    // stronger collision torque for more visible tumble
    let deltaOmegaCollA = signA * 0.03 * impulseMag * rA / IA;
    let deltaOmegaCollB = signB * 0.03 * impulseMag * rB / IB;
        roid1.angularVelocity += deltaOmegaCollA;
        roid2.angularVelocity += deltaOmegaCollB;
        // update 3D angular rates: primarily affect yaw (z)
        roid1.omega.z += deltaOmegaCollA;
        roid2.omega.z += deltaOmegaCollB;
        // Deterministic tumble: map contact point on each roid to pitch/roll changes
    const collisionTumble = 3.0; // amplify mapping into pitch/roll
        // contact point relative to roid centers
        let relAx = (collisionX - roid1.pos.x) / roid1.radius; // -1..1
        let relAy = (collisionY - roid1.pos.y) / roid1.radius; // -1..1
        let relBx = (collisionX2 - roid2.pos.x) / roid2.radius;
        let relBy = (collisionY2 - roid2.pos.y) / roid2.radius;
        // Map relative position to pitch/roll: hit toward top (relAy < 0) -> positive pitch change
        roid1.omega.x += -relAy * collisionTumble * deltaOmegaCollA; // pitch
        roid1.omega.y += relAx * collisionTumble * deltaOmegaCollA;  // roll
        roid2.omega.x += -relBy * collisionTumble * deltaOmegaCollB;
        roid2.omega.y += relBx * collisionTumble * deltaOmegaCollB;
        // Debug: log angular velocity changes on collision
        try {
            //console.log('collision angulars:', {
            //    idA: roid1.id || '?', omegaA: roid1.omega, yawA: roid1.yaw, pitchA: roid1.pitch, rollA: roid1.roll,
            //    idB: roid2.id || '?', omegaB: roid2.omega, yawB: roid2.yaw, pitchB: roid2.pitch, rollB: roid2.roll
            //});
        } catch (e) {}

    //  FRICTIONAL TRANSFER OF ROTATIONAL VELOCITY  ----------------
        //  Relative velocity at contact point (linear + rotational)
        // Compute rotational surface velocity from 3D omega: v = omega x r_contact
        // For contact on rim, r_contact ~ (tx * r, ty * r, 0) in local plane.
        // omega cross r = (omega.y * 0 - omega.z * r_contact.y, omega.z * r_contact.x - omega.x * 0, omega.x * r_contact.y - omega.y * r_contact.x)
        let rA_contact = { x: tx * roid1.radius, y: ty * roid1.radius, z: 0 };
        let rB_contact = { x: -tx * roid2.radius, y: -ty * roid2.radius, z: 0 };
        let vA_rot_x = roid1.omega.y * rA_contact.z - roid1.omega.z * rA_contact.y;
        let vA_rot_y = roid1.omega.z * rA_contact.x - roid1.omega.x * rA_contact.z;
        let vB_rot_x = roid2.omega.y * rB_contact.z - roid2.omega.z * rB_contact.y;
        let vB_rot_y = roid2.omega.z * rB_contact.x - roid2.omega.x * rB_contact.z;
        // Project surface velocities onto tangent direction
        let vA = roid1.vel.x * tx + roid1.vel.y * ty + (vA_rot_x * tx + vA_rot_y * ty);
        let vB = roid2.vel.x * tx + roid2.vel.y * ty + (vB_rot_x * tx + vB_rot_y * ty);
        let relVel = vA - vB;
        //  Angular impulse (tweak frictionCoeff for realism)
        let frictionCoeff = 1;
        let impulse = frictionCoeff * relVel;
        //  Update angular velocities
        // Map friction impulse into change in angular rate (Î”Ï‰ = r * impulse / I)
    // stronger friction torque for visible tangential tumble transfer
    let deltaOmegaA = signA * 0.02 * impulse * roid1.radius / IA;
    let deltaOmegaB = signB * 0.02 * impulse * roid2.radius / IB;
        roid1.angularVelocity += deltaOmegaA;
        roid2.angularVelocity += deltaOmegaB;
        // Also nudge 3D omega vectors around the Z axis (yaw) and small X/Y for visible tumble transfer
        roid1.omega.z += deltaOmegaA;
        roid2.omega.z += deltaOmegaB;
        // Deterministic mapping of friction impulse into pitch/roll using contact tangent
    const frictionTumble = 2.0; // amplify mapping into pitch/roll from tangential impulse
        // tangent direction components (tx,ty) already computed
        // map tangent sign and contact offset into pitch/roll contributions
        roid1.omega.x += -ty * frictionTumble * deltaOmegaA; // pitch from tangent
        roid1.omega.y += tx * frictionTumble * deltaOmegaA;  // roll from tangent
        roid2.omega.x += -ty * frictionTumble * deltaOmegaB;
        roid2.omega.y += tx * frictionTumble * deltaOmegaB;
        // Keep scalar angularVelocity roughly in sync with omega.z
        roid1.angularVelocity = roid1.omega.z;
        roid2.angularVelocity = roid2.omega.z;

        //  limit angular velocity  ----------
    // Relax angularVelocity clamp to allow stronger spins from collisions
    roid1.angularVelocity = Math.max(-0.2, Math.min(roid1.angularVelocity, 0.2));
    roid2.angularVelocity = Math.max(-0.2, Math.min(roid2.angularVelocity, 0.2));
    }

    //  HANDLE PUSHER ROID PUSH  -------------------
    function handlePusherRoidPushes(roid1, pusher) {
        var dir = new Vector2();
        dir.subtract(pusher.pos, roid1.pos);
        var d = dir.length();
        if (d <= roid1.radius + 1.1 * pusher.radius) {
            roid1.polkadotFlashTimer = 0.5;
            // Normalize direction
            dir.scale(1.0 / d);
            var corr = 0.95 * (roid1.radius + pusher.radius - d) / 2.0;
            var pushSpeed = -0.2; 
            // Set velocity in push direction
            roid1.vel.x = dir.x * pushSpeed;
            roid1.vel.y = dir.y * pushSpeed;
            // Correct position to avoid sticking
            roid1.pos.add(dir, -corr);
        }
    }

    //  HANDLE  ROID TO ROKET DEBRIS  BOUNCES  -------------------
    function handleShipDebrisCollisions(roid1, debris) {
        var dir = new Vector2();
        dir.subtract(debris.pos, roid1.pos);
        var d = dir.length();
        if (d == 0.0 || d > roid1.radius + debris.radius)
            return;

        dir.scale(1.0 / d);
        var corr = (roid1.radius + debris.radius - d) / 2.0;
        var v1 = roid1.vel.dot(dir);
        var v2 = debris.vel.dot(dir);
        var m1 = roid1.mass;
        var m2 = 0;
        var newV1 = (m1 * v1 + m2 * v2 - m2 * (v1 - v2) * 0.8) / (m1 + m2);
        var newV2 = (m1 * v1 + m2 * v2 - m1 * (v2 - v1) * 0.8) / (m1 + m2);
        
        debris.pos.add(dir, corr);
        debris.vel.add(dir, newV2 - v2);
    }

    //  HANDLE  EXHAUST TO ROID  PUSHES  -------------------
    function handleExhaustPushes(roid1, exhaustlet) {
        var dir = new Vector2();
        dir.subtract(exhaustlet.pos, roid1.pos);
        var d = dir.length();
        if (d > roid1.radius + exhaustlet.radius)
            return;
        
        dir.scale(1.0 / d);
        var v1 = roid1.vel.dot(dir);
        var v2 = exhaustlet.vel.dot(dir);
        var m1 = roid1.mass;
        var m2 = .000001 / exhaustlet.radius;
        var newV1 = (m1 * v1 + m2 * v2 - m2 * (v1 - v2) * 1) / (m1 + m2);
        
        roid1.vel.add(dir, newV1 - v1);
    }

    //  HANDLE PLAYER TORPEDO TO ROID  HITS  -------------------
    function handleTorpedoRoidHits(roid1, torpedo, r, u) {
        var dir = new Vector2();
        dir.subtract(torpedo.pos, roid1.pos);
        var d = dir.length();
        if (d <= torpedo.radius + roid1.radius) {
            //  HIT --------------------
            //if (polkadots.checked == true) {
                // Compute contact vector on the sphere surface in 3D with a small, robust
                // out-of-plane component so grazing torpedo hits still produce pitch/roll.
                let rx = torpedo.pos.x - roid1.pos.x;
                let ry = torpedo.pos.y - roid1.pos.y;
                const rlen2 = rx * rx + ry * ry;
                const rRadius = roid1.radius;
                const rlen = Math.sqrt(rlen2);

                // Unit approach direction from torpedo velocity (safeguard zero-length)
                let ax = torpedo.vel.x;
                let ay = torpedo.vel.y;
                let alen = Math.sqrt(ax*ax + ay*ay) || 1.0;
                ax /= alen; ay /= alen;

                // Surface normal (in-plane) from roid center toward impact (safeguard zero)
                let nx = rlen > 1e-9 ? rx / rlen : 0;
                let ny = rlen > 1e-9 ? ry / rlen : 0;

                // How head-on is the approach relative to the local normal? (positive = approaching)
                let approachDot = Math.max(0, -(ax * nx + ay * ny));

                // Heuristic alpha: larger when torpedo center is deeper inside the projected disk
                // and when approach is head-on. Always leave a small floor so rim hits still get some z.
                let penetrationFrac = Math.max(0, 1 - (rlen / rRadius));
                let alpha = Math.max(0.02, penetrationFrac * 0.8 * Math.max(0.1, approachDot));
                // contact z on the sphere surface (positive toward viewer)
                let rz = rRadius * alpha;

                // torpedo impulse vector (assume in-plane force from torpedo velocity)
                // Increase impulse scale so torpedoes can impart noticeable off-axis torque
                const IMPULSE_SCALE = 0.25; // was 0.025
                let fx = torpedo.vel.x * IMPULSE_SCALE;
                let fy = torpedo.vel.y * IMPULSE_SCALE;
                let fz = 0;

                // Contact position vector r = (rx, ry, rz)
                // Compute 3D torque = r x F
                // torque.x = ry * fz - rz * fy = - rz * fy
                // torque.y = rz * fx - rx * fz = rz * fx
                // torque.z = rx * fy - ry * fx  (original 2D torque)
                let torqueX = -rz * fy;
                let torqueY = rz * fx;
                let torqueZ = rx * fy - ry * fx;

                // Moment of inertia (approximate solid disk behavior as before)
                let inertia = 0.5 * roid1.mass * rRadius * rRadius;

                // scale into angular velocity change
                // Use separate gains: keep axial (Z) modest to avoid only pole-spin,
                // but amplify off-axis (X/Y) so pitch/roll are visible.
                const TORP_GAIN_Z = 0.15;   // preserves previous axial feel
                const TORP_GAIN_OFF = 0.9;  // stronger off-axis effect
                let deltaOmegaX = TORP_GAIN_OFF * torqueX / inertia;
                let deltaOmegaY = TORP_GAIN_OFF * torqueY / inertia;
                let deltaOmegaZ = TORP_GAIN_Z * torqueZ / inertia;

                // apply to 3D omega so wireframe roids pick up off-axis tumble
                roid1.omega.x += deltaOmegaX;
                roid1.omega.y += deltaOmegaY;
                roid1.omega.z += deltaOmegaZ;

                // keep scalar compatibility and clamp axial spin used for pole visuals
                roid1.angularVelocity = roid1.omega.z;
                roid1.angularVelocity = Math.max(-0.05, Math.min(roid1.angularVelocity, 0.05));
                roid1.polkadotFlashTimer = 0.5;
                try {
                    //console.log('torp hit angulars:', { id: roid1.id || '?', omega: roid1.omega, yaw: roid1.yaw, pitch: roid1.pitch, roll: roid1.roll });
                } catch (e) {}
            //}

            if (torpedo.friendOrFoe == 'friend') {
                torpedoHit += 1
                var thisScore = hitPct/100 * 100 * roid1.vel.length() / roid1.radius;
                spawnScorer(torpedo.pos, thisScore);
                score = score + thisScore;
            }

            makePulse(torpedo.pos);
            spawnRoidDebris(torpedo.pos, 0.003, roid1.hue, roid1.hue, sat = 80, 200, 0.8, 'roid');
            
            roid1.hue += 5;
            roid1.lightness -= 2;
            if (roid1.isWireframe == true) {
                spawnRingOfFire(roid1.pos, roid1.radius, roid1.hue, roid1.vel);
                roid1.radius *= 0.80;
            } else {
                roid1.radius *= 0.75;
            }
            roid1.mass = roid1.radius;
            dir.scale(1.0 / d);  
            var v1 = roid1.vel.dot(dir);
            var v2 = torpedo.vel.dot(dir);
            var m1 = roid1.mass;
            var m2 = 0.01; //roid1.mass;
            var newV1 = (m1 * v1 + m2 * v2 - m2 * (v1 - v2) * 1) / (m1 + m2);
            
            roid1.vel.add(dir, (-0.5 + Math.random()) + 0.2*(newV1 - v1));
            Torpedo.splice(u, 1);
            roid1.polkaSeed = Math.floor(Math.random() * 0xFFFFFFFF);

            //  REMOVE IF TOO SMALL  ----------
            if (roid1.isWireframe == true) {
                if (roid1.radius <= 0.3 * roid1.originalRadius) {
                    //  SPAWN BOMB  ----------
                    // create bomb and explicitly set its velocity to the roid's current velocit
                    const __b = new BOMB(roid1.pos.clone(), roid1.vel.clone(), 0.0001 * cScale);
                    Bomb.push(__b);
                    // ensure the bomb's velocity matches the roid's (defensive in case constructor mutation occurs)
                    Bomb[Bomb.length - 1].vel = roid1.vel.clone();
                    Roids.splice(r, 1);
                } 
            } else {
                if (roid1.radius <= 0.05) {
                    Roids.splice(r, 1);
                }
            }

            //  pick position for new one  ----------
            if (roid1.isWireframe != true) {
                if (0.5 * roid1.radius > 0.05) {
                    var newDir = 2 * Math.PI * Math.random();
                    var pos = new Vector2(
                        roid1.pos.x + 2 * roid1.radius * Math.cos(newDir), 
                        roid1.pos.y + 2 * roid1.radius * Math.sin(newDir));
                    var vel = new Vector2(
                        roid1.vel.x + (-0.5 + Math.random()), 
                        roid1.vel.y + (-0.5 + Math.random()));
                    var radius = 0.5 * roid1.radius;
                    var mass = radius;
                    var hue = roid1.hue + 22.5;
                    var saturation = 30 + 70 * Math.random();
                    var lightness = roid1.lightness - 3;
                    let seed = Math.floor(Math.random() * 0xFFFFFFFF);
                    let randomNo = Math.random();
                    Roids.push(new ROID(pos, vel, radius, mass, hue, saturation, lightness, seed, randomNo, roid1.isWireframe, roid1.yaw, roid1.pitch, roid1.roll));
                }

                //  pick position for another new one  ----------
                if (0.15 * roid1.radius > 0.05) {
                    var newDir = 2 * Math.PI * Math.random();
                    var pos = new Vector2(
                        roid1.pos.x + 2 * roid1.radius * Math.cos(newDir), 
                        roid1.pos.y + 2 * roid1.radius * Math.sin(newDir));
                    var vel = new Vector2(
                        roid1.vel.x + (-0.5 + Math.random()), 
                        roid1.vel.y + (-0.5 + Math.random()));
                    var radius = 0.5 * roid1.radius;
                    var mass = radius;
                    var hue = roid1.hue + 45;
                    var saturation = 30 + 70 * Math.random();
                    var lightness = roid1.lightness - 5;
                    /*// make sure not to spawn too close to existing roids
                    for (var i = 0; i < Roids.length; i++) {
                        var existingRoid = Roids[i];
                        var existingDir = new Vector2();
                        existingDir.subtract(existingRoid.pos, pos);
                        var existingD = existingDir.length();
                        if (existingD < 0.5 * (existingRoid.radius + radius)) {
                            // too close to existing roid, discard this spawn
                            return;
                        }
                    }*/
                    let seed = Math.floor(Math.random() * 0xFFFFFFFF);
                    let randomNo = Math.random();
                    Roids.push(new ROID(pos, vel, radius, mass, hue, saturation, lightness, seed, randomNo, roid1.isWireframe, roid1.yaw, roid1.pitch, roid1.roll));
                }
            }
        } 
    }

    //  HANDLE PLAYER TORPEDO ON ENEMY HITS  -------------------
    function handleTorpedoOnEnemyHits(enemy, torpedo) {
        if (torpedo != null && enemy != null) {
            var dir = new Vector2();
            dir.subtract(enemy.pos, torpedo.pos);
            var d = dir.length();
            if (d <= enemy.radius) {
                //  HIT --------------------
                torpedoHit += 1
                var thisScore = hitPct/100 * 5000;
                spawnScorer(torpedo.pos, thisScore);
                score = score + thisScore;
                makePulse(torpedo.pos);
                makeEnemyDebris();

                //  SPAWN PRIZE  -------------------
                if (weaponLevel < 9) {
                    spawnPrize(Enemy[0].pos);
                }

                spawnSoloAlien(enemy.pos);
                // remove the specific torpedo object from the array (find its index first)
                var ti = Torpedo.indexOf(torpedo);
                if (ti !== -1) Torpedo.splice(ti, 1);
                window.clearInterval(gonnaGetcha);
                Enemy = [];
            } 
        }
    }

    //  HANDLE ENEMY TORPEDO ON PLAYER  HITS  -------------------
    function handleTorpedoOnPlayerHits(torpedo) {
        if (torpedo != null && Roket[0] != null) {
            var dir = new Vector2();
            dir.subtract(Roket[0].pos, torpedo.pos);
            var d = dir.length();
            if (d < 0.6 * Roket[0].radius) {
                //  HIT --------------------
                trash = TrashTalk[Math.floor(Math.random() * TrashTalk.length)];
                if (Enemy[0] != null) {
                    Enemy[0].lol = true;
                }
                lolStart = Date.now();
                if (gameIdle == true) {
                    makePulse(Roket[0].pos);
                    spawnSpawnlets(Roket[0].pos.x, Roket[0].pos.y, 50, 0.02, 1500);
                    // remove the specific torpedo object from the array (find its index first)
                    var ti = Torpedo.indexOf(torpedo);
                    if (ti !== -1) Torpedo.splice(ti, 1);
                } else {
                    if (!athena.checked) {
                        Roket[0].collision = 2;
                        sayByeBye = true;
                        // remove the specific torpedo object from the array (find its index first)
                        var ti = Torpedo.indexOf(torpedo);
                        if (ti !== -1) Torpedo.splice(ti, 1);
                    }
                }
            } 
        }
    }

    //  HANDLE TORPEDO PULSE AGE OUT  ------------------
    function handlePulseLifespan(pulse, p) {
        if (Date.now() - pulse.birthday > 300) {
                Pulse.splice(p,1);
                firstPulse = true;
        }
    }

    //  HANDLE ROKET DEBRIS AGE OUT  -------------------
    function handleRoketDebrisAge(debris, d) {
        if (Date.now() - debris.birthday > 2000) {
                RoketDebris.splice(d, 1);

            if (RoketDebris.length == 0 && lives > 0) {
                makePusher();
            }
        }
    }
            
    //  HANDLE ROID DEBRIS AGE OUT  -------------------
    function handleRoidDebrisAge(debris, d) {
        if (Date.now() - debris.birthday > 1000) {
                RoidDebris.splice(d, 1);
        }
    }
    
    //  RESET ROKET  ------------------
    function resetRoket() {
        Roket[0].pos = PusherSpot.clone();
        Roket[0].vel = new Vector2(0.15, 0);
        Roket[0].angle = 0;
        Roket[0].collision = 0;
        tumbling = false;
        interference = 0;        
    }

    //  SPAWN ENEMY ON PAUSE  ----------
    function introSpawn() {
            spawnEnemy();
            gonnaGetcha = setInterval(spawnEnemyTorpedo, 4000);
        }

    //  PRE RENDER TORPEDO IMPACT FLASH
    function defineFlash() {
        offscreenFlashCtx.clearRect(0, 0, offscreenFlashCanvas.width, offscreenFlashCanvas.height);
        offscreenDrawCircle(0.2 * cScale, 0.2 * cScale, 0.2 * cScale);
        var sphereGradient = offscreenFlashCtx.createRadialGradient(
        0.2 * cScale, 
        0.2 * cScale, 
        0, 
        0.2 * cScale, 
        0.2 * cScale, 
        0.2 * cScale);

        sphereGradient.addColorStop(0.0, `hsla(0, 0%, 100%, 80%)`);
        sphereGradient.addColorStop(0.5, `hsla(30, 50%, 20%, 40%)`);
        sphereGradient.addColorStop(1.0, `hsla(0, 0%, 0%, 0%)`);
        offscreenFlashCtx.fillStyle = sphereGradient;
        offscreenFlashCtx.fill();
    }

    //  DEFINE STARFIELD ON OFFSCREEN CANVAS  --------------------
    function defineStarfield() {
        offscreenStarfieldCtx.clearRect(0, 0, offscreenStarfieldCanvas.width, offscreenStarfieldCanvas.height);
        for (var n = 0; n < StarField.length; n++) {
            StarField[n].draw(n);
        }
    }

    //  SETUP  ---------------------
    function setupScene() {
        StarField = [];
        Roket = [];
        targetImage = [];
        Roids = [];
        SortedRoids = [];
        Torpedo = [];
        Exhaustlets = [];
        RetroLets = [];
        RoketDebris = [];
        RoidDebris = [];
        Pulse = [];
        CopyVel = [];
        Pusher = [];
        Scorer = [];
        Spawnlets = [];
        Enemy = [];
        Alien = [];
        EnemyDebris = [];
        MuzzleFlash = [];
        startReentryPos = [];
        WarpIn = [];
        Prize = [];
        Bomb = [];
        RingOfFire = [];

        TrashTalk = [
            'BOOM!', 'KABOOM!', 'BOOYAH!', 'HAHAHA!!', 'HAH HAAAA!', 
            'PFFT...', 'TRY HARDER', 'WINNER!', 'YOU LOSE', 'A HIT!!', 
            'SO LAME', 'YO MOMMA', 'MERDE', 'SEE YAAA!', 'BAM!', 
            'DE NADA', 'PUHLEASE', 'LATER!', 'CIAO!', 'ADIOS!', 
            'TOO EASY', '$*@*&%#!!!', 'TSK TSK', 'DONE!', 'DUSTED!',
            'WHAM-O!', 'GOTCHA!', 'BUH-BYE!', 'BYE BYE!', 'WHY EVEN?',
            'WHY TRY?', 'YOU OK??', 'OK, LOSER', 'LOSER!', 'YOU LOSE',
            'I WIN!', 'YUP', 'NOPE!', 'DENIED!', 'NICE!!',
            'OUCH!!', 'THAT HURT?', 'KA-POW!!', '!!!!!!!', 'TOO BAD',
            'SO SAD', 'OH, YEAH!!', 'GET SOME!', 'POOF!', 'BOOF!',
            'EAT IT', 'HOSER', 'HEHEHE', 'BANG!!', 'BYEEEE!!',
            'TSCHUSS!', 'NEWB', 'AWWWWW', 'YAY ME!', 'GO ALIENS!',
            'YOU SUCK', 'SUCKER', 'SUCK IT', 'POP!!', 'BINGO!!',
            'GONE!!', 'TAKE THAT!', 'HAPPY?', 'GIVE UP', 'DENIED!',
            'I RULE!!', 'UM... NO', 'GOTTA GO!', 'SHAME...', 'YES!!!',
            'I H8 U', 'ET VOILA!', 'BONJOUR!', 'TAKE THAT!', 'OLE!!',
            'CHUMP', 'YA BLIND?', 'GO AWAY', 'WHOO HOO!', 'SWEET!',
            'SO HAPPY', 'BONGGGG', 'PEST', 'SHOO!',
            'SUCKS 2B U', 'SCHLECT', 'BAD SHOW', 'HAR HAR HAR', 'BOOSH!',
            'YOUR MOM', 'DAYAMN!', 'DAMN!', 'AW SHUCKS', 'SORRY!',
            'SORRY?', 'WHAT??', 'YO!', 'TWAT', 'WANKER', 
            'JACKASS', 'ASS', 'WHASSUP?', 'THERE!', 'TASTY!',
            'TOSSER', 'KLUTZ', 'ALIENS RULE!', 'UFOs RULE!', 'CALL SETI!',
            'SHAKA LAKA!', 'PISS OFF!', 'SCAT!', 'BE GONE!', 'OUTTA HERE!',
            'SUCKA!!', 'DING!!', 'SMELL THAT?']

        SmackTalk = [ 
            'DAMN IT!!!', 'YO MOMMA!!', 'MERDE!!', '$*@*&~%#^!!',  
            'OUCH!!', 'O THAT HURT', 'EAT ME!!', 'JERK!!', 
            'YOU SUCK!', 'OH, NOOOO!', 'SUCK IT!!', 'HAPPY NOW?', 'DIIIICK!!', 
            'I H8 YOU!', 'EXCUSE ME?!', 'NO FAIR!!', 'SHIIIIIT!!',
            'WHAT?!', 'TWAAAAT!!', 'WANKERRR!', 'JACKASS!', 'ASSHOLE!!', 
            'NOOOOOO!', 'JERKOFF!', 'PISS OFF!!', 'BASTARDO!!',
            'DAMN IT!', 'REALLY?!', 'UH, OH...', 'DOHHHHH!', "I'LL BE BACK",
            "I'LL GET YOU!", 'AAAAAAAH!!', 'HELLLLLP!!', 'AGAIN??!!',
            'FAAAAAK!!', 'FARK YOU!!', 'FARKIN ASS!', 'DIIIICK!!', 
            'BACK SOON!', 'DAMN UUUUU!', 'HATED IT!', 'ZERO STARS!',
            'OH JUST GREAT', 'MY PANTS!!', 'ELIZABETH!!', 'SAVE ME!!',
            'SAY WHAT?!', "I'LL GET YOU", 'AMATEUR!!', 'I H8 SPACE!', 
            'SPACE SUCKS!!', 'YOU SUUUCK!', 'THIS SUUUCKS!'];

        gameOn = false;
        gameIdle = true;
        gameBootTime = Date.now();
        userPause = false;
        gameStarting = false;
        pickFallingStar = 0;
        spawnTorpedoKey = false;
        bombsAway = false;
        rightPressed = false;
        leftPressed = false;
        upPressed = false;
        downPressed = false;
        thrustKey = false;
        tumbling = false;
        debrisMade = false;
        spawning = false;
        firstSpawnPass = true; 
        animateWave = false;
        dropOnce = true;
        sayByeBye = false; 
        firstPulse = true;
        poofPrize = false;
        wavingForward = true;
        timeWarp = false;
        
        lastSide = '';
        trash = '';
        
        dT = 1/60;
        startingRoidLimit = 4;
        wave = 0;
        weaponLevel = 0;

        lastRoidSpawnTime = 0;
        bSide = 0;
        spawnCounter = 0; 
        // spawnCounter will be reset at the start of a new wave, not here
        interference = 0;
        score = 0;
        hitPct = 0;
        lives = 3;
        waveNoBday = 0;
        nSpawn = 1;
        gameStartTime = 0;
        gameOverTime = 0;
        torpedoFired = 0;
        torpedoHit = 0;
        rainbowTorpedoIndex = 0;
        wagTorpedoIndex = 0;
        totalTravelX = 0;
        totalTravelY = 0;
        earthrise = 0;
        earthriseAdj = 2 * simHeight;
        earthSpinner = 0;

        col = 0;
        blinkyCycle = 0;
        eyeLiftL = 0;
        eyeLiftR = 0;
        eyeRoll = 0;
        lol = 0;
        lolX = 0;
        lolStart = 0;
        lolTime = 0;
        lolAdjY = 1;
        lolAdjX = 1;
        toothAdj = 0;
        knobLight = 90;
        leftArmAngle = Math.PI;
        rightArmAngle = 0;
        leftLegAngle = 0.8 * Math.PI;
        rightLegAngle = 0.2 * Math.PI;

        f = 0;
        knobOn = true;
        needNewCycleCounter = false;
        knobCounter = 0;
        knobOffCycles = 0;
        enemyShotBirthday = 0;
        bbl = 0;
        enemyCycling = true;
        nextWait = 0;
        prizeTimer = 0;
        poofStars = 1;
        poofPrizeDate = 0;
        textPulse = 0;
        bombDirShake = 0;
        bombBlastAngle = null;
        radarPulser = 0;

        c.shadowBlur = 0;
        
        bob = 0;
        orbit = 0;
        titleLightness = 0;
        titleBallRadius = 0.25;
        titleBallX = 0.05 * simWidth;
        titleBallY = 0.05 * (-0.5 + Math.random());
        titleBallYIndex = 0.005 * (-0.5 + Math.random());
        titleBallHue = 360 * Math.random();
        titleBallSaturation = 20 + 60 * Math.random();
        titleBallLightness = 40 + 40 * Math.random();
        titleBallDir = 1;

        titleLightness2 = 0;
        titleBallRadius2 = 0.25;
        titleBallX2 = 0.95 * simWidth;
        titleBallY2 = 0.05 * (-0.5 + Math.random());
        titleBallYIndex2 = 0.005 * (-0.5 + Math.random());
        titleBallHue2 = 360 * Math.random();
        titleBallSaturation2 = 20 + 60 * Math.random();
        titleBallLightness2 = 40 + 40 * Math.random();
        titleBallDir2 = -1;

        titleLightness3 = 0;
        titleBallRadius3 = 0.25;
        titleBallX3 = 0.2 * simWidth + 0.6 * Math.random() * simWidth;
        titleBallY3 = 0.9 * simHeight;
        titleBallXIndex3 = 0.005 * (-0.5 + Math.random());
        titleBallHue3 = 360 * Math.random();
        titleBallSaturation3 = 20 + 60 * Math.random();
        titleBallLightness3 = 40 + 40 * Math.random();
        titleBallDir3 = -1;

        rudolph = 0;
        rudolphIntensity = 0;
    
        cursorX = 0;
        cursorY = 0;
        lastMouseX = 0;
        lastMouseY = 0;

        makeStars();
        makeRoket();
        defineFlash();
        defineStarfield();
    }


    //  SIMULATE   ===================================================
    function simulate() {   
        if (userPause == true) {
            return;
        }

        //  SLOW TIME  ------------------
        if (timeWarp == true) {
            dT *= 0.95;
            if (dT < 1/500) {dT = 1/500}
        } else {
            dT *= 1.1;
            if (dT >= 1/60) {dT = 1/60}
        }

        //  ADVANCE WAVE WHEN ALL ROIDS AND ENEMIES GONE  -------------------
        if (gameIdle != true) {
            if (Roids.length == 0 && spawning == false && Enemy.length == 0 && Bomb.length == 0) {
                spawning = true;
                wave += 1;
                waveNoBday = Date.now();
                lastRoidSpawnTime = Date.now(); // Track last spawn time (global)
                spawnCounter = 0; // Reset spawnCounter at the start of a new wave
                animateWave = true;
                if (wave > 1) {
                    spawnEnemy();
                    //  SET EMENY FIRE RATE, DECREASE WITH WAVE+ ----------
                    gonnaGetcha = setInterval(spawnEnemyTorpedo, 4000 - (wave * 100));
                }
            }
        }
       
        //  SPAWN ROIDS PERIODICALLY (fixed interval)  -------------------
        if (spawning == true && Roket[0] != null) {
            if ((Date.now() - lastRoidSpawnTime) > 3000) {
                spawnRoids();
                lastRoidSpawnTime = Date.now();
            }
        }

        //  SIMULATE ENGINE EXHAUST  ------------------
        for (var y = 0; y < Exhaustlets.length; y++) {
            Exhaustlets[y].simulate();
        }

        //  SIMULATE RETRO EXHAUST  -----------------
        for (var w = 0; w < RetroLets.length; w++) {
            RetroLets[w].simulate();
        }

        //  SIMULATE ROKET ON START  --------------------
        if (gameIdle == true) {
            Roket[0].startSimulate();
        }

        //  SIMULATE PRIZE  -------------------
        if (Prize[0] != null) {
            var prize = Prize[0];
            prize.simulate();

            //  HANDLE PRIZE BOUNDARIES  -------------------  
            if (prize.pos.x > simWidth + 4 * prize.startingRadius ||
            prize.pos.x < 0 - 4 * prize.startingRadius ||
            prize.pos.y < 0 - 4 * prize.startingRadius ||
            prize.pos.y > simHeight + 4 * prize.startingRadius) {
                Prize = [];
            }
        }

        //  SIMULATE ROKET IN PLAY  --------------------
        if (Roket[0].collision < 2 && gameOn == true) {
            Roket[0].simulate();

            //  HANDLE ROKET ENEMY COLLISIONS  ---------------------
            if (Enemy[0] != null) {
                handleRoketEnemyCollisions(Roket[0], Enemy[0]);
            }

            //  HANDLE ROKET BOMB COLLISIONS  ------------------
            for (var b = 0; b < Bomb.length; b++) {
                handleRoketBombCollisions(Roket[0], Bomb[b]);
            }

            //  HANDLE PRIZE COLLECTION  -------------------
            if (Prize[0] != null) {
                handlePrizeCollisions(Roket[0], Prize[0]);
            }
        }  

        //  SIMULATE ENEMY  -------------------
        for (var e = 0; e < Enemy.length; e++) {
            Enemy[e].simulate();
        }

        //  SIMULATE ENEMY DEBRIS  -------------------
        for (var e = 0; e < EnemyDebris.length; e++) {
            EnemyDebris[e].simulate();
        }

        //  SIMULATE SEND ALIEN  -------------------
        for (var e = 0; e < Alien.length; e++) {
            Alien[e].simulate();
        }

        //  SPAWN TORPEDO  ------------------
        if (spawnTorpedoKey == true && Roket[0].collision < 2 && tumbling != true && gameOn == true) {
            spawnTorpedo();
        }

        //  SIMULATE MUZZLE FLASH  ------------------- 
        for (var m = 0; m < MuzzleFlash.length; m++) {
            MuzzleFlash[m].simulate();
        }

        //  SIMULATE PUSHER  ---------------------
        if (Pusher[0] != null && lives > -1) { 
            Pusher[0].simulate();
            PusherSpot = Pusher[0].pos.clone();
            if (Pusher[0].radius >= 0.3) {
                spawnSpawnlets(PusherSpot.x, PusherSpot.y, 4, 0.35, 1000);
            }
            if (Date.now() - Pusher[0].birthday > 2000) {
                //pusher = Pusher[0];
                Pusher = [];
                debrisMade = false;
                resetRoket();
            } 
        }

        // GAME OVER  -----------------
        if (lives < 1 & gameOn == true) {
            gameOn = false;
            gameOverTime = Date.now();
            //sadTromboneSound.play();
        }

        //  SIMULATE RING OF FIRE  -------------------
        for (var r = 0; r < RingOfFire.length; r++) {
            RingOfFire[r].simulate();
            if (Date.now() - RingOfFire[r].birthday > 300) {
                RingOfFire.splice(r, 1);
                r--;
                continue;
            }
        }   

        //  SIMULATE ROIDS  --------------------
        SortedRoids = Roids.sort((a, b) => a.left - b.left); 
        for (var r = 0; r < Roids.length; r++) {
            if (Roids[r] != null) {
                var sortedRoids1 = SortedRoids[r]
                //Roids[r].simulate();
                sortedRoids1.simulate();

                //  HANDLE ROKET ROID COLLISIONS ------------------
                var roket = Roket[0];
                if (roket.left < sortedRoids1.right) {
                    if (Math.abs(sortedRoids1.pos.y - roket.pos.y) <= sortedRoids1.radius + roket.radius) {
                        handleRoketRoidCollisions(roket, sortedRoids1);
                    }
                }  
                
                //  HANDLE RESPAWN PUSHER  ------------------
                if (Pusher[0] != null) {
                    handlePusherRoidPushes(sortedRoids1, Pusher[0]);
                }
            
                //  HANDLE ROID ROID COLLISIONS  ------------------
                for (var t = r+1; t < Roids.length; t++) {
                    var sortedRoids2 = SortedRoids[t];
                    if (sortedRoids2 != null && sortedRoids1 != null ) {
                        if (sortedRoids2.left < sortedRoids1.right) {
                            if (Math.abs(sortedRoids1.pos.y - sortedRoids2.pos.y) <= sortedRoids1.radius + sortedRoids2.radius) {
                                handleRoidCollisions(sortedRoids1, sortedRoids2);
                            }
                        }  
                    }
                }

                //  HANDLE BOMB ROID COLLISIONS  -------------------
                if (Bomb.length > 0) {
                    var SortedBombs = Bomb.sort((a, b) => a.left - b.left);
                    for (var b = 0; b < SortedBombs.length; b++) {
                        if (SortedBombs[b].left < sortedRoids1.right) {
                            if (Math.abs(sortedRoids1.pos.y - SortedBombs[b].pos.y) <= sortedRoids1.radius + SortedBombs[b].radius) {
                                handleBombRoidCollisions(sortedRoids1, SortedBombs[b]);
                            }
                        }   
                    }
                }

                //  HANDLE SHIP DEBRIS HITS ON ROIDS ------------------
                var SortedRoketDebris = RoketDebris.sort((a, b) => a.left - b.left);
                for (var s = 0; s < RoketDebris.length; s++) {
                    var sortedRoketDebris1 = SortedRoketDebris[s];
                    if (Roids[r] != null) {
                        if (sortedRoketDebris1.left < sortedRoids1.right) {
                            if (Math.abs(sortedRoids1.pos.y - sortedRoketDebris1.pos.y) <= sortedRoids1.radius + sortedRoketDebris1.radius) {
                                handleShipDebrisCollisions(sortedRoids1, sortedRoketDebris1);
                            }
                        }   
                    }
                }

                //  HANDLE TORPEDO ROID HITS  --------------------
                var SortedTorpedos = Torpedo.sort((a, b) => a.left - b.left);
                for (var u = 0; u < SortedTorpedos.length; u++) {
                    var sortedTorpedo1 = SortedTorpedos[u];
                    if (Roids[r] != null) {
                        if (sortedTorpedo1.left < sortedRoids1.right) {
                            if (Math.abs(sortedRoids1.pos.y - sortedTorpedo1.pos.y) <= sortedRoids1.radius + sortedTorpedo1.radius) {
                                handleTorpedoRoidHits(sortedRoids1, sortedTorpedo1, r, u);
                            }
                        }   
                    }
                }

                /*//  HANDLE EXHAUST PUSHES  --------------------
                for (var e = 0; e < Exhaustlets.length; e++) {
                    if (Roids[r] != null) {
                        handleExhaustPushes(Roids[r], Exhaustlets[e]);
                    }
                }*/
            }
        } 

        //  SIMULATE BOMB  ----------------------------
        for (var b = 0; b < Bomb.length; b++) {
            Bomb[b].simulate();
            //  HANDLE BOMB ROCKET COLLISIONS  -------------
            if (Roket[0] != null && Bomb[b].left < Roket[0].right) {
                if (Math.abs(Roket[0].pos.y - Bomb[b].pos.y) <= Roket[0].radius + Bomb[b].radius) {
                    handleBombRoketCollisions(Roket[0], Bomb[b]);
                }
            }
            //  EXPLODE BOMB  ----------
            if (Bomb[b].exploding != true && Date.now() - Bomb[b].birthday > 3000) {
                Bomb[b].exploding = true;
                Bomb[b].birthday = Date.now();
            }
            if (Bomb[b].exploding == true && Date.now() - Bomb[b].birthday > 300) {
                Bomb.splice(b, 1);
            }
        }
        if (Bomb.length > 0) {
            radarPulser += 0.04;
            if (radarPulser > 1) {
                radarPulser = 0;
            }
            bombDirShake += 0.05;
            if (bombDirShake > 2 * Math.PI) {
                bombDirShake -= 2 * Math.PI;
            }
        }

        //  HANDLE TORPEDO ENEMY HITS  --------------------
        for (var e = 0; e < Enemy.length; e++) {
            for (var f = 0; f < Torpedo.length; f++) {
                if (Torpedo[f].friendOrFoe == 'friend') {
                    handleTorpedoOnEnemyHits(Enemy[e], Torpedo[f]);
                }
            }
        }

        //  HANDLE ENEMY TORPEDO PLAYER HITS  --------------------
        //for (var e = 0; e < Enemy.length; e++) {
            for (var f = 0; f < Torpedo.length; f++)
                if (Torpedo[f].friendOrFoe == 'foe' && !athena.checked) {
                    handleTorpedoOnPlayerHits(Torpedo[f]);
                }
        //}

        //  SIMULATE TORPEDO and HANDLE BOUNDS  ------------------
        for (var u = 0; u < Torpedo.length; u++) {
            torpedo = Torpedo[u];
            torpedo.simulate();
            if (torpedo.pos.x + torpedo.radius >= simWidth 
            || torpedo.pos.x - torpedo.radius <= 0 
            || torpedo.pos.y - torpedo.radius < 0 
            || torpedo.pos.y + torpedo.radius >= simHeight) {
                Torpedo.splice(u,1);
            }
        }

        //  SIMULATE ROKET DEBRIS  ------------------
        for (var d = 0; d < RoketDebris.length; d++) {
            RoketDebris[d].simulate();
            handleRoketDebrisAge(RoketDebris[d], d);
        }

        //  SIMULATE ROID DEBRIS  ------------------
        for (var d = 0; d < RoidDebris.length; d++) {
            RoidDebris[d].simulate();
            handleRoidDebrisAge(RoidDebris[d], d);
        }

        //  SIMULATE TORPEDO PULSE  -------------------
        for (var p = 0; p < Pulse.length; p++) {
            Pulse[p].simulate();
            handlePulseLifespan(Pulse[p], p);
        }

        //  SIMULATE SCORER  -------------------
        for (var p = 0; p < Scorer.length; p++) {
            Scorer[p].simulate();
            if (Date.now() - Scorer[p].birthday > 1000) {
                Scorer.splice(p, 1);
            }
        }

        //  SIMULATE SPAWNLETS  --------------------
        for (var b = 0; b < Spawnlets.length; b++) {
            Spawnlets[b].simulate();
        }

        //  SIMULATE WARP-IN  --------------------
        for (var w = 0; w < WarpIn.length; w++) {
            WarpIn[w].simulate();
        }

        //  DROP STARS  ---------------------
        for (var s = 0; s < StarField.length; s++) {
            star = StarField[s];
            if (star.falling == true) {
                star.simulate(); 
                if (star.posY > simHeight) {
                    star.falling == false;
                }
            }
        }
    }


    //  DRAW   ===================================================
    
    function draw() {  
        //  BLACK BACKGROUND  ----------------
        c.fillStyle = 'black';
        c.fillRect(0, 0, canvas.width, canvas.height);

        //  SPACE STUFF BACKGROUND  ----------------------
        c.drawImage(galaxy, 650 - 0.01 * cScale, - 350 - 0.01 * cScale, canvas.width, canvas.height);
        
        //  STARS  --------------------
        if (gameOn != true && lives < 1) {
            for (var n = 0; n < StarField.length; n++) {
                StarField[n].drawForReal(n);
            }
        } else {
            c.drawImage(offscreenStarfieldCanvas, 0, 0); 
        }

        //  EARTH BACKGROUND  ---------------------
        //  fix so southen hemisphere travel flips rotation of planet
        if (earthriseAdj > 2.95) {
            earthriseAdj -= 2 * (earthriseAdj - 2.9) / (3.3 - 2.9) * 0.002;;
        } else {
            earthriseAdj = 2.95;
        }

        if (gameIdle == true || gameStarting == true) {
            var elapsed = (Date.now() - gameBootTime) / 1000;
            if (elapsed <= 7) {
                // start with an extra spin of 0.02 (i.e. 0.02 * dT) and decay exponentially
                // choose tau so the extra is ~1% after 7s: tau = 7 / ln(100) ~= 1.52s
                var extraSpin = 1 * Math.exp(-elapsed / 1.22);
                var earthSpinIncrement = (0.002 + extraSpin) * dT;
                var earthZoom = 1;

            } else {
                var earthSpinIncrement = 0.002 * dT;
                var earthZoom = 1;
            }
        } else {
            var earthSpinIncrement = 0.002 * dT;
            var earthZoom = 1;
        }

        earthSpinner += earthSpinIncrement;
        if (earthSpinner > 2 * Math.PI) {
            earthSpinner -= 2 * Math.PI;
        }
        const earthImage = document.getElementById("earth");
        const earthWidth = 9 * cScale * earthZoom;
        const earthHeight = 9 * cScale * earthZoom;
        const centerX = 0.5 * simWidth * cScale;
        const centerY = earthriseAdj * simHeight * cScale - 0.03 * totalTravelY * cScale;
        //const earthAngle = -earthSpinner - 0.0025 * totalTravelX * Math.PI + 0.34 * Math.PI; // 180 degrees
        const earthAngle = -earthSpinner - 0.0025 * totalTravelX * Math.PI + 2.7 * Math.PI; // 180 degrees
        c.save();
        c.translate(centerX, centerY); // move origin
        c.rotate(earthAngle); 
        c.drawImage(
            earthImage,
            -0.5 * earthWidth, // center origin
            -0.5 * earthHeight,
            earthWidth,
            earthHeight);
        c.restore();

        //  DRAW RING OF FIRE  -------------------
        for (var r = 0; r < RingOfFire.length; r++) {
            RingOfFire[r].draw();
        }   
        
        //  DRAW ROIDS  --------------------
        for (var r = 0; r < Roids.length; r++) {
            if (Roids[r] != null) {
                Roids[r].draw();
            }
        }

        for (var b = 0; b < Bomb.length; b++) {
            Bomb[b].draw();
        }

        //  DRAW TORPEDO  ------------------
        for (var v = 0; v < Torpedo.length; v++) {
            Torpedo[v].draw();
        }

        //  SIMULATE MUZZLE FLASH  ------------------- 
        for (var m = 0; m < MuzzleFlash.length; m++) {
            MuzzleFlash[m].draw();
        }

        //  DRAW PULSE  ------------------
        for (var p = 0; p < Pulse.length; p++) {
            Pulse[p].draw();
        }

        //  DRAW ROID DEBRIS  ------------------
        for (var d = 0; d < RoidDebris.length; d++) {
            RoidDebris[d].draw();
        }

        //  DRAW ROKET DEBRIS  ------------------
        for (var d = 0; d < RoketDebris.length; d++) {
            RoketDebris[d].draw();
        }

        //  DRAW ENEMY DEBRIS -------------------
        for (var e = 0; e < EnemyDebris.length; e++) {
            EnemyDebris[e].draw();
        }

        //  DRAW PRIZE  -------------------
        if (Prize[0] != null) {
            Prize[0].draw();
        }

        //  DRAW SEND ALIEN  -------------------
        for (var e = 0; e < Alien.length; e++) {
            Alien[e].draw();
        }

        //  DRAW SCORER  -------------------
        for (var p = 0; p < Scorer.length; p++) {
            Scorer[p].draw();
        }

        //  DRAW PUSHER  ---------------------
        if (Pusher[0] != null) {
            Pusher[0].draw();
        }


        // DRAW OSD ELEMENTS ========================================

        //  DRAW WAVE NUMBER  -------------------
        if (gameOn == true) {
            if (gameOn == true && gameStarting != true) { 
                var trans4 = 100;
            }
            if (gameOn == true && gameStarting == true) { 
                var trans4 = ((Date.now() - gameStartTime) / 20);
            }
            c.font = `${0.05 * cScale}px monospace`;
            c.textBaseline = 'middle';
            c.textAlign = "center";
            c.fillStyle = `hsla(30, 80%, 50%, ${trans4}%)`;
            c.lineWidth = 2;
            c.fillText('wave', 0.5 * simWidth * cScale, .06 * cScale);
            if (animateWave != true) {
                c.strokeStyle = `hsla(30, 80%, 50%, ${trans4}%)`;
                c.textBaseline = 'top';
                c.font = `${0.1 * cScale}px monospace`;
                c.strokeText(wave, 0.5 * simWidth * cScale, .09 * cScale);
            }
        }

        //  ANIMATE WAVE NUMBER CHANGE  -----------------
        if (animateWave == true) {
            var waveNoAge = (Date.now() - waveNoBday) / 1000;
            var maxFont = 3;
            var minFont = 1 / (20 * waveNoAge);
            var fontSize = maxFont * minFont;
            
            var trans6 = 30 + 100 * waveNoAge / 3;
            c.textBaseline = 'top';
            if (fontSize > 0.1) {
                c.font = `${fontSize * cScale}px monospace`;
            } else {
                c.font = `${0.1 * cScale}px monospace`;
                animateWave = false;
            }
            c.strokeStyle = `hsla(30, 80%, 50%, ${trans6}%)`;
            c.strokeText(wave, 0.5 * simWidth * cScale, .09 * cScale);
        }

        //  DRAW HIT PERCENTAGE  ------------------
        if (gameIdle != true) {
            if (torpedoFired > 1) {
                hitPct = Math.floor(100 * torpedoHit / torpedoFired);
            } else {
                hitPct = 100;
            }
            c.textBaseline = 'middle';
            c.textAlign = "left";
            c.fillStyle = `hsl(30, 80%, 50%, ${trans4}%)`;
        
            c.font = "9px monospace";
            c.fillText('hit rate', 5, cScale * simHeight - 8);
            c.font = "15px monospace";
            c.fillText(hitPct + '%', 55, cScale * simHeight - 10);
        }
        
        //  DRAW SHIP/LIFE ICONS  ------------------
        for (var l = 0; l < lives; l++) {
            c.beginPath();
            c.moveTo(((simWidth-0.15) + 0.12*-l) * cScale, 0.05 * cScale);
            c.lineTo(((simWidth-0.15) + 0.12*-l - 0.04) * cScale, 0.15 * cScale);
            c.lineTo(((simWidth-0.15) + 0.12*-l) * cScale, 0.1 * cScale);
            c.lineTo(((simWidth-0.15) + 0.12*-l + 0.04) * cScale, 0.15 * cScale);
            c.closePath();
            c.lineWidth = 2;
            c.strokeStyle = `hsla(105, 70%, 50%, 70%)`;
            c.stroke();
        }
        
        //  DRAW SCORE  ------------------
        if (!athena.checked) {
            c.font = `${0.13 * cScale}px monospace`;
            c.textBaseline = 'middle';
            c.textAlign = "left";
            c.strokeStyle = `hsla(105, 70%, 50%, 70%)`;
            c.lineWidth = 2;
            c.strokeText(Math.floor(score), .07 * cScale, .11 * cScale);
        } else {
            score = 0;
        }

        //  DRAW GAME OVER AND DROP STARS  ------------------
        if (gameOn != true && lives < 1) {
            var trans5 = ((Date.now() - gameOverTime) / 10);
            c.font = "120px monospace";
            c.textAlign = "center";
            c.strokeStyle = `hsla(105, 60%, 50%, ${trans5}%)`;
            c.shadowColor = 'black'
            c.shadowBlur = 5;
            c.strokeText('GAME OVER', 0.5 * simWidth * cScale, 0.5 * simHeight * cScale);
            
            if (dropOnce == true) {
                fallingStars = setInterval(dropStar, 20);
                dropOnce = false;
            }

            //  ANY KEY TO TO RETURN  ------------------
            rudolphIntensity = 100;
            c.fillStyle = `hsla(175, 100%, 50%, 80%)`;
            c.font = "italic 15px courier";
            c.fillText('PRESS "R" TO RETURN', 0.5 * simWidth * cScale, 0.8 * simHeight * cScale);
            c.shadowBlur = 0;
        }
  
        //  INTRO SCREEN ------------------
        if (gameIdle == true || gameStarting == true && lives > -1) {
            const fadeTime = 3000
            if ((Date.now() - gameStartTime) > 4.0 * fadeTime) {
                gameStarting = false;
            }

            //  MAKE BOBBER  ----------------
            bob += 0.02;
            var bobDisp = 0.07 * simHeight;
            var bobberR = bobDisp * Math.sin(bob + Math.PI / 5);
            var bobberO = bobDisp * Math.sin(bob + 2 * Math.PI / 5);
            var bobberI = bobDisp * Math.sin(bob + 3 * Math.PI / 5);
            var bobberD = bobDisp * Math.sin(bob + 4 * Math.PI / 5);
            var bobberS = bobDisp * Math.sin(bob + Math.PI);
            var bobberLR = bobDisp * Math.cos(0.75*bob);

            //  SET TRANSPARENCY AND GROW  ------------------
            if (gameIdle == true) {
                var trans = 100;
                var trans2 = 70;
                var trans3 = 70;
                var trans4 = 0;
                c.font = `bolder ${0.25 * simWidth * cScale}px monospace`;
            } else {
                var trans = 70 - (Date.now() - gameStartTime) * 100 / fadeTime;
                var trans2 = 70 - (Date.now() - gameStartTime) * 100 / (0.25 * fadeTime);
                var trans3 = 70 - (Date.now() - gameStartTime) * 100 / (4.0 * fadeTime);
                var grow = (Date.now() - gameStartTime) * 5 / fadeTime;
                c.font = `bolder ${(0.25 * simWidth + grow) * cScale}px monospace`;
            }

            //  SPAWN ENEMY ON PAUSE, OCCASSIONALLY  ----------
            if (gameIdle == true && gameStarting != true) {
                if (enemyCycling == true) {
                    enemyCycling = false;
                    nextWait = Date.now() + Math.random() * 5000;
                }
                if (Date.now() > nextWait && Enemy[0] == null) {
                    introSpawn();
                    enemyCycling = true;
                }
            }

            //  DRAW ROIDS TITLE FILL  ------------------
            if (titleBallX >= simWidth || titleBallX <= 0) {
                titleBallHue = 360 * Math.random();
                titleBallSaturation = 20 + 60 * Math.random();
                titleBallLightness = 40 + 40 * Math.random();

                titleBallDir *= -1.0;
                titleBallY = 0.05 * (-0.5 + Math.random());
                titleBallYIndex = 0.005 * (-0.5 + Math.random());
                titleBallRadius = 0.1 + 0.3 * Math.random();
            }
            var sphereGradient = c.createRadialGradient(
                titleBallX * cScale, 
                (0.5 * simHeight + titleBallY) * cScale, 
                0, 
                titleBallX * cScale, 
                (0.5 * simHeight + titleBallY) * cScale, 
                titleBallRadius * cScale);  
            titleBallX += 0.01 * titleBallDir;
            titleBallY += titleBallYIndex;
            var highlight = `hsla(${titleBallHue}, ${titleBallSaturation}%, ${titleBallLightness}%, ${trans}%)`;
            var midtone = `hsla(${titleBallHue}, ${titleBallSaturation - 30}%, ${titleBallSaturation - 50}%, ${trans}%)`;
            var shadow = `hsla(225, 50%, 10%, ${trans - 50}%)`;
            sphereGradient.addColorStop(0.0, highlight);
            sphereGradient.addColorStop(0.95, midtone);
            sphereGradient.addColorStop(1.0, shadow);
            c.fillStyle = sphereGradient;
            c.textBaseline = "middle";
            c.textAlign = "center";
            //c.fillText('R0IDS', 0.5 * simWidth * cScale, 0.5 * simHeight * cScale);
            c.fillText('R    ', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberR) * cScale);
            c.fillText(' 0   ', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberO) * cScale);
            c.fillText('  I  ', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberI) * cScale);
            c.fillText('   D ', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberD) * cScale);
            c.fillText('    S', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberS) * cScale);
                
            //  DRAW SECOND TITLE FILL  ------------------
            if (titleBallX2 >= simWidth || titleBallX2 <= 0) {
                titleBallHue2 = 360 * Math.random();
                titleBallSaturation2 = 20 + 60 * Math.random();
                titleBallLightness2 = 40 + 40 * Math.random();
                titleBallDir2 *= -1.0;
                titleBallY2 = 0.05 * (-0.5 + Math.random());
                titleBallYIndex2 = 0.005 * (-0.5 + Math.random());
                titleBallRadius2 = 0.1 + 0.3 * Math.random();
            }
            var sphereGradient = c.createRadialGradient(
                titleBallX2 * cScale, 
                (0.5 * simHeight + titleBallY2) * cScale, 
                0, 
                titleBallX2 * cScale, 
                (0.5 * simHeight + titleBallY2) * cScale, 
                titleBallRadius2 * cScale);  
            titleBallX2 += 0.01 * titleBallDir2;
            titleBallY2 += titleBallYIndex2;
            var highlight = `hsla(${titleBallHue2}, ${titleBallSaturation2}%, ${titleBallLightness2}%, ${trans}%)`;
            var midtone = `hsla(${titleBallHue2}, ${titleBallSaturation2 - 30}%, ${titleBallLightness2 - 50}%, ${trans}%)`;
            var shadow = `hsla(0, 0%, 0%, 0%)`;
            sphereGradient.addColorStop(0.0, highlight);
            sphereGradient.addColorStop(0.95, midtone);
            sphereGradient.addColorStop(1.0, shadow);
            c.fillStyle = sphereGradient;
            c.textBaseline = "middle";
            c.textAlign = "center";
            c.fillText('R    ', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberR) * cScale);
            c.fillText(' 0   ', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberO) * cScale);
            c.fillText('  I  ', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberI) * cScale);
            c.fillText('   D ', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberD) * cScale);
            c.fillText('    S', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberS) * cScale);

            //  DRAW THIRD UP-DOWN TITLE FILL  ------------------
            if (titleBallY3 >= simHeight || titleBallY3 <= 0) {
                titleBallHue3 = 360 * Math.random();
                titleBallSaturation3 = 20 + 60 * Math.random();
                titleBallLightness3 = 40 + 40 * Math.random();
                titleBallDir3 *= -1.0;
                titleBallX3 = 0.2 * simWidth + 0.6 * Math.random() * simWidth;
                titleBallXIndex3 = 0.01 * (-0.5 + Math.random());
                titleBallRadius3 = 0.1 + 0.3 * Math.random();
            }

            var sphereGradient = c.createRadialGradient(
                titleBallX3 * cScale, 
                titleBallY3 * cScale, 
                0, 
                titleBallX3 * cScale, 
                titleBallY3 * cScale, 
                titleBallRadius3 * cScale);  
            titleBallY3 += 0.01 * titleBallDir3;
            titleBallX3 += titleBallXIndex3;
            var highlight = `hsla(${titleBallHue3}, ${titleBallSaturation3}%, ${titleBallLightness3}%, ${trans}%)`;
            var midtone = `hsla(${titleBallHue3}, ${titleBallSaturation3 - 30}%, ${titleBallLightness3 - 50}%, ${trans}%)`;
            var shadow = `hsla(0, 0%, 0%, 0%)`;
            sphereGradient.addColorStop(0.0, highlight);
            sphereGradient.addColorStop(0.95, midtone);
            sphereGradient.addColorStop(1.0, shadow);
            c.fillStyle = sphereGradient;
            c.textBaseline = "middle";
            c.textAlign = "center";
            c.fillText('R    ', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberR) * cScale);
            c.fillText(' 0   ', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberO) * cScale);
            c.fillText('  I  ', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberI) * cScale);
            c.fillText('   D ', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberD) * cScale);
            c.fillText('    S', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberS) * cScale);

            //  draw outline
            c.lineWidth = 2;
            c.strokeStyle = `hsla(105, 0%, 70%, ${trans}%)`;
            c.strokeText('R    ', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberR) * cScale);
            c.strokeText(' 0   ', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberO) * cScale);
            c.strokeText('  I  ', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberI) * cScale);
            c.strokeText('   D ', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberD) * cScale);
            c.strokeText('    S', (0.5 * simWidth + bobberLR) * cScale, (0.5 * simHeight + bobberS) * cScale);
            
            //  ANY KEY TO TO START  ------------------
            c.fillStyle = `hsla(0, 0%, 100%, ${Math.min(trans2, rudolphIntensity)}%)`;
            c.font = "italic 16px courier";
            c.shadowColor = 'black';
            c.shadowBlur = 10;
            c.fillText('START FLYING TO BEGIN', 0.5 * simWidth * cScale, 0.8 * simHeight * cScale);
            c.font = "italic 12px courier";
            c.fillText("'P' TO PAUSE", 0.5 * simWidth * cScale, 0.83 * simHeight * cScale);
            c.shadowBlur = 0;

            //  INSTRUCTION TEXT  ------------------
            c.strokeStyle = `hsla(105, 90%, 40%, ${trans3}%)`;
            c.fillStyle = `hsla(30, 90%, 50%, ${trans3}%)`;
            c.font = `${0.055 * cScale}px monospace`;
            c.fillText('LEFT', (0.2 * simWidth + 0.15) * cScale, 0.91 * simHeight * cScale);
            c.fillText('RIGHT', (0.4 * simWidth + 0.16) * cScale, 0.91 * simHeight * cScale);
            c.fillText('THRUST', (0.6 * simWidth + 0.16) * cScale, 0.91 * simHeight * cScale);
            c.fillText('SH00T', (0.8 * simWidth + 0.15) * cScale, 0.91 * simHeight * cScale);
            c.lineWidth = 2;
            c.font = `${0.08 * cScale}px monospace`;
            c.strokeText('S', (0.8 * simWidth - 0.12) * cScale, 0.914 * simHeight * cScale);
            c.font = `${0.06 * cScale}px monospace`;
            c.strokeText('/', (0.8 * simWidth - .06) * cScale, 0.912 * simHeight * cScale);
            
            //  ARROWS  ------------------
            drawArrow(0.2 * simWidth, 0.908 * simHeight, 0.5 * Math.PI, 0.08);
            c.stroke();
            drawArrow(0.4 * simWidth, 0.908 * simHeight, 1.5 * Math.PI, 0.08);
            c.stroke();
            drawArrow(0.6 * simWidth, 0.908 * simHeight, 0, 0.08);
            c.stroke();
            drawArrow(0.8 * simWidth, 0.908 * simHeight, Math.PI, 0.08);
            c.stroke();
        }

        //  DRAW ENGINE EXHAUST  ------------------
        for (var y = 0; y < Exhaustlets.length; y++) {
            Exhaustlets[y].draw();
        }

        //  DRAW ENEMY  -------------------
        for (var e = 0; e < Enemy.length; e++) {
            Enemy[e].draw();
        }

        //  DRAW RETRO STEERING EXHAUST  -----------------
        for (var w = 0; w < RetroLets.length; w++) {
            RetroLets[w].draw();
        }
        
        //  DRAW ROKET  --------------------
        if (Roket[0].collision < 2) {
            Roket[0].draw();
        } else {
            if (debrisMade != true) {
                weaponLevel -= 3;
                if (weaponLevel < 0) weaponLevel = 0;  
                makePulse(Roket[0].pos);
                spawnRoketDebris();
            }
        }

        //  DRAW WARP-IN  --------------------
        for (var w = 0; w < WarpIn.length; w++) {
            WarpIn[w].draw();
        }

        //  DRAW SPAWNLETS  --------------------
        for (var b = 0; b < Spawnlets.length; b++) {
            Spawnlets[b].draw();
        }

    }

    //  RUN  --------------------
    setupScene();
    function update() {
        simulate();
        draw();
        requestAnimationFrame(update);
    }
    update();

</script> 
</body>
</html>