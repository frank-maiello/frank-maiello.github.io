<!-- Frank Maiello -->

<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=500, initial-scale=1.0">
<!-- <meta name="viewport" content="width=device-width, initial-scale=1.0"> -->
<style>

    body {font-family: monospace; 
        font-size: 30px;
        color: hsl(0, 0%, 89%);
        text-align: left;
        text-shadow: 5px 7px 10px hsl(0, 0%, 0%);
        margin: 0;
        padding: 0;
    }

    h2 {font-family: verdana; 
        font-size: 24px;
        color: hsl(0, 0%, 89%);
        text-align: left;
        text-shadow: 5px 7px 10px hsl(0, 0%, 0%);
        margin-left: 0px;
        margin-right: 0px;
        padding-left: 10px;
        padding-right: 5px;
    }

    h3 {font-family: verdana; 
        font-size: 2px;
        color: hsl(0, 0%, 89%);
        text-align: left;
        text-shadow: 5px 7px 10px hsl(0, 0%, 0%);
        margin-left: 0px;
        margin-right: 0px;
        padding-left: 10px;
        padding-right: 5px;
    }
    

    .verbiage {font-family: verdana; 
        font-size: 13px;
        font-style: italic;
        color: hsl(0, 0%, 89%);
        text-align: left;
        text-shadow: 5px 7px 10px hsl(0, 0%, 0%);
        margin-left: 0px;
        margin-right: 0px;
        padding-left: 10px;
        padding-right: 5px;
    }
    
    .verbiage a {
        color: hsl(37, 100%, 58%);
        text-decoration: none;
    }
    
    .verbiage a:hover {
        color: #C93226;
        text-decoration: underline;
    }

    table#pubTable {
        text-align: left;
        width: 100%;
        font-size: 18px;
        vertical-align: bottom;
    }
    td {
    vertical-align: top;
    white-space: nowrap;
    padding : 10px 20px;
    }

    .appTitle {
        font-weight: bold;
        color : #C93226;
    }

    thead tr th:first-child,
    tbody tr td:first-child {
    width: 360px;
    min-width: 360px;
    max-width: 360px;
    }

    .paperButton:hover {
    background-color: #777777; 
    color: white;
    }

    .button {
    background-color: #555555;
    border: none;
    color: white;
    padding: 5px 5px;
    margin: 2px 0px 2px 0px;  
    border-radius: 5px;
    
    text-align: center;
    text-decoration: none;
    display: inline-block;
    font-size: 14px;
    box-shadow: 5px 7px 10px hsl(0, 0%, 0%);
    }
    
    .paperImage {
    width: 350px;
    box-shadow: 5px 7px 10px hsl(0, 0%, 0%);
    }
</style>

</head>
<body>

<canvas id="myCanvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0;"></canvas>

<div style="position: relative; z-index: 1; padding: 10px;">
<title>FM Home</title>
<h2>Simulation and Animation</h2>
<div class = "verbiage">A small collection of JavaScript exercises by Frank Maiello</div>
<div class = "verbiage"><a href="mailto:maiello.frank@gmail.com">maiello.frank@gmail.com</a></div>
<br>
<table id = "pubTable">

<tr>
  <td>
    <a href = "https://frank-maiello.github.io//slosh.html"><img class = "paperImage" src = "https://frank-maiello.github.io/screen_slosh.png"></a>
  </td>
  <td>
    <div class = "appTitle">4. SL0SH</div>
    <h3><br></h3>
    <div class = "description">Particle Physics Sandbox</div>
    <div class = "verbiage"><br>Fluid-like "sloshy" particle simulation with</div>
    <div class = "verbiage">interactive toys and a menu-driven user interface.</div>
    <div class = "verbiage">Created with the extensive help of Claude AI.</div>
    <br>
    <a href = "https://frank-maiello.github.io/slosh.html" target="_blank" class="button">Play</a>
    <a href = "https://github.com/frank-maiello/frank-maiello.github.io/blob/main/slosh.html" target="_blank" class="button">Code</a>
    &nbsp; &nbsp; &nbsp;
  </td>
</tr>

<tr>
  <td>
    <a href = "https://frank-maiello.github.io//roids.html"><img class = "paperImage" src = "https://frank-maiello.github.io/screen_roids.png"></a>
  </td>
  <td>
    <div class = "appTitle">3. R0IDS</div>
    <h3><br></h3>
    <div class = "description">My Take on Asteroids</div>
    <div class = "verbiage"><br>First there was Space Invaders. Then came Asteroids.</div>
    <div class = "verbiage">Unique obstacles, a cranky enemy, weapon power-ups,</div>
    <div class = "verbiage">floaty physics, increasing difficulty... and cheats!</div>
    <br>
    <a href = "https://frank-maiello.github.io/roids.html" target="_blank" class="button">Play</a>
    <a href = "https://github.com/frank-maiello/frank-maiello.github.io/blob/main/roids.html" target="_blank" class="button">Code</a>
    &nbsp; &nbsp; &nbsp;
  </td>
</tr>
  
<tr>
  <td>
    <a href = "https://frank-maiello.github.io/droplets.html"><img class = "paperImage" src = "https://frank-maiello.github.io/screen_droplets.png"></a>
  </td>
  <td>
    <div class = "appTitle">2. DR0PLETS</div>
    <h3><br></h3>
    <div class = "description">Abstract Algorithmic Line Art</div>
    <div class = "verbiage"><br>Repetetive line-drawing the slow way, using</div>
    <div class = "verbiage">trigonometry and polar coordinates.</div>
    <br>
    <a href = "https://frank-maiello.github.io/droplets.html" target="_blank" class="button">Play</a>
    <a href = "https://github.com/frank-maiello/frank-maiello.github.io/blob/6404a30fcd3e544bf28b16d2a8adea4be639b728/droplets.html" target="_blank" class="button">Code</a>
    &nbsp; &nbsp; &nbsp;
  </td>
</tr>
              
<tr>
  <td>
    <a href = "https://frank-maiello.github.io/plinkolab.html"><img class = "paperImage" src = "https://frank-maiello.github.io/screen_plinkolab.png"></a>
  </td>
  <td>
  <div class = "appTitle">1. PLINK0 LAB</div>
  <h3><br></h3>
  <div class = "description">Intro to Particle Physics Simulation</div>
  <div class = "verbiage"><br>If you dare. My first undertaking. Consult a child</div>
  <div class = "verbiage">to best navigate the Playskool user interface.</div>

  <br>
  <a href = "https://frank-maiello.github.io/plinkolab.html" target="_blank" class="button">Play</a>
  <a href = "https://github.com/frank-maiello/frank-maiello.github.io/blob/6404a30fcd3e544bf28b16d2a8adea4be639b728/plinkolab.html" target="_blank" class="button">Code</a>
  &nbsp; &nbsp; &nbsp;  
  </td>
</tr>      
</table>
</div>
</body>
    
<script>

    //  CANVAS SETUP AND SCALING --------------------------------------------------------------
    canvas = document.getElementById("myCanvas");
	    c = canvas.getContext("2d");
        canvas.style.cursor = "pointer";
       
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

        simMinWidth = 2.0;
        cScale = Math.min(canvas.width, canvas.height) / simMinWidth;
        simWidth = canvas.width / cScale;
        simHeight = canvas.height / cScale;
        topMargin = 0;
        bottomMargin = 0;
    
    function resizeCanvas() {
        canvas = document.getElementById("myCanvas");
	    c = canvas.getContext("2d");
        canvas.style.cursor = "pointer";
       
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;        simMinWidth = 2.0;
        cScale = Math.min(canvas.width, canvas.height) / simMinWidth;
        simWidth = canvas.width / cScale;
        simHeight = canvas.height / cScale;
    }

    window.addEventListener("resize", resizeCanvas);

    function drawCircle(x, y, radius) {
        c.beginPath();			
		c.arc(x, y, radius, 0.0, 2.0 * Math.PI) 
		c.closePath();
	}
    function drawEllipse(x, y, radiusX, radiusY) {
        c.beginPath();			
		c.ellipse(x * cScale, y * cScale, radiusX * cScale, radiusY * cScale, 0, 0, 2 * Math.PI) 
		c.closePath();
	}

    //  SETUP SCENE ======================================================
	function setupScene() {
        PrimaryNodes = [];
        SecondaryNodes = [];
        spawnNodes();
        spinner = 0;
        f = 0;
    }
    
	//  VECTOR OPERATIONS ---------------------------------------------------------------------
	class Vector2 {
		constructor(x = 0.0, y = 0.0) {
			this.x = x; 
			this.y = y;
		}
		set(v) {
			this.x = v.x; 
            this.y = v.y;
		}
		clone() {
			return new Vector2(this.x, this.y);
		}
		add(v, s=1) {
			this.x += v.x * s;
			this.y += v.y * s;
			return this;
		}
		addVectors(a, b) {
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			return this;
		}
		subtract(v, s = 1.0) {
			this.x -= v.x * s;
			this.y -= v.y * s;
			return this;
		}
		subtractVectors(a, b) {
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			return this;			
		}
		length() {
			return Math.sqrt(this.x * this.x + this.y * this.y);
		}
		scale(s) {
			this.x *= s;
			this.y *= s;
		}
		dot(v) {
			return this.x * v.x + this.y * v.y;
		}
        perp() {
			return new Vector2(-this.y, this.x);
		}
	}

    function cX(pos) {
        return pos.x * cScale;
    }
	function cY(pos) {
        return canvas.height - pos.y * cScale;
    }

    //  NORMALIZE DISTANCE  -------------------
    function measureDistAndShade(node1, node2) {
		var dir = new Vector2();
		dir.subtractVectors(node1.pos, node2.pos);
		d = dir.length();
		
		return 1 / d;
	}

    //  NODE CLASS  -------------------
    class NODE { 
        constructor(pos, angle, color, speed, direction) {
            this.pos = pos.clone();
            this.angle = angle;
            this.color = color;
            this.speed = speed;
            this.direction = direction;
            this.trail = [];
            this.maxTrailLength = 40;
            this.trailMinDistance = 0.001;
        }
        simulate() {
            this.angle += .05 * this.direction * this.speed;
            if (this.direction > 0 && this.angle > 2 * Math.PI) {
                this.angle -= 2 * Math.PI;
            }
            if (this.direction < 0 && this.angle < 0) {
                this.angle += 2 * Math.PI;
            }

            var lobeId = 5;
            f += 0.000001 * this.speed * this.direction;
            
            // Pre-calculate trig values to avoid redundant calculations
            const angleDirection = this.angle * this.direction;
            const fPlusAngle = f + this.angle;
            const lobeFPlusAngle = lobeId * fPlusAngle;
            
            const cosAngleDirection = Math.cos(angleDirection);
            const sinAngle = Math.sin(this.angle);
            const cosLobeFPlusAngle = Math.cos(lobeFPlusAngle);
            const cosFPlusAngle = Math.cos(fPlusAngle);
            const sinFPlusAngle = Math.sin(fPlusAngle);
            
            const lobeEffect = 0.008 * cosLobeFPlusAngle;
            
            this.pos.x += 0.002 * cosAngleDirection + lobeEffect * cosFPlusAngle;
            this.pos.y += 0.001 * sinAngle + lobeEffect * sinFPlusAngle;
            
            // Add current position to trail
            this.addToTrail();
        }
        addToTrail() {
            // Only add if moved enough distance from last trail point
            if (this.trail.length === 0) {
                this.trail.push(this.pos.clone());
            } else {
                const lastPos = this.trail[this.trail.length - 1];
                const dx = this.pos.x - lastPos.x;
                const dy = this.pos.y - lastPos.y;
                const distSquared = dx * dx + dy * dy;
                
                if (distSquared > this.trailMinDistance * this.trailMinDistance) {
                    this.trail.push(this.pos.clone());
                    
                    // Keep trail at max length
                    if (this.trail.length > this.maxTrailLength) {
                        this.trail.shift();
                    }
                }
            }
        }
    }

    //  GENERATE NODE ARRAY ------------------
    function spawnNodes() {
        // right side
        for (i = 0; i < 20; i++) {
            var radius = 0.1 * simHeight + 0.5 * simHeight * Math.random();
            var angle = 2 * Math.PI * Math.random();
            var color = `hsl(${Math.random() * 360}, 30%, 50%)`;
            var speed = 0.4 * Math.random();
            if (Math.random() < 0.50) {
                var direction = 1;
            } else {
                var direction = -1;
            }
            PrimaryNodes.push(new NODE(
                new Vector2(
                    0.7 * simWidth + radius * Math.cos(angle), 
                    0.5 * simHeight + radius * Math.sin(angle)), 
                2 * Math.PI * Math.random(),
                color,
                speed,
                direction));
        }

        //  left side
        for (i = 0; i < 20; i++) {
            var radius = 0.1 * simHeight + 0.5 * simHeight * Math.random();
            var angle = 2 * Math.PI * Math.random();
            var color = `hsl(${Math.random() * 360}, 30%, 50%)`;
            var speed = .1 + .4 * Math.random();
            if (Math.random() < 0.50) {
                direction = 1;
            } else {
                direction = -1;
            }
            SecondaryNodes.push(new NODE(
                new Vector2(
                    0.1 * simWidth + radius * Math.cos(angle), 
                    0.5 * simHeight + radius * Math.sin(angle)), 
                2 * Math.PI * Math.random(),
                color,
                speed,
                direction));
        }
    }

    //  SIMULATION --------------------------------------------------------------------------
	function simulate() {
        for (n = 0; n < PrimaryNodes.length; n++) {
            PrimaryNodes[n].simulate();
            SecondaryNodes[n].simulate();
        }
    }
    
    //  DRAW EVERYTHING ==============================================================
	function drawEverything() {
            c.fillStyle = 'hsl(0, 0%, 0%)';
            c.fillRect(0, 0, canvas.width, canvas.height);

            // Draw connections between primary and secondary nodes
            for (i = 0; i < PrimaryNodes.length; i++) {
                node1 = PrimaryNodes[i];
                for (j = 0; j < SecondaryNodes.length; j++) {
                    node2 = SecondaryNodes[i];
                    c.moveTo(node1.pos.x * cScale, node1.pos.y * cScale);
                    c.lineTo(node2.pos.x * cScale, node2.pos.y * cScale);
                    if (measureDistAndShade(node1, node2) * 20 < 60) {
                        var lineLite = measureDistAndShade(node1, node2) * 20
                    } else {
                        var lineLite = 60;
                    }
                    c.strokeStyle = `hsla(0, 70%, 20%, 10%)`;
                    c.lineWidth = Math.min(2 * measureDistAndShade(node1, node2), 2);
                    
                }
                c.stroke();
            }

            // Draw connections between secondary nodes (left side)
            for (i = 0; i < SecondaryNodes.length; i++) {
                node1 = SecondaryNodes[i];
                for (j = i + 1; j < PrimaryNodes.length; j++) {
                    node2 = SecondaryNodes[j];
                    c.beginPath();
                    c.moveTo(node1.pos.x * cScale, node1.pos.y * cScale);
                    c.lineTo(node2.pos.x * cScale, node2.pos.y * cScale);
                    if (measureDistAndShade(node1, node2) * 20 < 60) {
                        var lineLite = measureDistAndShade(node1, node2) * 20
                    } else {
                        var lineLite = 60;
                    }
                    c.strokeStyle = `hsla(130, 50%, ${lineLite}%, ${lineLite + 20}%)`;
                    c.lineWidth = Math.min(2 * measureDistAndShade(node1, node2), 4);
                    c.stroke();
                }   
            }

            // Draw connections between primary nodes (right side)
            for (i = 0; i < PrimaryNodes.length; i++) {
                node1 = PrimaryNodes[i];
                for (j = i + 1; j < PrimaryNodes.length; j++) {
                    node2 = PrimaryNodes[j];
                    c.beginPath();
                    c.moveTo(node1.pos.x * cScale, node1.pos.y * cScale);
                    c.lineTo(node2.pos.x * cScale, node2.pos.y * cScale);
                    if (measureDistAndShade(node1, node2) * 20 < 60) {
                        var lineLite = measureDistAndShade(node1, node2) * 20
                    } else {
                        var lineLite = 60;
                    }
                    c.strokeStyle = `hsla(${180 + 3 * lineLite}, 50%, ${lineLite}%, ${lineLite + 20}%)`;
                    c.lineWidth = Math.min(4 * measureDistAndShade(node1, node2), 4);
                    c.stroke();
                }  
            }

            // Draw trails for primary nodes
            for (i = 0; i < PrimaryNodes.length; i++) {
                const node = PrimaryNodes[i];
                if (node.trail.length > 1) {
                    c.lineCap = 'round';
                    c.lineJoin = 'round';
                    
                    for (let j = 1; j < node.trail.length; j++) {
                        const alpha = j / node.trail.length;
                        c.strokeStyle = `hsla(210, 70%, 60%, ${alpha * 0.1})`;
                        c.lineWidth = 2 + 25 * alpha;
                        
                        c.beginPath();
                        c.moveTo(node.trail[j - 1].x * cScale, node.trail[j - 1].y * cScale);
                        c.lineTo(node.trail[j].x * cScale, node.trail[j].y * cScale);
                        c.stroke();
                    }
                }
            }
            
            // Draw trails for secondary nodes
            for (i = 0; i < SecondaryNodes.length; i++) {
                const node = SecondaryNodes[i];
                if (node.trail.length > 1) {
                    c.lineCap = 'round';
                    c.lineJoin = 'round';
                    for (let j = 1; j < node.trail.length; j++) {
                        const alpha = j / node.trail.length;
                        c.strokeStyle = `hsla(320, 70%, 50%, ${alpha * 0.15})`;
                        c.lineWidth = 2 + 25 * alpha;
                        
                        c.beginPath();
                        c.moveTo(node.trail[j - 1].x * cScale, node.trail[j - 1].y * cScale);
                        c.lineTo(node.trail[j].x * cScale, node.trail[j].y * cScale);
                        c.stroke();
                    }
                }
            }

            // Draw primary nodes with spherical shading
            for (i = 0; i < PrimaryNodes.length; i++) {
                node1 = PrimaryNodes[i];
                const x = node1.pos.x * cScale;
                const y = node1.pos.y * cScale;
                const radius = 0.03 * cScale;
                
                // Create radial gradient for 3D sphere effect
                const gradient = c.createRadialGradient(
                    x - radius * 0.3, y - radius * 0.3, radius * 0.1,
                    x, y, radius
                );
                gradient.addColorStop(0, 'hsl(210, 70%, 85%)');
                gradient.addColorStop(0.3, 'hsl(210, 70%, 60%)');
                gradient.addColorStop(0.7, 'hsl(210, 70%, 40%)');
                gradient.addColorStop(1, 'hsl(210, 70%, 20%)');
                
                drawCircle(x, y, radius);
                c.fillStyle = gradient;
                c.fill();   
            }

            // Draw secondary nodes with spherical shading
            for (i = 0; i < SecondaryNodes.length; i++) {
                node1 = SecondaryNodes[i];
                const x = node1.pos.x * cScale;
                const y = node1.pos.y * cScale;
                const radius = 0.03 * cScale;
                
                // Create radial gradient for 3D sphere effect
                const gradient = c.createRadialGradient(
                    x - radius * 0.3, y - radius * 0.3, radius * 0.1,
                    x, y, radius
                );
                gradient.addColorStop(0, 'hsl(320, 70%, 85%)');
                gradient.addColorStop(0.3, 'hsl(320, 70%, 60%)');
                gradient.addColorStop(0.7, 'hsl(320, 70%, 40%)');
                gradient.addColorStop(1, 'hsl(320, 70%, 20%)');
                
                drawCircle(x, y, radius);
                c.fillStyle = gradient;
                c.fill();   
            }

            // Draw side fades
            const sideFade = c.createLinearGradient(0, 0, canvas.width, 0);
            sideFade.addColorStop(0.00, 'hsla(0, 0%, 5%, 1)');
            sideFade.addColorStop(0.30, 'hsla(0, 0%, 3%, 1.0)');
            sideFade.addColorStop(0.50, 'hsla(0, 0%, 0%, 0)');
            sideFade.addColorStop(0.90, 'hsla(0, 0%, 0%, 0)');
            sideFade.addColorStop(0.97, 'hsla(0, 0%, 0%, 0.8)');
            sideFade.addColorStop(1, 'hsla(0, 0%, 0%, 0.9)');
            c.fillStyle = sideFade;
            c.fillRect(0, 0, canvas.width, canvas.height);
            c.fillStyle = 'hsla(0, 0%, 0%, 0.2)';
            c.fillRect(0, 0, canvas.width, canvas.height);
            
	}

    //  MAIN SEQUENCE ----------------------------------------------------------------------------
	setupScene();
    
    function update() {
        simulate();
        
		drawEverything();
		requestAnimationFrame(update);
	}
    
	update();

</script> 

</body>
</html>
